{"version":3,"file":"static/js/978.92a21f88.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/readers/index.js","../node_modules/jaspagate/src/general.js","../node_modules/bakana/browser/defaults.js","../node_modules/bakana/browser/index.js","../node_modules/bakana/browser/dump/interfaces.js","../node_modules/bakana/browser/dump/abstract/dump.js","../node_modules/bakana/browser/steps/inputs.js","../node_modules/bakana/browser/readers/alabaster-abstract.js","../node_modules/bakana/browser/steps/custom_selections.js","../node_modules/bioconductor/src/SingleCellExperiment.js","../node_modules/bakana/browser/dump/assays.js","../node_modules/bakana/browser/dump/reducedDimensions.js","../node_modules/jaspagate/src/List.js","../node_modules/hash-wasm/dist/index.esm.js","../node_modules/bakana/browser/dump/markers.js","../node_modules/jaspagate/src/RangedSummarizedExperiment.js","../node_modules/jaspagate/src/utils.js","../node_modules/jaspagate/src/SummarizedExperiment.js","../node_modules/gesel/src/searchGenes.js","../node_modules/gesel/src/utils.js","../node_modules/bakana/browser/dump/SingleCellExperiment.js","../node_modules/bakana/browser/steps/feature_set_enrichment.js","../node_modules/jaspagate/src/DataFrame.js","../node_modules/bakana/browser/dump/DataFrame.js","../node_modules/gesel/src/findOverlappingSets.js","../node_modules/bakana/browser/serialize.js","../node_modules/bakana/browser/readers/se.js","../node_modules/bakana/browser/readers/alabaster-zipped.js","../node_modules/bakana/browser/dump/index.js","../node_modules/jaspagate/src/SingleCellExperiment.js","../node_modules/bakana/browser/readers/h5ad.js","../node_modules/bakana/browser/readers/ArtifactDB-zipped.js","../node_modules/bioconductor/src/List.js","../node_modules/bakana/browser/steps/cell_labelling.js","../node_modules/scran.js/browser/writeSparseMatrixToHdf5.js","../node_modules/jaspagate/src/metadata.js","../node_modules/bakana/browser/version.js","../node_modules/bakana/browser/steps/utils/viz_parent.js","../node_modules/bakana/browser/analysis.js"],"sourcesContent":["export * from \"./10x.js\";\nexport * from \"./h5ad.js\";\nexport * from \"./mtx.js\"\nexport * from \"./se.js\";\nexport * from \"./ArtifactDB-abstract.js\";\nexport * from \"./ArtifactDB-zipped.js\";\nexport * from \"./alabaster-abstract.js\";\nexport * from \"./alabaster-zipped.js\";\nexport * from \"./utils/extract.js\";\nexport * from \"./abstract/file.js\";\n\nimport { TenxHdf5Dataset } from \"./10x.js\";\nimport { H5adDataset } from \"./h5ad.js\";\nimport { TenxMatrixMarketDataset } from \"./mtx.js\"\nimport { SummarizedExperimentDataset } from \"./se.js\";\nimport { ZippedArtifactdbDataset } from \"./ArtifactDB-zipped.js\";\n\n/**\n * Any class that satisfies the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md).\n * Each class contains methods to load data from some arbitrary data source into {@linkplain ScranMatrix} objects (for the counts)\n * and {@linkplain DataFrame} objects (for the feature or cell annotations).\n * The default set of known dataset reader classes is listed in the {@linkcode availableReaders} object\n * and includes {@linkplain TenxHdf5Dataset}, {@linkplain TenxMatrixMarketDataset}, {@linkplain H5adDataset} and {@linkplain SummarizedExperimentDataset} instances.\n *\n * @typedef Dataset\n */\n\n/**\n * A representation of a matrix of expression values, where the values are hosted on the Wasm heap for easier compute via [**scran.js**](https://github.com/kanaverse/scran.js).\n * See [here](https://kanaverse.github.io/scran.js/ScranMatrix.html) for more details.\n *\n * @external ScranMatrix\n */ \n\n/**\n * A representation of multiple {@linkplain external:ScranMatrix ScranMatrix} objects, where each object contains data for the same cells but across a different feature space, e.g., for different data modalities.\n * See [here](https://kanaverse.github.io/scran.js/MultiMatrix.html) for more details.\n *\n * @external MultiMatrix\n */ \n\n/**\n * A DataFrame from the [**bioconductor**](https://github.com/LTLA/bioconductor.js) package, where each column is represented by some arbitrary vector-like object.\n * See [here](https://ltla.github.io/bioconductor.js/DataFrame.html) for more details.\n *\n * @external DataFrame\n */ \n\n/**\n * All known dataset readers.\n * Each entry contains a {@linkplain Dataset} class with the key defined as the {@linkcode Dataset#format format} return value.\n */\nexport const availableReaders = {\n    \"10X\": TenxHdf5Dataset,\n    \"MatrixMarket\": TenxMatrixMarketDataset,\n    \"H5AD\": H5adDataset,\n    \"SummarizedExperiment\": SummarizedExperimentDataset,\n    \"ArtifactDB-zipped\": ZippedArtifactdbDataset\n};\n","import * as bioc from \"bioconductor\";\nimport * as list from \"./List.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as sce from \"./SingleCellExperiment.js\";\nimport { joinPath } from \"./utils.js\";\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link DataFrame}.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}. \n * @return {object} Object metadata.\n * @async\n */\nexport async function readObjectFile(path, globals) {\n    let payload = await globals.get(joinPath(path, \"OBJECT\"), { asBuffer: true });\n    try {\n        let dec = new TextDecoder;\n        return JSON.parse(dec.decode(payload));\n    } finally {\n        await globals.clean(payload);\n    }\n}\n\n/**\n * @type {object}\n * @desc Registry of reader functions.\n * Each key is a takane object type, and each value is a function that accepts the same arguments as {@linkcode readObject}.\n */\nexport const readObjectRegistry = {};\n\n/**\n * This function will inspect {@linkcode readObjectRegistry} to check if any reader function is supplied for the takane object type at `path`.\n * If found, it will use that function, otherwise it will fall back to the default functions:\n * \n * - {@linkcode readDataFrame}, to read {@link external:DataFrame DataFrame} objects.\n * - {@linkcode readSummarizedExperiment}, to read {@link external:SummarizedExperiment SummarizedExperiment} objects.\n * - {@linkcode readRangedSummarizedExperiment}, to read {@link external:RangedSummarizedExperiment RangedSummarizedExperiment} objects.\n * - {@linkcode readSingleCellExperiment}, to read {@link external:SingleCellExperiment SingleCellExperiment} objects.\n *\n * @param {string} path - Path to a takane-formatted object directory. \n * @param {?object} metadata - Object metadata.\n * If `null`, this is automatically loaded by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, to be passed to the reader functions for individual takane object types.\n *\n * @return Some in-memory representation of the takane object at `path`.\n * @async\n */\nexport async function readObject(path, metadata, globals, options = {}) {\n    if (metadata == null) {\n        metadata = await readObjectFile(path, globals);\n    }\n\n    let objtype = metadata[\"type\"];\n    if (objtype in readObjectRegistry) {\n        return readObjectRegistry[objtype](path, metadata, globals, options);\n\n    } else {\n        const defaults = {\n            \"simple_list\": list.readList,\n            \"data_frame\": df.readDataFrame,\n            \"summarized_experiment\": se.readSummarizedExperiment,\n            \"ranged_summarized_experiment\": rse.readRangedSummarizedExperiment,\n            \"single_cell_experiment\": sce.readSingleCellExperiment\n        };\n\n        if (objtype in defaults) {\n            return defaults[objtype](path, metadata, globals, options);\n        }\n\n        throw new Error(\"type '\" + objtype + \"' is not supported\");\n    }\n}\n\n/**\n * @type {Array}\n * @desc Registry of saving functions.\n * Each entry should be an array of length 2, containing a Javascript class and its saving function.\n * Each saving function should accept the same arguments as {@linkcode saveObject}.\n * Subclasses should be placed after their parents in this array.\n */\nexport const saveObjectRegistry = [];\n\n/**\n * This function will inspect {@linkcode saveObjectRegistry} to check if any saving function is supplied for `x`.\n * If found, it will use that function, otherwise it will fall back to the default functions:\n * \n * - {@linkcode saveDataFrame}, to save {@link external:DataFrame DataFrame} objects.\n * - {@linkcode saveSummarizedExperiment}, to save {@link external:SummarizedExperiment SummarizedExperiment} objects.\n * - {@linkcode saveRangedSummarizedExperiment}, to save {@link external:RangedSummarizedExperiment RangedSummarizedExperiment} objects.\n * - {@linkcode saveSingleCellExperiment}, to save {@link external:SingleCellExperiment SingleCellExperiment} objects.\n *\n * @param {Any} x - The takane-compatible object to be saved.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveObject(x, path, globals, options = {}) {\n    for (var i = saveObjectRegistry.length; i > 0; i--) {\n        const [cls, meth] = saveObjectRegistry[i - 1];\n        if (x instanceof cls) {\n            await meth(x, path, globals, options);\n            return;\n        }\n    }\n\n    const defaults = [\n        [bioc.SingleCellExperiment, sce.saveSingleCellExperiment],\n        [bioc.RangedSummarizedExperiment, rse.saveRangedSummarizedExperiment],\n        [bioc.SummarizedExperiment, se.saveSummarizedExperiment],\n        [bioc.DataFrame, df.saveDataFrame],\n        [bioc.List, list.saveList]\n    ];\n\n    for (const [cls, fun] of defaults) {\n        if (x instanceof cls) {\n            await fun(x, path, globals, options);\n            return;\n        }\n    }\n\n    throw new Error(\"object of type '\" + x.constructor.name + \"' is not supported\");\n}\n","import * as inputs from \"./steps/inputs.js\";\nimport * as qc from \"./steps/rna_quality_control.js\";\nimport * as qcadt from \"./steps/adt_quality_control.js\";\nimport * as qccrispr from \"./steps/crispr_quality_control.js\";\nimport * as filter from \"./steps/cell_filtering.js\";\nimport * as norm from \"./steps/rna_normalization.js\";\nimport * as normadt from \"./steps/adt_normalization.js\";\nimport * as normcrispr from \"./steps/crispr_normalization.js\";\nimport * as fsel from \"./steps/feature_selection.js\";\nimport * as pca from \"./steps/rna_pca.js\";\nimport * as pcaadt from \"./steps/adt_pca.js\";\nimport * as pcacrispr from \"./steps/crispr_pca.js\";\nimport * as combine from \"./steps/combine_embeddings.js\";\nimport * as correct from \"./steps/batch_correction.js\";\nimport * as index from \"./steps/neighbor_index.js\";\nimport * as snngraph from \"./steps/snn_graph_cluster.js\";\nimport * as tsne from \"./steps/tsne.js\";\nimport * as umap from \"./steps/umap.js\";\nimport * as kmeans from \"./steps/kmeans_cluster.js\";\nimport * as choose from \"./steps/choose_clustering.js\";\nimport * as markers from \"./steps/marker_detection.js\";\nimport * as custom from \"./steps/custom_selections.js\";\nimport * as enrichment from \"./steps/feature_set_enrichment.js\";\nimport * as labelling from \"./steps/cell_labelling.js\";\n\n/**\n * Generate an object containing all of the default analysis parameters.\n *\n * @return An object where each property corresponds to an analysis step and contains the default parameters for that step.\n * See the documentation for each step's `compute` method for more details:\n * \n * - {@linkcode InputsState#compute inputs}\n * - {@linkcode RnaQualityControlState#compute rna_quality_control}\n * - {@linkcode AdtQualityControlState#compute adt_quality_control}\n * - {@linkcode CrisprQualityControlState#compute crispr_quality_control}\n * - {@linkcode CellFiltering#compute cell_filtering}\n * - {@linkcode RnaNormalizationState#compute rna_normalization}\n * - {@linkcode AdtNormalizationState#compute adt_normalization}\n * - {@linkcode CrisprNormalizationState#compute crispr_normalization}\n * - {@linkcode FeatureSelectionState#compute feature_selection}\n * - {@linkcode RnaPcaState#compute rna_pca}\n * - {@linkcode AdtPcaState#compute adt_pca}\n * - {@linkcode CrisprPcaState#compute crispr_pca}\n * - {@linkcode NeighborIndexState#compute neighbor_index}\n * - {@linkcode TsneState#compute tsne}\n * - {@linkcode UmapState#compute umap}\n * - {@linkcode KmeansClusterState#compute kmeans_cluster}\n * - {@linkcode SnnGraphClusterState#compute snn_graph_cluster}\n * - {@linkcode ChooseClusteringState#compute choose_clustering}\n * - {@linkcode CellLabellingState#compute cell_labelling}\n * - {@linkcode FeatureSetEnrichmentState#compute feature_set_enrichment}\n *\n * See also {@linkcode configureBatchCorrection} and {@linkcode configureApproximateNeighbors} to synchronize certain parameter settings across multiple steps.\n */\nexport function analysisDefaults() {\n    var output = {};\n\n    output[inputs.step_name] = inputs.InputsState.defaults();\n    output[fsel.step_name] = fsel.FeatureSelectionState.defaults();\n\n    output[qc.step_name] = qc.RnaQualityControlState.defaults();\n    output[qcadt.step_name] = qcadt.AdtQualityControlState.defaults();\n    output[qccrispr.step_name] = qccrispr.CrisprQualityControlState.defaults();\n    output[filter.step_name] = filter.CellFilteringState.defaults();\n\n    output[norm.step_name] = norm.RnaNormalizationState.defaults();\n    output[normadt.step_name] = normadt.AdtNormalizationState.defaults();\n    output[normcrispr.step_name] = normcrispr.CrisprNormalizationState.defaults();\n\n    output[pca.step_name] = pca.RnaPcaState.defaults();\n    output[pcaadt.step_name] = pcaadt.AdtPcaState.defaults();\n    output[pcacrispr.step_name] = pcacrispr.CrisprPcaState.defaults();\n\n    output[combine.step_name] = combine.CombineEmbeddingsState.defaults();\n    output[correct.step_name] = correct.BatchCorrectionState.defaults();\n\n    output[index.step_name] = index.NeighborIndexState.defaults();\n    output[snngraph.step_name] = snngraph.SnnGraphClusterState.defaults();\n    output[tsne.step_name] = tsne.TsneState.defaults();\n    output[umap.step_name] = umap.UmapState.defaults();\n\n    output[kmeans.step_name] = kmeans.KmeansClusterState.defaults();\n    output[choose.step_name] = choose.ChooseClusteringState.defaults();\n\n    output[markers.step_name] = markers.MarkerDetectionState.defaults();\n    output[custom.step_name] = custom.CustomSelectionsState.defaults();\n\n    output[enrichment.step_name] = enrichment.FeatureSetEnrichmentState.defaults();\n    output[labelling.step_name] = labelling.CellLabellingState.defaults();\n\n    return output;\n}\n\nconst correctible_pca_steps = [pca.step_name, pcaadt.step_name, pcacrispr.step_name];\n\n/**\n * Set the batch correction parameters across multiple steps.\n * This is a convenient helper as the correction process is split across the PCA and batch correction steps.\n * For MNN, we project cells onto rotation vectors computed within each batch in the various PCA steps (e.g., {@linkplain PcaState}) before performing MNN correction in {@linkplain BatchCorrectionState};\n * for linear regression, we need to regress by block in the PCA without any additional correction in {@linkplain BatchCorrectionState};\n * and for no correction, we need to turn off any block handling in the PCA as well as removing any additional correction in {@linkplain BatchCorrectionState}.\n *\n * @param {object} parameters Object containing parameters for all steps, e.g., from {@linkcode analysisDefaults}.\n * @param {string} method Correction method to perform, one of `\"mnn\"`, \"`regress\"` or `\"none\"`.\n * \n * @return `parameters` is modified with appropriate parameters in `batch_correction`, `pca` and `adt_pca`.\n */\nexport function configureBatchCorrection(parameters, method) {\n    let correct_method;\n    let pca_blocker;\n\n    if (method == \"mnn\") {\n        correct_method = method;\n        pca_blocker = \"project\";\n    } else if (method == \"regress\") {\n        correct_method = \"none\";\n        pca_blocker = method;\n    } else if (method == \"none\") {\n        correct_method = method;\n        pca_blocker = method;\n    } else {\n        throw new Error(\"unknown correction method '\" + method + \"'\");\n    }\n\n    parameters[correct.step_name].method = correct_method;\n    for (const x of correctible_pca_steps) {\n        parameters[x].block_method = pca_blocker;\n    }\n\n    return parameters;\n}\n\n/**\n * Guess the `method` value from {@linkcode configureBatchCorrection} based on the parameter object.\n * This effectively consolidates the various correction parameters into a single setting.\n *\n * @param {object} parameters - Object containing parameters for all steps, typically after {@linkcode configureBatchCorrection}.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.strict] - Whether to only report the `method` when the set of parameters modified by {@linkcode configureBatchCorrection} are consistent.\n *\n * @return {?string} One of `\"mnn\"`, `\"regress\"` or `\"none\"`, based on the expected set of modifications from {@linkcode configureBatchCorrection}.\n * If `strict = false` and there is no exact match to the expected set, the most appropriate method is returned;\n * otherwise, if `strict = true`, `null` is returned.\n */\nexport function guessBatchCorrectionConfig(parameters, { strict = false } = {}) {\n    let pca_blockers = new Set(correctible_pca_steps.map(x => parameters[x].block_method));\n\n    let resp;\n    if (parameters[correct.step_name].method == \"mnn\") {\n        resp = \"mnn\";\n        if (strict) {\n            if (pca_blockers.size > 1 || !pca_blockers.has(\"project\")) {\n                resp = null;\n            }\n        }\n    } else {\n        if (pca_blockers.has(\"regress\")) {\n            if (strict && pca_blockers.size > 1) {\n                resp = null;\n            } else {\n                resp = \"regress\";\n            }\n        } else if (pca_blockers.has(\"none\")) {\n            if (strict && pca_blockers.size > 1) {\n                resp = null;\n            } else {\n                resp = \"none\";\n            }\n        } else {\n            // If pca block_methods are set to 'project',\n            // this doesn't really correspond to anything,\n            // but is closest to 'none'.\n            if (strict) {\n                resp = null;\n            } else {\n                resp = \"none\";\n            }\n        }\n    }\n\n    return resp;\n}\n\nconst approximatable_steps = [correct.step_name, combine.step_name, index.step_name];\n\n/**\n * Specify whether approximate neighbor searches should be performed across all affected steps.\n * This is a convenient helper as it is generally unnecessary to switch between exact and approximate searches in different steps.\n * Affected steps are {@linkplain BatchCorrectionState}, {@linkplain CombineEmbeddingsState} and {@linkplain NeighborIndexState}.\n *\n * @param {object} parameters Object containing parameters for all steps, e.g., from {@linkcode analysisDefaults}.\n * @param {boolean} approximate Whether to perform approximate nearest neighbor searces.\n * \n * @return `parameters` is modified with appropriate parameters in relevant steps, e.g., `batch_correction`, `combine_embeddings` and `neighbor_index`.\n */\nexport function configureApproximateNeighbors(parameters, approximate) {\n    for (const step of approximatable_steps) {\n        parameters[step].approximate = approximate;\n    }\n    return parameters;\n}\n\n/**\n * Guess the value of `approximate` from {@linkcode configureApproximateNeighbors} based on the parameter object.\n * This effectively consolidates the various approximation parameters into a single setting.\n *\n * @param {object} parameters - Object containing parameters for all steps, typically after {@linkcode configureApproximateNeighbors}.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.strict] - Whether to only report `approximate` when the set of parameters modified by {@linkcode configureApproximateNeighbors} are consistent.\n *\n * @return {?boolean} Whether or not approximate neighbor search was used.\n * If `strict = false` and there is a mixture of approximate and exact matches, an approximate search is reported;\n * otherwise, if `strict = true`, `null` is returned.\n */\nexport function guessApproximateNeighborsConfig(parameters, { strict = false } = {}) {\n    let approximates = new Set(approximatable_steps.map(x => parameters[x].approximate));\n    if (strict && approximates.size > 1) {\n        return null;\n    } else {\n        return approximates.has(true);\n    }\n}\n","export * from \"./defaults.js\";\nexport * from \"./analysis.js\";\nexport * from \"./serialize.js\";\nexport * from \"./readers/index.js\";\nexport * from \"./dump/index.js\";\n\nexport { setVisualizationAnimate } from \"./steps/utils/viz_parent.js\";\nexport { formatMarkerResults } from \"./steps/utils/markers.js\";\n\n// Need these exports to get their static methods.\nexport { RnaQualityControlState } from \"./steps/rna_quality_control.js\";\nexport { CellLabellingState } from \"./steps/cell_labelling.js\";\nexport { FeatureSetEnrichmentState } from \"./steps/feature_set_enrichment.js\"\n\n// Need these exports for manual construction.\nexport { MarkerDetectionStandalone } from \"./steps/marker_detection.js\";\nexport { CustomSelectionsStandalone } from \"./steps/custom_selections.js\";\nexport { FeatureSetEnrichmentStandalone } from \"./steps/feature_set_enrichment.js\";\nexport { CellLabellingStandalone } from \"./steps/cell_labelling.js\";\n\nimport { RnaQualityControlState } from \"./steps/rna_quality_control.js\";\nimport { CellLabellingState } from \"./steps/cell_labelling.js\";\nimport { FeatureSetEnrichmentState } from \"./steps/feature_set_enrichment.js\";\n\nimport * as scran from \"scran.js\";\nimport * as vizutils from \"./steps/utils/viz_parent.js\";\n\n/**\n * Initialize the backend for computation.\n * This is required prior to running any other **bakana** function.\n *\n * @param {object} [options] - Optional parameters.\n * @param {number} [options.numberOfThreads] - Number of threads used by **scran.js**.\n * @param {boolean} [options.localFile] - Whether to use local file paths for imported modules in **scran.js**.\n * This only needs to be `true` for old Node versions that do not support file URIs.\n * \n * @return A promise that resolves to `null` when initialization is complete.\n */\nexport function initialize({ numberOfThreads = 1, localFile = false } = {}) {\n    let s = scran.initialize({ \n        numberOfThreads: numberOfThreads,\n        localFile: localFile\n    });\n    vizutils.scranOptions.localFile = localFile;\n    return s.then(x => null); \n}\n\n/**\n * Terminate the backend, in particular shutting down all workers.\n * This is typically necessary for a clean shutdown in Node.js applications.\n *\n * @return A promise that resolves to `null` when all workers are terminated.\n */\nexport function terminate() {\n    RnaQualityControlState.flush();\n    CellLabellingState.flush();\n    FeatureSetEnrichmentState.flush();\n    let s = scran.terminate();\n    let w = vizutils.killAllWorkers();\n    return Promise.all([s, w]).then(x => null);\n}\n\n/**\n * Call a **scran.js** function.\n * This allows client applications to operate in the same **scran.js** memory space as **bakana** functions,\n * which is not guaranteed if applications import **scran.js** on their own (e.g., due to name mangling with Webpack).\n *\n * @param {function} fun - A function that accepts the **scran.js** module object and presumably calls some of its functions.\n *\n * @return The return value of `fun`.\n */\nexport function callScran(fun) {\n    return fun(scran);\n}\n","import * as scran from \"scran.js\";\nimport * as jsp from \"jaspagate\";\nimport * as internal from \"./abstract/dump.js\";\n\nfunction toStringType(data, options) {\n    let length = null;\n    if (\"maxStringLength\" in options) {\n        length = options.maxStringLength;\n    }\n    if (length == null) {\n        if (data == null) {\n            throw new Error(\"'maxStringLength' must be supplied if 'data' is null\"); \n        }\n        length = scran.findMaxStringLength(data, null);\n    }\n    return new scran.H5StringType(\"UTF-8\", length);\n}\n\nexport class AlabasterH5Group extends jsp.H5Group {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    writeAttribute(name, type, shape, data, options = {}) {\n        if (type == \"String\") {\n            type = toStringType(data, options);\n        }\n        this.#handle.writeAttribute(name, type, shape, data);\n    }\n\n    open(name) {\n        let out = this.#handle.open(name);\n        if (out instanceof scran.H5Group) {\n            return new AlabasterH5Group(out);\n        } else {\n            return new AlabasterH5DataSet(out);\n        }\n    }\n\n    children() {\n        return this.#handle.children;\n    }\n\n    createGroup(name) {\n        return new AlabasterH5Group(this.#handle.createGroup(name));\n    }\n\n    createDataSet(name, type, shape, options = {}) {\n        if (\"data\" in options) {\n            if (type == \"String\") {\n                type = toStringType(options.data, options);\n            }\n            return new AlabasterH5DataSet(this.#handle.writeDataSet(name, type, shape, options.data));\n        } else {\n            if (type == \"String\") {\n                type = toStringType(null, options);\n            }\n            return new AlabasterH5DataSet(this.#handle.createDataSet(name, type, shape));\n        }\n    }\n\n    close() {}\n}\n\nexport class AlabasterH5DataSet extends jsp.H5DataSet {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    writeAttribute(name, type, shape, data, options = {}) {\n        if (type == \"String\") {\n            type = toStringType(data, options);\n        }\n        this.#handle.writeAttribute(name, type, shape, data);\n    }\n\n    write(x) {\n        this.#handle.write(x);\n    }\n\n    close() {}\n}\n\nexport class AlabasterGlobalsInterface extends jsp.GlobalsInterface {\n    #directory;\n    #files;\n\n    constructor(directory, files) {\n        super();\n        this.#directory = directory;\n        this.#files = files;\n    }\n\n    get(path, options = {}) {\n        if (this.#directory !== null) {\n            const { asBuffer = true } = options;\n            return internal.read(this.#directory, path, asBuffer);\n        } else {\n            return this.#files[path];\n        }\n    }\n\n    clean(localPath) {}\n\n    async write(path, contents) {\n        if (this.#directory !== null) {\n            await internal.write(this.#directory, path, contents);\n        } else {\n            this.#files[path] = contents;\n        }\n    }\n\n    async mkdir(path) {\n        if (this.#directory !== null) {\n            await internal.mkdir(this.#directory, path);\n        }\n    }\n\n    async copy(from, to) {\n        if (this.#directory !== null) {\n            await internal.copy(this.#directory, from, to);\n        } else {\n            this.#files[to] = this.#files[from];\n        }\n    }\n\n    h5create(path) {\n        if (this.#directory !== null) {\n            let actual_path = jsp.joinPath(this.#directory, path);\n            let latest = scran.createNewHdf5File(actual_path);\n            let output = new AlabasterH5Group(latest);\n            output._path = actual_path;\n            return output;\n        } else {\n            let tmppath = scran.chooseTemporaryPath();\n            let latest = scran.createNewHdf5File(tmppath);\n            let output = new AlabasterH5Group(latest);\n            output._path = tmppath;\n            output._intended = path;\n            return output;\n        }\n    }\n\n    h5finish(handle, failed) {\n        if (this.#directory === null) {\n            if (!failed) {\n                this.write(handle._intended, scran.readFile(handle._path));\n            }\n            scran.removeFile(handle._path);\n        }\n    }\n}\n","// Stub file to ensure that something is loaded.\n\nexport function fsexists() {\n    return false;\n}\n\nexport function read(dir, path, asBuffer) {\n    throw new Error(\"read() is not supported in a web context\");\n}\n\nexport function write(dir, path, x) {\n    throw new Error(\"write() is not supported in a web context\");\n}\n\nexport function mkdir(dir, path) {\n    throw new Error(\"mkdir() is not supported in a web context\");\n}\n\nexport function copy(dir, from, to) {\n    throw new Error(\"copy() is not supported in a web context\");\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as iutils from \"../readers/index.js\";\nexport const step_name = \"inputs\";\n\nconst RAW_SUBSET_OVERRIDE = \"raw_subset_indices\";\n\n/**\n * This step handles the loading of all datasets into memory.\n * This wraps various matrix initialization functions in [**scran.js**](https://github.com/kanaverse/scran.js),\n * depending on the format of the supplied datasets.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class InputsState {\n    #parameters;\n    #cache;\n    #abbreviated;\n    #preserve_dataset_cache;\n\n    constructor(parameters = null, cache = null, abbreviated = null) {\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.#abbreviated = (abbreviated === null ? {} : abbreviated);\n        this.#preserve_dataset_cache = false;\n        this.changed = false;\n        return;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.raw_matrix);\n        utils.freeCache(this.#cache.block_ids);\n        utils.freeCache(this.#cache.raw_block_ids);\n        utils.freeCache(this.#cache.multi_block_ids);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {external:MultiMatrix} A {@linkplain external:MultiMatrix MultiMatrix} object containing counts for one or more modalities.\n     * Each modality is represented by a separate count matrix, where each row of the matrix represents a feature of that modality.\n     * All matrices have the same number and ordering of cells in their columns.\n     */\n    fetchCountMatrix() {\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {object} Object where each key is the name of a modality and each value is a {@linkplain external:DataFrame DataFrame}.\n     * Each row of the DataFrame corresponds to a feature in that modality \n     * (i.e., a row in the corresponding matrix from {@linkcode InputsState#fetchCountMatrix fetchCountMatrix})\n     * and each column represents a per-feature annotation field.\n     */\n    fetchFeatureAnnotations() {\n        return this.#cache.genes;\n    }\n\n    /**\n     * @return {external:DataFrame} {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * Each row of the DataFrame corresponds to a cell in {@linkcode InputsState#fetchCountMatrix fetchCountMatrix},\n     * and each column represents a per-cell annotation field.\n     *\n     * Note that this considers all cells in the dataset before QC filtering - \n     * see {@linkcode QualityControlState#applyFilter QualityControlState.applyFilter} to obtain a filtered version of each column.\n     */\n    fetchCellAnnotations() {\n        return this.#cache.annotations;\n    }\n\n    /**\n     * @return {?Int32WasmArray} Array of length equal to the number of cells in the dataset,\n     * identifying the block to which each cell is assigned.\n     * Alternatively `null`, if no blocking is performed.\n     */\n    fetchBlock() {\n        return this.#cache.block_ids;\n    }\n\n    /**\n     * @return {?Array} Array of names of the blocks, or `null` if no blocking is performed.\n     */\n    fetchBlockLevels() {\n        return this.#cache.block_levels;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Cloning the parameters to avoid pass-by-reference behavior affecting the\n        // InputsState object. We don't pass the files back here.\n        let output = { ...this.#parameters };\n        output.subset = this.constructor.#cloneSubset(output.subset);\n        return output;\n    }\n\n    fetchDatasets() {\n        return this.#cache.datasets;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to return a copy of the subsets to avoid pass-by-reference behaviors.\n     *\n     * @return {?Int32Array} Array containing the indices to use for direct subsetting -\n     * see {@linkcode InputsState#setDirectSubset setDirectSubset} for more information.\n     * Alternatively `null`, if direct subsetting is not performed.\n     */\n    fetchDirectSubset({ copy = true } = {}) {\n        if (RAW_SUBSET_OVERRIDE in this.#cache) {\n            let candidate = this.#cache[RAW_SUBSET_OVERRIDE];\n            return (copy ? candidate.slice() : candidate);\n        } else {\n            return null;\n        }\n    }\n\n    guessRnaFeatureTypes() {\n        if (!(\"RNA\" in this.#cache.genes)) {\n            return null;\n        }\n\n        if (!(\"inferred_rna_types\" in this.#cache)) {\n            this.#cache.inferred_rna_types = utils.guessFeatureTypes(this.#cache.genes[\"RNA\"]);\n        }\n\n        return this.#cache.inferred_rna_types;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode InputsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            block_factor: null,\n            subset: null\n        };\n    }\n\n    /**\n     * Allow each {@linkplain Dataset} reader (i.e., the `datasets` in {@linkcode InputsState#compute compute}) to cache any intermediate results during loading.\n     * By default, this is disabled as caching increases memory usage of the analysis without any major runtime improvements to `compute` when the `datasets` do not change.\n     *\n     * Setting `cache = true` is only useful if the instances in `datasets` are to be re-used outside of **bakana**, or if they are to be re-used in `compute()` in different combinations. \n     * In such cases, there may be a runtime improvement that warrants the increase in memory usage.\n     * If caching is used, the user is responsible for releasing cached resources via each instance's `clear()` method once they are no longer needed.\n     *\n     * @param {boolean} cache - Whether to allow {@linkplain Dataset} instances to cache their results.\n     */\n    enableDatasetCache(cache) {\n        this.#preserve_dataset_cache = cache;\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} datasets - An object containing data for one or more datasets.\n     * Each property corresponds to a single dataset and its value should satisfy the {@linkplain Dataset} contract.\n     * See the description of the argument of the same name in {@linkcode runAnalysis}.\n     * @param {object} parameters - Parameter object, equivalent to the `inputs` property of the `parameters` in {@linkcode runAnalysis}.\n     * @param {?string} [parameters.block_factor] - Name of the column of the cell annotations specifying the sample of origin for each cell.\n     * This is only used if a single count matrix is supplied.\n     *\n     * If `null`, all cells are assumed to originate from the same sample.\n     *\n     * If any entries of the blocking factor are invalid (i.e., `null`), they are removed from downstream analyses.\n     * @param {?subset} [parameters.subset] - Object describing if any pre-analysis subsetting should be applied.\n     * This should contain `field`, a string specifying a field of the column annotation.\n     *\n     * - For categorical variables, the object should also contain `values`, an array of allowed values for that annotation.\n     *   Cells are only retained if they are associated with any of the allowable values for that annotation field.\n     * - For continuous variables, the object should also contain `ranges`, an array of arrays.\n     *   Each inner array should contain two numbers defining the start and end of a range.\n     *   Ranges should be sorted and non-overlapping (boundaries excepted).\n     *\n     * If `subset` is `null`, no subsetting is performed and all cells are used in the downstream analysis.\n     *\n     * @return The object is updated with the new results.\n     * A promise is returned that resolves once input loading is complete, after which downstream steps can be run.\n     */\n    async compute(datasets, parameters) {\n        parameters = utils.defaultizeParameters(parameters, InputsState.defaults());\n        this.changed = false;\n\n        // Don't bother proceeding with any of the below\n        // if we're operating from a reloaded state.\n        if (datasets !== null) {\n            let tmp_abbreviated = {};\n            for (const [key, val] of Object.entries(datasets)) {\n                tmp_abbreviated[key] = { format: val.constructor.format(), details: val.abbreviate() };\n            }\n\n            if (utils.changedParameters(tmp_abbreviated, this.#abbreviated)) {\n                await load_and_cache(datasets, this.#cache, this.#preserve_dataset_cache);\n                this.#abbreviated = tmp_abbreviated;\n                this.#cache.datasets = { ...datasets }; // making a deep-ish copy to avoid pass-by-reference links.\n                delete this.#cache.inferred_rna_types;\n                this.changed = true;\n            }\n        }\n\n        if (this.changed || this.#parameters.block_factor !== parameters.block_factor) {\n            block_and_cache(parameters.block_factor, this.#cache);\n            this.changed = true;\n        }\n\n        // final condition handles loss of 'matrix' when setDirectSubset() is called.\n        if (this.changed || (!(RAW_SUBSET_OVERRIDE in this.#cache) && utils.changedParameters(parameters.subset, this.#parameters.subset)) || !(\"matrix\" in this.#cache)) { \n            subset_and_cache(parameters.subset, this.#cache);\n            this.changed = true;\n        }\n\n        this.#parameters = parameters;\n        this.#parameters.subset = InputsState.#cloneSubset(this.#parameters.subset);\n        return;\n    }\n\n    /******************************\n     ******** Subsetting **********\n     ******************************/\n\n    static #cloneSubset(subset) {\n        // We use a dedicated cloning function to handle Infs,\n        // as these get converted to nulls by the JSON stringify.\n        if (subset == null) {\n            return subset;\n        }\n\n        let clone = { ...subset };\n        if (\"values\" in clone) {\n            clone.values = clone.values.slice();\n        }\n\n        if (\"ranges\" in clone) {\n            clone.ranges = clone.ranges.map(x => x.slice());\n        }\n\n        return clone;\n    }\n\n    /**\n     * Undo the effect of subsetting on an array of indices.\n     * This works with all subset specifications, e.g., via `parameters.subset` in {@linkcode InputsState#compute compute}, with {@linkcode InputsState#setDirectSubset setDirectSubset},\n     * or even from the implicit subsetting when the factor specified in `parameters.block` contains `null` entries.\n     *\n     * @param {Array|TypedArray} indices - Array of column indices to the subsetted matrix.\n     * Note that this will be modified in-place.\n     *\n     * @return Entries of `indices` are replaced with indices to the pre-subsetted matrix.\n     */\n    undoSubset(indices) {\n        if (\"matrix\" in this.#cache) {\n            let max_index = this.fetchCountMatrix().numberOfColumns();\n            for (const x of indices) {\n                if (x < 0 || x >= max_index) {\n                    throw new Error(\"entries of 'indices' should be less than the number of cells in the dataset\");\n                }\n            }\n        }\n\n        // Setting the subset to null, if the parameter-level subset hasn't\n        // been set yet. This is because we might get indirectly called via\n        // setDirectSubset() before compute() has been run.\n        let subset = null;\n        if (\"subset\" in this.#parameters) {\n            subset = this.#parameters.subset;\n        }\n\n        let keep = harvest_subset_indices(subset, this.#cache);\n        if (keep !== null) {\n            indices.forEach((x, i) => { indices[i] = keep[x] });\n        }\n    }\n\n    #configureIndices(indices, copy, onOriginal) {\n        // scran.js's subset functions will pick up out-of-range indices.\n        utils.checkIndices(indices, null);\n\n        // We make a copy here to take ownership of the underlying memory,\n        // otherwise any edits in the caller would mutate the new InputsState's\n        // indices by reference.\n        if (copy) {\n            indices = indices.slice();\n        }\n\n        if (!onOriginal) {\n            this.undoSubset(indices);\n        }\n\n        return indices;\n    }\n\n    /**\n     * Unlike most of the other methods, `setDirectSubset` can be called on an InputsState before {@linkcode InputsState#compute compute}.\n     * This means that a user can create the state object from {@linkcode createAnalysis},\n     * specify a subset of cells via `setDirectSubset` on the (currently empty) InputsState object in `inputs`,\n     * and then call {@linkcode runAnalysis} to execute an analysis on the desired subset of cells.\n     * \n     * @param {TypedArray|Array} indices - Array containing the indices for the desired subset of cells.\n     * This should be sorted and non-duplicate.\n     * Any existing subset in this object will be overridden by `indices`.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `indices` before storing it inside the returned state object.\n     * If `false`, it is assumed that the caller makes no further use of the passed `indices`.\n     * @param {boolean} [options.onOriginal=false] - Whether `indices` contains indices on the original dataset or on the dataset in `state`.\n     * This distinction is only relevant if the current InputsState object already contains a specified subset.\n     * If `false`, the `indices` are assumed to refer to the already-subsetted dataset that exists in `state`;\n     * if `true`, the `indices` are assumed to refer to the original dataset from which the subset in `state` was created.\n     *\n     * @return The dataset in this InputsState object is subsetted to the desired `indices`.\n     */\n    setDirectSubset(indices, { copy = true, onOriginal = false } = {}) {\n        if (indices !== null) {\n            this.#cache[RAW_SUBSET_OVERRIDE] = this.#configureIndices(indices, copy, onOriginal);\n        } else {\n            delete this.#cache[RAW_SUBSET_OVERRIDE];            \n        }\n\n        // Flag that it needs to be rerun.\n        scran.free(this.#cache.matrix);\n        delete this.#cache.matrix;\n    }\n\n    createDirectSubset(indices, { copy = true, onOriginal = false } = {}) {\n        let new_cache = {};\n        new_cache[RAW_SUBSET_OVERRIDE] = this.#configureIndices(indices, copy, onOriginal);\n\n        // Need to manually copy everything in 'this.#cache' that is set in\n        // load_and_cache or block_and_cache.\n\n        // Making explicit clones to take ownership.\n        new_cache.raw_matrix = this.#cache.raw_matrix.clone();\n        for (const x of [ \"multi_block_ids\", \"raw_block_ids\" ]) {\n            if (x in this.#cache) {\n                if (this.#cache[x] === null) {\n                    new_cache[x] = null;\n                } else {\n                    new_cache[x] = this.#cache[x].clone();\n                }\n            }\n        }\n\n        // These can probably be copied directly, given that they are always\n        // replaced wholesale in the various *_and_cache functions, rather than\n        // being modified in-place.\n        for (const x of [ \"raw_annotations\", \"genes\", \"multi_block_levels\", \"raw_block_levels\" ]) {\n            if (x in this.#cache) {\n                new_cache[x] = this.#cache[x];\n            }\n        }\n\n        subset_and_cache(null, new_cache);\n\n        let new_params = this.fetchParameters();\n        new_params.subset = null;\n\n        return new InputsState(new_params, new_cache, this.#abbreviated);\n    }\n}\n\n/************************************\n ******* Internals - loading ********\n ************************************/\n\nconst known_modalities = [ \"RNA\", \"ADT\", \"CRISPR\" ];\n\nfunction bind_single_modality(modality, loaded) {\n    let output = {};\n\n    try {\n        let gnames = [];\n        let mats = [];\n        for (var i = 0; i < loaded.length; i++) {\n            mats.push(loaded[i].matrix.get(modality));\n\n            let primary_id = loaded[i].primary_ids[modality];\n            if (primary_id == null) {\n                throw new Error(\"modality '\" + modality + \"' lacks a primary identifier for dataset \" + String(i));\n            }\n            gnames.push(primary_id);\n        }\n\n        let merged = scran.cbindWithNames(mats, gnames);\n        output.matrix = merged.matrix;\n\n        // Extracting gene information from the first object. We won't make\n        // any attempt at merging and deduplication across objects.\n        output.features = bioc.SLICE(loaded[0].features[modality], merged.indices);\n\n    } catch (e) {\n        utils.freeCache(output.matrix);\n        throw e;\n    }\n\n    return output;\n}\n\nfunction bind_datasets(names, loaded) {\n    let common_modes = [];\n    for (const mod of known_modalities) {\n        let okay = true;\n        for (const l of loaded) {\n            if (!l.matrix.has(mod)) {\n                okay = false;\n                break;\n            }\n        }\n        if (okay) {\n            common_modes.push(mod);\n        }\n    }\n\n    if (common_modes.length == 0) {\n        throw new Error(\"failed to find common modalities across all datasets\");\n    }\n\n    let blocks;\n    let output = { \n        matrix: new scran.MultiMatrix, \n        features: {}\n    };\n\n    try {\n        for (const k of common_modes) {\n            let current = bind_single_modality(k, loaded);\n            output.matrix.add(k, current.matrix);\n            output.features[k] = current.features;\n        }\n\n        let annos = loaded.map(x => x.cells);\n        output.cells = bioc.flexibleCombineRows(annos);\n\n        // Generating a block vector.\n        let ncells = new Array(loaded.length);\n        loaded.forEach((x, i) => { ncells[i] = x.matrix.numberOfColumns(); });\n        blocks = scran.createBlock(ncells);\n        output.block_ids = blocks;\n        output.block_levels = names;\n\n        let nice_barr = new Array(blocks.length);\n        blocks.forEach((x, i) => { nice_barr[i] = names[x]; })\n        output.cells.$setColumn(\"__batch__\", nice_barr);\n\n    } catch (e) {\n        utils.freeCache(blocks);\n        utils.freeCache(output.matrix);\n        throw e;\n    } \n\n    return output;\n}\n\nfunction rename_dataset(single) {\n    let modalities = single.matrix.available();\n    if (modalities.length == 0) {\n        throw new Error(\"no available modalities\");\n    }\n\n    let output = { \n        matrix: new scran.MultiMatrix, \n        features: {}\n    };\n\n    try {\n        for (const k of known_modalities) {\n            if (!single.matrix.has(k)) {\n                continue;\n            }\n\n            output.matrix.add(k, single.matrix.get(k));\n            output.features[k] = single.features[k];\n        }\n    } catch (e) {\n        scran.free(output.matrix);\n        throw e;\n    }\n\n    output.cells = single.cells;\n    output.block_ids = null;\n    output.block_levels = null;\n\n    return output;\n}\n\nasync function load_datasets(datasets, preserve_dataset_cache) {\n    // Ensure we have a reproducible order; otherwise the batch\n    // order becomes dependent on the JS engine's ordering.\n    let names = Object.keys(datasets);\n    names.sort();\n\n    let loaded = [];\n    try {\n        for (const key of names) {\n            // Too much hassle to convert this into a Promise.all(), because we\n            // need to make sure it gets freed properly on failure.\n            loaded.push(await datasets[key].load({ cache: preserve_dataset_cache }));\n        }\n    } catch (e) {\n        // If any one fails, we free the rest.\n        for (const x of loaded) {\n            scran.free(x.matrix);\n        }\n        throw e;\n    }\n\n    let output;\n    if (names.length == 1) {\n        try {\n            output = rename_dataset(loaded[0]);\n        } catch (e) {\n            scran.free(loaded[0].matrix);\n            throw e;\n        }\n    } else {\n        try {\n            output = bind_datasets(names, loaded);\n        } finally {\n            // No need to hold references to the individual matrices once the\n            // binding is complete, so we release them.\n             for (const x of loaded) {\n                scran.free(x.matrix);\n            }\n        }\n    }\n\n    return output;\n}\n\n/******************************************\n ******* Internals - miscellaneous ********\n ******************************************/\n\nconst invalid_block_id = -1;\n\nfunction harvest_subset_indices(subset, cache) {\n    let keep;\n\n    if (RAW_SUBSET_OVERRIDE in cache) {\n        keep = cache[RAW_SUBSET_OVERRIDE];\n    } else if (subset == null) {\n        keep = null;\n    } else {\n        if (!cache.raw_annotations.hasColumn(subset.field)) {\n            throw new Error(\"failed to find '\" + subset.field + \"' in the column annotations\");\n        }\n\n        let anno = cache.raw_annotations.column(subset.field);\n        keep = [];\n\n        if (\"values\" in subset) {\n            let allowed = new Set(subset.values);\n            anno.forEach((x, i) => {\n                if (allowed.has(x)) {\n                    keep.push(i);\n                }\n            });\n        } else {\n            // Check each entry to see whether it belongs to the range.\n            // This is cheaper than sorting anything, assuming there \n            // aren't that many ranges.\n            anno.forEach((x, i) => {\n                for (const r of subset.ranges) {\n                    if (x >= r[0] && x <= r[1]) {\n                        keep.push(i);\n                        return;\n                    }\n                }\n            });\n        }\n    }\n\n    // Filter out invalid block IDs. Note that this might get called\n    // before compute() is run (via undoSubset), so we need to protect\n    // against the case where the raw_block_ids has not been set yet.\n    if (\"raw_block_ids\" in cache && cache.raw_block_ids !== null) {\n        let bids = cache.raw_block_ids.array();\n\n        let keep2 = [];\n        if (keep !== null) {\n            for (const i of keep) {\n                if (bids[i] !== invalid_block_id) {\n                    keep2.push(i);\n                }\n            }\n        } else {\n            for (var i = 0; i < bids.length; i++) {\n                if (bids[i] !== invalid_block_id) {\n                    keep2.push(i);\n                }\n            }\n        }\n        keep = keep2;\n    }\n\n    return keep;\n}\n\nfunction check_subset_ranges(ranges) { \n    if (ranges.length % 2 !== 0) {\n        throw new Error(\"'ranges' should have two columns in 'subset'\");\n    }\n    for (var i = 1; i < ranges.length; i++) {\n        if (ranges[i] < ranges[i-1]) {\n            throw new Error(\"'ranges' should be sorted in increasing order\");\n        }\n    }\n}\n\n/************************************\n ******* Internals - caching ********\n ************************************/\n\nasync function load_and_cache(new_datasets, cache, preserve_dataset_cache) {\n    utils.freeCache(cache.raw_matrix);\n    utils.freeCache(cache.matrix); // freeing this as well, to release all references and potentially release memory.\n    utils.freeCache(cache.multi_block_ids);\n\n    let res = await load_datasets(new_datasets, preserve_dataset_cache);\n    cache.raw_matrix = res.matrix;\n    cache.raw_annotations = res.cells;\n    cache.multi_block_ids = res.block_ids;\n    cache.multi_block_levels = res.block_levels;\n    cache.genes = res.features;\n}\n\nfunction block_and_cache(block_factor, cache) {\n    utils.freeCache(cache.raw_block_ids);\n\n    let blocks = null;\n    let block_levels = null;\n\n    if (block_factor !== null) {\n        // Single matrix with a batch factor.\n        try {\n            let anno_batch = cache.raw_annotations.column(block_factor);\n            if (anno_batch.length != cache.raw_matrix.numberOfColumns()) {\n                throw new Error(\"length of blocking factor '\" + block_factor + \"' should be equal to the number of cells\"); \n            }\n            let converted = scran.convertToFactor(anno_batch, { action: \"none\", placeholder: invalid_block_id });\n            blocks = converted.ids;\n            block_levels = converted.levels;\n        } catch (e) {\n            utils.freeCache(blocks);\n            throw e;\n        }\n    } else {\n        if (cache.multi_block_ids !== null) { \n            // Creating a view so that freeing of this object is a no-op.\n            // We're downstream of load_and_cache so any freeing of\n            // multi_block_ids would require block_and_cache to rerun\n            // anyway, so we don't have to worry about invalidation.\n            blocks = cache.multi_block_ids.view();\n        } else {\n            blocks = null;\n        }\n        block_levels = cache.multi_block_levels;\n    }\n\n    cache.raw_block_ids = blocks;\n    cache.raw_block_levels = block_levels;\n}\n\nfunction subset_and_cache(subset, cache) {\n    utils.freeCache(cache.matrix);\n    utils.freeCache(cache.block_ids);\n\n    let keep = harvest_subset_indices(subset, cache);\n\n    let new_annotations;\n    let new_matrix;\n    let new_block_ids;\n    let new_block_levels;\n\n    try {\n        if (keep === null) {\n            new_annotations = cache.raw_annotations;\n\n            // Need to make a clone so that it can be freed independently of the original.\n            // This is cheap as only the shared pointer is cloned, not the underlying data.\n            new_matrix = cache.raw_matrix.clone();\n\n            if (cache.raw_block_ids !== null) {\n                // A view also works, given that we're downstream of the generating\n                // process for raw_block_ids and thus our lifetime is always tied to it.\n                new_block_ids = cache.raw_block_ids.view();\n                new_block_levels = cache.raw_block_levels;\n            } else {\n                new_block_ids = null;\n                new_block_levels = null;\n            }\n\n        } else {\n            new_annotations = bioc.SLICE(cache.raw_annotations, keep);\n\n            if (cache.raw_block_ids !== null) {\n                let subsetted = scran.subsetFactor({ ids: cache.raw_block_ids, levels: cache.raw_block_levels }, keep);\n                new_block_ids = subsetted.ids;\n                new_block_levels = subsetted.levels;\n            } else {\n                new_block_ids = null;\n                new_block_levels = null;\n            }\n\n            new_matrix = new scran.MultiMatrix;\n            for (const key of cache.raw_matrix.available()) {\n                let current = cache.raw_matrix.get(key);\n                new_matrix.add(key, scran.subsetColumns(current, keep));\n            }\n        }\n\n    } catch (e) {\n        utils.freeCache(new_matrix);\n        utils.freeCache(new_block_ids);\n        throw e;\n    }\n\n    cache.annotations = new_annotations;\n    cache.block_levels = new_block_levels;\n    cache.block_ids = new_block_ids;\n    cache.matrix = new_matrix;\n}\n\n/**************************\n ******** Linking *********\n **************************/\n\nvar file2link = null;\nvar link2file = null;\n\n/**\n * Specify a function to create links for data files.\n *\n * @param {function} fun - Function that accepts:\n *\n * - `format`: the string containing the format of the dataset that owns the file.\n * - `file`: a {@linkplain SimpleFile} representing the file contents.\n *\n * It should return a string containing some unique identifier to the file.\n * This is most typically used to register the file with some user-specified database system for later retrieval.\n *\n * @return `fun` is set as the global link creator for this step. \n * The _previous_ value of the creator is returned.\n */\nexport function setCreateLink(fun) {\n    let previous = file2link;\n    file2link = fun;\n    return previous;\n}\n\n/**\n * Specify a function to resolve links for data files.\n *\n * @param {function} fun - Function that accepts a string containing a linking idenfier and returns any value that can be used in the {@linkplain SimpleFile} constructor\n * i.e., a Uint8Array, File (on browser) or string containing a file path (on Node.js).\n * This is most typically used to retrieve a file from some user-specified database system.\n *\n * @return `fun` is set as the global resolver for this step. \n * The _previous_ value of the resolver is returned.\n */\nexport function setResolveLink(fun) {\n    let previous = link2file;\n    link2file = fun;\n    return previous;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\nimport * as jsp from \"jaspagate\";\n\n/**\n * Any class that satisfies the AlabasterProjectNavigator contract, so called as it is intended to \"navigate\" an alabaster-formatted object directory.\n * This should provide the following methods:\n * \n * - `get(path, asBuffer)`, a (possibly async) method that accepts a string `path` containing a relative path to a file inside an object directory. \n *   This should return a string containing a path to the file on the local filesystem, or a Uint8Array containing the contents of the file if no local filesystem exists.\n *   If `asBuffer = true`, a Uint8Array must be returned.\n * - `exists(path)`, a (possibly async) method that accepts a string `path` containing a relative path to a file inside an object directory. \n *   This should return a boolean indicating whether `path` exists in the object directory.\n * - `clean(localPath)`, a (possibly async) method that accepts a string containing a local path returned by `get()`.\n *   It should remove any temporary file that was created by `get()` at `localPath`.\n *   This will not be called if `get()` returns a Uint8Array.\n *\n * @typedef AlabasterProjectNavigator\n */\n\n/****************************\n *** Jaspagate interfaces ***\n ****************************/\n\nclass AlabasterH5Group extends jsp.H5Group {\n    #handle;\n    #flush;\n\n    constructor(handle, flush) {\n        super();\n        this.#handle = handle;\n        this.#flush = flush;\n    }\n\n    attributes() {\n        return this.#handle.attributes;\n    }\n\n    readAttribute(attr) {\n        let ares = this.#handle.readAttribute(attr);\n        return { values: ares.values, shape: ares.shape };\n    }\n\n    children() {\n        return Array.from(Object.keys(this.#handle.children));\n    }\n\n    open(name) {\n        let out = this.#handle.open(name);\n        if (out instanceof scran.H5Group) {\n            return new AlabasterH5Group(out);\n        } else {\n            return new AlabasterH5DataSet(out);\n        }\n    }\n\n    close() {}\n\n    _flush() {\n        this.#flush();\n    }\n}\n\nclass AlabasterH5DataSet extends jsp.H5DataSet {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    attributes() {\n        return this.#handle.attributes;\n    }\n\n    readAttribute(attr) {\n        let ares = this.#handle.readAttribute(attr);\n        return { values: ares.values, shape: ares.shape };\n    }\n\n    type() {\n        let type = this.#handle.type;\n        if (type instanceof scran.H5StringType) {\n            return \"String\";\n        } else if (type instanceof scran.H5CompoundType) {\n            return type.members;\n        } else {\n            return type;\n        }\n    }\n\n    shape() {\n        return this.#handle.shape;\n    }\n\n    values() {\n        return this.#handle.values;\n    }\n\n    close() {}\n}\n\nclass AlabasterGlobalsInterface extends jsp.GlobalsInterface {\n    #navigator;\n\n    constructor(navigator) {\n        super();\n        this.#navigator = navigator;\n    }\n\n    get(path, options = {}) {\n        const { asBuffer = false } = options;\n        return this.#navigator.get(path, asBuffer);\n    }\n\n    exists(path) {\n        return this.#navigator.exists(path);\n    }\n\n    clean(localPath) {\n        this.#navigator.clean(localPath); \n    }\n\n    async h5open(path) {\n        let realized = scran.realizeFile(await this.get(path));\n        try {\n            return new AlabasterH5Group(new scran.H5File(realized.path), realized.flush);\n        } catch (e) {\n            realized.flush();\n            throw e;\n        }\n    }\n\n    h5close(handle) {\n        handle._flush();\n    }\n}\n\n/*********************\n *** Assay readers ***\n *********************/\n\nclass MockMatrix {\n    #nrow;\n    #ncol;\n    #path;\n\n    constructor(nrow, ncol, path) {\n        this.#nrow = nrow;\n        this.#ncol = ncol;\n        this.#path = path;\n    }\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.#nrow;\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.#ncol;\n    }\n\n    async realize(globals, forceInteger, forceSparse) {\n        let metadata = await jsp.readObjectFile(this.#path, globals);\n        if (metadata.type == \"delayed_array\") {\n            let contents = await globals.get(jsp.joinPath(this.#path, \"array.h5\"));\n            try {\n                let realized = scran.realizeFile(contents);\n                try {\n                    let handle = new scran.H5File(realized.path);\n                    let output = await extract_delayed(handle.open(\"delayed_array\"), this.#path, globals, forceInteger, forceSparse);\n                    if (output == null) {\n                        throw new Error(\"currently only supporting bakana-generated log-counts for delayed arrays\");\n                    }\n                    return output;\n                } finally {\n                    realized.flush();\n                }\n            } finally {\n                await globals.clean(contents);\n            }\n        } else {\n            return extract_matrix(this.#path, metadata, globals, forceInteger, forceSparse);\n        }\n    }\n}\n\nasync function extract_matrix(path, metadata, globals, forceInteger, forceSparse) {\n    if (metadata.type == \"compressed_sparse_matrix\") {\n        let contents = await globals.get(jsp.joinPath(path, \"matrix.h5\"));\n        try {\n            let realized = scran.realizeFile(contents);\n            try {\n                let fhandle = new scran.H5File(realized.path);\n                const name = \"compressed_sparse_matrix\";\n\n                let dhandle = fhandle.open(name);\n                const shape = dhandle.open(\"shape\").values; \n                const layout = dhandle.readAttribute(\"layout\").values[0];\n\n                let out = scran.initializeSparseMatrixFromHdf5Group(realized.path, name, shape[0], shape[1], (layout == \"CSR\"), { forceInteger });\n                return out;\n            } finally {\n                realized.flush();\n            }\n        } finally {\n            await globals.clean(contents);\n        }\n\n    } else if (metadata.type == \"dense_array\") {\n        let contents = await globals.get(jsp.joinPath(path, \"array.h5\"));\n        try {\n            let realized = scran.realizeFile(contents);\n            try {\n                let fhandle = new scran.H5File(realized.path);\n                const name = \"dense_array\";\n                let dhandle = fhandle.open(name);\n                let transposed = false;\n                if (dhandle.attributes.indexOf(\"transposed\") >= 0) {\n                    let trans_info = dhandle.readAttribute(\"transposed\");\n                    transposed = (trans_info.values[0] != 0);\n                }\n\n                return scran.initializeMatrixFromHdf5Dataset(realized.path, name + \"/data\", { transposed, forceInteger, forceSparse });\n            } finally {\n                realized.flush();\n            }\n        } finally {\n            await globals.clean(contents);\n        }\n\n    } else {\n        throw new Error(\"unknown matrix type '\" + metadata.type + \"'\");\n    }\n}\n\nasync function extract_delayed(handle, path, globals, forceInteger, forceSparse) {\n    const dtype = handle.readAttribute(\"delayed_type\").values[0];\n    if (dtype === \"operation\") {\n        let optype = handle.readAttribute(\"delayed_operation\").values[0];\n\n        if (optype === \"unary arithmetic\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n\n            const dhandle = handle.open(\"value\");\n            let arg = dhandle.values;\n            let along = \"row\";\n            if (dhandle.shape.length == 0) {\n                arg = arg[0];\n            } else {\n                along = (handle.open(\"along\").values[0] === 0 ? \"row\" : \"column\");\n            }\n\n            return scran.delayedArithmetic(\n                seed,\n                handle.open(\"method\").values[0],\n                arg,\n                {\n                    right: handle.open(\"side\").values[0] === \"right\",\n                    along: along,\n                    inPlace: true\n                }\n            );\n\n        } else if (optype === \"unary math\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const meth = handle.open(\"method\").values[0];\n            let base = null;\n            if (meth == \"log\") {\n                if (\"base\" in handle.children) {\n                    base = handle.open(\"base\").values[0];\n                }\n            }\n            return scran.delayedMath(\n                seed,\n                meth,\n                {\n                    logBase: base,\n                    inPlace: true\n                }\n            );\n\n        } else if (optype == \"transpose\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const perm = handle.open(\"permutation\").values;\n            if (perm[0] == 1 && perm[1] == 0) {\n                return scran.transpose(seed, { inPlace: true });\n            } else if (perm[0] == 0 && perm[1] == 1) {\n                return seed;\n            } else {\n                throw new Error(\"invalid permutation for transposition operation at '\" + path + \"'\");\n            }\n\n        } else if (optype == \"subset\") {\n            let mat = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const ihandle = handle.open(\"index\");\n            if (\"0\" in ihandle.children) {\n                mat = scran.subsetRows(mat, ihandle.open(\"0\").values, { inPlace: true });\n            }\n            if (\"1\" in ihandle.children) {\n                mat = scran.subsetColumns(mat, ihandle.open(\"1\").values, { inPlace: true });\n            }\n            return mat;\n\n        } else if (optype == \"combine\") {\n            const shandle = handle.open(\"seeds\");\n            let seeds = [];\n            try {\n                const nchildren = Object.keys(shandle.childen).length;\n                for (var c = 0; c < nchildren; c++) {\n                    seeds.push(await extract_delayed(shandle.open(String(c)), path, globals, forceInteger, forceSparse));\n                }\n                if (handle.open(\"along\").values[0] == 0) {\n                    return scran.rbind(seeds);\n                } else {\n                    return scran.cbind(seeds);\n                }\n            } finally {\n                for (const s of seeds) {\n                    scran.free(s);\n                }\n            }\n\n        } else {\n            throw new Error(\"unsupported delayed operation '\" + optype + \"'\");\n        }\n\n    } else if (dtype === \"array\") {\n        let atype = handle.readAttribute(\"delayed_array\").values[0];\n\n        if (atype === \"custom takane seed array\") {\n            let index = handle.open(\"index\").values[0];\n            let seed_path = jsp.joinPath(path, \"seeds\", String(index));\n            let seed_metadata = await jsp.readObjectFile(seed_path, globals);\n            let mat;\n            let output;\n            try {\n                return await extract_matrix(seed_path, seed_metadata, globals, forceInteger, forceSparse); \n            } finally {\n                scran.free(mat);\n            }\n\n        } else if (atype == \"dense array\") {\n            let is_native = handle.open(\"native\").values[0] != 0;\n            return scran.initializeMatrixFromHdf5Dataset(handle.file, handle.name + \"/data\", { transposed: !is_native, forceInteger, forceSparse });\n\n        } else if (atype == \"sparse matrix\") {\n            const shape = handle.open(\"shape\").values; \n            const is_csr = handle.open(\"by_column\").values[0] == 0;\n            return scran.initializeSparseMatrixFromHdf5Group(handle.file, handle.name, shape[0], shape[1], is_csr, { forceInteger });\n\n        } else {\n            throw new Error(\"unsupported delayed array '\" + atype + \"'\");\n        }\n\n    } else {\n        throw new Error(\"unsupported delayed type '\" + dtype + \"'\");\n    }\n\n    return output;\n}\n\nfunction readMockAssay(nrow, ncol, path, metadata, globals, options) {\n    return new MockMatrix(nrow, ncol, path);\n}\n\nfunction readMockReducedDimension(ncol, path, metadata, globals, options) {\n    return new MockMatrix(ncol, 2, path);\n}\n\n/*************************\n *** Utility functions ***\n *************************/\n\nfunction apply_over_experiments(se, fun) {\n    let main_experiment_name = \"\";\n    let is_sce = se instanceof bioc.SingleCellExperiment;\n    if (is_sce && se.mainExperimentName() !== null) {\n        main_experiment_name = se.mainExperimentName();\n    }\n\n    let output = {};\n    output[main_experiment_name] = fun(se);\n    if (is_sce) {\n        for (const alt of se.alternativeExperimentNames()) {\n            if (alt !== main_experiment_name) { // do not clobber the main experiment!\n                output[alt] = fun(se.alternativeExperiment(alt));\n            }\n        }\n    }\n    return output;\n}\n\nfunction extract_all_features(se) {\n    return apply_over_experiments(se, x => x.rowData());\n}\n\nfunction extract_all_assay_names(se) {\n    return apply_over_experiments(se, x => x.assayNames());\n}\n\nfunction simplify_List_columns(df) { // avoid the hassle of dealing with List compatibility problems in the rest of bakana.\n    for (const k of df.columnNames()) {\n        let col = df.column(k);\n        if (col instanceof bioc.List) {\n            df.setColumn(k, col.toArray(), { inPlace: true });\n        }\n    }\n    return null;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment in the **alabaster** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain AlabasterProjectNavigator} class.\n * Subclasses should define `abbreviate()` and `serialize()` methods, as well as the static `format()` and `unserialize()` methods - \n * see the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md) for more details.\n */\nexport class AbstractAlabasterDataset {\n    #navigator;\n    #raw_se;\n    #options;\n\n    /**\n     * @param {AlabasterProjectNavigator} navigator - A navigator object that describes how to obtain files from the alabaster-formatted object directory.\n     */\n    constructor(navigator) {\n        this.#navigator = navigator;\n        this.#options = AbstractAlabasterDataset.defaults();\n        this.#raw_se = null;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractAlabasterDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractAlabasterDataset#load load} (but not {@linkcode AbstractAlabasterDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?string} [options.rnaExperiment] - Name of the main/alternative experiment containing gene expression data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no RNA data is assumed to be present.\n     * @param {?string} [options.adtExperiment] - Name of the main/alternative experiment containing ADT data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no ADTs are assumed to be present.\n     * @param {?string} [options.crisprExperiment] - Name of the main/alternative experiment containing CRISPR guide data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no CRISPR guides are assumed to be present.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractAlabasterDataset#load load} or {@linkcode AbstractAlabasterDataset#summary summary}.\n     */\n    clear() {\n        this.#raw_se = null;\n    }\n\n    #create_globals() { \n        return new AlabasterGlobalsInterface(this.#navigator);\n    }\n\n    async #populate() {\n        if (this.#raw_se === null) {\n            this.#raw_se = await jsp.readObject(\n                \".\",\n                null, \n                this.#create_globals(),\n                {\n                    DataFrame_readNested: false,\n                    DataFrame_readMetadata: false,\n                    SummarizedExperiment_readAssay: readMockAssay,\n                    SummarizedExperiment_readMetadata: false,\n                    SingleCellExperiment_readReducedDimension: false\n                }\n            );\n            simplify_List_columns(this.#raw_se.columnData());\n            apply_over_experiments(this.#raw_se, y => simplify_List_columns(y.rowData()));\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = {\n            modality_features: extract_all_features(this.#raw_se),\n            cells: this.#raw_se.columnData(),\n            modality_assay_names: extract_all_assay_names(this.#raw_se)\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode AbstractAlabasterDataset#load load} but the order of values may be different.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned object.\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#populate();\n\n        let fmapping = {\n            RNA: this.#options.rnaExperiment, \n            ADT: this.#options.adtExperiment, \n            CRISPR: this.#options.crisprExperiment \n        };\n\n        let raw_features = extract_all_features(this.#raw_se);\n        let altnames = [];\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            altnames = this.#raw_se.alternativeExperimentNames();\n        }\n        let preview = futils.extractRemappedPrimaryIds(raw_features, altnames, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode AbstractAlabasterDataset#defaults defaults} or with {@linkcode AbstractAlabasterDataset#setOptions setOptions}.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_se.columnData()\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        let experiments_by_name = apply_over_experiments(this.#raw_se, x => x);\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null || !(v.exp in experiments_by_name)) {\n                    continue;\n                }\n                let chosen_se = experiments_by_name[v.exp];\n                let loaded = await chosen_se.assay(v.assay).realize(this.#create_globals(), /* forceInteger = */ true, /* forceSparse = */ true);\n                output.matrix.add(k, loaded);\n                output.features[k] = chosen_se.rowData();\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain AlabasterProjectNavigator} class.\n */\nexport class AbstractAlabasterResult {\n    #navigator;\n    #raw_se;\n    #options;\n\n    /**\n     * @param {AlabasterNavigator} navigator - A navigator object that describes how to obtain files from an alabaster-formatted object directory.\n     */\n    constructor(navigator) {\n        this.#navigator = navigator;\n        this.#options = AbstractAlabasterResult.defaults();\n        this.#raw_se = null;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractAlabasterResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractAlabasterResult#load load} (but not {@linkcode AbstractAlabasterResult#summary summary}.\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractAlabasterResult#load load} or {@linkcode AbstractAlabasterResult#summary summary}.\n     */\n    clear() {\n        this.#raw_se = null;\n    }\n\n    #create_globals() { \n        return new AlabasterGlobalsInterface(this.#navigator);\n    }\n\n    async #populate() {\n        if (this.#raw_se === null) {\n            this.#raw_se = await jsp.readObject(\n                \".\",\n                null, \n                this.#create_globals(),\n                {\n                    DataFrame_readNested: false,\n                    DataFrame_readMetadata: false,\n                    SummarizedExperiment_readAssay: readMockAssay,\n                    SummarizedExperiment_readMetadata: false,\n                    SingleCellExperiment_readReducedDimension: readMockReducedDimension\n                }\n            );\n            simplify_List_columns(this.#raw_se.columnData());\n            apply_over_experiments(this.#raw_se, y => simplify_List_columns(y.rowData()));\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractAlabasterResult#load load}.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async \n     */\n    async summary({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = {\n            modality_features: extract_all_features(this.#raw_se),\n            cells: this.#raw_se.columnData(),\n            modality_assay_names: extract_all_assay_names(this.#raw_se),\n            reduced_dimension_names: []\n        };\n\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            output.reduced_dimension_names = this.#raw_se.reducedDimensionNames();\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractAlabasterResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_se.columnData(),\n            reduced_dimensions: {}\n        };\n\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            let chosen_rd = this.#options.reducedDimensionNames;\n            if (chosen_rd === null) {\n                chosen_rd = this.#raw_se.reducedDimensionNames();\n            }\n            for (const k of chosen_rd) {\n                let current = await this.#raw_se.reducedDimension(k).realize(this.#create_globals(), /* forceInteger = */ false, /* forceSparse = */ false);\n                try {\n                    let collected = [];\n                    let ncol = current.numberOfColumns();\n                    for (var c = 0; c < ncol; c++) {\n                        collected.push(current.column(c));\n                    }\n                    output.reduced_dimensions[k] = collected;\n                } finally {\n                    scran.free(current);\n                }\n            }\n        }\n\n        // Now fetching the assay matrix.\n        const experiments_by_name = apply_over_experiments(this.#raw_se, x => x);\n        try {\n            for (const [name, chosen_se] of Object.entries(experiments_by_name)) {\n                let curassay = this.#options.primaryAssay;\n                if (typeof curassay == \"object\") {\n                    if (name in curassay) {\n                        curassay = curassay[name];\n                    } else {\n                        continue;\n                    }\n                }\n\n                let curnormalized = this.#options.isPrimaryNormalized;\n                if (typeof curnormalized == \"object\") {\n                    if (name in curnormalized) {\n                        curnormalized = curnormalized[name];\n                    } else {\n                        curnormalized = true;\n                    }\n                }\n\n                let loaded = await chosen_se.assay(curassay).realize(this.#create_globals(), /* forceInteger= */ !curnormalized, /* forceSparse = */ true);\n                output.matrix.add(name, loaded);\n\n                if (!curnormalized) {\n                    let normed = scran.normalizeCounts(loaded, { allowZeros: true });\n                    output.matrix.add(name, normed);\n                }\n\n                output.features[name] = chosen_se.rowData();\n            }\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as markers from \"./utils/markers.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as rna_norm_module from \"./rna_normalization.js\";\nimport * as adt_norm_module from \"./adt_normalization.js\";\nimport * as crispr_norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"custom_selections\";\n\n/************************\n ****** Internals *******\n ************************/\n\nclass SelectionManager {\n    constructor(selections = null, cache = null) {\n        this._selections = (selections == null ? {} : selections);\n        this._cache = (cache == null ? { results: {} } : cache);\n    }\n\n    #liberate(i) {\n        for (const [k, v] of Object.entries(this._cache.results[i].raw)) {\n            v.free();                                                \n        }\n    }\n\n    free() {\n        utils.freeCache(this._cache.buffer);\n        delete this._cache.buffer;\n\n        for (const k of Object.keys(this._cache.results)) {\n            this.#liberate(k);\n        }\n        this._cache.results = {};        \n\n        markers.freeVersusResults(this._cache.versus);\n        delete this._cache.versus;\n    }\n\n    addSelection(id, selection, to_use, matfun, block, copy, lfc_threshold, compute_auc) {\n        let mat = matfun(to_use[0]);\n        let ncells = mat.numberOfColumns();\n        utils.checkIndices(selection, ncells);\n\n        // Assumes that we have at least one cell in and outside the selection!\n        var buffer = utils.allocateCachedArray(ncells, \"Int32Array\", this._cache);\n        buffer.fill(0);\n        var tmp = buffer.array();\n        selection.forEach(element => { tmp[element] = 1; });\n\n        let res = {};\n        for (const k of to_use) {\n            let mat = matfun(k);\n            res[k] = scran.scoreMarkers(mat, buffer, { block: block, threshold: lfc_threshold, computeAuc: compute_auc }); \n        }\n              \n        // Removing previous results, if there were any.\n        if (id in this._cache.results) {\n            this.#liberate(id);\n        }\n      \n        this._cache.results[id] = { \"raw\": res };\n\n        // making a copy to take ownership.\n        if (copy) {\n            selection = selection.slice();\n        }\n        this._selections[id] = selection;\n        return;\n    }\n\n    removeSelection(id) {\n        this.#liberate(id);\n        delete this._cache.results[id];\n        delete this._selections[id];\n        return;\n    }\n\n    fetchResults(id) {\n        return this._cache.results[id].raw;\n    }\n\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        let raw = this._selections[id];\n        if (copy) {\n            raw = raw.slice();\n        }\n        return raw;\n    }\n\n    fetchSelections({ copy = true, force = null } = {}) {\n        let replacement = {};\n\n        for (const [k, v] of Object.entries(this._selections)) {\n            let store = v;\n            let needs_copy = copy;\n\n            if (force !== null) {\n                if (force == \"Array\") {\n                    if (!(v instanceof Array)) {\n                        store = Array.from(v);\n                        needs_copy = false;\n                    }\n                } else if (force == \"Int32Array\") {\n                    if (!(v instanceof Int32Array)) {\n                        store = new Int32Array(v);\n                        needs_copy = false;\n                    }\n                }\n            } \n\n            if (needs_copy) {\n                store = store.slice();\n            }\n            replacement[k] = store;\n        }\n        return replacement;        \n    }\n\n    computeVersus(left, right, to_use, matfun, block, lfc_threshold, compute_auc) {\n        if (!(\"versus\" in this._cache)) {\n            this._cache[\"versus\"] = {};\n        }\n        let cache = this._cache.versus;\n\n        let cache_info = markers.locateVersusCache(left, right, cache);\n        let left_index = (cache_info.left_small ? 0 : 1);\n        let right_index = (cache_info.left_small ? 1 : 0);\n\n        if (cache_info.run) {\n            // No need to free this afterwards; we don't own the normalized matrices anyway.\n            let matrices = new scran.MultiMatrix;\n            for (const modality of to_use) {\n                matrices.add(modality, matfun(modality));\n            }\n\n            let selections = this._selections;\n            if (!(left in selections && right in selections)) {\n                throw new Error(\"invalid selection ID requested in versus mode\");\n            }\n\n            let leftsel = selections[left];\n            let rightsel = selections[right];\n            if (leftsel.length == 0 || rightsel.length == 0) {\n                throw new Error(\"non-zero entries should be present for both requested selections in versus mode\");\n            }\n\n            let triplets = [];\n            leftsel.forEach(x => {\n                triplets.push({ \"index\": x, \"cluster\": left_index });\n            });\n            rightsel.forEach(x => {\n                triplets.push({ \"index\": x, \"cluster\": right_index });\n            });\n\n            triplets.sort((a, b) => a.index - b.index);\n            let keep = triplets.map(x => x.index);\n            let new_clusters = triplets.map(x => x.cluster);\n            markers.computeVersusResults(matrices, new_clusters, block, keep, cache_info.cached, lfc_threshold, compute_auc);\n        }\n\n        return { \n            results: cache_info.cached,\n            left: left_index,\n            right: right_index\n        };\n    }\n}\n\n/********************\n ****** State *******\n ********************/\n\n/**\n * Applications can perform marker detection on custom selections of cells.\n * This allows users to dynamically select cells on a UI and quickly obtain a list of distinguishing markers for that selection.\n * This wraps the [`scoreMarkers`](https://kanaverse.github.io/scran.js/global.html#scoreMarkers) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Users should not construct these instances manually; instead, they are automatically assembled by {@linkcode createAnalysis}.\n * Similarly, users should not directly call the {@linkcode CustomSelectionsCore#compute compute} method, which is instead invoked by {@linkcode runAnalysis}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CustomSelectionsState {\n    #filter;\n    #norm_states;\n\n    #manager;\n    #parameters;\n\n    constructor(filter, norm_states, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm_states.RNA instanceof rna_norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm_states.RNA' should be an RnaNormalizationState object\");\n        }\n        if (!(norm_states.ADT instanceof adt_norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm_states.ADT' should be an AdtNormalizationState object\");\n        }\n        if (!(norm_states.CRISPR instanceof crispr_norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm_states.CRISPR' should be an CrisprNormalizationState object\");\n        }\n        this.#norm_states = norm_states;\n\n        let selections = null;\n        if (parameters !== null && \"selections\" in parameters) {\n            selections = parameters.selections;\n        }\n\n        this.#manager = new SelectionManager(selections, cache);\n        this.#parameters = {};\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        this.#manager.free();\n        return;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return {\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        };\n    }\n\n    /**\n     * Add a custom selection and compute its markers.\n     * It is assumed that {@linkcode runAnalysis} was already run on this instance before calling this method.\n     *\n     * @param {string} id A unique identifier for the new custom selection.\n     * @param {Array|TypedArray} selection The indices of the cells in the selection.\n     * Indices should refer to positions of cells in the QC-filtered matrix, not the original matrix.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before storing it inside this object.\n     * If `false`, it is assumed that the caller makes no further modifications to the passed `selection`.\n     *\n     * @return The custom selection is added to the state and calculation of its markers is performed.\n     * Nothing is returned.\n     */\n    addSelection(id, selection, { copy = true } = {}) {\n        this.#addSelection(id, selection, copy, this.#parameters.lfc_threshold, this.#parameters.compute_auc);\n    }\n\n    #addSelection(id, selection, copy, lfc_threshold, compute_auc) {\n        let to_use = utils.findValidUpstreamStates(this.#norm_states);\n        this.#manager.addSelection(\n            id, \n            selection, \n            to_use, \n            modality => this.#norm_states[modality].fetchNormalizedMatrix(),\n            this.#filter.fetchFilteredBlock(),\n            copy,\n            lfc_threshold,\n            compute_auc\n        );\n        return;\n    }\n\n    /**\n     * Remove a custom selection and its results from the state.\n     *\n     * @param {string} id - An identifier for the selection to be removed.\n     *\n     * @return The specified selection and its results are removed from the state.\n     * Nothing is returned.\n     */\n    removeSelection(id) {\n        this.#manager.removeSelection(id);\n        return;\n    }\n\n    /**\n     * @param {string} id - An identifier for the desired selection.\n     *\n     * @return {object} Object containing the markers for the desired selection.\n     * Each key is a modality name while each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object,\n     * containing the marker detection results across all features of the corresponding modality.\n     * The set of cells in the selection is denoted as group 1, while all cells outside of the selection are denoted as group 0.\n     */\n    fetchResults(id) {\n        return this.#manager.fetchResults(id);\n    }\n\n    /**\n     * Retrieve the indices for a selection of interest.\n     *\n     * @param {string} id - The identifier for the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     *\n     * @return {Array|TypedArray} Array of indices in the requested selection.\n     * Note that indices are relative to the filtered matrix - \n     * use {@linkcode CellFilteringState#undoFiltering CellFilteringState.undoFiltering} to convert them to indices on the original dataset.\n     */\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        return this.#manager.fetchSelectionIndices(id, { copy });\n    }\n\n    /**\n     * Retrieve indices for all selections.\n     *\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     * @param {?string} [force=null] - Whether to force each `selection` to be an `\"Array\"` or \"`Int32Array\"`.\n     * If `null`, the existing type of each selection is used.\n     *\n     * @return {object} Object where the keys are the selection names and the values are arrays of indices for each selection.\n     * Each array is a copy and can be modified without affecting the CustomSelectionsState.\n     * See {@linkcode CustomSelectionsState#fetchSelectionIndices fetchSelectionIndices} for more details on the interpretation of the indices.\n     */\n    fetchSelections({ copy = true, force = null } = {}) {\n        return this.#manager.fetchSelections({ copy, force });\n    }\n\n    /**\n     * @param {object} parameters - Parameter object, equivalent to the `custom_selections` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} [parameters.lfc_threshold] - Log-fold change threshold to use when computing the Cohen's d and AUC for each pairwise comparison.\n     * @param {boolean} [parameters.compute_auc] - Whether to compute the AUCs.\n     * Setting this to `false` will skip AUC calculations and improve speed and memory efficiency.\n     *\n     * @return The state is updated by removing stale selections if the QC filter was altered.\n     */\n    compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CustomSelectionsState.defaults());\n        this.changed = false;\n\n        /* If the QC filter was re-run, all of the selections are invalidated as\n         * the identity of the indices may have changed.\n         */\n        if (this.#filter.changed) {\n            this.#manager.free();\n            this.#manager = new SelectionManager;\n            this.changed = true;\n        }\n\n        /* If the parameters changed, we recompute all the per-selection markers.\n         * Technically we would need to re-run detection on the existing selections\n         * if the normalization changed but the QC was the same. In practice, this\n         * never happens, so we'll deal with it later.\n         */\n        if (parameters.lfc_threshold !== this.#parameters.lfc_threshold || parameters.compute_auc != this.#parameters.compute_auc) {\n            for (const [key, value] of Object.entries(this.#manager._selections)) {\n                this.#addSelection(key, value, false, parameters.lfc_threshold, parameters.compute_auc);\n            }\n            this.#parameters.lfc_threshold = parameters.lfc_threshold;\n            this.#parameters.compute_auc = parameters.compute_auc;\n            this.changed = true;\n        }\n\n        return;\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CustomSelectionsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two selections for more detailed examination of the differences between them.\n     *\n     * @param {string} left - Identifier of one selection in which to find upregulated markers.\n     * @param {string} right - Identifier of another selection to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` selection are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `right` selection are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        let to_use = utils.findValidUpstreamStates(this.#norm_states);\n        return this.#manager.computeVersus(\n            left, \n            right, \n            to_use,\n            modality => this.#norm_states[modality].fetchNormalizedMatrix(),\n            this.#filter.fetchFilteredBlock(),\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n    }\n}\n\n/*************************\n ****** Standalone *******\n *************************/\n\n/**\n * Standalone version of {@linkplain CustomSelectionsState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own normalized matrices and blocking factor to compute the various marker statistics for each custom selection.\n * Users are also responsible for ensuring that the lifetime of the supplied objects exceeds that of the constructed CustomSelectionsStandalone instance,\n * i.e., the Wasm-related `free()` methods are not called while the MarkerDetectionStandalone instance is still in operation.\n */\nexport class CustomSelectionsStandalone {\n    #normalized;\n    #block;\n    #block_levels;\n\n    #manager;\n    #parameters;\n\n    #missing_map;\n\n    /**\n     * @param {external:MultiMatrix} normalized - A {@linkplain external:MultiMatrix MultiMatrix} of log-normalized values for multiple modalities.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in any value of `normalized`, containing the block assignments for each column.\n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(normalized, { block = null } = {}) {\n        let N = null;\n        for (const k of normalized.available()) {\n            let alt = normalized.get(k).numberOfColumns();\n            if (N != null) {\n                if (alt != N) {\n                    throw new Error(\"all matrices in 'normalized' should have the same number of columns as the length of 'groups'\");\n                }\n            } else {\n                N = alt;\n            }\n        }\n\n        this.#block = null;\n        this.#block_levels = null;\n        this.#missing_map = null;\n\n        if (block !== null) {\n            if (block.length != N) {\n                throw new Error(\"'block' should have the same length as the number of columns in each entry of 'normalized'\");\n            }\n\n            let dump = utils.subsetInvalidFactors([ block ]);\n            if (dump.retain !== null) {\n                let revmap = new Int32Array(N);\n                revmap.fill(-1);\n                dump.retain.forEach((y, i) => { revmap[y] = i; });\n                this.#missing_map = { to: revmap, from: dump.retain };\n\n                let new_matrices = new scran.MultiMatrix;\n                let temp = scran.createInt32WasmArray(dump.retain.length);\n                try {\n                    temp.set(dump.retain);\n                    for (const k of normalized.available()) {\n                        new_matrices.add(k, scran.subsetColumns(normalized.get(k), temp))\n                    }\n                } catch (e) {\n                    scran.free(new_matrices);\n                    throw e;\n                } finally {\n                    scran.free(temp);\n                }\n\n                this.#normalized = new_matrices;\n            } else {\n                this.#normalized = normalized.clone();\n            }\n\n            this.#block = dump.arrays[0].ids;\n            this.#block_levels = dump.arrays[0].levels;\n        } else {\n            this.#normalized = normalized.clone();\n        }\n\n        this.#manager = new SelectionManager;\n        this.#parameters = CustomSelectionsState.defaults();\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#normalized);\n        scran.free(this.#block);\n        this.#manager.free();\n        return;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return {\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the blocking factor.\n     * Block indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchBlockLevels({ copy = true } = {}) {\n        let ret = this.#block_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#normalized;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CustomSelectionsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode CustomSelectionsStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see the argument of the same name in {@linkcode CustomSelectionsState#compute CustomSelectionsState.compute} for more details.\n     *\n     * @return The state is updated with the new parameters.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CustomSelectionsStandalone.defaults());\n        if (this.#parameters.lfc_threshold !== parameters.lfc_threshold || \n            this.#parameters.compute_auc !== parameters.compute_auc)\n        {\n            this.#manager.free();\n        }\n        this.#parameters = parameters;\n        return;\n    }\n\n    /**\n     * Add a custom selection and compute its markers.\n     * Users should run {@linkcode CustomSelectionsCore#compute compute} at least once before calling this function.\n     *\n     * @param {string} id - A unique identifier for the new custom selection.\n     * @param {Array|TypedArray} selection - The indices of the cells in the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before storing it inside this object.\n     * If `false`, it is assumed that the caller makes no further modifications to the passed `selection`.\n     *\n     * @return The custom selection is added to the state and calculation of its markers is performed.\n     * Nothing is returned.\n     */\n    addSelection(id, selection, { copy = true } = {}) {\n        let selection_internal = selection;\n\n        // Removing the invalid observations.\n        if (this.#missing_map !== null) { \n            let collected = [];\n            let revmap = this.#missing_map.to;\n            for (const i of selection) {\n                let j = revmap[i];\n                if (j >= 0) {\n                    collected.push(j);\n                }\n            }\n            selection_internal = collected;\n        }\n\n        this.#manager.addSelection(\n            id, \n            selection_internal,\n            this.#normalized.available(),\n            modality => this.#normalized.get(modality),\n            this.#block,\n            copy,\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n\n        return;\n    }\n\n    /**\n     * Remove a custom selection and its results from the state.\n     *\n     * @param {string} id - An identifier for the selection to be removed.\n     *\n     * @return The specified selection and its results are removed from the state.\n     * Nothing is returned.\n     */\n    removeSelection(id) {\n        this.#manager.removeSelection(id);\n        return;\n    }\n\n    /**\n     * @param {string} id - An identifier for the desired selection.\n     *\n     * @return {object} Object containing the markers for the desired selection.\n     * Each key is a modality name while each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object,\n     * containing the marker detection results across all features of the corresponding modality.\n     * The set of cells in the selection is denoted as group 1, while all cells outside of the selection are denoted as group 0.\n     */\n    fetchResults(id) {\n        return this.#manager.fetchResults(id);\n    }\n\n    #unmap(ids) {\n        // Restoring the indices after adjusting for the invalid observations,\n        // so that users get back indices relative to the input matrices.\n        if (this.#missing_map !== null) {\n            ids.forEach((x, i) => {\n                ids[i] = this.#missing_map.from[x];\n            });\n        }\n        return;\n    }\n\n    /**\n     * Retrieve the indices for a selection of interest.\n     *\n     * @param {string} id - The identifier for the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     *\n     * @return {Array|TypedArray} Array of indices in the requested selection.\n     */\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        let output = this.#manager.fetchSelectionIndices(id, { copy });\n        this.#unmap(output);\n        return output;\n    }\n\n    /**\n     * Retrieve indices for all selections.\n     *\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     * @param {?string} [force=null] - Whether to force each `selection` to be an `\"Array\"` or \"`Int32Array\"`.\n     * If `null`, the existing type of each selection is used.\n     *\n     * @return {object} Object where the keys are the selection names and the values are arrays of indices for each selection.\n     * Each array is a copy and can be modified without affecting the CustomSelectionsState.\n     */\n    fetchSelections({ copy = true, force = null } = {}) {\n        let output = this.#manager.fetchSelections({ copy, force });\n        for (const [k, v] of Object.entries(output)) {\n            this.#unmap(v);\n        }\n        return output;\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two selections, \n     * for more detailed examination of the differences between them.\n     *\n     * @param {string} left - Identifier of one selection in which to find upregulated markers.\n     * @param {string} right - Identifier of another selection to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` selection are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `right` selection are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        return this.#manager.computeVersus(\n            left, \n            right, \n            this.#normalized.available(),\n            modality => this.#normalized.get(modality),\n            this.#block,\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SingleCellExperiment is a {@linkplain RangedSummarizedExperiment} subclass that contains additional fields for storing reduced dimensions and alternative experiments.\n * It supports the same set of generics as the {@linkplain SummarizedExperiment}.\n *\n * Each reduced dimension instance should have number of rows equal to the number of columns of the SingleCellExperiment.\n * Each instance is expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode CLONE}\n *\n * Each alternative experiment should be a {@linkplain SummarizedExperiment} with number of columns equal to that of the SingleCellExperiment.\n *\n * Constructors of RangedSummarizedExperiment subclasses should be callable with no arguments, possibly creating an empty object with no properties.\n * This will be used by the `_bioconductor_CLONE`, `_bioconductor_COMBINE_ROWS`, `_bioconductor_COMBINE_COLUMNS` and `_bioconductor_SLICE_2D` methods to return an instance of the subclass.\n *\n * @extends RangedSummarizedExperiment\n */\nexport class SingleCellExperiment extends rse.RangedSummarizedExperiment {\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {?(GRanges|GroupedGRanges)} [options.rowRanges=null] - Genomic ranges corresponding to each row, see the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {Object|Map} [options.reducedDimensions={}] - Object containing named reduced dimensions.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns of the assays.\n     * @param {?Array} [options.reducedDimensionOrder=null] - Array containing the order of the reduced dimensions.\n     * This should have the same values as the keys of `reducedDimensions`, and defaults to those keys if `null`.\n     * @param {Object|Map} [options.alternativeExperiments={}] - Object containing named alternative experiments.\n     * Each value should be a 2-dimensional object with number of columns equal to that of the assays.\n     * @param {?Array} [options.alternativeExperimentOrder=null] - Array containing the order of the alternative experiments.\n     * This should have the same values as the keys of `alternativeExperiments`, and defaults to those keys if `null`.\n     * @param {?string} [options.mainExperimentName=null] - Main experiment name, possibly `null` if the main experiment is unnamed.\n     */\n    constructor(assays, options={}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        let { reducedDimensions = {}, reducedDimensionOrder = null, alternativeExperiments = {}, alternativeExperimentOrder = null, rowRanges = null, mainExperimentName = null } = options;\n        super(assays, rowRanges, options);\n        let ncols = this.numberOfColumns();\n\n        try {\n            this._reducedDimensions = new il.InternalList(reducedDimensions, reducedDimensionOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize reduced dimension list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._reducedDimensions.names()) {\n            let v = this._reducedDimensions.entry(k);\n            if (generics.NUMBER_OF_ROWS(v) !== ncols) {\n                throw new Error(\"number of rows for reduced dimension '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        try {\n            this._alternativeExperiments = new il.InternalList(alternativeExperiments, alternativeExperimentOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize alternative experiment list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._alternativeExperiments.names()) {\n            let v = this._alternativeExperiments.entry(k);\n            if (!(v instanceof se.SummarizedExperiment)) {\n                throw new Error(\"alternative experiment '\" + k + \"' is not a SummarizedExperiment\");\n            }\n            if (v.numberOfColumns(v) !== ncols) {\n                throw new Error(\"number of columns for alternative experiment '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        this._mainExperimentName = mainExperimentName;\n        return;\n    }\n\n    static className = \"SingleCellExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the reduced dimensions.\n     */\n    reducedDimensionNames() {\n        return this._reducedDimensions.names();\n    }\n\n    /**\n     * @param {string|number} i - Reduced dimension to retrieve, either by name or index.\n     * @return {*} The contents of reduced dimension `i` as an multi-dimensional array-like object.\n     */\n    reducedDimension(i) {\n        let output;\n        try {\n            output = this._reducedDimensions.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Map} Map where keys are the names and values are the reduced dimensions.\n     */\n    reducedDimensions() {\n        return this._reducedDimensions.entries();\n    }\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the alternative experiments.\n     */\n    alternativeExperimentNames() {\n        return this._alternativeExperiments.names();\n    }\n\n    /**\n     * @param {string|number} i - Alternative experiment to retrieve, either by name or index.\n     * @return {SummarizedExperiment} The specified alternative experiment `i`. \n     */\n    alternativeExperiment(i) {\n        let output;\n        try {\n            output = this._alternativeExperiments.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Map} Map where keys are the names and values are the alternative experiments.\n     */\n    alternativeExperiments() {\n        return this._alternativeExperiments.entries();\n    }\n\n    /**\n     * @return {?string} The name of the main experiment, possibly `null` if this is unnamed.\n     */\n    mainExperimentName() {\n        return this._mainExperimentName;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeReducedDimension(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $removeReducedDimension(i) {\n        return this.removeReducedDimension(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimension(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) != this.numberOfColumns()) {\n            throw new Error(\"number of rows of 'value' should be the same as the number of columns of this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._reducedDimensions = target._reducedDimensions.set(i, value, { inPlace });\n        return target;\n    }\n\n    $setReducedDimension(i, value) {\n        return this.setReducedDimension(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimension names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensionNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the reduced dimension names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $setReducedDimensionNames(names) {\n        return this.setReducedDimensionNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Object|Map} value - Object containing zero, one or more multi-dimensional array-like objects in the values.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns in this SingleCellExperiment.\n     * Keys are reduced dimension names, each of which should be present in `order`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @param {Array|boolean} [options.newOrder=false] - Whether to replace the order of reduced dimensions with the order of keys in `value`.\n     * If `false`, the existing order in {@linkcode SingleCellExperiment#reducedDimensionNames reducedDimensionNames} is used.\n     * If an array is provided, this is used as the order.\n     * If `null`, this has the same effect as `true`.\n     *\n     * @return {SingleCellExperiment} A SingleCellExperiment with the new reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensions(value, { inPlace = false, newOrder = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (newOrder === false) {\n            newOrder = target._reducedDimensions.names();\n        } else if (newOrder == true) {\n            newOrder = null;\n        }\n        try {\n            target._reducedDimensions = new il.InternalList(value, newOrder);\n        } catch (e) {\n            throw new Error(\"failed to replace reduced dimension list for this SingleCellExperiment; \" + e.message, { cause: e });\n        }\n\n        let sce_nc = target.numberOfColumns();\n        for (const k of target._reducedDimensions.names()) {\n            let current = target._reducedDimensions.entry(k);\n            let nr = generics.NUMBER_OF_ROWS(current);\n            if (nr !== sce_nc) {\n                throw new Error(\"mismatch in the number of rows for reduced dimension '\" + k + \"' compared to the number of columns in the SingleCellExperiment\");\n            }\n        }\n\n        return target;\n    }\n\n    $setReducedDimensions(value, { newOrder = false } = {}) {\n        return this.setReducedDimensions(value, { inPlace: true, newOrder });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with sliced reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceReducedDimensions(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = this._reducedDimensions.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the reduced dimensions for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $sliceReducedDimensions(i) {\n        return this.sliceReducedDimensions(i, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAlternativeExperiment(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $removeAlternativeExperiment(i) {\n        return this.removeAlternativeExperiment(i, { inPlace: true });;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {SummarizedExperiment} value - A SummarizedExperiment to set/add as the alternative experiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiment(i, value, { inPlace = false } = {}) {\n        if (!(value instanceof se.SummarizedExperiment) || generics.NUMBER_OF_COLUMNS(value) != this.numberOfColumns()) {\n            throw new Error(\"'value' should be a SummarizedExperiment with the same number of columns as this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._alternativeExperiments = target._alternativeExperiments.set(i, value, { inPlace });\n        return target;\n    }\n\n    $setAlternativeExperiment(i, value) {\n        return this.setAlternativeExperiment(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiment names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperimentNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the alternative experiment names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $setAlternativeExperimentNames(names) {\n        return this.setAlternativeExperimentNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Object|Map} value - Object containing zero, one or more {@link SummarizedExperiment} objects in the values.\n     * Each value should have the same number of columns as this SingleCellExperiment.\n     * Keys are alternative experiment names, each of which should be present in `order`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @param {Array|boolean} [options.newOrder=false] - Whether to replace the order of alternative experiments with the order of keys in `value`.\n     * If `false`, the existing order in {@linkcode SingleCellExperiment#alternativeExperimentNames alternativeExperimentNames} is used.\n     * If an array is provided, this is used as the order.\n     * If `null`, this has the same effect as `true`.\n     *\n     * @return {SingleCellExperiment} A SingleCellExperiment with the new alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiments(value, { inPlace = false, newOrder = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (newOrder === false) {\n            newOrder = target._alternativeExperiments.names();\n        } else if (newOrder == true) {\n            newOrder = null;\n        }\n        try {\n            target._alternativeExperiments = new il.InternalList(value, newOrder);\n        } catch (e) {\n            throw new Error(\"failed to replace alternative experiment list for this SingleCellExperiment; \" + e.message, { cause: e });\n        }\n\n        let sce_nc = target.numberOfColumns();\n        for (const k of target._alternativeExperiments.names()) {\n            let current = target._alternativeExperiments.entry(k);\n            let nr = generics.NUMBER_OF_COLUMNS(current);\n            if (nr !== sce_nc) {\n                throw new Error(\"mismatch in the number of columns for alternative experiment '\" + k + \"' compared to the SingleCellExperiment\");\n            }\n        }\n\n        return target;\n    }\n\n    $setAlternativeExperiments(value, { newOrder = false } = {}) {\n        return this.setAlternativeExperiments(value, { inPlace: true, newOrder });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with sliced alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAlternativeExperiments(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = this._alternativeExperiments.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the alternative experiments for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $sliceAlternativeExperiments(i) {\n        return this.sliceAlternativeExperiments(i, { inPlace: true });\n    }\n\n    /**\n     * @return {?string} name - The name of the main experiment, possibly `null` if this is unnamed.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @return {SingleCellExperiment} A SingleCellExperiment with a new main experiment name.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setMainExperimentName(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._mainExperimentName = name;\n        return target;\n    }\n\n    $setMainExperimentName(name) {\n        return this.setMainExperimentName(name, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(rows, columns, { allowView = false }) {\n        let output = super._bioconductor_SLICE_2D(rows, columns, { allowView });\n\n        if (columns !== null) {\n            output._reducedDimensions = this._reducedDimensions.apply(v => generics.SLICE_2D(v, columns, null, { allowView }));\n            output._alternativeExperiments = this._alternativeExperiments.apply(v => generics.SLICE_2D(v, null, columns, { allowView }));\n        } else {\n            output._reducedDimensions = this._reducedDimensions;\n            output._alternativeExperiments = this._alternativeExperiments;\n        }\n\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_COMBINE_ROWS(objects) {\n        let output = super._bioconductor_COMBINE_ROWS(objects);\n        output._reducedDimensions = this._reducedDimensions;\n        output._alternativeExperiments = this._alternativeExperiments;\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(objects) {\n        let output = super._bioconductor_COMBINE_COLUMNS(objects);\n\n        let all_rd = [this._reducedDimensions];\n        let all_ae = [this._alternativeExperiments];\n        for (const x of objects) {\n            all_rd.push(x._reducedDimensions);\n            all_ae.push(x._alternativeExperiments);\n        }\n\n        try {\n            output._reducedDimensions = il.InternalList.parallelCombine(all_rd, generics.COMBINE_ROWS);\n        } catch (e) {\n            throw new Error(\"failed to combine reduced dimensions for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        try {\n            output._alternativeExperiments = il.InternalList.parallelCombine(all_ae, generics.COMBINE_COLUMNS);\n        } catch (e) {\n            throw new Error(\"failed to combine alternative experiments for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_CLONE({ deepCopy }) {\n        let output = super._bioconductor_CLONE({ deepCopy });\n        output._reducedDimensions = cutils.cloneField(this._reducedDimensions, deepCopy);\n        output._alternativeExperiments = cutils.cloneField(this._alternativeExperiments, deepCopy);\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as jsp from \"jaspagate\";\n\nexport class MockSparseMatrix {\n    #matrix;\n\n    constructor(matrix) {\n        this.#matrix = matrix;\n    }\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.#matrix.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.#matrix.numberOfColumns();\n    }\n\n    get matrix() {\n        return this.#matrix;\n    }\n}\n\nexport class MockNormalizedMatrix {\n    #matrix;\n    #sf;\n\n    constructor(matrix, sf) {\n        this.#matrix = matrix;\n        this.#sf = sf;\n    }\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.#matrix.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.#matrix.numberOfColumns();\n    }\n\n    get matrix() {\n        return this.#matrix;\n    }\n\n    get sf() {\n        return this.#sf;\n    }\n}\n\nexport async function saveSparseMatrix(x, path, globals, options) {\n    let has_ext_store = \"external_Matrix_store\" in options;\n    if (has_ext_store) {\n        for (const [y, ypath] of options.external_Matrix_store) {\n            if (y === x.matrix) {\n                for (const f of [\"OBJECT\", \"matrix.h5\"]) {\n                    await globals.copy(jsp.joinPath(ypath, f), jsp.joinPath(path, f));\n                }\n                return;\n            }\n        }\n    }\n\n    await globals.mkdir(path);\n    let fhandle = await globals.h5create(jsp.joinPath(path, \"matrix.h5\"))\n    let handle_stack = [fhandle];\n    let success = false;\n    try {\n        scran.writeSparseMatrixToHdf5(x.matrix, fhandle._path, \"compressed_sparse_matrix\", { format: \"tenx_matrix\", saveShape: false, overwrite: false });\n        let kids = fhandle.children();\n        kids[\"compressed_sparse_matrix\"] = \"Group\"; // need to trick it a little to get open() to work.\n        let ghandle = fhandle.open(\"compressed_sparse_matrix\");\n        handle_stack.push(ghandle);\n        ghandle.createDataSet(\"shape\", \"Uint32\", [2], { data: [x.matrix.numberOfRows(), x.matrix.numberOfColumns()] }).close();\n        ghandle.writeAttribute(\"layout\", \"String\", [], [\"CSC\"]);\n        ghandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]); // assume that we're always dealing with count matrices.\n        success = true;\n    } finally {\n        for (const handle of handle_stack.reverse()) {\n            handle.close();\n        }\n        await globals.h5finish(fhandle, !success);\n    }\n\n    await globals.write(jsp.joinPath(path, \"OBJECT\"), JSON.stringify({\n        type: \"compressed_sparse_matrix\",\n        compressed_sparse_matrix: { version: \"1.0\" }\n    }));\n\n    if (\"external_Matrix_store\" in options) {\n        options.external_Matrix_store.push([x.matrix, path]);\n    }\n}\n\nexport async function saveNormalizedMatrix(x, path, globals, options) {\n    await globals.mkdir(path);\n    let fhandle = await globals.h5create(jsp.joinPath(path, \"array.h5\"));\n    let handle_stack = [fhandle];\n    let success = false;\n    try {\n        // Saving the division by log(2).\n        let dhandle = fhandle.createGroup(\"delayed_array\");\n        handle_stack.push(dhandle);\n        dhandle.writeAttribute(\"delayed_type\", \"String\", [], [\"operation\"]);\n        dhandle.writeAttribute(\"delayed_operation\", \"String\", [], [\"unary arithmetic\"]);\n        dhandle.writeAttribute(\"delayed_version\", \"String\", [], [\"1.1\"]);\n        let vhandle = dhandle.createDataSet(\"value\", \"Float64\", [], { data: [Math.log(2)] });\n        vhandle.writeAttribute(\"type\", \"String\", [], [\"FLOAT\"]);\n        handle_stack.push(vhandle);\n        dhandle.createDataSet(\"method\", \"String\", [], { data: [\"/\"] }).close();\n        dhandle.createDataSet(\"side\", \"String\", [], { data: [\"right\"] }).close();\n\n        // Saving the log-transformation.\n        let l1phandle = dhandle.createGroup(\"seed\");\n        handle_stack.push(l1phandle);\n        l1phandle.writeAttribute(\"delayed_type\", \"String\", [], [\"operation\"]);\n        l1phandle.writeAttribute(\"delayed_operation\", \"String\", [], [\"unary math\"]);\n        l1phandle.createDataSet(\"method\", \"String\", [], { data: [\"log1p\"] }).close();\n\n        // Saving the division by the size factors.\n        let sfhandle = l1phandle.createGroup(\"seed\");\n        handle_stack.push(sfhandle);\n        sfhandle.writeAttribute(\"delayed_type\", \"String\", [], [\"operation\"]);\n        sfhandle.writeAttribute(\"delayed_operation\", \"String\", [], [\"unary arithmetic\"]);\n        vhandle = sfhandle.createDataSet(\"value\", \"Float64\", [x.sf.length], { data: x.sf });\n        vhandle.writeAttribute(\"type\", \"String\", [], [\"FLOAT\"]);\n        handle_stack.push(vhandle);\n        sfhandle.createDataSet(\"method\", \"String\", [], { data: [\"/\"] }).close();\n        sfhandle.createDataSet(\"side\", \"String\", [], { data: [\"right\"] }).close();\n        sfhandle.createDataSet(\"along\", \"Uint8\", [], { data: [1] }).close();\n\n        // Saving the original seed as a custom array.\n        let xhandle = sfhandle.createGroup(\"seed\");\n        handle_stack.push(xhandle);\n        xhandle.writeAttribute(\"delayed_type\", \"String\", [], [\"array\"]);\n        xhandle.writeAttribute(\"delayed_array\", \"String\", [], [\"custom takane seed array\"]);\n        xhandle.createDataSet(\"dimensions\", \"Uint64\", [2], { data: [x.matrix.numberOfRows(), x.matrix.numberOfColumns()] }).close();\n        xhandle.createDataSet(\"type\", \"String\", [], { data: [\"INTEGER\"] }).close();\n        xhandle.createDataSet(\"index\", \"Uint8\", [], { data: [0] }).close();\n\n        let seed_dir = jsp.joinPath(path, \"seeds\");\n        await globals.mkdir(seed_dir);\n        await saveSparseMatrix(new MockSparseMatrix(x.matrix), jsp.joinPath(seed_dir, \"0\"), globals, options);\n        success = true;\n\n    } finally {\n        for (const handle of handle_stack.reverse()) {\n            handle.close();\n        }\n        await globals.h5finish(fhandle, !success);\n    }\n\n    await globals.write(jsp.joinPath(path, \"OBJECT\"), JSON.stringify({\n        type: \"delayed_array\",\n        delayed_array: { version: \"1.0\" }\n    }));\n}\n","import * as jsp from \"jaspagate\";\nimport * as bioc from \"bioconductor\";\n\nexport class MockReducedDimensionMatrix {\n    #values;\n    #nr;\n    #nc;\n\n    constructor(nr, nc, values) {\n        this.#nr = nr;\n        this.#nc = nc;\n        this.#values = values;\n    }\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.#nr;\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.#nc;\n    }\n\n    get values() {\n        return this.#values;\n    }\n}\n\nexport async function saveReducedDimensionMatrix(x, path, globals, options) {\n    await globals.mkdir(path);\n    let fhandle = await globals.h5create(jsp.joinPath(path, \"array.h5\"));\n    let handle_stack = [fhandle]\n    let success = false;\n    try {\n        let dhandle = fhandle.createGroup(\"dense_array\");\n        handle_stack.push(dhandle);\n        dhandle.createDataSet(\"data\", \"Float64\", [bioc.NUMBER_OF_COLUMNS(x), bioc.NUMBER_OF_ROWS(x)], { data: x.values }); // [ncol, nrow] as HDF5 uses row-major storage.\n        dhandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n        dhandle.writeAttribute(\"transposed\", \"Int8\", [], [1]);\n        success = true;\n    } finally {\n        for (const handle of handle_stack.reverse()) {\n            handle.close();\n        }\n        await globals.h5finish(fhandle, !success);\n    }\n\n    await globals.write(jsp.joinPath(path, \"OBJECT\"), JSON.stringify({\n        type: \"dense_array\",\n        dense_array: { version: \"1.0\" }\n    }));\n}\n","import { List, IntegerList, StringList, BooleanList, NumberList } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, exceedsInt32, jsonBuffer } from \"./utils.js\";\n\nfunction load_number(x) {\n    if (x === \"NaN\") {\n        return Number.NaN;\n    } else if (x === \"Inf\") {\n        return Number.POSITIVE_INFINITY;\n    } else if (x === \"-Inf\") {\n        return Number.NEGATIVE_INFINITY;\n    } else {\n        return x;\n    }\n}\n\nfunction load_vector(x, constructor, options, typedarray) {\n    let vals = x.values;\n    let scalar = false;\n    if (!(vals instanceof Array)) {\n        vals = [vals];\n        scalar = true;\n    }\n    let output = constructor(vals);\n    if (\"names\" in x) {\n        output.setNames(x.names, { inPlace: true });\n    } else {\n        if (scalar) {\n            if (\"List_toScalar\" in options && options.List_toScalar) {\n                return output.get(0);\n            }\n        } else if (typedarray !== null && output.toArray().every(y => y !== null)) {\n            if (\"List_toTypedArray\" in options && options.List_toTypedArray) {\n                return new typedarray(output.toArray());\n            }\n        }\n    }\n    output._jaspalite_scalar = scalar;\n    return output;\n}\n\nasync function load_json_list(x, path, globals, options) {\n    if (x.type == \"list\") {\n        let contents = [];\n        for (const y of x.values) {\n            contents.push(await load_json_list(y, path, globals, options));\n        }\n        let output = new List(contents);\n        if (\"names\" in x) {\n            output.setNames(x.names, { inPlace: true });\n        }\n        return output;\n\n    } else if (x.type == \"integer\") {\n        return load_vector(x, v => new IntegerList(v), options, Int32Array);\n\n    } else if (x.type == \"number\") {\n        return load_vector(x, v => new NumberList(v.map(load_number)), options, Float64Array);\n\n    } else if (x.type == \"string\") {\n        return load_vector(x, v => new StringList(v), options, null);\n\n    } else if (x.type == \"boolean\") {\n        return load_vector(x, v => new BooleanList(v), options, null);\n\n    } else if (x.type == \"factor\") {\n        // Whatever, just turn it into a StringList.\n        return load_vector(\n            x,\n            v => {\n                let copy = v.slice();\n                for (var i = 0; i < copy.length; i++) {\n                    if (copy[i] !== null) {\n                        copy[i] = x.levels[copy[i]];\n                    }\n                }\n                return new StringList(copy);\n            },\n            options,\n            null\n        );\n\n    } else if (x.type == \"nothing\") {\n        return null;\n\n    } else if (x.type == \"external\") {\n        return readObject(joinPath(path, \"other_contents\", String(x.index)), null, globals, options);\n\n    } else {\n        throw new Error(\"unknown JSON list type '\" + x.type + \"'\");\n    }\n}\n\n/**\n * An R-style list that allows access by name or index. \n * @external List \n * @see {@link https://ltla.github.io/bioconductor.js/List.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:List List}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {boolean} [options.List_toScalar=false] - Whether to report unnamed scalars as Javascript scalars. \n * Integers are automatically converted to floating-point.\n * If `false`, scalars are reported as instances of an appropriately-typed {@link List} subclass with length 1 and a `_jaspalite_scalar` property.\n * @param {boolean} [options.List_toTypedArray=false] - Whether to report unnamed integer/number vectors without missing values as TypedArrays.\n * If `false`, such vectors are reported as instances of an appropriately-typed {@link List} subclass.\n *\n * @return {external:List} The list.\n * @async\n */\nexport async function readList(path, metadata, globals, options = {}) {\n    if (metadata.simple_list.format !== \"json.gz\") {\n        throw new Error(\"list formats other than 'json.gz' are currently not supported\");\n    }\n    let contents = await globals.get(joinPath(path, \"list_contents.json.gz\"), { asBuffer: true });\n\n    const stream = new Blob([contents]).stream();\n    const decompressed_stream = stream.pipeThrough(new DecompressionStream(\"gzip\"));\n    let chunks = [];\n    let counter = 0;\n    for await (const chunk of decompressed_stream) {\n        chunks.push(chunk);\n        counter += chunk.length;\n    }\n    let decompressed_final = new Uint8Array(counter);\n    counter = 0;\n    for (const chunk of chunks) {\n        decompressed_final.set(chunk, counter);\n        counter += chunk.length;\n    }\n\n    let dec = new TextDecoder;\n    let str = dec.decode(decompressed_final);\n    let x = JSON.parse(str);\n    return load_json_list(x, path, globals, options);\n}\n\nfunction dump_number_array(x) {\n    let output = Array.from(x);\n    for (var i = 0; i < output.length; i++) {\n        let current = output[i];\n        if (Number.isNaN(current)) {\n            output[i] = \"NaN\";\n        } else if (current == Number.POSITIVE_INFINITY) {\n            output[i] = \"Inf\";\n        } else if (current == Number.NEGATIVE_INFINITY) {\n            output[i] = \"-Inf\";\n        }\n    }\n    return output;\n}\n\nfunction dump_vector(x) {\n    let vals = x.toArray();\n    if (vals.length == 1 && \"_jaspagate_scalar\" in x && x._jaspagate_scalar) {\n        return vals[0];\n    } else {\n        return vals;\n    }\n}\n\nasync function dump_json_list(x, path, globals, options, state) {\n    if (x instanceof Array) {\n        let output = { \"type\": \"list\", \"values\": [] };\n\n        if (x.length) {\n            let all_strings = true;\n            let all_bools = true;\n            let all_numbers = true;\n            for (const e of x) {\n                if (e !== null) {\n                    if (typeof e !== \"string\") {\n                        all_strings = false;\n                    }\n                    if (typeof e !== \"boolean\") {\n                        all_bools = false;\n                    }\n                    if (typeof e !== \"number\") {\n                        all_numbers = false;\n                    }\n                }\n            }\n\n            if (all_strings) {\n                output.type = \"string\";\n                output.values = x;\n            } else if (all_bools) {\n                output.type = \"boolean\";\n                output.values = x;\n            } else if (all_numbers) {\n                output.type = \"number\";\n                output.values = dump_number_array(x);\n            } else {\n                for (const e of x) {\n                    output.values.push(await dump_json_list(e, path, globals, options, state));\n                }\n            }\n        }\n\n        return output;\n\n    } else if (x instanceof List) {\n        let output = { \"type\": \"list\", \"values\": [] }\n        if (x instanceof IntegerList) {\n            output.type = (exceedsInt32(x) ? \"number\" : \"integer\");\n            output.values = dump_vector(x);\n        } else if (x instanceof NumberList) {\n            output.type = \"number\";\n            output.values = dump_vector(x);\n        } else if (x instanceof StringList) {\n            output.type = \"string\";\n            output.values = dump_vector(x);\n        } else if (x instanceof BooleanList) {\n            output.type = \"boolean\";\n            output.values = dump_vector(x);\n        } else {\n            for (const v of x) {\n                output.values.push(await dump_json_list(v, path, globals, options, state));\n            }\n        }\n        if (x.names() !== null) {\n            output.names = x.names();\n        }\n        return output;\n\n    } else if (x === null) {\n        return { \"type\": \"nothing\" };\n\n    } else if (x.constructor === Object) {\n        let output = { \"type\": \"list\", \"values\": [], \"names\": [] };\n        for (const [k, v] of Object.entries(x)) {\n            output.names.push(k);\n            output.values.push(await dump_json_list(v, path, globals, options, state));\n        }\n        return output;\n\n    } else if (x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Uint8Array || x instanceof Uint16Array) {\n        return { \"type\": \"integer\", \"values\": Array.from(x) }\n\n    } else if (x instanceof Uint32Array || x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        return { \"type\": \"number\", \"values\": Array.from(x).map(y => Number(y)) }\n\n    } else if (x instanceof Float64Array || x instanceof Float32Array) {\n        return { \"type\": \"number\", \"values\": dump_number_array(x) };\n\n    } else if (typeof x == \"number\") {\n        return { \"type\": \"number\", \"values\": x };\n\n    } else if (typeof x == \"string\") {\n        return { \"type\": \"string\", \"values\": x };\n\n    } else if (typeof x == \"boolean\") {\n        return { \"type\": \"boolean\", \"values\": x };\n\n    } else {\n        if (\"List_saveOther\" in options) {\n            let converted = options.List_saveOther(x);\n            if (converted !== null) {\n                return converted;\n            }\n        }\n\n        let odir = joinPath(path, \"other_contents\");\n        if (!(await globals.exists(odir))) {\n            await globals.mkdir(odir);\n        }\n        let curdex = state.index;\n        await saveObject(x, joinPath(odir, String(curdex)), globals, options);\n        state.index++;\n        return { \"type\": \"external\", \"index\": curdex };\n    }\n}\n\n/**\n * @param {external:List} x - The list.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function} [?options.List_saveOther=null] - Function to save custom class instances within a list, without resorting to a reference to an external object.\n * This should accept `y`, an instance of a custom object, and return an object containing the contents of `y` in the **uzuki2** JSON format.\n * If the class of `y` is not supported, `null` should be returned instead.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveList(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n\n    let objmeta = {\n        type: \"simple_list\",\n        simple_list: {\n            version: \"1.1\",\n            format: \"json.gz\"\n        }\n    };\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(objmeta));\n\n    let converted = await dump_json_list(x, path, globals, options, { index: 0 });\n    let stringified = JSON.stringify(converted);\n\n    const stream = new Blob([stringified]).stream();\n    const compressed_stream = stream.pipeThrough(new CompressionStream(\"gzip\"));\n    let chunks = [];\n    let counter = 0;\n    for await (const chunk of compressed_stream) {\n        chunks.push(chunk);\n        counter += chunk.length;\n    }\n    let compressed_final = new Uint8Array(counter);\n    counter = 0;\n    for (const chunk of chunks) {\n        compressed_final.set(chunk, counter);\n        counter += chunk.length;\n    }\n\n    await globals.write(joinPath(path, \"list_contents.json.gz\"), compressed_final);\n}\n","/*!\n * hash-wasm (https://www.npmjs.com/package/hash-wasm)\n * (c) Dani Biro\n * @license MIT\n */\n\nvar name$l = \"adler32\";\nvar data$l = \"AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAgUEAQECAgYOAn8BQYCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEK6wkGBQBBgAkLCgBBAEEBNgKECAvjCAEHf0EAKAKECCIBQf//A3EhAiABQRB2IQMCQAJAIABBAUcNACACQQAtAIAJaiIBQY+AfGogASABQfD/A0sbIgEgA2oiBEEQdCIFQYCAPGogBSAEQfD/A0sbIAFyIQEMAQsCQAJAAkACQAJAIABBEEkNAEGACSEGIABBsCtJDQFBgAkhBgNAQQAhBQNAIAYgBWoiASgCACIEQf8BcSACaiICIANqIAIgBEEIdkH/AXFqIgJqIAIgBEEQdkH/AXFqIgJqIAIgBEEYdmoiAmogAiABQQRqKAIAIgRB/wFxaiICaiACIARBCHZB/wFxaiICaiACIARBEHZB/wFxaiICaiACIARBGHZqIgJqIAIgAUEIaigCACIEQf8BcWoiAmogAiAEQQh2Qf8BcWoiAmogAiAEQRB2Qf8BcWoiAmogAiAEQRh2aiIEaiAEIAFBDGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiAmohAyAFQRBqIgVBsCtHDQALIANB8f8DcCEDIAJB8f8DcCECIAZBsCtqIQYgAEHQVGoiAEGvK0sNAAsgAEUNBCAAQQ9LDQEMAgsCQCAARQ0AAkACQCAAQQNxIgUNAEGACSEBIAAhBAwBCyAAQXxxIQRBACEBA0AgAiABQYAJai0AAGoiAiADaiEDIAUgAUEBaiIBRw0ACyAFQYAJaiEBCyAAQQRJDQADQCACIAEtAABqIgUgAS0AAWoiBiABLQACaiIAIAFBA2otAABqIgIgACAGIAUgA2pqamohAyABQQRqIQEgBEF8aiIEDQALCyACQY+AfGogAiACQfD/A0sbIANB8f8DcEEQdHIhAQwECwNAIAYoAgAiAUH/AXEgAmoiBCADaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgRqIAQgBkEEaigCACIBQf8BcWoiBGogBCABQQh2Qf8BcWoiBGogBCABQRB2Qf8BcWoiBGogBCABQRh2aiIEaiAEIAZBCGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiBGogBCAGQQxqKAIAIgFB/wFxaiIEaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgJqIQMgBkEQaiEGIABBcGoiAEEPSw0ACyAARQ0BCyAAQX9qIQcCQCAAQQNxIgVFDQAgAEF8cSEAIAUhBCAGIQEDQCACIAEtAABqIgIgA2ohAyABQQFqIQEgBEF/aiIEDQALIAYgBWohBgsgB0EDSQ0AA0AgAiAGLQAAaiIBIAYtAAFqIgQgBi0AAmoiBSAGQQNqLQAAaiICIAUgBCABIANqampqIQMgBkEEaiEGIABBfGoiAA0ACwsgA0Hx/wNwIQMgAkHx/wNwIQILIAIgA0EQdHIhAQtBACABNgKECAsxAQF/QQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwUAQYQICzsAQQBBATYChAggABACQQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwsVAgBBgAgLBAQAAAAAQYQICwQBAAAA\";\nvar hash$l = \"02ddbd17\";\nvar wasmJson$l = {\n\tname: name$l,\n\tdata: data$l,\n\thash: hash$l\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass Mutex {\n    constructor() {\n        this.mutex = Promise.resolve();\n    }\n    lock() {\n        let begin = () => { };\n        this.mutex = this.mutex.then(() => new Promise(begin));\n        return new Promise((res) => {\n            begin = res;\n        });\n    }\n    dispatch(fn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const unlock = yield this.lock();\n            try {\n                return yield Promise.resolve(fn());\n            }\n            finally {\n                unlock();\n            }\n        });\n    }\n}\n\nvar _a;\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    return global;\n}\nconst globalObject = getGlobal();\nconst nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;\nconst textEncoder = globalObject.TextEncoder\n    ? new globalObject.TextEncoder()\n    : null;\nfunction intArrayToString(arr, len) {\n    return String.fromCharCode(...arr.subarray(0, len));\n}\nfunction hexCharCodesToInt(a, b) {\n    return ((((a & 0xf) + ((a >> 6) | ((a >> 3) & 0x8))) << 4) |\n        ((b & 0xf) + ((b >> 6) | ((b >> 3) & 0x8))));\n}\nfunction writeHexToUInt8(buf, str) {\n    const size = str.length >> 1;\n    for (let i = 0; i < size; i++) {\n        const index = i << 1;\n        buf[i] = hexCharCodesToInt(str.charCodeAt(index), str.charCodeAt(index + 1));\n    }\n}\nfunction hexStringEqualsUInt8(str, buf) {\n    if (str.length !== buf.length * 2) {\n        return false;\n    }\n    for (let i = 0; i < buf.length; i++) {\n        const strIndex = i << 1;\n        if (buf[i] !==\n            hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {\n            return false;\n        }\n    }\n    return true;\n}\nconst alpha = \"a\".charCodeAt(0) - 10;\nconst digit = \"0\".charCodeAt(0);\nfunction getDigestHex(tmpBuffer, input, hashLength) {\n    let p = 0;\n    for (let i = 0; i < hashLength; i++) {\n        let nibble = input[i] >>> 4;\n        tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;\n        nibble = input[i] & 0xf;\n        tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;\n    }\n    return String.fromCharCode.apply(null, tmpBuffer);\n}\nconst getUInt8Buffer = nodeBuffer !== null\n    ? (data) => {\n        if (typeof data === \"string\") {\n            const buf = nodeBuffer.from(data, \"utf8\");\n            return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);\n        }\n        if (nodeBuffer.isBuffer(data)) {\n            return new Uint8Array(data.buffer, data.byteOffset, data.length);\n        }\n        if (ArrayBuffer.isView(data)) {\n            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new Error(\"Invalid data type!\");\n    }\n    : (data) => {\n        if (typeof data === \"string\") {\n            return textEncoder.encode(data);\n        }\n        if (ArrayBuffer.isView(data)) {\n            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new Error(\"Invalid data type!\");\n    };\nconst base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64Lookup = new Uint8Array(256);\nfor (let i = 0; i < base64Chars.length; i++) {\n    base64Lookup[base64Chars.charCodeAt(i)] = i;\n}\nfunction encodeBase64(data, pad = true) {\n    const len = data.length;\n    const extraBytes = len % 3;\n    const parts = [];\n    const len2 = len - extraBytes;\n    for (let i = 0; i < len2; i += 3) {\n        const tmp = ((data[i] << 16) & 0xff0000) +\n            ((data[i + 1] << 8) & 0xff00) +\n            (data[i + 2] & 0xff);\n        const triplet = base64Chars.charAt((tmp >> 18) & 0x3f) +\n            base64Chars.charAt((tmp >> 12) & 0x3f) +\n            base64Chars.charAt((tmp >> 6) & 0x3f) +\n            base64Chars.charAt(tmp & 0x3f);\n        parts.push(triplet);\n    }\n    if (extraBytes === 1) {\n        const tmp = data[len - 1];\n        const a = base64Chars.charAt(tmp >> 2);\n        const b = base64Chars.charAt((tmp << 4) & 0x3f);\n        parts.push(`${a}${b}`);\n        if (pad) {\n            parts.push(\"==\");\n        }\n    }\n    else if (extraBytes === 2) {\n        const tmp = (data[len - 2] << 8) + data[len - 1];\n        const a = base64Chars.charAt(tmp >> 10);\n        const b = base64Chars.charAt((tmp >> 4) & 0x3f);\n        const c = base64Chars.charAt((tmp << 2) & 0x3f);\n        parts.push(`${a}${b}${c}`);\n        if (pad) {\n            parts.push(\"=\");\n        }\n    }\n    return parts.join(\"\");\n}\nfunction getDecodeBase64Length(data) {\n    let bufferLength = Math.floor(data.length * 0.75);\n    const len = data.length;\n    if (data[len - 1] === \"=\") {\n        bufferLength -= 1;\n        if (data[len - 2] === \"=\") {\n            bufferLength -= 1;\n        }\n    }\n    return bufferLength;\n}\nfunction decodeBase64(data) {\n    const bufferLength = getDecodeBase64Length(data);\n    const len = data.length;\n    const bytes = new Uint8Array(bufferLength);\n    let p = 0;\n    for (let i = 0; i < len; i += 4) {\n        const encoded1 = base64Lookup[data.charCodeAt(i)];\n        const encoded2 = base64Lookup[data.charCodeAt(i + 1)];\n        const encoded3 = base64Lookup[data.charCodeAt(i + 2)];\n        const encoded4 = base64Lookup[data.charCodeAt(i + 3)];\n        bytes[p] = (encoded1 << 2) | (encoded2 >> 4);\n        p += 1;\n        bytes[p] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        p += 1;\n        bytes[p] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        p += 1;\n    }\n    return bytes;\n}\n\nconst MAX_HEAP = 16 * 1024;\nconst WASM_FUNC_HASH_LENGTH = 4;\nconst wasmMutex = new Mutex();\nconst wasmModuleCache = new Map();\nfunction WASMInterface(binary, hashLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let wasmInstance = null;\n        let memoryView = null;\n        let initialized = false;\n        if (typeof WebAssembly === \"undefined\") {\n            throw new Error(\"WebAssembly is not supported in this environment!\");\n        }\n        const writeMemory = (data, offset = 0) => {\n            memoryView.set(data, offset);\n        };\n        const getMemory = () => memoryView;\n        const getExports = () => wasmInstance.exports;\n        const setMemorySize = (totalSize) => {\n            wasmInstance.exports.Hash_SetMemorySize(totalSize);\n            const arrayOffset = wasmInstance.exports.Hash_GetBuffer();\n            const memoryBuffer = wasmInstance.exports.memory.buffer;\n            memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);\n        };\n        const getStateSize = () => {\n            const view = new DataView(wasmInstance.exports.memory.buffer);\n            const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);\n            return stateSize;\n        };\n        const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {\n            if (!wasmModuleCache.has(binary.name)) {\n                const asm = decodeBase64(binary.data);\n                const promise = WebAssembly.compile(asm);\n                wasmModuleCache.set(binary.name, promise);\n            }\n            const module = yield wasmModuleCache.get(binary.name);\n            wasmInstance = yield WebAssembly.instantiate(module, {\n            // env: {\n            //   emscripten_memcpy_big: (dest, src, num) => {\n            //     const memoryBuffer = wasmInstance.exports.memory.buffer;\n            //     const memView = new Uint8Array(memoryBuffer, 0);\n            //     memView.set(memView.subarray(src, src + num), dest);\n            //   },\n            //   print_memory: (offset, len) => {\n            //     const memoryBuffer = wasmInstance.exports.memory.buffer;\n            //     const memView = new Uint8Array(memoryBuffer, 0);\n            //     console.log('print_int32', memView.subarray(offset, offset + len));\n            //   },\n            // },\n            });\n            // wasmInstance.exports._start();\n        }));\n        const setupInterface = () => __awaiter(this, void 0, void 0, function* () {\n            if (!wasmInstance) {\n                yield loadWASMPromise;\n            }\n            const arrayOffset = wasmInstance.exports.Hash_GetBuffer();\n            const memoryBuffer = wasmInstance.exports.memory.buffer;\n            memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);\n        });\n        const init = (bits = null) => {\n            initialized = true;\n            wasmInstance.exports.Hash_Init(bits);\n        };\n        const updateUInt8Array = (data) => {\n            let read = 0;\n            while (read < data.length) {\n                const chunk = data.subarray(read, read + MAX_HEAP);\n                read += chunk.length;\n                memoryView.set(chunk);\n                wasmInstance.exports.Hash_Update(chunk.length);\n            }\n        };\n        const update = (data) => {\n            if (!initialized) {\n                throw new Error(\"update() called before init()\");\n            }\n            const Uint8Buffer = getUInt8Buffer(data);\n            updateUInt8Array(Uint8Buffer);\n        };\n        const digestChars = new Uint8Array(hashLength * 2);\n        const digest = (outputType, padding = null) => {\n            if (!initialized) {\n                throw new Error(\"digest() called before init()\");\n            }\n            initialized = false;\n            wasmInstance.exports.Hash_Final(padding);\n            if (outputType === \"binary\") {\n                // the data is copied to allow GC of the original memory object\n                return memoryView.slice(0, hashLength);\n            }\n            return getDigestHex(digestChars, memoryView, hashLength);\n        };\n        const save = () => {\n            if (!initialized) {\n                throw new Error(\"save() can only be called after init() and before digest()\");\n            }\n            const stateOffset = wasmInstance.exports.Hash_GetState();\n            const stateLength = getStateSize();\n            const memoryBuffer = wasmInstance.exports.memory.buffer;\n            const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);\n            // prefix is 4 bytes from SHA1 hash of the WASM binary\n            // it is used to detect incompatible internal states between different versions of hash-wasm\n            const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);\n            writeHexToUInt8(prefixedState, binary.hash);\n            prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);\n            return prefixedState;\n        };\n        const load = (state) => {\n            if (!(state instanceof Uint8Array)) {\n                throw new Error(\"load() expects an Uint8Array generated by save()\");\n            }\n            const stateOffset = wasmInstance.exports.Hash_GetState();\n            const stateLength = getStateSize();\n            const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;\n            const memoryBuffer = wasmInstance.exports.memory.buffer;\n            if (state.length !== overallLength) {\n                throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);\n            }\n            if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {\n                throw new Error(\"This state was written by an incompatible hash implementation\");\n            }\n            const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);\n            new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);\n            initialized = true;\n        };\n        const isDataShort = (data) => {\n            if (typeof data === \"string\") {\n                // worst case is 4 bytes / char\n                return data.length < MAX_HEAP / 4;\n            }\n            return data.byteLength < MAX_HEAP;\n        };\n        let canSimplify = isDataShort;\n        switch (binary.name) {\n            case \"argon2\":\n            case \"scrypt\":\n                canSimplify = () => true;\n                break;\n            case \"blake2b\":\n            case \"blake2s\":\n                // if there is a key at blake2 then cannot simplify\n                canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);\n                break;\n            case \"blake3\":\n                // if there is a key at blake3 then cannot simplify\n                canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);\n                break;\n            case \"xxhash64\": // cannot simplify\n            case \"xxhash3\":\n            case \"xxhash128\":\n            case \"crc64\":\n                canSimplify = () => false;\n                break;\n        }\n        // shorthand for (init + update + digest) for better performance\n        const calculate = (data, initParam = null, digestParam = null) => {\n            if (!canSimplify(data, initParam)) {\n                init(initParam);\n                update(data);\n                return digest(\"hex\", digestParam);\n            }\n            const buffer = getUInt8Buffer(data);\n            memoryView.set(buffer);\n            wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);\n            return getDigestHex(digestChars, memoryView, hashLength);\n        };\n        yield setupInterface();\n        return {\n            getMemory,\n            writeMemory,\n            getExports,\n            setMemorySize,\n            init,\n            update,\n            digest,\n            save,\n            load,\n            calculate,\n            hashLength,\n        };\n    });\n}\n\nfunction lockedCreate(mutex, binary, hashLength) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const unlock = yield mutex.lock();\n        const wasm = yield WASMInterface(binary, hashLength);\n        unlock();\n        return wasm;\n    });\n}\n\nconst mutex$l = new Mutex();\nlet wasmCache$l = null;\n/**\n * Calculates Adler-32 hash. The resulting 32-bit hash is stored in\n * network byte order (big-endian).\n *\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction adler32(data) {\n    if (wasmCache$l === null) {\n        return lockedCreate(mutex$l, wasmJson$l, 4).then((wasm) => {\n            wasmCache$l = wasm;\n            return wasmCache$l.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$l.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new Adler-32 hash instance\n */\nfunction createAdler32() {\n    return WASMInterface(wasmJson$l, 4).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 4,\n            digestSize: 4,\n        };\n        return obj;\n    });\n}\n\nvar name$k = \"argon2\";\nvar data$k = \"AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkD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\";\nvar hash$k = \"e4cdc523\";\nvar wasmJson$k = {\n\tname: name$k,\n\tdata: data$k,\n\thash: hash$k\n};\n\nvar name$j = \"blake2b\";\nvar data$j = \"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\";\nvar hash$j = \"c6f286e6\";\nvar wasmJson$j = {\n\tname: name$j,\n\tdata: data$j,\n\thash: hash$j\n};\n\nconst mutex$k = new Mutex();\nlet wasmCache$k = null;\nfunction validateBits$4(bits) {\n    if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) {\n        return new Error(\"Invalid variant! Valid values: 8, 16, ..., 512\");\n    }\n    return null;\n}\nfunction getInitParam$1(outputBits, keyBits) {\n    return outputBits | (keyBits << 16);\n}\n/**\n * Calculates BLAKE2b hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8, between 8 and 512. Defaults to 512.\n * @param key Optional key (string, Buffer or TypedArray). Maximum length is 64 bytes.\n * @returns Computed hash as a hexadecimal string\n */\nfunction blake2b(data, bits = 512, key = null) {\n    if (validateBits$4(bits)) {\n        return Promise.reject(validateBits$4(bits));\n    }\n    let keyBuffer = null;\n    let initParam = bits;\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length > 64) {\n            return Promise.reject(new Error(\"Max key length is 64 bytes\"));\n        }\n        initParam = getInitParam$1(bits, keyBuffer.length);\n    }\n    const hashLength = bits / 8;\n    if (wasmCache$k === null || wasmCache$k.hashLength !== hashLength) {\n        return lockedCreate(mutex$k, wasmJson$j, hashLength).then((wasm) => {\n            wasmCache$k = wasm;\n            if (initParam > 512) {\n                wasmCache$k.writeMemory(keyBuffer);\n            }\n            return wasmCache$k.calculate(data, initParam);\n        });\n    }\n    try {\n        if (initParam > 512) {\n            wasmCache$k.writeMemory(keyBuffer);\n        }\n        const hash = wasmCache$k.calculate(data, initParam);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new BLAKE2b hash instance\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8, between 8 and 512. Defaults to 512.\n * @param key Optional key (string, Buffer or TypedArray). Maximum length is 64 bytes.\n */\nfunction createBLAKE2b(bits = 512, key = null) {\n    if (validateBits$4(bits)) {\n        return Promise.reject(validateBits$4(bits));\n    }\n    let keyBuffer = null;\n    let initParam = bits;\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length > 64) {\n            return Promise.reject(new Error(\"Max key length is 64 bytes\"));\n        }\n        initParam = getInitParam$1(bits, keyBuffer.length);\n    }\n    const outputSize = bits / 8;\n    return WASMInterface(wasmJson$j, outputSize).then((wasm) => {\n        if (initParam > 512) {\n            wasm.writeMemory(keyBuffer);\n        }\n        wasm.init(initParam);\n        const obj = {\n            init: initParam > 512\n                ? () => {\n                    wasm.writeMemory(keyBuffer);\n                    wasm.init(initParam);\n                    return obj;\n                }\n                : () => {\n                    wasm.init(initParam);\n                    return obj;\n                },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 128,\n            digestSize: outputSize,\n        };\n        return obj;\n    });\n}\n\nfunction encodeResult(salt, options, res) {\n    const parameters = [\n        `m=${options.memorySize}`,\n        `t=${options.iterations}`,\n        `p=${options.parallelism}`,\n    ].join(\",\");\n    return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;\n}\nconst uint32View = new DataView(new ArrayBuffer(4));\nfunction int32LE(x) {\n    uint32View.setInt32(0, x, true);\n    return new Uint8Array(uint32View.buffer);\n}\nfunction hashFunc(blake512, buf, len) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (len <= 64) {\n            const blake = yield createBLAKE2b(len * 8);\n            blake.update(int32LE(len));\n            blake.update(buf);\n            return blake.digest(\"binary\");\n        }\n        const r = Math.ceil(len / 32) - 2;\n        const ret = new Uint8Array(len);\n        blake512.init();\n        blake512.update(int32LE(len));\n        blake512.update(buf);\n        let vp = blake512.digest(\"binary\");\n        ret.set(vp.subarray(0, 32), 0);\n        for (let i = 1; i < r; i++) {\n            blake512.init();\n            blake512.update(vp);\n            vp = blake512.digest(\"binary\");\n            ret.set(vp.subarray(0, 32), i * 32);\n        }\n        const partialBytesNeeded = len - 32 * r;\n        let blakeSmall;\n        if (partialBytesNeeded === 64) {\n            blakeSmall = blake512;\n            blakeSmall.init();\n        }\n        else {\n            blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);\n        }\n        blakeSmall.update(vp);\n        vp = blakeSmall.digest(\"binary\");\n        ret.set(vp.subarray(0, partialBytesNeeded), r * 32);\n        return ret;\n    });\n}\nfunction getHashType(type) {\n    switch (type) {\n        case \"d\":\n            return 0;\n        case \"i\":\n            return 1;\n        default:\n            return 2;\n    }\n}\nfunction argon2Internal(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { parallelism, iterations, hashLength } = options;\n        const password = getUInt8Buffer(options.password);\n        const salt = getUInt8Buffer(options.salt);\n        const version = 0x13;\n        const hashType = getHashType(options.hashType);\n        const { memorySize } = options; // in KB\n        const secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : \"\");\n        const [argon2Interface, blake512] = yield Promise.all([\n            WASMInterface(wasmJson$k, 1024),\n            createBLAKE2b(512),\n        ]);\n        // last block is for storing the init vector\n        argon2Interface.setMemorySize(memorySize * 1024 + 1024);\n        const initVector = new Uint8Array(24);\n        const initVectorView = new DataView(initVector.buffer);\n        initVectorView.setInt32(0, parallelism, true);\n        initVectorView.setInt32(4, hashLength, true);\n        initVectorView.setInt32(8, memorySize, true);\n        initVectorView.setInt32(12, iterations, true);\n        initVectorView.setInt32(16, version, true);\n        initVectorView.setInt32(20, hashType, true);\n        argon2Interface.writeMemory(initVector, memorySize * 1024);\n        blake512.init();\n        blake512.update(initVector);\n        blake512.update(int32LE(password.length));\n        blake512.update(password);\n        blake512.update(int32LE(salt.length));\n        blake512.update(salt);\n        blake512.update(int32LE(secret.length));\n        blake512.update(secret);\n        blake512.update(int32LE(0)); // associatedData length + associatedData\n        const segments = Math.floor(memorySize / (parallelism * 4)); // length of each lane\n        const lanes = segments * 4;\n        const param = new Uint8Array(72);\n        const H0 = blake512.digest(\"binary\");\n        param.set(H0);\n        for (let lane = 0; lane < parallelism; lane++) {\n            param.set(int32LE(0), 64);\n            param.set(int32LE(lane), 68);\n            let position = lane * lanes;\n            let chunk = yield hashFunc(blake512, param, 1024);\n            argon2Interface.writeMemory(chunk, position * 1024);\n            position += 1;\n            param.set(int32LE(1), 64);\n            chunk = yield hashFunc(blake512, param, 1024);\n            argon2Interface.writeMemory(chunk, position * 1024);\n        }\n        const C = new Uint8Array(1024);\n        writeHexToUInt8(C, argon2Interface.calculate(new Uint8Array([]), memorySize));\n        const res = yield hashFunc(blake512, C, hashLength);\n        if (options.outputType === \"hex\") {\n            const digestChars = new Uint8Array(hashLength * 2);\n            return getDigestHex(digestChars, res, hashLength);\n        }\n        if (options.outputType === \"encoded\") {\n            return encodeResult(salt, options, res);\n        }\n        // return binary format\n        return res;\n    });\n}\nconst validateOptions$3 = (options) => {\n    var _a;\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (!options.password) {\n        throw new Error(\"Password must be specified\");\n    }\n    options.password = getUInt8Buffer(options.password);\n    if (options.password.length < 1) {\n        throw new Error(\"Password must be specified\");\n    }\n    if (!options.salt) {\n        throw new Error(\"Salt must be specified\");\n    }\n    options.salt = getUInt8Buffer(options.salt);\n    if (options.salt.length < 8) {\n        throw new Error(\"Salt should be at least 8 bytes long\");\n    }\n    options.secret = getUInt8Buffer((_a = options.secret) !== null && _a !== void 0 ? _a : \"\");\n    if (!Number.isInteger(options.iterations) || options.iterations < 1) {\n        throw new Error(\"Iterations should be a positive number\");\n    }\n    if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {\n        throw new Error(\"Parallelism should be a positive number\");\n    }\n    if (!Number.isInteger(options.hashLength) || options.hashLength < 4) {\n        throw new Error(\"Hash length should be at least 4 bytes.\");\n    }\n    if (!Number.isInteger(options.memorySize)) {\n        throw new Error(\"Memory size should be specified.\");\n    }\n    if (options.memorySize < 8 * options.parallelism) {\n        throw new Error(\"Memory size should be at least 8 * parallelism.\");\n    }\n    if (options.outputType === undefined) {\n        options.outputType = \"hex\";\n    }\n    if (![\"hex\", \"binary\", \"encoded\"].includes(options.outputType)) {\n        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);\n    }\n};\n/**\n * Calculates hash using the argon2i password-hashing function\n * @returns Computed hash\n */\nfunction argon2i(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions$3(options);\n        return argon2Internal(Object.assign(Object.assign({}, options), { hashType: \"i\" }));\n    });\n}\n/**\n * Calculates hash using the argon2id password-hashing function\n * @returns Computed hash\n */\nfunction argon2id(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions$3(options);\n        return argon2Internal(Object.assign(Object.assign({}, options), { hashType: \"id\" }));\n    });\n}\n/**\n * Calculates hash using the argon2d password-hashing function\n * @returns Computed hash\n */\nfunction argon2d(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions$3(options);\n        return argon2Internal(Object.assign(Object.assign({}, options), { hashType: \"d\" }));\n    });\n}\nconst getHashParameters = (password, encoded, secret) => {\n    const regex = /^\\$argon2(id|i|d)\\$v=([0-9]+)\\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\\$([A-Za-z0-9+/]+)\\$([A-Za-z0-9+/]+)$/;\n    const match = encoded.match(regex);\n    if (!match) {\n        throw new Error(\"Invalid hash\");\n    }\n    const [, hashType, version, parameters, salt, hash] = match;\n    if (version !== \"19\") {\n        throw new Error(`Unsupported version: ${version}`);\n    }\n    const parsedParameters = {};\n    const paramMap = { m: \"memorySize\", p: \"parallelism\", t: \"iterations\" };\n    for (const x of parameters.split(\",\")) {\n        const [n, v] = x.split(\"=\");\n        parsedParameters[paramMap[n]] = Number(v);\n    }\n    return Object.assign(Object.assign({}, parsedParameters), { password,\n        secret, hashType: hashType, salt: decodeBase64(salt), hashLength: getDecodeBase64Length(hash), outputType: \"encoded\" });\n};\nconst validateVerifyOptions$1 = (options) => {\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (options.hash === undefined || typeof options.hash !== \"string\") {\n        throw new Error(\"Hash should be specified\");\n    }\n};\n/**\n * Verifies password using the argon2 password-hashing function\n * @returns True if the encoded hash matches the password\n */\nfunction argon2Verify(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateVerifyOptions$1(options);\n        const params = getHashParameters(options.password, options.hash, options.secret);\n        validateOptions$3(params);\n        const hashStart = options.hash.lastIndexOf(\"$\") + 1;\n        const result = (yield argon2Internal(params));\n        return result.substring(hashStart) === options.hash.substring(hashStart);\n    });\n}\n\nvar name$i = \"blake2s\";\nvar data$i = \"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\";\nvar hash$i = \"5c0ff166\";\nvar wasmJson$i = {\n\tname: name$i,\n\tdata: data$i,\n\thash: hash$i\n};\n\nconst mutex$j = new Mutex();\nlet wasmCache$j = null;\nfunction validateBits$3(bits) {\n    if (!Number.isInteger(bits) || bits < 8 || bits > 256 || bits % 8 !== 0) {\n        return new Error(\"Invalid variant! Valid values: 8, 16, ..., 256\");\n    }\n    return null;\n}\nfunction getInitParam(outputBits, keyBits) {\n    return outputBits | (keyBits << 16);\n}\n/**\n * Calculates BLAKE2s hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8, between 8 and 256. Defaults to 256.\n * @param key Optional key (string, Buffer or TypedArray). Maximum length is 32 bytes.\n * @returns Computed hash as a hexadecimal string\n */\nfunction blake2s(data, bits = 256, key = null) {\n    if (validateBits$3(bits)) {\n        return Promise.reject(validateBits$3(bits));\n    }\n    let keyBuffer = null;\n    let initParam = bits;\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length > 32) {\n            return Promise.reject(new Error(\"Max key length is 32 bytes\"));\n        }\n        initParam = getInitParam(bits, keyBuffer.length);\n    }\n    const hashLength = bits / 8;\n    if (wasmCache$j === null || wasmCache$j.hashLength !== hashLength) {\n        return lockedCreate(mutex$j, wasmJson$i, hashLength).then((wasm) => {\n            wasmCache$j = wasm;\n            if (initParam > 512) {\n                wasmCache$j.writeMemory(keyBuffer);\n            }\n            return wasmCache$j.calculate(data, initParam);\n        });\n    }\n    try {\n        if (initParam > 512) {\n            wasmCache$j.writeMemory(keyBuffer);\n        }\n        const hash = wasmCache$j.calculate(data, initParam);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new BLAKE2s hash instance\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8, between 8 and 256. Defaults to 256.\n * @param key Optional key (string, Buffer or TypedArray). Maximum length is 32 bytes.\n */\nfunction createBLAKE2s(bits = 256, key = null) {\n    if (validateBits$3(bits)) {\n        return Promise.reject(validateBits$3(bits));\n    }\n    let keyBuffer = null;\n    let initParam = bits;\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length > 32) {\n            return Promise.reject(new Error(\"Max key length is 32 bytes\"));\n        }\n        initParam = getInitParam(bits, keyBuffer.length);\n    }\n    const outputSize = bits / 8;\n    return WASMInterface(wasmJson$i, outputSize).then((wasm) => {\n        if (initParam > 512) {\n            wasm.writeMemory(keyBuffer);\n        }\n        wasm.init(initParam);\n        const obj = {\n            init: initParam > 512\n                ? () => {\n                    wasm.writeMemory(keyBuffer);\n                    wasm.init(initParam);\n                    return obj;\n                }\n                : () => {\n                    wasm.init(initParam);\n                    return obj;\n                },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: outputSize,\n        };\n        return obj;\n    });\n}\n\nvar name$h = \"blake3\";\nvar data$h = \"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IQEgAkFAaiICQcAASw0ACwsCQEHAACAHQf8BcSIGayIFIAIgBSACSRsiCUUNACAJQQNxIQtBACEFAkAgCUEESQ0AIAAgBmohByAJQfwAcSEIQQAhBQNAIAcgBWoiAkEoaiABIAVqIgotAAA6AAAgAkEpaiAKQQFqLQAAOgAAIAJBKmogCkECai0AADoAACACQStqIApBA2otAAA6AAAgCCAFQQRqIgVHDQALCwJAIAtFDQAgASAFaiEBIAUgBmogAGpBKGohBQNAIAUgAS0AADoAACABQQFqIQEgBUEBaiEFIAtBf2oiCw0ACwsgAC0AaCEHCyAAIAcgCWo6AGggA0HAAGokAAveAwQFfwN+BX8GfiMAQdABayIBJAACQCAAe6ciAkEALQCQigEiA08NAEEALQCKigFBBHIhBCABQShqIQVBACkDmIkBIQBBACkDkIkBIQZBACkDiIkBIQdBACkDgIkBIQggAyEJA0AgASAANwMYIAEgBjcDECABIAc3AwggASAINwMAIAEgA0EFdCIDQdGJAWoiCikDADcDKCABIANB2YkBaiILKQMANwMwIAEgA0HhiQFqIgwpAwA3AzggASADQemJAWoiDSkDADcDQCABIANB8YkBaikDADcDSCABIANB+YkBaikDADcDUCABIANBgYoBaikDADcDWCADQYmKAWopAwAhDiABQcAAOgBoIAEgDjcDYCABQgA3AyAgASAEOgBpIAEgADcDiAEgASAGNwOAASABIAc3A3ggASAINwNwIAFBkAFqIAFB8ABqIAVBwABCACAEQf8BcRACIAEpA7ABIQ4gASkDkAEhDyABKQO4ASEQIAEpA5gBIREgASkDwAEhEiABKQOgASETIA0gASkDyAEgASkDqAGFNwMAIAwgEiAThTcDACALIBAgEYU3AwAgCiAOIA+FNwMAIAlBf2oiCUH/AXEiAyACSw0AC0EAIAk6AJCKAQsgAUHQAWokAAvHCQIKfwV+IwBB4AJrIgUkAAJAAkAgAUGACEsNACAFIAA2AvwBIAVB/AFqIAFBgAhGIgZBECACQQEgA0EBQQIgBBABIAZBCnQiByABTw0BIAVB4ABqIgZCADcDACAFQdgAaiIIQgA3AwAgBUHQAGoiCUIANwMAIAVByABqIgpCADcDACAFQcAAaiILQgA3AwAgBUE4aiIMQgA3AwAgBUEwaiINQgA3AwAgBSADOgBqIAVCADcDKCAFQQA7AWggBUEAKQOAiQE3AwAgBUEAKQOIiQE3AwggBUEAKQOQiQE3AxAgBUEAKQOYiQE3AxggBSABQYAIRiIOrSACfDcDICAFIAAgB2pBACABIA4bEAQgBUGIAWpBMGogDSkDADcDACAFQYgBakE4aiAMKQMANwMAIAUgBSkDACIPNwOIASAFIAUpAwgiEDcDkAEgBSAFKQMQIhE3A5gBIAUgBSkDGCISNwOgASAFIAUpAyg3A7ABIAUtAGohACAFLQBpIQcgBSkDICECIAUtAGghASAFQYgBakHAAGogCykDADcDACAFQYgBakHIAGogCikDADcDACAFQYgBakHQAGogCSkDADcDACAFQYgBakHYAGogCCkDADcDACAFQYgBakHgAGogBikDADcDACAFIAE6APABIAUgAjcDqAEgBSAAIAdFckECciIAOgDxASAFIBI3A5gCIAUgETcDkAIgBSAQNwOIAiAFIA83A4ACIAVBoAJqIAVBgAJqIAVBsAFqIAEgAiAAQf8BcRACIAUpA8ACIQIgBSkDoAIhDyAFKQPIAiEQIAUpA6gCIREgBSkD0AIhEiAFKQOwAiETIAQgDkEFdGoiASAFKQPYAiAFKQO4AoU3AxggASASIBOFNwMQIAEgECARhTcDCCABIAIgD4U3AwBBAkEBIA4bIQYMAQsgAEIBIAFBf2pBCnZBAXKteUI/hYYiD6dBCnQiDiACIAMgBRAGIQcgACAOaiABIA5rIA9C////AYMgAnwgAyAFQcAAQSAgDkGACEsbahAGIQECQCAHQQFHDQAgBCAFKQMANwMAIAQgBSkDCDcDCCAEIAUpAxA3AxAgBCAFKQMYNwMYIAQgBSkDIDcDICAEIAUpAyg3AyggBCAFKQMwNwMwIAQgBSkDODcDOEECIQYMAQtBACEGQQAhAAJAIAEgB2oiCUECSQ0AIAlBfmoiCkEBdkEBaiIGQQNxIQ5BACEHAkAgCkEGSQ0AIAZB/P///wdxIQhBACEHIAVBiAFqIQEgBSEAA0AgASAANgIAIAFBDGogAEHAAWo2AgAgAUEIaiAAQYABajYCACABQQRqIABBwABqNgIAIABBgAJqIQAgAUEQaiEBIAggB0EEaiIHRw0ACwsgCkF+cSEIAkAgDkUNACAFIAdBBnRqIQEgBUGIAWogB0ECdGohAANAIAAgATYCACABQcAAaiEBIABBBGohACAOQX9qIg4NAAsLIAhBAmohAAsgBUGIAWogBkEBQgBBACADQQRyQQBBACAEEAEgACAJTw0AIAQgBkEFdGoiASAFIAZBBnRqIgApAwA3AwAgASAAKQMINwMIIAEgACkDEDcDECABIAApAxg3AxggBkEBaiEGCyAFQeACaiQAIAYLrRAIAn8EfgF/AX4EfwR+BH8EfiMAQfABayIBJAACQCAARQ0AAkBBAC0AkIoBIgINACABQTBqQQApA9CJATcDACABQThqQQApA9iJATcDACABQQApA6CJASIDNwMAIAFBACkDqIkBIgQ3AwggAUEAKQOwiQEiBTcDECABQQApA7iJASIGNwMYIAFBACkDyIkBNwMoQQAtAIqKASECQQAtAImKASEHQQApA8CJASEIQQAtAIiKASEJIAFBwABqQQApA+CJATcDACABQcgAakEAKQPoiQE3AwAgAUHQAGpBACkD8IkBNwMAIAFB2ABqQQApA/iJATcDACABQeAAakEAKQOAigE3AwAgASAJOgBoIAEgCDcDICABIAIgB0VyIgJBAnI6AGkgAUEoaiEKQgAhCEGACSELIAJBCnJB/wFxIQwDQCABQbABaiABIAogCUH/AXEgCCAMEAIgASABKQPQASINIAEpA7ABhTcDcCABIAEpA9gBIg4gASkDuAGFNwN4IAEgASkD4AEiDyABKQPAAYU3A4ABIAEgASkD6AEiECAGhTcDqAEgASAPIAWFNwOgASABIA4gBIU3A5gBIAEgDSADhTcDkAEgASAQIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQAMAgsLAkACQAJAQQAtAImKASIHQQZ0QQBBAC0AiIoBIhFrRg0AIAEgEToAaCABQQApA4CKATcDYCABQQApA/iJATcDWCABQQApA/CJATcDUCABQQApA+iJATcDSCABQQApA+CJATcDQCABQQApA9iJATcDOCABQQApA9CJATcDMCABQQApA8iJATcDKCABQQApA8CJASIINwMgIAFBACkDuIkBIgM3AxggAUEAKQOwiQEiBDcDECABQQApA6iJASIFNwMIIAFBACkDoIkBIgY3AwAgAUEALQCKigEiEyAHRXJBAnIiCzoAaSATQQRyIRNBACkDmIkBIQ1BACkDkIkBIQ5BACkDiIkBIQ9BACkDgIkBIRAMAQtBwAAhESABQcAAOgBoQgAhCCABQgA3AyAgAUEAKQOYiQEiDTcDGCABQQApA5CJASIONwMQIAFBACkDiIkBIg83AwggAUEAKQOAiQEiEDcDACABQQAtAIqKAUEEciITOgBpIAEgAkF+aiICQQV0IgdByYoBaikDADcDYCABIAdBwYoBaikDADcDWCABIAdBuYoBaikDADcDUCABIAdBsYoBaikDADcDSCABIAdBqYoBaikDADcDQCABIAdBoYoBaikDADcDOCABIAdBmYoBaikDADcDMCABIAdBkYoBaikDADcDKCATIQsgECEGIA8hBSAOIQQgDSEDIAJFDQELIAJBf2oiB0EFdCIUQZGKAWopAwAhFSAUQZmKAWopAwAhFiAUQaGKAWopAwAhFyAUQamKAWopAwAhGCABIAM3A4gBIAEgBDcDgAEgASAFNwN4IAEgBjcDcCABQbABaiABQfAAaiABQShqIhQgESAIIAtB/wFxEAIgASATOgBpIAFBwAA6AGggASAYNwNAIAEgFzcDOCABIBY3AzAgASAVNwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggB0UNACACQQV0QemJAWohAiATQf8BcSERA0AgAkFoaikDACEIIAJBcGopAwAhAyACQXhqKQMAIQQgAikDACEFIAEgDTcDiAEgASAONwOAASABIA83A3ggASAQNwNwIAFBsAFqIAFB8ABqIBRBwABCACAREAIgASATOgBpIAFBwAA6AGggASAFNwNAIAEgBDcDOCABIAM3AzAgASAINwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggAkFgaiECIAdBf2oiBw0ACwsgAUEoaiEJQgAhCEGACSELIBNBCHJB/wFxIQoDQCABQbABaiABIAlBwAAgCCAKEAIgASABKQPQASIDIAEpA7ABhTcDcCABIAEpA9gBIgQgASkDuAGFNwN4IAEgASkD4AEiBSABKQPAAYU3A4ABIAEgDSABKQPoASIGhTcDqAEgASAOIAWFNwOgASABIA8gBIU3A5gBIAEgECADhTcDkAEgASAGIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQALCyABQfABaiQAC6MCAQR+AkACQCAAQSBGDQBCq7OP/JGjs/DbACEBQv+kuYjFkdqCm38hAkLy5rvjo6f9p6V/IQNC58yn0NbQ67O7fyEEQQAhAAwBC0EAKQOYCSEBQQApA5AJIQJBACkDiAkhA0EAKQOACSEEQRAhAAtBACAAOgCKigFBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEIANwPAiQFBACABNwO4iQFBACACNwOwiQFBACADNwOoiQFBACAENwOgiQFBACABNwOYiQFBACACNwOQiQFBACADNwOIiQFBACAENwOAiQFBAEEAOgCQigFBAEEAOwGIigELBgAgABADCwYAIAAQBwsGAEGAiQELqwIBBH4CQAJAIAFBIEYNAEKrs4/8kaOz8NsAIQNC/6S5iMWR2oKbfyEEQvLmu+Ojp/2npX8hBULnzKfQ1tDrs7t/IQZBACEBDAELQQApA5gJIQNBACkDkAkhBEEAKQOICSEFQQApA4AJIQZBECEBC0EAIAE6AIqKAUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQgA3A8CJAUEAIAM3A7iJAUEAIAQ3A7CJAUEAIAU3A6iJAUEAIAY3A6CJAUEAIAM3A5iJAUEAIAQ3A5CJAUEAIAU3A4iJAUEAIAY3A4CJAUEAQQA6AJCKAUEAQQA7AYiKASAAEAMgAhAHCwsLAQBBgAgLBHgHAAA=\";\nvar hash$h = \"215d875f\";\nvar wasmJson$h = {\n\tname: name$h,\n\tdata: data$h,\n\thash: hash$h\n};\n\nconst mutex$i = new Mutex();\nlet wasmCache$i = null;\nfunction validateBits$2(bits) {\n    if (!Number.isInteger(bits) || bits < 8 || bits % 8 !== 0) {\n        return new Error(\"Invalid variant! Valid values: 8, 16, ...\");\n    }\n    return null;\n}\n/**\n * Calculates BLAKE3 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8. Defaults to 256.\n * @param key Optional key (string, Buffer or TypedArray). Length should be 32 bytes.\n * @returns Computed hash as a hexadecimal string\n */\nfunction blake3(data, bits = 256, key = null) {\n    if (validateBits$2(bits)) {\n        return Promise.reject(validateBits$2(bits));\n    }\n    let keyBuffer = null;\n    let initParam = 0; // key is empty by default\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length !== 32) {\n            return Promise.reject(new Error(\"Key length must be exactly 32 bytes\"));\n        }\n        initParam = 32;\n    }\n    const hashLength = bits / 8;\n    const digestParam = hashLength;\n    if (wasmCache$i === null || wasmCache$i.hashLength !== hashLength) {\n        return lockedCreate(mutex$i, wasmJson$h, hashLength).then((wasm) => {\n            wasmCache$i = wasm;\n            if (initParam === 32) {\n                wasmCache$i.writeMemory(keyBuffer);\n            }\n            return wasmCache$i.calculate(data, initParam, digestParam);\n        });\n    }\n    try {\n        if (initParam === 32) {\n            wasmCache$i.writeMemory(keyBuffer);\n        }\n        const hash = wasmCache$i.calculate(data, initParam, digestParam);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new BLAKE3 hash instance\n * @param bits Number of output bits, which has to be a number\n *             divisible by 8. Defaults to 256.\n * @param key Optional key (string, Buffer or TypedArray). Length should be 32 bytes.\n */\nfunction createBLAKE3(bits = 256, key = null) {\n    if (validateBits$2(bits)) {\n        return Promise.reject(validateBits$2(bits));\n    }\n    let keyBuffer = null;\n    let initParam = 0; // key is empty by default\n    if (key !== null) {\n        keyBuffer = getUInt8Buffer(key);\n        if (keyBuffer.length !== 32) {\n            return Promise.reject(new Error(\"Key length must be exactly 32 bytes\"));\n        }\n        initParam = 32;\n    }\n    const outputSize = bits / 8;\n    const digestParam = outputSize;\n    return WASMInterface(wasmJson$h, outputSize).then((wasm) => {\n        if (initParam === 32) {\n            wasm.writeMemory(keyBuffer);\n        }\n        wasm.init(initParam);\n        const obj = {\n            init: initParam === 32\n                ? () => {\n                    wasm.writeMemory(keyBuffer);\n                    wasm.init(initParam);\n                    return obj;\n                }\n                : () => {\n                    wasm.init(initParam);\n                    return obj;\n                },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType, digestParam),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: outputSize,\n        };\n        return obj;\n    });\n}\n\nvar name$g = \"crc32\";\nvar data$g = \"AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==\";\nvar hash$g = \"d2eba587\";\nvar wasmJson$g = {\n\tname: name$g,\n\tdata: data$g,\n\thash: hash$g\n};\n\nconst mutex$h = new Mutex();\nlet wasmCache$h = null;\nfunction validatePoly(poly) {\n    if (!Number.isInteger(poly) || poly < 0 || poly > 0xffffffff) {\n        return new Error(\"Polynomial must be a valid 32-bit long unsigned integer\");\n    }\n    return null;\n}\n/**\n * Calculates CRC-32 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param polynomial Input polynomial (defaults to 0xedb88320, for CRC32C use 0x82f63b78)\n * @returns Computed hash as a hexadecimal string\n */\nfunction crc32(data, polynomial = 0xedb88320) {\n    if (validatePoly(polynomial)) {\n        return Promise.reject(validatePoly(polynomial));\n    }\n    if (wasmCache$h === null) {\n        return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm) => {\n            wasmCache$h = wasm;\n            return wasmCache$h.calculate(data, polynomial);\n        });\n    }\n    try {\n        const hash = wasmCache$h.calculate(data, polynomial);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new CRC-32 hash instance\n * @param polynomial Input polynomial (defaults to 0xedb88320, for CRC32C use 0x82f63b78)\n */\nfunction createCRC32(polynomial = 0xedb88320) {\n    if (validatePoly(polynomial)) {\n        return Promise.reject(validatePoly(polynomial));\n    }\n    return WASMInterface(wasmJson$g, 4).then((wasm) => {\n        wasm.init(polynomial);\n        const obj = {\n            init: () => {\n                wasm.init(polynomial);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 4,\n            digestSize: 4,\n        };\n        return obj;\n    });\n}\n\nvar name$f = \"crc64\";\nvar data$f = \"AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQZCJBgt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKgwgGBQBBgAkL9QMDAX4BfwJ+AkBBACkDgIkCQQApA4AJIgBRDQBBgIkBIQFCACECA0AgAUIAQgBCAEIAQgBCAEIAQgAgAkIBg30gAIMgAkIBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIU3AwAgAUEIaiEBIAJCAXwiAkKAAlINAAtBACEBA0AgAUGImQFqIAFBiIkBaikDACICp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiKkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiLkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiMkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiNkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiOkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiPkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhTcDACABQQhqIgFB+A9HDQALQQAgADcDgIkCC0EAQgA3A4iJAguUAwIBfgJ/QQApA4iJAkJ/hSEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAIpAwAgAYUiAUIwiKdB/wFxQQN0QYCZAWopAwAgAUI4iKdBA3RBgIkBaikDAIUgAUIoiKdB/wFxQQN0QYCpAWopAwCFIAFCIIinQf8BcUEDdEGAuQFqKQMAhSABpyIDQRV2QfgPcUGAyQFqKQMAhSADQQ12QfgPcUGA2QFqKQMAhSADQQV2QfgPcUGA6QFqKQMAhSADQf8BcUEDdEGA+QFqKQMAhSEBIAJBCGohAiAAQXhqIgBBB0sNAAsLAkAgAEUNAAJAAkAgAEEBcQ0AIAAhAwwBCyABQv8BgyACMQAAhadBA3RBgIkBaikDACABQgiIhSEBIAJBAWohAiAAQX9qIQMLIABBAUYNAANAIAFC/wGDIAIxAACFp0EDdEGAiQFqKQMAIAFCCIiFIgFC/wGDIAJBAWoxAACFp0EDdEGAiQFqKQMAIAFCCIiFIQEgAkECaiECIANBfmoiAw0ACwtBACABQn+FNwOIiQILZAEBfkEAQQApA4iJAiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGIiQILAgALCwsBAEGACAsECAAAAA==\";\nvar hash$f = \"c5ac6c16\";\nvar wasmJson$f = {\n\tname: name$f,\n\tdata: data$f,\n\thash: hash$f\n};\n\nconst mutex$g = new Mutex();\nlet wasmCache$g = null;\nconst polyBuffer = new Uint8Array(8);\nfunction parsePoly(poly) {\n    const errText = \"Polynomial must be provided as a 16 char long hex string\";\n    if (typeof poly !== \"string\" || poly.length !== 16) {\n        return { hi: 0, lo: 0, err: new Error(errText) };\n    }\n    const hi = Number(`0x${poly.slice(0, 8)}`);\n    const lo = Number(`0x${poly.slice(8)}`);\n    if (Number.isNaN(hi) || Number.isNaN(lo)) {\n        return { hi, lo, err: new Error(errText) };\n    }\n    return { hi, lo, err: null };\n}\nfunction writePoly(arr, lo, hi) {\n    // write in little-endian format\n    const buffer = new DataView(arr);\n    buffer.setUint32(0, lo, true);\n    buffer.setUint32(4, hi, true);\n}\n/**\n * Calculates CRC-64 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param polynomial Input polynomial (defaults to 'c96c5795d7870f42' - ECMA)\n * @returns Computed hash as a hexadecimal string\n */\nfunction crc64(data, polynomial = \"c96c5795d7870f42\") {\n    const { hi, lo, err } = parsePoly(polynomial);\n    if (err !== null) {\n        return Promise.reject(err);\n    }\n    if (wasmCache$g === null) {\n        return lockedCreate(mutex$g, wasmJson$f, 8).then((wasm) => {\n            wasmCache$g = wasm;\n            writePoly(polyBuffer.buffer, lo, hi);\n            wasmCache$g.writeMemory(polyBuffer);\n            return wasmCache$g.calculate(data);\n        });\n    }\n    try {\n        writePoly(polyBuffer.buffer, lo, hi);\n        wasmCache$g.writeMemory(polyBuffer);\n        const hash = wasmCache$g.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new CRC-64 hash instance\n * @param polynomial Input polynomial (defaults to 'c96c5795d7870f42' - ECMA)\n */\nfunction createCRC64(polynomial = \"c96c5795d7870f42\") {\n    const { hi, lo, err } = parsePoly(polynomial);\n    if (err !== null) {\n        return Promise.reject(err);\n    }\n    return WASMInterface(wasmJson$f, 8).then((wasm) => {\n        const instanceBuffer = new Uint8Array(8);\n        writePoly(instanceBuffer.buffer, lo, hi);\n        wasm.writeMemory(instanceBuffer);\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.writeMemory(instanceBuffer);\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 8,\n            digestSize: 8,\n        };\n        return obj;\n    });\n}\n\nvar name$e = \"md4\";\nvar data$e = \"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\";\nvar hash$e = \"bd8ce7c7\";\nvar wasmJson$e = {\n\tname: name$e,\n\tdata: data$e,\n\thash: hash$e\n};\n\nconst mutex$f = new Mutex();\nlet wasmCache$f = null;\n/**\n * Calculates MD4 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction md4(data) {\n    if (wasmCache$f === null) {\n        return lockedCreate(mutex$f, wasmJson$e, 16).then((wasm) => {\n            wasmCache$f = wasm;\n            return wasmCache$f.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$f.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new MD4 hash instance\n */\nfunction createMD4() {\n    return WASMInterface(wasmJson$e, 16).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 16,\n        };\n        return obj;\n    });\n}\n\nvar name$d = \"md5\";\nvar data$d = \"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\";\nvar hash$d = \"e6508e4b\";\nvar wasmJson$d = {\n\tname: name$d,\n\tdata: data$d,\n\thash: hash$d\n};\n\nconst mutex$e = new Mutex();\nlet wasmCache$e = null;\n/**\n * Calculates MD5 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction md5(data) {\n    if (wasmCache$e === null) {\n        return lockedCreate(mutex$e, wasmJson$d, 16).then((wasm) => {\n            wasmCache$e = wasm;\n            return wasmCache$e.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$e.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new MD5 hash instance\n */\nfunction createMD5() {\n    return WASMInterface(wasmJson$d, 16).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 16,\n        };\n        return obj;\n    });\n}\n\nvar name$c = \"sha1\";\nvar data$c = \"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\";\nvar hash$c = \"6b530c24\";\nvar wasmJson$c = {\n\tname: name$c,\n\tdata: data$c,\n\thash: hash$c\n};\n\nconst mutex$d = new Mutex();\nlet wasmCache$d = null;\n/**\n * Calculates SHA-1 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha1(data) {\n    if (wasmCache$d === null) {\n        return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm) => {\n            wasmCache$d = wasm;\n            return wasmCache$d.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$d.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-1 hash instance\n */\nfunction createSHA1() {\n    return WASMInterface(wasmJson$c, 20).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 20,\n        };\n        return obj;\n    });\n}\n\nvar name$b = \"sha3\";\nvar data$b = \"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\";\nvar hash$b = \"fb24e536\";\nvar wasmJson$b = {\n\tname: name$b,\n\tdata: data$b,\n\thash: hash$b\n};\n\nconst mutex$c = new Mutex();\nlet wasmCache$c = null;\nfunction validateBits$1(bits) {\n    if (![224, 256, 384, 512].includes(bits)) {\n        return new Error(\"Invalid variant! Valid values: 224, 256, 384, 512\");\n    }\n    return null;\n}\n/**\n * Calculates SHA-3 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param bits Number of output bits. Valid values: 224, 256, 384, 512\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha3(data, bits = 512) {\n    if (validateBits$1(bits)) {\n        return Promise.reject(validateBits$1(bits));\n    }\n    const hashLength = bits / 8;\n    if (wasmCache$c === null || wasmCache$c.hashLength !== hashLength) {\n        return lockedCreate(mutex$c, wasmJson$b, hashLength).then((wasm) => {\n            wasmCache$c = wasm;\n            return wasmCache$c.calculate(data, bits, 0x06);\n        });\n    }\n    try {\n        const hash = wasmCache$c.calculate(data, bits, 0x06);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-3 hash instance\n * @param bits Number of output bits. Valid values: 224, 256, 384, 512\n */\nfunction createSHA3(bits = 512) {\n    if (validateBits$1(bits)) {\n        return Promise.reject(validateBits$1(bits));\n    }\n    const outputSize = bits / 8;\n    return WASMInterface(wasmJson$b, outputSize).then((wasm) => {\n        wasm.init(bits);\n        const obj = {\n            init: () => {\n                wasm.init(bits);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType, 0x06),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 200 - 2 * outputSize,\n            digestSize: outputSize,\n        };\n        return obj;\n    });\n}\n\nconst mutex$b = new Mutex();\nlet wasmCache$b = null;\nfunction validateBits(bits) {\n    if (![224, 256, 384, 512].includes(bits)) {\n        return new Error(\"Invalid variant! Valid values: 224, 256, 384, 512\");\n    }\n    return null;\n}\n/**\n * Calculates Keccak hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param bits Number of output bits. Valid values: 224, 256, 384, 512\n * @returns Computed hash as a hexadecimal string\n */\nfunction keccak(data, bits = 512) {\n    if (validateBits(bits)) {\n        return Promise.reject(validateBits(bits));\n    }\n    const hashLength = bits / 8;\n    if (wasmCache$b === null || wasmCache$b.hashLength !== hashLength) {\n        return lockedCreate(mutex$b, wasmJson$b, hashLength).then((wasm) => {\n            wasmCache$b = wasm;\n            return wasmCache$b.calculate(data, bits, 0x01);\n        });\n    }\n    try {\n        const hash = wasmCache$b.calculate(data, bits, 0x01);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new Keccak hash instance\n * @param bits Number of output bits. Valid values: 224, 256, 384, 512\n */\nfunction createKeccak(bits = 512) {\n    if (validateBits(bits)) {\n        return Promise.reject(validateBits(bits));\n    }\n    const outputSize = bits / 8;\n    return WASMInterface(wasmJson$b, outputSize).then((wasm) => {\n        wasm.init(bits);\n        const obj = {\n            init: () => {\n                wasm.init(bits);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType, 0x01),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 200 - 2 * outputSize,\n            digestSize: outputSize,\n        };\n        return obj;\n    });\n}\n\nvar name$a = \"sha256\";\nvar data$a = \"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c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJz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\";\nvar hash$a = \"8c18dd94\";\nvar wasmJson$a = {\n\tname: name$a,\n\tdata: data$a,\n\thash: hash$a\n};\n\nconst mutex$a = new Mutex();\nlet wasmCache$a = null;\n/**\n * Calculates SHA-2 (SHA-224) hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha224(data) {\n    if (wasmCache$a === null) {\n        return lockedCreate(mutex$a, wasmJson$a, 28).then((wasm) => {\n            wasmCache$a = wasm;\n            return wasmCache$a.calculate(data, 224);\n        });\n    }\n    try {\n        const hash = wasmCache$a.calculate(data, 224);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-2 (SHA-224) hash instance\n */\nfunction createSHA224() {\n    return WASMInterface(wasmJson$a, 28).then((wasm) => {\n        wasm.init(224);\n        const obj = {\n            init: () => {\n                wasm.init(224);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 28,\n        };\n        return obj;\n    });\n}\n\nconst mutex$9 = new Mutex();\nlet wasmCache$9 = null;\n/**\n * Calculates SHA-2 (SHA-256) hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha256(data) {\n    if (wasmCache$9 === null) {\n        return lockedCreate(mutex$9, wasmJson$a, 32).then((wasm) => {\n            wasmCache$9 = wasm;\n            return wasmCache$9.calculate(data, 256);\n        });\n    }\n    try {\n        const hash = wasmCache$9.calculate(data, 256);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-2 (SHA-256) hash instance\n */\nfunction createSHA256() {\n    return WASMInterface(wasmJson$a, 32).then((wasm) => {\n        wasm.init(256);\n        const obj = {\n            init: () => {\n                wasm.init(256);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 32,\n        };\n        return obj;\n    });\n}\n\nvar name$9 = \"sha512\";\nvar data$9 = \"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\";\nvar hash$9 = \"f2e40eb1\";\nvar wasmJson$9 = {\n\tname: name$9,\n\tdata: data$9,\n\thash: hash$9\n};\n\nconst mutex$8 = new Mutex();\nlet wasmCache$8 = null;\n/**\n * Calculates SHA-2 (SHA-384) hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha384(data) {\n    if (wasmCache$8 === null) {\n        return lockedCreate(mutex$8, wasmJson$9, 48).then((wasm) => {\n            wasmCache$8 = wasm;\n            return wasmCache$8.calculate(data, 384);\n        });\n    }\n    try {\n        const hash = wasmCache$8.calculate(data, 384);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-2 (SHA-384) hash instance\n */\nfunction createSHA384() {\n    return WASMInterface(wasmJson$9, 48).then((wasm) => {\n        wasm.init(384);\n        const obj = {\n            init: () => {\n                wasm.init(384);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 128,\n            digestSize: 48,\n        };\n        return obj;\n    });\n}\n\nconst mutex$7 = new Mutex();\nlet wasmCache$7 = null;\n/**\n * Calculates SHA-2 (SHA-512) hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sha512(data) {\n    if (wasmCache$7 === null) {\n        return lockedCreate(mutex$7, wasmJson$9, 64).then((wasm) => {\n            wasmCache$7 = wasm;\n            return wasmCache$7.calculate(data, 512);\n        });\n    }\n    try {\n        const hash = wasmCache$7.calculate(data, 512);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SHA-2 (SHA-512) hash instance\n */\nfunction createSHA512() {\n    return WASMInterface(wasmJson$9, 64).then((wasm) => {\n        wasm.init(512);\n        const obj = {\n            init: () => {\n                wasm.init(512);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 128,\n            digestSize: 64,\n        };\n        return obj;\n    });\n}\n\nvar name$8 = \"xxhash32\";\nvar data$8 = \"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\";\nvar hash$8 = \"4bb12485\";\nvar wasmJson$8 = {\n\tname: name$8,\n\tdata: data$8,\n\thash: hash$8\n};\n\nconst mutex$6 = new Mutex();\nlet wasmCache$6 = null;\nfunction validateSeed$3(seed) {\n    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) {\n        return new Error(\"Seed must be a valid 32-bit long unsigned integer.\");\n    }\n    return null;\n}\n/**\n * Calculates xxHash32 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param seed Number used to initialize the internal state of the algorithm (defaults to 0)\n * @returns Computed hash as a hexadecimal string\n */\nfunction xxhash32(data, seed = 0) {\n    if (validateSeed$3(seed)) {\n        return Promise.reject(validateSeed$3(seed));\n    }\n    if (wasmCache$6 === null) {\n        return lockedCreate(mutex$6, wasmJson$8, 4).then((wasm) => {\n            wasmCache$6 = wasm;\n            return wasmCache$6.calculate(data, seed);\n        });\n    }\n    try {\n        const hash = wasmCache$6.calculate(data, seed);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new xxHash32 hash instance\n * @param data Input data (string, Buffer or TypedArray)\n * @param seed Number used to initialize the internal state of the algorithm (defaults to 0)\n */\nfunction createXXHash32(seed = 0) {\n    if (validateSeed$3(seed)) {\n        return Promise.reject(validateSeed$3(seed));\n    }\n    return WASMInterface(wasmJson$8, 4).then((wasm) => {\n        wasm.init(seed);\n        const obj = {\n            init: () => {\n                wasm.init(seed);\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 16,\n            digestSize: 4,\n        };\n        return obj;\n    });\n}\n\nvar name$7 = \"xxhash64\";\nvar data$7 = \"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\";\nvar hash$7 = \"177fbfa3\";\nvar wasmJson$7 = {\n\tname: name$7,\n\tdata: data$7,\n\thash: hash$7\n};\n\nconst mutex$5 = new Mutex();\nlet wasmCache$5 = null;\nconst seedBuffer$2 = new Uint8Array(8);\nfunction validateSeed$2(seed) {\n    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) {\n        return new Error(\"Seed must be given as two valid 32-bit long unsigned integers (lo + high).\");\n    }\n    return null;\n}\nfunction writeSeed$2(arr, low, high) {\n    // write in little-endian format\n    const buffer = new DataView(arr);\n    buffer.setUint32(0, low, true);\n    buffer.setUint32(4, high, true);\n}\n/**\n * Calculates xxHash64 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @returns Computed hash as a hexadecimal string\n */\nfunction xxhash64(data, seedLow = 0, seedHigh = 0) {\n    if (validateSeed$2(seedLow)) {\n        return Promise.reject(validateSeed$2(seedLow));\n    }\n    if (validateSeed$2(seedHigh)) {\n        return Promise.reject(validateSeed$2(seedHigh));\n    }\n    if (wasmCache$5 === null) {\n        return lockedCreate(mutex$5, wasmJson$7, 8).then((wasm) => {\n            wasmCache$5 = wasm;\n            writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);\n            wasmCache$5.writeMemory(seedBuffer$2);\n            return wasmCache$5.calculate(data);\n        });\n    }\n    try {\n        writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);\n        wasmCache$5.writeMemory(seedBuffer$2);\n        const hash = wasmCache$5.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new xxHash64 hash instance\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n */\nfunction createXXHash64(seedLow = 0, seedHigh = 0) {\n    if (validateSeed$2(seedLow)) {\n        return Promise.reject(validateSeed$2(seedLow));\n    }\n    if (validateSeed$2(seedHigh)) {\n        return Promise.reject(validateSeed$2(seedHigh));\n    }\n    return WASMInterface(wasmJson$7, 8).then((wasm) => {\n        const instanceBuffer = new Uint8Array(8);\n        writeSeed$2(instanceBuffer.buffer, seedLow, seedHigh);\n        wasm.writeMemory(instanceBuffer);\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.writeMemory(instanceBuffer);\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 32,\n            digestSize: 8,\n        };\n        return obj;\n    });\n}\n\nvar name$6 = \"xxhash3\";\nvar data$6 = \"AGFzbQEAAAABNAhgAAF/YAR/f39/AGAHf39/f39/fwBgBH9+fn4BfmAEf39/fgF+YAN/f34BfmAAAGABfwADDg0AAQIDBAUFBQYHBgAGBQQBAQICBg4CfwFBwI4FC38AQcAJCwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQr6QQ0FAEGACgvkAwMPfgF/AX4CQCADRQ0AIAApAzAhBCAAKQM4IQUgACkDICEGIAApAyghByAAKQMQIQggACkDGCEJIAApAwAhCiAAKQMIIQsDQCAFIAFBMGopAwAiDHwgAkE4aikDACABQThqKQMAIg2FIgVCIIggBUL/////D4N+fCEFIAcgAUEgaikDACIOfCACQShqKQMAIAFBKGopAwAiD4UiB0IgiCAHQv////8Pg358IQcgCSABQRBqKQMAIhB8IAJBGGopAwAgAUEYaikDACIRhSIJQiCIIAlC/////w+DfnwhCSALIAEpAwAiEnwgAkEIaiITKQMAIAFBCGopAwAiFIUiC0IgiCALQv////8Pg358IQsgAkEwaikDACAMhSIMQiCIIAxC/////w+DfiAEfCANfCEEIAJBIGopAwAgDoUiDEIgiCAMQv////8Pg34gBnwgD3whBiACQRBqKQMAIBCFIgxCIIggDEL/////D4N+IAh8IBF8IQggAikDACAShSIMQiCIIAxC/////w+DfiAKfCAUfCEKIAFBwABqIQEgEyECIANBf2oiAw0ACyAAIAk3AxggACAKNwMAIAAgCzcDCCAAIAc3AyggACAINwMQIAAgBTcDOCAAIAY3AyAgACAENwMwCwveAgIBfwF+AkAgBCACIAEoAgAiB2siAkkNACAAIAMgBSAHQQN0aiACEAEgACAFIAZqIgcpAwAgACkDACIIQi+IhSAIhUKx893xCX43AwAgACAHKQMIIAApAwgiCEIviIUgCIVCsfPd8Ql+NwMIIAAgBykDECAAKQMQIghCL4iFIAiFQrHz3fEJfjcDECAAIAcpAxggACkDGCIIQi+IhSAIhUKx893xCX43AxggACAHKQMgIAApAyAiCEIviIUgCIVCsfPd8Ql+NwMgIAAgBykDKCAAKQMoIghCL4iFIAiFQrHz3fEJfjcDKCAAIAcpAzAgACkDMCIIQi+IhSAIhUKx893xCX43AzAgACAHKQM4IAApAzgiCEIviIUgCIVCsfPd8Ql+NwM4IAAgAyACQQZ0aiAFIAQgAmsiBxABIAEgBzYCAA8LIAAgAyAFIAdBA3RqIAQQASABIAcgBGo2AgALhQEBAX8gAiABhSADpyIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycq1CIIYgA4V9QQA1AoCMAUIghiAAQfyLAWo1AgCEhSIDQjGJIANCGImFIAOFQqW+4/TRjIfZn39+IgNCI4ggAK18IAOFQqW+4/TRjIfZn39+IgNCHIggA4ULZwAgAiABc60gA3wiA0IhiEEALQCAjAFBEHQgAEEIdHIgAEEBdkGAjAFqLQAAQRh0ciAAQf+LAWotAAByrYUgA4VCz9bTvtLHq9lCfiIDQh2IIAOFQvnz3fGZ9pmrFn4iA0IgiCADhQuJAwEEfgJAIABBCUkNAEEAKQOAjAEgASkDICABKQMYhSACfIUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAArXwgAEH4iwFqKQMAIAEpAzAgASkDKIUgAn2FIgJ8IAJC/////w+DIgQgA0IgiCIFfiIGQv////8PgyACQiCIIgIgA0L/////D4MiA358IAQgA34iA0IgiHwiBEIghiADQv////8Pg4QgBkIgiCACIAV+fCAEQiCIfIV8IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFDwsCQCAAQQRJDQAgACABQQhqKQMAIAFBEGopAwAgAhADDwsCQCAARQ0AIAAgASgCACABQQRqKAIAIAIQBA8LIAEpAzggASkDQIUgAoUiA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC94IAQZ+IACtQoeVr6+Ytt6bnn9+IQMCQCAAQSFJDQACQCAAQcEASQ0AAkAgAEHhAEkNACABKQNoIAJ9QQApA7iMAYUiBEL/////D4MiBSABKQNgIAJ8QQApA7CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDeCACfSAAQciLAWopAwCFIgNC/////w+DIgQgASkDcCACfCAAQcCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQNIIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQNAIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDWCACfSAAQdiLAWopAwCFIgNC/////w+DIgQgASkDUCACfCAAQdCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMoIAJ9QQApA5iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA5CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDOCACfSAAQeiLAWopAwCFIgNC/////w+DIgQgASkDMCACfCAAQeCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMIIAJ9QQApA4iMAYUiBEL/////D4MiBSABKQMAIAJ8QQApA4CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDGCACfSAAQfiLAWopAwCFIgNC/////w+DIgQgASkDECACfCAAQfCLAWopAwCFIgJCIIgiBX4iBkL/////D4MgA0IgiCIDIAJC/////w+DIgJ+fCAEIAJ+IgJCIIh8IgRCIIYgAkL/////D4OEIAZCIIggAyAFfnwgBEIgiHyFfCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQv8CgQBfwV+An8BfkEAIQMgASkDeCACfUEAKQP4jAGFIgRC/////w+DIgUgASkDcCACfEEAKQPwjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpA2ggAn1BACkD6IwBhSIEQv////8PgyIFIAEpA2AgAnxBACkD4IwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQNYIAJ9QQApA9iMAYUiBEL/////D4MiBSABKQNQIAJ8QQApA9CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDSCACfUEAKQPIjAGFIgRC/////w+DIgUgASkDQCACfEEAKQPAjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAzggAn1BACkDuIwBhSIEQv////8PgyIFIAEpAzAgAnxBACkDsIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQMoIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDGCACfUEAKQOYjAGFIgRC/////w+DIgUgASkDECACfEEAKQOQjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAwggAn1BACkDiIwBhSIEQv////8PgyIFIAEpAwAgAnxBACkDgIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSAArUKHla+vmLbem55/fnx8fHx8fHx8IgRCJYggBIVC+fPd8ZnymasWfiIEQiCIIASFIQQCQCAAQZABSA0AIABBBHZBeGohCQNAIAEgA2oiCkELaikDACACfSADQYiNAWopAwCFIgVC/////w+DIgYgCkEDaikDACACfCADQYCNAWopAwCFIgdCIIgiCH4iC0L/////D4MgBUIgiCIFIAdC/////w+DIgd+fCAGIAd+IgZCIIh8IgdCIIYgBkL/////D4OEIAtCIIggBSAIfnwgB0IgiHyFIAR8IQQgA0EQaiEDIAlBf2oiCQ0ACwsgASkDfyACfSAAQfiLAWopAwCFIgVC/////w+DIgYgASkDdyACfCAAQfCLAWopAwCFIgJCIIgiB34iCEL/////D4MgBUIgiCIFIAJC/////w+DIgJ+fCAGIAJ+IgJCIIh8IgZCIIYgAkL/////D4OEIAhCIIggBSAHfnwgBkIgiHyFIAR8IgJCJYggAoVC+fPd8ZnymasWfiICQiCIIAKFC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAA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QQApA4CKATcDACACQQApA4iKATcDCCACQQApA5CKATcDECACQQApA5iKATcDGCACQQApA6CKATcDICACQQApA6iKATcDKCACQQApA7CKASIFNwMwIAJBACkDuIoBIgY3AzgCQAJAQQAoAoCOASIHQcAASQ0AIAJBACgCiI4BNgJAIAIgAkHAAGpBACgCmI4BQYCMASAHQX9qQQZ2IANBACgCnI4BIgAQAiADIABqIgBBeWopAwAhCCAAKQMJIQkgACkDGSEKIAApAykhCyAHQcCLAWopAwAhBSAAKQMBIQwgB0HIiwFqKQMAIQYgB0HQiwFqKQMAIQ0gACkDESEOIAdB2IsBaikDACEPIAdB4IsBaikDACEQIAApAyEhESAHQeiLAWopAwAhEiACKQMAIRMgAikDECEUIAIpAyAhFSACKQMwIRYgAikDCCEXIAIpAxghGCACKQMoIRkgAiACKQM4IAdB8IsBaikDACIafCAAKQMxIAdB+IsBaikDACIbhSIcQiCIIBxC/////w+Dfnw3AzggGSAQfCARIBKFIhFCIIggEUL/////D4N+fCERIBggDXwgDiAPhSIOQiCIIA5C/////w+DfnwhDiAXIAV8IAwgBoUiDEIgiCAMQv////8Pg358IQwgGyAWIAsgGoUiC0IgiCALQv////8Pg358fCELIBIgFSAKIBCFIhBCIIggEEL/////D4N+fHwhECAPIBQgCSANhSINQiCIIA1C/////w+Dfnx8IRIgBiATIAggBYUiBUIgiCAFQv////8Pg358fCEIDAELIAdBwI0BaiEdQcAAIAdrIR4gAkHAAGohAAJAAkACQCAHQThNDQAgHiEfDAELAkACQEE4IAdrQQN2QQFqQQdxIh8NACACQcAAaiEAIB4hHwwBCyACQcAAaiEAIB9BA3QiICEfA0AgACAdKQMANwMAIABBCGohACAdQQhqIR0gH0F4aiIfDQALQcAAIAcgIGprIR8LAkAgBw0AA0AgACAdKQMANwMAIABBCGogHUEIaikDADcDACAAQRBqIB1BEGopAwA3AwAgAEEYaiAdQRhqKQMANwMAIABBIGogHUEgaikDADcDACAAQShqIB1BKGopAwA3AwAgAEEwaiAdQTBqKQMANwMAIABBOGogHUE4aikDADcDACAAQcAAaiEAIB1BwABqIR0gH0FAaiIfQQdLDQALCyAfRQ0BCyAfQX9qISECQCAfQQdxIiBFDQAgH0F4cSEfA0AgACAdLQAAOgAAIABBAWohACAdQQFqIR0gIEF/aiIgDQALCyAhQQdJDQADQCAAIB0pAAA3AAAgAEEIaiEAIB1BCGohHSAfQXhqIh8NAAsLIAJBwABqIB5qIR1BgIwBIQACQAJAAkAgB0EISQ0AAkAgB0E4akEDdkEBakEHcSIfDQAMAgsgH0EDdCEgQYCMASEAA0AgHSAAKQMANwMAIB1BCGohHSAAQQhqIQAgH0F/aiIfDQALIAcgIGshBwsgB0UNAQJAAkAgB0EHcSIgDQAgByEfDAELIAdBeHEhHwNAIB0gAC0AADoAACAdQQFqIR0gAEEBaiEAICBBf2oiIA0ACwsgB0EISQ0BCwNAIB0gACkAADcAACAdQQhqIR0gAEEIaiEAIB9BeGoiHw0ACwsgA0EAKAKcjgFqIgBBeWopAwAhCiAAKQMJIRMgACkDGSEUIAApAykhCyAAKQMBIQwgACkDESEOIAApAyEhESACKQMAIRUgAikDECEWIAIpAyAhFyACKQMIIRggAikDQCENIAIpA0ghDyACKQMYIRkgAikDUCESIAIpA1ghCCACKQMoIRogAikDYCEQIAIpA2ghCSACIAYgAikDcCIbfCAAKQMxIAIpA3giBoUiHEIgiCAcQv////8Pg358NwM4IBogEHwgESAJhSIRQiCIIBFC/////w+DfnwhESAZIBJ8IA4gCIUiDkIgiCAOQv////8Pg358IQ4gGCANfCAMIA+FIgxCIIggDEL/////D4N+fCEMIAYgCyAbhSILQiCIIAtC/////w+DfiAFfHwhCyAJIBcgFCAQhSIFQiCIIAVC/////w+Dfnx8IRAgCCAWIBMgEoUiBUIgiCAFQv////8Pg358fCESIA8gFSAKIA2FIgVCIIggBUL/////D4N+fHwhCAsgAykDQyACKQM4hSIFQv////8PgyIGIAMpAzsgC4UiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDMyARhSIFQv////8PgyIGIAMpAysgEIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDIyAOhSIFQv////8PgyIGIAMpAxsgEoUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDEyAMhSIFQv////8PgyIGIAMpAwsgCIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgBEKHla+vmLbem55/fnx8fHwiBEIliCAEhUL5893xmfKZqxZ+IgRCIIggBIUhBAwBCyAEpyEAAkBBACkDoI4BIgRQDQACQCAAQRBLDQAgAEGACCAEEAUhBAwCCwJAIABBgAFLDQAgAEGACCAEEAYhBAwCCyAAQYAIIAQQByEEDAELAkAgAEEQSw0AIAAgA0IAEAUhBAwBCwJAIABBgAFLDQAgACADQgAQBiEEDAELIAAgA0IAEAchBAtBACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwOACiABJAALBgBBgIoBCwIACwvMAQEAQYAIC8QBuP5sOSOkS758AYEs9yGtHN7UbemDkJfbckCkpLezZx/LeeZOzMDleIJa0H3M/3IhuAhGdPdDJI7gNZDmgTomTDwoUruRwwDLiNBlixtTLqNxZEiXog35TjgZ70ap3qzYqPp2P+OcND/53LvHxwtPHYpR4EvNtFkxyJ9+ydl4c2TqxayDNNPrw8WBoP/6E2PrFw3dUbfw2knTFlUmKdRonisWvlh9R6H8j/i40XrQMc5FyzqPlRYEKK/X+8q7S0B+QAIAAA==\";\nvar hash$6 = \"5a2fbdbb\";\nvar wasmJson$6 = {\n\tname: name$6,\n\tdata: data$6,\n\thash: hash$6\n};\n\nconst mutex$4 = new Mutex();\nlet wasmCache$4 = null;\nconst seedBuffer$1 = new Uint8Array(8);\nfunction validateSeed$1(seed) {\n    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) {\n        return new Error(\"Seed must be given as two valid 32-bit long unsigned integers (lo + high).\");\n    }\n    return null;\n}\nfunction writeSeed$1(arr, low, high) {\n    // write in little-endian format\n    const buffer = new DataView(arr);\n    buffer.setUint32(0, low, true);\n    buffer.setUint32(4, high, true);\n}\n/**\n * Calculates xxHash3 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @returns Computed hash as a hexadecimal string\n */\nfunction xxhash3(data, seedLow = 0, seedHigh = 0) {\n    if (validateSeed$1(seedLow)) {\n        return Promise.reject(validateSeed$1(seedLow));\n    }\n    if (validateSeed$1(seedHigh)) {\n        return Promise.reject(validateSeed$1(seedHigh));\n    }\n    if (wasmCache$4 === null) {\n        return lockedCreate(mutex$4, wasmJson$6, 8).then((wasm) => {\n            wasmCache$4 = wasm;\n            writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);\n            wasmCache$4.writeMemory(seedBuffer$1);\n            return wasmCache$4.calculate(data);\n        });\n    }\n    try {\n        writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);\n        wasmCache$4.writeMemory(seedBuffer$1);\n        const hash = wasmCache$4.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new xxHash3 hash instance\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n */\nfunction createXXHash3(seedLow = 0, seedHigh = 0) {\n    if (validateSeed$1(seedLow)) {\n        return Promise.reject(validateSeed$1(seedLow));\n    }\n    if (validateSeed$1(seedHigh)) {\n        return Promise.reject(validateSeed$1(seedHigh));\n    }\n    return WASMInterface(wasmJson$6, 8).then((wasm) => {\n        const instanceBuffer = new Uint8Array(8);\n        writeSeed$1(instanceBuffer.buffer, seedLow, seedHigh);\n        wasm.writeMemory(instanceBuffer);\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.writeMemory(instanceBuffer);\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 512,\n            digestSize: 8,\n        };\n        return obj;\n    });\n}\n\nvar name$5 = \"xxhash128\";\nvar data$5 = \"AGFzbQEAAAABKwdgAAF/YAR/f39/AGAHf39/f39/fwBgA39/fgF+YAR/f39+AGAAAGABfwADDQwAAQIDBAQEBQYFAAUFBAEBAgIGDgJ/AUHAjgULfwBBwAkLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAcLSGFzaF9VcGRhdGUACApIYXNoX0ZpbmFsAAkNSGFzaF9HZXRTdGF0ZQAKDkhhc2hfQ2FsY3VsYXRlAAsKU1RBVEVfU0laRQMBCqBNDAUAQYAKC+QDAw9+AX8BfgJAIANFDQAgACkDMCEEIAApAzghBSAAKQMgIQYgACkDKCEHIAApAxAhCCAAKQMYIQkgACkDACEKIAApAwghCwNAIAUgAUEwaikDACIMfCACQThqKQMAIAFBOGopAwAiDYUiBUIgiCAFQv////8Pg358IQUgByABQSBqKQMAIg58IAJBKGopAwAgAUEoaikDACIPhSIHQiCIIAdC/////w+DfnwhByAJIAFBEGopAwAiEHwgAkEYaikDACABQRhqKQMAIhGFIglCIIggCUL/////D4N+fCEJIAsgASkDACISfCACQQhqIhMpAwAgAUEIaikDACIUhSILQiCIIAtC/////w+DfnwhCyACQTBqKQMAIAyFIgxCIIggDEL/////D4N+IAR8IA18IQQgAkEgaikDACAOhSIMQiCIIAxC/////w+DfiAGfCAPfCEGIAJBEGopAwAgEIUiDEIgiCAMQv////8Pg34gCHwgEXwhCCACKQMAIBKFIgxCIIggDEL/////D4N+IAp8IBR8IQogAUHAAGohASATIQIgA0F/aiIDDQALIAAgCTcDGCAAIAo3AwAgACALNwMIIAAgBzcDKCAAIAg3AxAgACAFNwM4IAAgBjcDICAAIAQ3AzALC94CAgF/AX4CQCAEIAIgASgCACIHayICSQ0AIAAgAyAFIAdBA3RqIAIQASAAIAUgBmoiBykDACAAKQMAIghCL4iFIAiFQrHz3fEJfjcDACAAIAcpAwggACkDCCIIQi+IhSAIhUKx893xCX43AwggACAHKQMQIAApAxAiCEIviIUgCIVCsfPd8Ql+NwMQIAAgBykDGCAAKQMYIghCL4iFIAiFQrHz3fEJfjcDGCAAIAcpAyAgACkDICIIQi+IhSAIhUKx893xCX43AyAgACAHKQMoIAApAygiCEIviIUgCIVCsfPd8Ql+NwMoIAAgBykDMCAAKQMwIghCL4iFIAiFQrHz3fEJfjcDMCAAIAcpAzggACkDOCIIQi+IhSAIhUKx893xCX43AzggACADIAJBBnRqIAUgBCACayIHEAEgASAHNgIADwsgACADIAUgB0EDdGogBBABIAEgByAEajYCAAvtAwEFfiABKQM4IAApAziFIgNC/////w+DIgQgASkDMCAAKQMwhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMoIAApAyiFIgNC/////w+DIgQgASkDICAAKQMghSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMYIAApAxiFIgNC/////w+DIgQgASkDECAAKQMQhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMIIAApAwiFIgNC/////w+DIgQgASkDACAAKQMAhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSACfHx8fCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQu6CAIFfgN/AkAgAUEJSQ0AIAAgAUH4iwFqKQMAIgQgAikDOCACKQMwhSADfIUiBUL/////D4NC95Svrwh+IAVCgICAgHCDfEEAKQOAjAEgAikDKCACKQMghSADfYUgBIUiA0IgiCIEQrHz3fEJfnwgBEKHla+vCH4iBEIgiHwgBEL/////D4MgA0L/////D4MiA0Kx893xCX58IANCh5Wvrwh+IgRCIIh8IgVCIIh8IgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgBEL/////D4MgAUF/aq1CNoaEIAVCIIZ8hSIEQiCIIgVCz9bTvgJ+IgZC/////w+DIARC/////w+DIgRCvdzKlQx+fCAEQs/W074CfiIEQiCIfCIHQiCGIghCJYggCCAEQv////8Pg4SFQvnz3fGZ8pmrFn4iBEIgiCAEhTcDACAAIAVCvdzKlQx+IANCz9bTvtLHq9lCfnwgBkIgiHwgB0IgiHwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4U3AwgPCwJAIAFBBEkNACAAIAIpAxggAikDEIUgA6ciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnKtQiCGIAOFfCABQfyLAWo1AgBCIIZBADUCgIwBhIUiA0IgiCIEIAFBAnRBh5Wvr3hqrSIFfiIGQiCIIARCsfPd8Ql+fCAGQv////8PgyADQv////8PgyIDQrHz3fEJfnwgAyAFfiIDQiCIfCIEQiCIfCAEQiCGIANC/////w+DhCIEQgGGfCIDQiWIIAOFQvnz3fGZ8pmrFn4iBUIgiCAFhTcDCCAAIANCA4ggBIUiA0IjiCADhUKlvuP00YyH2Z9/fiIDQhyIIAOFNwMADwsCQCABRQ0AIAAgAigCBCACKAIAc60gA3wiBEIhiEEALQCAjAFBEHQgAUEIdHIiCSABQQF2QYCMAWotAABBGHRyIgogAUH/iwFqLQAAIgFyIguthSAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMAIAAgAigCDCACKAIIc60gA30iA0IhiCABQRh0IAtBgP4DcUEIdHIgCUEIdkGA/gNxIApBGHZyckENd62FIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwgPCyAAIAIpA1AgAikDWIUgA4UiBEIhiCAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMIIAAgAikDQCACKQNIhSADhSIDQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwALwwoBCn4gAa0iBEKHla+vmLbem55/fiEFAkACQCABQSFPDQBCACEGDAELQgAhBwJAIAFBwQBJDQBCACEHAkAgAUHhAEkNACACQfgAaikDACADfSABQciLAWopAwAiCIUiB0L/////D4MiCSACKQNwIAN8IAFBwIsBaikDACIKhSILQiCIIgx+Ig1CIIggB0IgiCIHIAx+fCANQv////8PgyAHIAtC/////w+DIgt+fCAJIAt+IgdCIIh8IglCIIh8QQApA7iMASILQQApA7CMASIMfIUgCUIghiAHQv////8Pg4SFIQcgAkHoAGopAwAgA30gC4UiCUL/////D4MiCyACKQNgIAN8IAyFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCALIAx+IgtCIIh8IgxCIIYgC0L/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAV8IAggCnyFIQULIAJB2ABqKQMAIAN9IAFB2IsBaikDACIIhSIJQv////8PgyIKIAIpA1AgA3wgAUHQiwFqKQMAIguFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCAKIAx+IgpCIIh8IgxCIIYgCkL/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAd8QQApA6iMASIJQQApA6CMASIKfIUhByACQcgAaikDACADfSAJhSIJQv////8PgyIMIAIpA0AgA3wgCoUiCkIgiCINfiIGQv////8PgyAJQiCIIgkgCkL/////D4MiCn58IAwgCn4iCkIgiHwiDEIghiAKQv////8Pg4QgBkIgiCAJIA1+fCAMQiCIfIUgBXwgCCALfIUhBQsgAkE4aikDACADfSABQeiLAWopAwAiCIUiCUL/////D4MiCiACKQMwIAN8IAFB4IsBaikDACILhSIMQiCIIg1+IgZC/////w+DIAlCIIgiCSAMQv////8PgyIMfnwgCiAMfiIKQiCIfCIMQiCGIApC/////w+DhCAGQiCIIAkgDX58IAxCIIh8hSAHfEEAKQOYjAEiB0EAKQOQjAEiCXyFIQYgAkEoaikDACADfSAHhSIHQv////8PgyIKIAIpAyAgA3wgCYUiCUIgiCIMfiINQv////8PgyAHQiCIIgcgCUL/////D4MiCX58IAogCX4iCUIgiHwiCkIghiAJQv////8Pg4QgDUIgiCAHIAx+fCAKQiCIfIUgBXwgCCALfIUhBQsgACACQRhqKQMAIAN9IAFB+IsBaikDACIHhSIIQv////8PgyIJIAIpAxAgA3wgAUHwiwFqKQMAIgqFIgtCIIgiDH4iDUL/////D4MgCEIgiCIIIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAZ8QQApA4iMASIIQQApA4CMASIJfIUiCyACQQhqKQMAIAN9IAiFIghC/////w+DIgwgAikDACADfCAJhSIJQiCIIg1+IgZC/////w+DIAhCIIgiCCAJQv////8PgyIJfnwgDCAJfiIJQiCIfCIMQiCGIAlC/////w+DhCAGQiCIIAggDX58IAxCIIh8hSAFfCAHIAp8hSIFfCIHQiWIIAeFQvnz3fGZ8pmrFn4iB0IgiCAHhTcDACAAQgAgBUKHla+vmLbem55/fiAEIAN9Qs/W077Sx6vZQn58IAtC49zKlfzO8vWFf358IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFfTcDCAuhDwMBfxR+An9BACEEIAJB+ABqKQMAIAN9QQApA/iMASIFhSIGQv////8PgyIHIAIpA3AgA3xBACkD8IwBIgiFIglCIIgiCn4iC0L/////D4MgBkIgiCIGIAlC/////w+DIgl+fCAHIAl+IgdCIIh8IglCIIYgB0L/////D4OEIAtCIIggBiAKfnwgCUIgiHyFIAJB2ABqKQMAIAN9QQApA9iMASIHhSIGQv////8PgyIJIAIpA1AgA3xBACkD0IwBIgqFIgtCIIgiDH4iDUL/////D4MgBkIgiCIGIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAJBOGopAwAgA31BACkDuIwBIgmFIgZC/////w+DIgsgAikDMCADfEEAKQOwjAEiDIUiDUIgiCIOfiIPQv////8PgyAGQiCIIgYgDUL/////D4MiDX58IAsgDX4iC0IgiHwiDUIghiALQv////8Pg4QgD0IgiCAGIA5+fCANQiCIfIUgAkEYaikDACADfUEAKQOYjAEiC4UiBkL/////D4MiDSACKQMQIAN8QQApA5CMASIOhSIPQiCIIhB+IhFC/////w+DIAZCIIgiBiAPQv////8PgyIPfnwgDSAPfiINQiCIfCIPQiCGIA1C/////w+DhCARQiCIIAYgEH58IA9CIIh8hUEAKQOIjAEiDUEAKQOAjAEiD3yFfEEAKQOojAEiEEEAKQOgjAEiEXyFfEEAKQPIjAEiEkEAKQPAjAEiE3yFfEEAKQPojAEiFEEAKQPgjAEiFXyFIgZCJYggBoVC+fPd8ZnymasWfiIGQiCIIAaFIQYgAkHoAGopAwAgA30gFIUiFEL/////D4MiFiACKQNgIAN8IBWFIhVCIIgiF34iGEL/////D4MgFEIgiCIUIBVC/////w+DIhV+fCAWIBV+IhVCIIh8IhZCIIYgFUL/////D4OEIBhCIIggFCAXfnwgFkIgiHyFIAJByABqKQMAIAN9IBKFIhJC/////w+DIhQgAikDQCADfCAThSITQiCIIhV+IhZC/////w+DIBJCIIgiEiATQv////8PgyITfnwgFCATfiITQiCIfCIUQiCGIBNC/////w+DhCAWQiCIIBIgFX58IBRCIIh8hSACQShqKQMAIAN9IBCFIhBC/////w+DIhIgAikDICADfCARhSIRQiCIIhN+IhRC/////w+DIBBCIIgiECARQv////8PgyIRfnwgEiARfiIRQiCIfCISQiCGIBFC/////w+DhCAUQiCIIBAgE358IBJCIIh8hSACQQhqKQMAIAN9IA2FIg1C/////w+DIhAgAikDACADfCAPhSIPQiCIIhF+IhJC/////w+DIA1CIIgiDSAPQv////8PgyIPfnwgECAPfiIPQiCIfCIQQiCGIA9C/////w+DhCASQiCIIA0gEX58IBBCIIh8hSABrSIPQoeVr6+Ytt6bnn9+fCALIA58hXwgCSAMfIV8IAcgCnyFfCAFIAh8hSIFQiWIIAWFQvnz3fGZ8pmrFn4iBUIgiCAFhSEFAkAgAUGgAUgNACABQQV2QXxqIRkDQCACIARqIhpBG2opAwAgA30gBEGYjQFqKQMAIgeFIghC/////w+DIgkgGkETaikDACADfCAEQZCNAWopAwAiCoUiC0IgiCIMfiINQv////8PgyAIQiCIIgggC0L/////D4MiC358IAkgC34iCUIgiHwiC0IghiAJQv////8Pg4QgDUIgiCAIIAx+fCALQiCIfIUgBnwgBEGIjQFqKQMAIgggBEGAjQFqKQMAIgl8hSEGIBpBC2opAwAgA30gCIUiCEL/////D4MiCyAaQQNqKQMAIAN8IAmFIglCIIgiDH4iDUL/////D4MgCEIgiCIIIAlC/////w+DIgl+fCALIAl+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAV8IAcgCnyFIQUgBEEgaiEEIBlBf2oiGQ0ACwsgACACQf8AaikDACADfCABQeiLAWopAwAiB4UiCEL/////D4MiCSACKQN3IAN9IAFB4IsBaikDACIKhSILQiCIIgx+Ig1C/////w+DIAhCIIgiCCALQv////8PgyILfnwgCSALfiIJQiCIfCILQiCGIAlC/////w+DhCANQiCIIAggDH58IAtCIIh8hSAGfCABQfiLAWopAwAiBiABQfCLAWopAwAiCHyFIgkgAkHvAGopAwAgA3wgBoUiBkL/////D4MiCyACKQNnIAN9IAiFIghCIIgiDH4iDUL/////D4MgBkIgiCIGIAhC/////w+DIgh+fCALIAh+IghCIIh8IgtCIIYgCEL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAV8IAcgCnyFIgZ8IgVCJYggBYVC+fPd8ZnymasWfiIFQiCIIAWFNwMAIABCACAGQoeVr6+Ytt6bnn9+IA8gA31Cz9bTvtLHq9lCfnwgCULj3MqV/M7y9YV/fnwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4V9NwMIC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iL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AkHAAGogDGohC0GAjAEhAAJAAkACQCAHQQhJDQACQCAHQThqQQN2QQFqQQdxIg0NAAwCCyANQQN0IQ5BgIwBIQADQCALIAApAwA3AwAgC0EIaiELIABBCGohACANQX9qIg0NAAsgByAOayEHCyAHRQ0BAkACQCAHQQdxIg4NACAHIQ0MAQsgB0F4cSENA0AgCyAALQAAOgAAIAtBAWohCyAAQQFqIQAgDkF/aiIODQALCyAHQQhJDQELA0AgCyAAKQAANwAAIAtBCGohCyAAQQhqIQAgDUF4aiINDQALCyACIAIpAwggAikDQCIIfCADQQAoApyOAWoiACkDASACKQNIIgmFIgpCIIggCkL/////D4N+fDcDCCACIAIpAxggAikDUCIKfCAAKQMRIAIpA1giEIUiEUIgiCARQv////8Pg358NwMYIAIgECAKIAApAwmFIgpCIIggCkL/////D4N+IAIpAxB8fDcDECACIAkgCCAAQXlqKQMAhSIIQiCIIAhC/////w+DfiACKQMAfHw3AwAgACkDGSEIIAIpAyAhCSACIAIpAyggAikDYCIKfCAAKQMhIAIpA2giEIUiEUIgiCARQv////8Pg358NwMoIAIgECAJIAggCoUiCEIgiCAIQv////8Pg358fDcDICACIAYgAikDcCIIfCAAKQMxIAIpA3giBoUiCUIgiCAJQv////8Pg358NwM4IAIgBiAIIAApAymFIghCIIggCEL/////D4N+IAV8fDcDMAsgAiACIANBC2ogBEKHla+vmLbem55/fhADNwNAIAIgAiADQQAoApyOAWpBdWogBELP1tO+0ser2UJ+Qn+FEAM3A0gMAQsgBKchAAJAQQApA6COASIEUA0AAkAgAEEQSw0AIAJBwABqIABBgAggBBAEDAILAkAgAEGAAUsNACACQcAAaiAAQYAIIAQQBQwCCyACQcAAaiAAQYAIIAQQBgwBCwJAIABBEEsNACACQcAAaiAAIANCABAEDAELAkAgAEGAAUsNACACQcAAaiAAIANCABAFDAELIAJBwABqIAAgA0IAEAYLQQAgAikDcDcDuApBACACKQNgNwOoCkEAIAIpA1A3A5gKQQAgAkH4AGopAwA3A8AKQQAgAkHoAGopAwA3A7AKQQAgAkHYAGopAwA3A6AKQQAgAikDSCIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIgQ3A4AKQQAgBDcDkApBACACKQNAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQ3A4gKIAEkAAsGAEGAigELAgALC8wBAQBBgAgLxAG4/mw5I6RLvnwBgSz3Ia0c3tRt6YOQl9tyQKSkt7NnH8t55k7MwOV4glrQfcz/ciG4CEZ090MkjuA1kOaBOiZMPChSu5HDAMuI0GWLG1Muo3FkSJeiDflOOBnvRqnerNio+nY/45w0P/ncu8fHC08dilHgS820WTHIn37J2XhzZOrFrIM00+vDxYGg//oTY+sXDd1Rt/DaSdMWVSYp1GieKxa+WH1HofyP+LjRetAxzkXLOo+VFgQor9f7yrtLQH5AAgAA\";\nvar hash$5 = \"b9ab74e2\";\nvar wasmJson$5 = {\n\tname: name$5,\n\tdata: data$5,\n\thash: hash$5\n};\n\nconst mutex$3 = new Mutex();\nlet wasmCache$3 = null;\nconst seedBuffer = new Uint8Array(8);\nfunction validateSeed(seed) {\n    if (!Number.isInteger(seed) || seed < 0 || seed > 0xffffffff) {\n        return new Error(\"Seed must be given as two valid 32-bit long unsigned integers (lo + high).\");\n    }\n    return null;\n}\nfunction writeSeed(arr, low, high) {\n    // write in little-endian format\n    const buffer = new DataView(arr);\n    buffer.setUint32(0, low, true);\n    buffer.setUint32(4, high, true);\n}\n/**\n * Calculates xxHash128 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @returns Computed hash as a hexadecimal string\n */\nfunction xxhash128(data, seedLow = 0, seedHigh = 0) {\n    if (validateSeed(seedLow)) {\n        return Promise.reject(validateSeed(seedLow));\n    }\n    if (validateSeed(seedHigh)) {\n        return Promise.reject(validateSeed(seedHigh));\n    }\n    if (wasmCache$3 === null) {\n        return lockedCreate(mutex$3, wasmJson$5, 16).then((wasm) => {\n            wasmCache$3 = wasm;\n            writeSeed(seedBuffer.buffer, seedLow, seedHigh);\n            wasmCache$3.writeMemory(seedBuffer);\n            return wasmCache$3.calculate(data);\n        });\n    }\n    try {\n        writeSeed(seedBuffer.buffer, seedLow, seedHigh);\n        wasmCache$3.writeMemory(seedBuffer);\n        const hash = wasmCache$3.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new xxHash128 hash instance\n * @param seedLow Lower 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n * @param seedHigh Higher 32 bits of the number used to\n *  initialize the internal state of the algorithm (defaults to 0)\n */\nfunction createXXHash128(seedLow = 0, seedHigh = 0) {\n    if (validateSeed(seedLow)) {\n        return Promise.reject(validateSeed(seedLow));\n    }\n    if (validateSeed(seedHigh)) {\n        return Promise.reject(validateSeed(seedHigh));\n    }\n    return WASMInterface(wasmJson$5, 16).then((wasm) => {\n        const instanceBuffer = new Uint8Array(8);\n        writeSeed(instanceBuffer.buffer, seedLow, seedHigh);\n        wasm.writeMemory(instanceBuffer);\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.writeMemory(instanceBuffer);\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 512,\n            digestSize: 16,\n        };\n        return obj;\n    });\n}\n\nvar name$4 = \"ripemd160\";\nvar data$4 = \"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\";\nvar hash$4 = \"6abbce74\";\nvar wasmJson$4 = {\n\tname: name$4,\n\tdata: data$4,\n\thash: hash$4\n};\n\nconst mutex$2 = new Mutex();\nlet wasmCache$2 = null;\n/**\n * Calculates RIPEMD-160 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction ripemd160(data) {\n    if (wasmCache$2 === null) {\n        return lockedCreate(mutex$2, wasmJson$4, 20).then((wasm) => {\n            wasmCache$2 = wasm;\n            return wasmCache$2.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$2.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new RIPEMD-160 hash instance\n */\nfunction createRIPEMD160() {\n    return WASMInterface(wasmJson$4, 20).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 20,\n        };\n        return obj;\n    });\n}\n\nfunction calculateKeyBuffer(hasher, key) {\n    const { blockSize } = hasher;\n    const buf = getUInt8Buffer(key);\n    if (buf.length > blockSize) {\n        hasher.update(buf);\n        const uintArr = hasher.digest(\"binary\");\n        hasher.init();\n        return uintArr;\n    }\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);\n}\nfunction calculateHmac(hasher, key) {\n    hasher.init();\n    const { blockSize } = hasher;\n    const keyBuf = calculateKeyBuffer(hasher, key);\n    const keyBuffer = new Uint8Array(blockSize);\n    keyBuffer.set(keyBuf);\n    const opad = new Uint8Array(blockSize);\n    for (let i = 0; i < blockSize; i++) {\n        const v = keyBuffer[i];\n        opad[i] = v ^ 0x5c;\n        keyBuffer[i] = v ^ 0x36;\n    }\n    hasher.update(keyBuffer);\n    const obj = {\n        init: () => {\n            hasher.init();\n            hasher.update(keyBuffer);\n            return obj;\n        },\n        update: (data) => {\n            hasher.update(data);\n            return obj;\n        },\n        digest: ((outputType) => {\n            const uintArr = hasher.digest(\"binary\");\n            hasher.init();\n            hasher.update(opad);\n            hasher.update(uintArr);\n            return hasher.digest(outputType);\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n        }),\n        save: () => {\n            throw new Error(\"save() not supported\");\n        },\n        load: () => {\n            throw new Error(\"load() not supported\");\n        },\n        blockSize: hasher.blockSize,\n        digestSize: hasher.digestSize,\n    };\n    return obj;\n}\n/**\n * Calculates HMAC hash\n * @param hash Hash algorithm to use. It has to be the return value of a function like createSHA1()\n * @param key Key (string, Buffer or TypedArray)\n */\nfunction createHMAC(hash, key) {\n    if (!hash || !hash.then) {\n        throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), \"key\").');\n    }\n    return hash.then((hasher) => calculateHmac(hasher, key));\n}\n\nfunction calculatePBKDF2(digest, salt, iterations, hashLength, outputType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const DK = new Uint8Array(hashLength);\n        const block1 = new Uint8Array(salt.length + 4);\n        const block1View = new DataView(block1.buffer);\n        const saltBuffer = getUInt8Buffer(salt);\n        const saltUIntBuffer = new Uint8Array(saltBuffer.buffer, saltBuffer.byteOffset, saltBuffer.length);\n        block1.set(saltUIntBuffer);\n        let destPos = 0;\n        const hLen = digest.digestSize;\n        const l = Math.ceil(hashLength / hLen);\n        let T = null;\n        let U = null;\n        for (let i = 1; i <= l; i++) {\n            block1View.setUint32(salt.length, i);\n            digest.init();\n            digest.update(block1);\n            T = digest.digest(\"binary\");\n            U = T.slice();\n            for (let j = 1; j < iterations; j++) {\n                digest.init();\n                digest.update(U);\n                U = digest.digest(\"binary\");\n                for (let k = 0; k < hLen; k++) {\n                    T[k] ^= U[k];\n                }\n            }\n            DK.set(T.subarray(0, hashLength - destPos), destPos);\n            destPos += hLen;\n        }\n        if (outputType === \"binary\") {\n            return DK;\n        }\n        const digestChars = new Uint8Array(hashLength * 2);\n        return getDigestHex(digestChars, DK, hashLength);\n    });\n}\nconst validateOptions$2 = (options) => {\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (!options.hashFunction || !options.hashFunction.then) {\n        throw new Error('Invalid hash function is provided! Usage: pbkdf2(\"password\", \"salt\", 1000, 32, createSHA1()).');\n    }\n    if (!Number.isInteger(options.iterations) || options.iterations < 1) {\n        throw new Error(\"Iterations should be a positive number\");\n    }\n    if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {\n        throw new Error(\"Hash length should be a positive number\");\n    }\n    if (options.outputType === undefined) {\n        options.outputType = \"hex\";\n    }\n    if (![\"hex\", \"binary\"].includes(options.outputType)) {\n        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);\n    }\n};\n/**\n * Generates a new PBKDF2 hash for the supplied password\n */\nfunction pbkdf2(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions$2(options);\n        const hmac = yield createHMAC(options.hashFunction, options.password);\n        return calculatePBKDF2(hmac, options.salt, options.iterations, options.hashLength, options.outputType);\n    });\n}\n\nvar name$3 = \"scrypt\";\nvar data$3 = \"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cyICajYCOCAAIAAoAjwgAiAKakESdyAGc2o2AjwLvxIDFX8Bfg5/AkAgAkUNACAAQQd0IgNBQGoiBEEAKAKACCIFIAMgAmwiBmogAyABbGoiByADaiIIaiEJIAAgAkEHdCIKIAFBB3RqIgtsIQwgACALQYABamwhDSAAQQV0IgtBASALQQFLGyILQWBxIQ4gC0EBcSEPIAdBeGohECAHQXBqIREgB0FoaiESIAdBYGohEyAHQVhqIRQgB0FQaiEVIAdBSGohFiAHQUBqIRcgAa1Cf3whGCAEIAdqIRkgByAAQQh0IhpqIRsgACAKQYABamwhHCALQQRJIR1BACEeQQAhHwNAQQAoAoAIIiAgAyAfbGohIQJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgByALaiIEICMgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AIAcgIkECdCILaiAhIAtqKAIANgIACwJAIAFFDQBBACElIBwhIyAGISYDQCAFISQgACEiAkACQCAADQAgGyAXKQMANwMAIBsgFikDADcDCCAbIBUpAwA3AxAgGyAUKQMANwMYIBsgEykDADcDICAbIBIpAwA3AyggGyARKQMANwMwIBsgECkDADcDOAwBCwNAICQgJmoiCyAkIAxqIgQpAwA3AwAgC0EIaiAEQQhqKQMANwMAIAtBEGogBEEQaikDADcDACALQRhqIARBGGopAwA3AwAgC0EgaiAEQSBqKQMANwMAIAtBKGogBEEoaikDADcDACALQTBqIARBMGopAwA3AwAgC0E4aiAEQThqKQMANwMAIAtBwABqIARBwABqKQMANwMAIAtByABqIARByABqKQMANwMAIAtB0ABqIARB0ABqKQMANwMAIAtB2ABqIARB2ABqKQMANwMAIAtB4ABqIARB4ABqKQMANwMAIAtB6ABqIARB6ABqKQMANwMAIAtB8ABqIARB8ABqKQMANwMAIAtB+ABqIARB+ABqKQMANwMAICRBgAFqISQgIkF/aiIiDQALIAcgCCAbIAAQAiAFISQgACEiA0AgJCAjaiILICQgDWoiBCkDADcDACALQQhqIARBCGopAwA3AwAgC0EQaiAEQRBqKQMANwMAIAtBGGogBEEYaikDADcDACALQSBqIARBIGopAwA3AwAgC0EoaiAEQShqKQMANwMAIAtBMGogBEEwaikDADcDACALQThqIARBOGopAwA3AwAgC0HAAGogBEHAAGopAwA3AwAgC0HIAGogBEHIAGopAwA3AwAgC0HQAGogBEHQAGopAwA3AwAgC0HYAGogBEHYAGopAwA3AwAgC0HgAGogBEHgAGopAwA3AwAgC0HoAGogBEHoAGopAwA3AwAgC0HwAGogBEHwAGopAwA3AwAgC0H4AGogBEH4AGopAwA3AwAgJEGAAWohJCAiQX9qIiINAAsLIAggByAbIAAQAiAjIBpqISMgJiAaaiEmICVBAmoiJSABSQ0AC0EAISUDQAJAAkAgAA0AIBsgFykDADcDACAbIBYpAwA3AwggGyAVKQMANwMQIBsgFCkDADcDGCAbIBMpAwA3AyAgGyASKQMANwMoIBsgESkDADcDMCAbIBApAwA3AzgMAQsgACAKIBkpAgAgGIOnQQd0amwhJiAFISQgACEiA0AgJCAMaiILIAspAwAgJCAmaiIEKQMAhTcDACALQQhqIiMgIykDACAEQQhqKQMAhTcDACALQRBqIiMgIykDACAEQRBqKQMAhTcDACALQRhqIiMgIykDACAEQRhqKQMAhTcDACALQSBqIiMgIykDACAEQSBqKQMAhTcDACALQShqIiMgIykDACAEQShqKQMAhTcDACALQTBqIiMgIykDACAEQTBqKQMAhTcDACALQThqIiMgIykDACAEQThqKQMAhTcDACALQcAAaiIjICMpAwAgBEHAAGopAwCFNwMAIAtByABqIiMgIykDACAEQcgAaikDAIU3AwAgC0HQAGoiIyAjKQMAIARB0ABqKQMAhTcDACALQdgAaiIjICMpAwAgBEHYAGopAwCFNwMAIAtB4ABqIiMgIykDACAEQeAAaikDAIU3AwAgC0HoAGoiIyAjKQMAIARB6ABqKQMAhTcDACALQfAAaiIjICMpAwAgBEHwAGopAwCFNwMAIAtB+ABqIgsgCykDACAEQfgAaikDAIU3AwAgJEGAAWohJCAiQX9qIiINAAsgByAIIBsgABACIAAgCiAJKQIAIBiDp0EHdGpsISYgBSEkIAAhIgNAICQgDWoiCyALKQMAICQgJmoiBCkDAIU3AwAgC0EIaiIjICMpAwAgBEEIaikDAIU3AwAgC0EQaiIjICMpAwAgBEEQaikDAIU3AwAgC0EYaiIjICMpAwAgBEEYaikDAIU3AwAgC0EgaiIjICMpAwAgBEEgaikDAIU3AwAgC0EoaiIjICMpAwAgBEEoaikDAIU3AwAgC0EwaiIjICMpAwAgBEEwaikDAIU3AwAgC0E4aiIjICMpAwAgBEE4aikDAIU3AwAgC0HAAGoiIyAjKQMAIARBwABqKQMAhTcDACALQcgAaiIjICMpAwAgBEHIAGopAwCFNwMAIAtB0ABqIiMgIykDACAEQdAAaikDAIU3AwAgC0HYAGoiIyAjKQMAIARB2ABqKQMAhTcDACALQeAAaiIjICMpAwAgBEHgAGopAwCFNwMAIAtB6ABqIiMgIykDACAEQegAaikDAIU3AwAgC0HwAGoiIyAjKQMAIARB8ABqKQMAhTcDACALQfgAaiILIAspAwAgBEH4AGopAwCFNwMAICRBgAFqISQgIkF/aiIiDQALCyAIIAcgGyAAEAIgJUECaiIlIAFJDQALCwJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgIyALaiIEIAcgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AICEgIkECdCILaiAHIAtqKAIANgIACyAeIANqIR4gH0EBaiIfIAJHDQALCws=\";\nvar hash$3 = \"b32721f8\";\nvar wasmJson$3 = {\n\tname: name$3,\n\tdata: data$3,\n\thash: hash$3\n};\n\nfunction scryptInternal(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { costFactor, blockSize, parallelism, hashLength } = options;\n        const SHA256Hasher = createSHA256();\n        const blockData = yield pbkdf2({\n            password: options.password,\n            salt: options.salt,\n            iterations: 1,\n            hashLength: 128 * blockSize * parallelism,\n            hashFunction: SHA256Hasher,\n            outputType: \"binary\",\n        });\n        const scryptInterface = yield WASMInterface(wasmJson$3, 0);\n        // last block is for storing the temporary vectors\n        const VSize = 128 * blockSize * costFactor;\n        const XYSize = 256 * blockSize;\n        scryptInterface.setMemorySize(blockData.length + VSize + XYSize);\n        scryptInterface.writeMemory(blockData, 0);\n        // mix blocks\n        scryptInterface.getExports().scrypt(blockSize, costFactor, parallelism);\n        const expensiveSalt = scryptInterface\n            .getMemory()\n            .subarray(0, 128 * blockSize * parallelism);\n        const outputData = yield pbkdf2({\n            password: options.password,\n            salt: expensiveSalt,\n            iterations: 1,\n            hashLength,\n            hashFunction: SHA256Hasher,\n            outputType: \"binary\",\n        });\n        if (options.outputType === \"hex\") {\n            const digestChars = new Uint8Array(hashLength * 2);\n            return getDigestHex(digestChars, outputData, hashLength);\n        }\n        // return binary format\n        return outputData;\n    });\n}\nconst isPowerOfTwo = (v) => v && !(v & (v - 1));\nconst validateOptions$1 = (options) => {\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (!Number.isInteger(options.blockSize) || options.blockSize < 1) {\n        throw new Error(\"Block size should be a positive number\");\n    }\n    if (!Number.isInteger(options.costFactor) ||\n        options.costFactor < 2 ||\n        !isPowerOfTwo(options.costFactor)) {\n        throw new Error(\"Cost factor should be a power of 2, greater than 1\");\n    }\n    if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {\n        throw new Error(\"Parallelism should be a positive number\");\n    }\n    if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {\n        throw new Error(\"Hash length should be a positive number.\");\n    }\n    if (options.outputType === undefined) {\n        options.outputType = \"hex\";\n    }\n    if (![\"hex\", \"binary\"].includes(options.outputType)) {\n        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);\n    }\n};\n/**\n * Calculates hash using the scrypt password-based key derivation function\n * @returns Computed hash as a hexadecimal string or as\n *          Uint8Array depending on the outputType option\n */\nfunction scrypt(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions$1(options);\n        return scryptInternal(options);\n    });\n}\n\nvar name$2 = \"bcrypt\";\nvar data$2 = \"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\";\nvar hash$2 = \"8bd8822d\";\nvar wasmJson$2 = {\n\tname: name$2,\n\tdata: data$2,\n\thash: hash$2\n};\n\nfunction bcryptInternal(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { costFactor, password, salt } = options;\n        const bcryptInterface = yield WASMInterface(wasmJson$2, 0);\n        bcryptInterface.writeMemory(getUInt8Buffer(salt), 0);\n        const passwordBuffer = getUInt8Buffer(password);\n        bcryptInterface.writeMemory(passwordBuffer, 16);\n        const shouldEncode = options.outputType === \"encoded\" ? 1 : 0;\n        bcryptInterface\n            .getExports()\n            .bcrypt(passwordBuffer.length, costFactor, shouldEncode);\n        const memory = bcryptInterface.getMemory();\n        if (options.outputType === \"encoded\") {\n            return intArrayToString(memory, 60);\n        }\n        if (options.outputType === \"hex\") {\n            const digestChars = new Uint8Array(24 * 2);\n            return getDigestHex(digestChars, memory, 24);\n        }\n        // return binary format\n        // the data is copied to allow GC of the original memory buffer\n        return memory.slice(0, 24);\n    });\n}\nconst validateOptions = (options) => {\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (!Number.isInteger(options.costFactor) ||\n        options.costFactor < 4 ||\n        options.costFactor > 31) {\n        throw new Error(\"Cost factor should be a number between 4 and 31\");\n    }\n    options.password = getUInt8Buffer(options.password);\n    if (options.password.length < 1) {\n        throw new Error(\"Password should be at least 1 byte long\");\n    }\n    if (options.password.length > 72) {\n        throw new Error(\"Password should be at most 72 bytes long\");\n    }\n    options.salt = getUInt8Buffer(options.salt);\n    if (options.salt.length !== 16) {\n        throw new Error(\"Salt should be 16 bytes long\");\n    }\n    if (options.outputType === undefined) {\n        options.outputType = \"encoded\";\n    }\n    if (![\"hex\", \"binary\", \"encoded\"].includes(options.outputType)) {\n        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);\n    }\n};\n/**\n * Calculates hash using the bcrypt password-hashing function\n * @returns Computed hash\n */\nfunction bcrypt(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateOptions(options);\n        return bcryptInternal(options);\n    });\n}\nconst validateHashCharacters = (hash) => {\n    if (!/^\\$2[axyb]\\$[0-3][0-9]\\$[./A-Za-z0-9]{53}$/.test(hash)) {\n        return false;\n    }\n    if (hash[4] === \"0\" && Number(hash[5]) < 4) {\n        return false;\n    }\n    if (hash[4] === \"3\" && Number(hash[5]) > 1) {\n        return false;\n    }\n    return true;\n};\nconst validateVerifyOptions = (options) => {\n    if (!options || typeof options !== \"object\") {\n        throw new Error(\"Invalid options parameter. It requires an object.\");\n    }\n    if (options.hash === undefined || typeof options.hash !== \"string\") {\n        throw new Error(\"Hash should be specified\");\n    }\n    if (options.hash.length !== 60) {\n        throw new Error(\"Hash should be 60 bytes long\");\n    }\n    if (!validateHashCharacters(options.hash)) {\n        throw new Error(\"Invalid hash\");\n    }\n    options.password = getUInt8Buffer(options.password);\n    if (options.password.length < 1) {\n        throw new Error(\"Password should be at least 1 byte long\");\n    }\n    if (options.password.length > 72) {\n        throw new Error(\"Password should be at most 72 bytes long\");\n    }\n};\n/**\n * Verifies password using bcrypt password-hashing function\n * @returns True if the encoded hash matches the password\n */\nfunction bcryptVerify(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        validateVerifyOptions(options);\n        const { hash, password } = options;\n        const bcryptInterface = yield WASMInterface(wasmJson$2, 0);\n        bcryptInterface.writeMemory(getUInt8Buffer(hash), 0);\n        const passwordBuffer = getUInt8Buffer(password);\n        bcryptInterface.writeMemory(passwordBuffer, 60);\n        return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);\n    });\n}\n\nvar name$1 = \"whirlpool\";\nvar data$1 = \"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\";\nvar hash$1 = \"8d8f6035\";\nvar wasmJson$1 = {\n\tname: name$1,\n\tdata: data$1,\n\thash: hash$1\n};\n\nconst mutex$1 = new Mutex();\nlet wasmCache$1 = null;\n/**\n * Calculates Whirlpool hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction whirlpool(data) {\n    if (wasmCache$1 === null) {\n        return lockedCreate(mutex$1, wasmJson$1, 64).then((wasm) => {\n            wasmCache$1 = wasm;\n            return wasmCache$1.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache$1.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new Whirlpool hash instance\n */\nfunction createWhirlpool() {\n    return WASMInterface(wasmJson$1, 64).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 64,\n        };\n        return obj;\n    });\n}\n\nvar name = \"sm3\";\nvar data = \"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\";\nvar hash = \"b6fb4b8e\";\nvar wasmJson = {\n\tname: name,\n\tdata: data,\n\thash: hash\n};\n\nconst mutex = new Mutex();\nlet wasmCache = null;\n/**\n * Calculates SM3 hash\n * @param data Input data (string, Buffer or TypedArray)\n * @returns Computed hash as a hexadecimal string\n */\nfunction sm3(data) {\n    if (wasmCache === null) {\n        return lockedCreate(mutex, wasmJson, 32).then((wasm) => {\n            wasmCache = wasm;\n            return wasmCache.calculate(data);\n        });\n    }\n    try {\n        const hash = wasmCache.calculate(data);\n        return Promise.resolve(hash);\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n}\n/**\n * Creates a new SM3 hash instance\n */\nfunction createSM3() {\n    return WASMInterface(wasmJson, 32).then((wasm) => {\n        wasm.init();\n        const obj = {\n            init: () => {\n                wasm.init();\n                return obj;\n            },\n            update: (data) => {\n                wasm.update(data);\n                return obj;\n            },\n            // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type\n            digest: (outputType) => wasm.digest(outputType),\n            save: () => wasm.save(),\n            load: (data) => {\n                wasm.load(data);\n                return obj;\n            },\n            blockSize: 64,\n            digestSize: 32,\n        };\n        return obj;\n    });\n}\n\nexport { adler32, argon2Verify, argon2d, argon2i, argon2id, bcrypt, bcryptVerify, blake2b, blake2s, blake3, crc32, crc64, createAdler32, createBLAKE2b, createBLAKE2s, createBLAKE3, createCRC32, createCRC64, createHMAC, createKeccak, createMD4, createMD5, createRIPEMD160, createSHA1, createSHA224, createSHA256, createSHA3, createSHA384, createSHA512, createSM3, createWhirlpool, createXXHash128, createXXHash3, createXXHash32, createXXHash64, keccak, md4, md5, pbkdf2, ripemd160, scrypt, sha1, sha224, sha256, sha3, sha384, sha512, sm3, whirlpool, xxhash128, xxhash3, xxhash32, xxhash64 };\n","import * as bioc from \"bioconductor\";\nimport * as df from \"./DataFrame.js\";\n\nconst translate_effects = { \"lfc\": \"deltaMean\", \"delta_detected\": \"deltaDetected\", \"auc\": \"auc\", \"cohen\": \"cohensD\" };\n\nexport function formatMarkerDetectionResults(state, modality_names) {\n    const translate_summary = { \"min\": \"minimum\", \"mean\": \"mean\", \"min_rank\": \"min-rank\" };\n    const do_auc = state.marker_detection.fetchParameters().compute_auc;\n    let all_rowdata = state.inputs.fetchFeatureAnnotations();\n    let all_output = {};\n\n    for (const [m, rn] of Object.entries(modality_names)) {\n        let res = state.marker_detection.fetchResults()[m];\n        let ngroups = res.numberOfGroups();\n        let nfeatures = all_rowdata[m].numberOfRows();\n\n        for (var group = 0; group < ngroups; group++) {\n            let mdf = new bioc.DataFrame({}, { numberOfRows: nfeatures, rowNames: rn });\n\n            for (const x of [ \"mean\", \"detected\" ]) {\n                mdf.setColumn(x, res[x](group, { copy: \"view\" }), { inPlace: true });\n            }\n\n            for (const [eff, trans_eff] of Object.entries(translate_effects)) {\n                if (eff == \"auc\" && !do_auc) {\n                    continue;\n                }\n                for (const [summ, trans_summ] of Object.entries(translate_summary)) {\n                    mdf.setColumn(eff + \"-\" + summ, res[trans_eff](group, { summary: trans_summ }), { inPlace: true });\n                }\n            }\n\n            let new_name = group + 1; // incrementing to avoid cluster names starting from 0.\n            all_output[m + \"/\" + String(new_name)] = mdf;\n        }\n    }\n\n    return all_output;\n}\n\nexport function formatCustomSelectionResults(state, modality_names) {\n    const do_auc = state.custom_selections.fetchParameters().compute_auc;\n    let all_sel = state.custom_selections.fetchSelections();\n    let all_rowdata = state.inputs.fetchFeatureAnnotations();\n    let all_output = {};\n\n    for (const [m, rn] of Object.entries(modality_names)) {\n        let nfeatures = all_rowdata[m].numberOfRows();\n\n        for (const sel of Object.keys(all_sel)) {\n            let res = state.custom_selections.fetchResults(sel)[m];\n            let mdf = new bioc.DataFrame({}, { numberOfRows: nfeatures, rowNames: rn });\n\n            for (const x of [ \"mean\", \"detected\" ]) {\n                mdf.setColumn(x, res[x](1, { copy: \"view\" }), { inPlace: true });\n            }\n\n            for (const [eff, trans_eff] of Object.entries(translate_effects)) {\n                if (eff == \"auc\" && !do_auc) {\n                    continue;\n                }\n                mdf.setColumn(eff, res[trans_eff](1, { copy: \"view\" }), { inPlace: true });\n            }\n\n            all_output[m + \"/\" + sel] = mdf;\n        }\n    }\n\n    return all_output;\n}\n\nexport function formatFeatureSelectionResults(state, rna_names) {\n    let res = state.feature_selection.fetchResults();\n    let fdf = new bioc.DataFrame(\n        {\n            mean: res.means({ copy: \"view\" }),\n            variance: res.variances({ copy: \"view\" }),\n            fitted: res.fitted({ copy: \"view\" }),\n            residual: res.residuals({ copy: \"view\" })\n        }, \n        { \n            columnOrder: [ \"mean\", \"variance\", \"fitted\", \"residual\" ],\n            rowNames: rna_names\n        }\n    );\n\n    return fdf;\n}\n","import { RangedSummarizedExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { readSummarizedExperiment, saveSummarizedExperiment } from \"./SummarizedExperiment.js\"; \nimport { joinPath, jsonBuffer } from \"./utils.js\";\n\n/**\n * A ranged summarized experiment.\n * @external RangedSummarizedExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/RangedSummarizedExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:RangedSummarizedExperiment RangedSummarizedExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, see also {@link readSummarizedExperiment}.\n *\n * @return {external:RangedSummarizedExperiment} The ranged summarized experiment object.\n * @async\n */\nexport async function readRangedSummarizedExperiment(path, metadata, globals, options = {}) {\n    let se = await readSummarizedExperiment(path, metadata, globals, options);\n\n    let rse = new RangedSummarizedExperiment(\n        se.assays(),\n        null,\n        {\n            assayOrder: se.assayNames(),\n            rowData: se.rowData(),\n            columnData: se.columnData(),\n            rowNames: se.rowNames(),\n            columnNames: se.columnNames(),\n            metadata: se.metadata(),\n        }\n    );\n\n    return rse;\n}\n\n/**\n * @param {external:RangedSummarizedExperiment} x - The ranged summarized experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, see also {@linkcode saveSummarizedExperiment}.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveRangedSummarizedExperiment(x, path, globals, options = {}) {\n    await saveSummarizedExperiment(x, path, globals, options);\n    const existing = await readObjectFile(path, globals);\n    existing.type = \"ranged_summarized_experiment\";\n    existing.ranged_summarized_experiment = { \"version\": \"1.0\" };\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(existing));\n}\n","/**\n * Join paths while accounting for `.` inputs.\n *\n * @param {string} args - One or more strings containing path components.\n * These should not have leading or trailing `/` but may be equal to `.`\n *\n * @return The joined path.\n */\nexport function joinPath(...args) {\n    let output = args[0];\n    for (var i = 1; i < args.length; i++) {\n        let current = args[i];\n        if (output == \".\") {\n            output = current;\n        } else if (current != \".\") {\n            output += \"/\" + current;\n        }\n    }\n    return output;\n}\n\nexport function exceedsInt32(x) {\n    const upper = 2**31, lower = -upper;\n    for (const v of x) {\n        if (v !== null && (v < lower || v >= upper)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction substitutePlaceholder(x, placeholder, outclass) {\n    let output = new outclass(x.length);\n    x.forEach((y, i) => {\n        output[i] = (y === null ? placeholder : y);\n    });\n    return output;\n}\n\nexport function formatIntegerArrayForHdf5(x) {\n    let has_missing = x.some(y => y == null);\n\n    if (exceedsInt32(x)) {\n        let placeholder = null;\n        if (has_missing) {\n            placeholder = Number.NaN;\n            x = substitutePlaceholder(x, placeholder, Float64Array);\n        }\n        return { integer: false, data: x, placeholder: placeholder };\n    }\n\n    if (!has_missing) {\n        return { integer: true, data: x, placeholder: null };\n    }\n\n    let output = { integer: true, data: null, placeholder: null };\n\n    // Quickly searching some of the most obvious candidates.\n    const upper = 2**31, lower = -upper;\n    for (const candidate of [lower, upper - 1, 0]) {\n        if (!x.some(y => y == candidate)) {\n            output.placeholder = candidate;\n            break;\n        }\n    }\n\n    if (output.placeholder === null) {\n        let everything = new Set(x);\n        for (var i = lower + 1; i < upper - 1; i++) {\n            if (!everything.has(i)) {\n                output.placeholder = i;\n                break;\n            }\n        }\n    }\n\n    if (output.placeholder === null) {\n        output.integer = false;\n        output.placeholder = Number.NaN;\n    }\n\n    output.data = substitutePlaceholder(x, output.placeholder, Int32Array);\n    return output;\n}\n\nexport function formatNumberArrayForHdf5(x) {\n    if (!x.some(y => y == null)) {\n        return { data: x, placeholder: null };\n    }\n\n    // Quickly searching some of the most obvious candidates.\n    if (!x.some(Number.isNaN)) {\n        return { data: substitutePlaceholder(x, Number.NaN, Float64Array), placeholder: Number.NaN };\n    }\n\n    for (const candidate of [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.MAX_VALUE, -Number.MAX_VALUE, 0]) {\n        if (!x.some(y => y == candidate)) {\n            return { data: substitutePlaceholder(x, candidate, Float64Array), placeholder: candidate };\n        }\n    }\n\n    let previous = -Number.MAX_VALUE;\n    let sorted = (new Float64Array(x.filter(Number.isFinite))).sort();\n    let chosen;\n    for (const y of sorted) {\n        let candidate = previous + (y - previous) / 2;\n        if (candidate != previous && candidate != y) {\n            chosen = candidate;\n            break;\n        }\n        previous = y;\n    }\n\n    return { data: substitutePlaceholder(x, chosen, Float64Array), placeholder: chosen };\n}\n\nexport function formatStringArrayForHdf5(x) {\n    if (!x.some(y => y == null)) {\n        return { data: x, placeholder: null };\n    }\n\n    let placeholder = \"NA\";\n    if (x.some(y => y == \"NA\")) { // Quickly searching the most obvious candidates.\n        let everything = new Set(x);\n        placeholder += \"_\";\n        while (everything.has(placeholder)) {\n            placeholder += \"_\";\n        }\n    }\n\n    return { data: x.map(y => y == null ? placeholder : y), placeholder: placeholder };\n}\n\nexport function formatBooleanArrayForHdf5(x) {\n    return { \n        data: substitutePlaceholder(x, 2, Uint8Array),\n        placeholder: (x.some(y => y == null) ? 2 : null)\n    };\n}\n\nexport function jsonBuffer(obj) {\n    const str = JSON.stringify(obj);\n    const enc = new TextEncoder;\n    return enc.encode(str);\n}\n","import { DataFrame, SummarizedExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, jsonBuffer } from \"./utils.js\";\nimport { readAnnotatedMetadata, saveAnnotatedMetadata } from \"./metadata.js\";\n\n/**\n * A summarized experiment.\n * @external SummarizedExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/SummarizedExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:SummarizedExperiment SummarizedExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {?function} [options.SummarizedExperiment_readAssay=null] - How to read the assays.\n * If `null`, {@linkcode readObject} is used.\n * If a function is provided, it should accept `nrow` and `ncol` (the number of rows and columns in the SummarizedExperiment, respectively) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `nrow`\n * and [`NUMBER_OF_COLUMNS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_COLUMNS) is equal to `ncol`. \n * @param {function|boolean} [options.SummarizedExperiment_readMetadata=true] - How to read the metadata.\n * If `true`, {@linkcode readObject} is used, while if `false`, metadata will be skipped.\n * If a function is provided, it should accept `path`, `metadata`, `globals` and `options` (as described above), and return a {@link external:List List}.\n *\n * @return {external:SummarizedExperiment} The summarized experiment object.\n * @async\n */\nexport async function readSummarizedExperiment(path, metadata, globals, options = {}) {\n    let read_assay = null;\n    if (\"SummarizedExperiment_readAssay\" in options) {\n        read_assay = options.SummarizedExperiment_readAssay;\n    }\n\n    let handle_stack = [];\n    const se_options = {};\n    const assays = {};\n    const name_path = joinPath(path, \"assays/names.json\");\n    if (await globals.exists(name_path)) {\n        let names_contents = await globals.get(name_path, { asBuffer: true });\n        const dec = new TextDecoder;\n        const assay_names = JSON.parse(dec.decode(names_contents));\n\n        se_options.assayOrder = assay_names;\n        for (const [i, aname] of Object.entries(assay_names)) {\n            let assay_path = joinPath(path, \"assays\", String(i));\n            let assay_meta = await readObjectFile(assay_path, globals);\n            if (read_assay === null) {\n                assays[aname] = await readObject(assay_path, assay_meta, globals, options);\n            } else {\n                assays[aname] = await read_assay(metadata.summarized_experiment.dimensions[0], metadata.summarized_experiment.dimensions[1], assay_path, assay_meta, globals, options);\n\n            }\n        }\n    }\n\n    if (await globals.exists(joinPath(path, \"column_data/OBJECT\"))) {\n        let cd = await readObject(joinPath(path, \"column_data\"), null, globals, options);\n        se_options.columnData = cd;\n        se_options.columnNames = cd.rowNames();\n    } else if (Object.keys(assays).length == 0) {\n        se_options.columnData = new DataFrame({}, { numberOfRows: 0 });\n    }\n\n    if (await globals.exists(joinPath(path, \"row_data/OBJECT\"))) {\n        let cd = await readObject(joinPath(path, \"row_data\"), null, globals, options);\n        se_options.rowData = cd;\n        se_options.rowNames = cd.rowNames();\n    } else if (Object.keys(assays).length == 0) {\n        se_options.rowData = new DataFrame({}, { numberOfRows: 0 });\n    }\n\n    se_options.metadata = await readAnnotatedMetadata(joinPath(path, \"other_data\"), globals, options, \"SummarizedExperiment_readMetadata\")\n    return new SummarizedExperiment(assays, se_options);\n}\n\n/**\n * @param {external:SummarizedExperiment} x - The summarized experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveSummarizedExperiment(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer({\n        type: \"summarized_experiment\",\n        summarized_experiment: {\n            version: \"1.0\",\n            dimensions: [ x.numberOfRows(), x.numberOfColumns() ]\n        }\n    }));\n\n    const assay_names = x.assayNames();\n    if (assay_names.length > 0) {\n        const adir = joinPath(path, \"assays\");\n        await globals.mkdir(adir);\n        await globals.write(joinPath(adir, \"names.json\"), jsonBuffer(assay_names));\n        for (const [i, aname] of Object.entries(assay_names)) {\n            await saveObject(x.assay(aname), joinPath(adir, String(i)), globals, options);\n        }\n    }\n\n    if (x.columnData().numberOfColumns() > 0 || x.columnNames() !== null) {\n        const cd = x.columnData().setRowNames(x.columnNames());\n        await saveObject(cd, joinPath(path, \"column_data\"), globals, options);\n    }\n\n    if (x.rowData().numberOfColumns() > 0 || x.rowNames() !== null) {\n        const cd = x.rowData().setRowNames(x.rowNames());\n        await saveObject(cd, joinPath(path, \"row_data\"), globals, options);\n    }\n\n    await saveAnnotatedMetadata(x.metadata(), joinPath(path, \"other_data\"), globals, options);\n}\n","import { fetchAllGenes } from \"./fetchAllGenes.js\";\nimport { mapGenesByIdentifier } from \"./mapGenesByIdentifier.js\";\n\n/**\n * @param {string} species - Taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {Array} queries - Array of strings containing gene identifiers of some kind (e.g., Ensembl, symbol, Entrez).\n * @param {object} [options={}] - Optional parameters.\n * @param {?Array} [options.types=null] - Array of strings specifying the identifier types to use for searching.\n * The exact choice of strings depends on how the references were constructed.\n * If `null`, it defaults to an array containing `\"entrez\"`, `\"ensembl\"` and `\"symbol\"`.\n * @param {boolean} [options.ignoreCase=true] - Whether to perform case-insensitive matching.\n *\n * @return {Array} An array of length equal to `queries`.\n * Each element of the array is an array containing the **gesel** gene IDs with any identifiers that match the corresponding search string.\n * See {@linkcode fetchAllGenes} for more details on the interpretation of these IDs.\n *\n * @async\n */\nexport async function searchGenes(species, queries, { types = null, ignoreCase = true } ={}) {\n    if (types === null) {\n        types = [ \"entrez\", \"ensembl\", \"symbol\" ];\n    }\n\n    let promises = [];\n    for (const t of types) {\n        promises.push(mapGenesByIdentifier(species, t, { lowerCase: ignoreCase }));\n    }\n    let resolved = await Promise.all(promises);\n\n    let mapping = [];\n    for (var i = 0; i < queries.length; i++) {\n        let current = queries[i];\n        if (current.length == 0) {\n            mapping.push([]);\n            continue;\n        }\n\n        if (ignoreCase) {\n            current = current.toLowerCase();\n        }\n\n        let findings = [];\n        for (var j = 0; j < types.length; j++) {\n            let val = resolved[j].get(current);\n            if (typeof val !== \"undefined\") {\n                for (const v of val) {\n                    findings.push(v);\n                }\n            }\n        }\n\n        mapping.push(findings);\n    }\n\n    return mapping;\n}\n\n","import * as pako from \"pako\";\n\nexport var default_download = (base, file, start, end) => {\n    let url = base + \"/\" + file;\n    if (start == null || end == null) {\n        return fetch(url);\n    } else {\n        return fetch(url, { headers: { Range: \"bytes=\" + String(start) + \"-\" + String(end) } }); \n    }\n}\n\nvar reference_base_url = \"https://github.com/LTLA/gesel-feedstock/releases/download/indices-v0.2.2\";\n\n/**\n * Get or set the base URL for the pre-built references.\n * By default, it uses the `indices-*` release files from [the feedstock repository](https://github.com/LTLA/gesel-feedstock).\n * Setters should call this function before calling any **gesel** functions that might fetch resources.\n *\n * @param {string} [url] - Base URL to use for the prebuilt references.\n *\n * @return {string} If `url` is not supplied, the current base URL is returned.\n *\n * If `url` is supplied, it is set as the base URL, and the previous base URL is returned.\n */\nexport function referenceBaseUrl(url) {\n    if (typeof url == \"undefined\") {\n        return reference_base_url;\n    } else {\n        let old = reference_base_url;\n        reference_base_url == url;\n        return old;\n    }\n}\n\nexport var reference_download = (file, start = null, end = null) => default_download(reference_base_url, file, start, end);\n\n/**\n * Get or set the global download function to fetch pre-built references.\n * By default, it uses the global `fetch` in browsers and later versions of Node.js.\n * Applications may specify a different function, e.g., to handle authentication or caching; \n * this should be done before calling any other **gesel** functions that might fetch resources.\n *\n * @param {function} [fun] - Function that performs a GET request to an index file, returning a Response object containing the file contents.\n * This accepts three arguments:\n *\n * - The base name of the pre-built index file of interest (e.g., `\"10090_collections.tsv.gz\"`).\n * - The starting byte of the request.\n * - The ending byte of the request.\n *\n * If all three arguments are specified, the function should perform a HTTP range request to obtain the specified range of bytes.\n * If only the first argument is supplied, the function should download the entire file.\n *\n * @return {function} If `fun` is not supplied, the current global downloader is returned.\n *\n * If `fun` is supplied, it is used to set the global downloader, and the previous global value of the function is returned.\n */\nexport function referenceDownload(fun) {\n    let prev = reference_download;\n    if (typeof fun !== \"undefined\") {\n        reference_download = fun;\n    }\n    return prev;\n}\n\n// For back-compatibility.\nexport function setReferenceDownload(fun) {\n    return referenceDownload(fun);\n}\n\nvar gene_base_url = \"https://github.com/LTLA/gesel-feedstock/releases/download/genes-v1.0.0\";\n\n/**\n * Get or set the base URL for the gene information.\n * By default, it uses the `genes-*` release files from [the feedstock repository](https://github.com/LTLA/gesel-feedstock).\n * Setters should call this function before calling any other **gesel** functions that might fetch resources.\n *\n * @param {string} [url] - Base URL to use for the gene informatin.\n *\n * @return {string} If `url` is not supplied, the current base URL is returned.\n *\n * If `url` is supplied, it is set as the base URL, and the previous base URL is returned.\n */\nexport function geneBaseUrl(url) {\n    if (typeof url == \"undefined\") {\n        return gene_base_url;\n    } else {\n        let old = gene_base_url;\n        gene_base_url == url;\n        return old;\n    }\n}\n\nexport var gene_download = (file) => default_download(gene_base_url, file, null, null);\n\n/**\n * Set the global download function to fetch gene information.\n * By default, it uses the global `fetch` in browsers and later versions of Node.js.\n * Applications may specify a different function, e.g., to handle authentication or caching; \n * this should be done before calling any other **gesel** functions that might fetch resources.\n *\n * @param {function} [fun] - Function that performs a GET request to an index file, returning a Response object containing the file contents.\n * This should accept the base name of the pre-built index file of interest (e.g., `\"9606_symbol.tsv.gz\"`).\n *\n * @return {function} If `fun` is not supplied, the current global downloader is returned.\n *\n * If `fun` is supplied, it is used to set the global downloader, and the previous global value of the function is returned.\n */\nexport function geneDownload(fun) {\n    let prev = gene_download;\n    if (typeof fun !== \"undefined\") {\n        gene_download = fun;\n    }\n    return prev;\n}\n\n// For back-compatibility.\nexport function setGeneDownload(fun) {\n    return geneDownload(fun);\n}\n\nexport function decompressLines(buffer) {\n    var contents = pako.inflate(new Uint8Array(buffer));\n    const txt = new TextDecoder();\n    var lines = txt.decode(contents).split(\"\\n\");\n\n    if (lines[lines.length - 1] == \"\") {\n        return lines.slice(0, lines.length - 1); // remove empty string at trailing newline.\n    } else {\n        return lines;\n    }\n}\n\nexport async function retrieveRanges(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lengths = decompressLines(buffer);\n\n    var ranges = [0];\n    for (var i = 0; i < lengths.length; i++) { \n        ranges.push(ranges[i] + Number(lengths[i]) + 1);\n    }\n    return ranges;\n}\n\nexport async function retrieveNamedRanges(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lines = decompressLines(buffer);\n\n    var last = 0;\n    var ranges = new Map; \n    var order = [];\n    for (var i = 0; i < lines.length; i++) { \n        let split = lines[i].split(\"\\t\");\n        let next = last + Number(split[1]) + 1; // +1 for the newline.\n        ranges.set(split[0], [last, next]);\n        order.push(split[0]);\n        last = next;\n    }\n\n    return { ranges, order };\n}\n\nexport async function retrieveRangesWithExtras(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lines = decompressLines(buffer);\n\n    var ranges = [0];\n    var extra = [];\n    for (var i = 0; i < lines.length; i++) {\n        let split = lines[i].split(\"\\t\");\n        ranges.push(ranges[i] + Number(split[0]) + 1); // +1 for the newline.\n        extra.push(Number(split[1]));\n    }\n\n    return { ranges, extra };\n}\n\nexport function retrieveBytesByIndex(resource, ranges, index) {\n    var start = ranges[index];\n    var end = ranges[index + 1];\n    return retrieveBytes(resource, start, end);\n}\n\nexport async function retrieveBytes(resource, start, end) {\n    end--; // ignore the newline.\n\n    var res = await reference_download(resource, start, end);\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var txt = await res.text();\n    return txt.slice(0, end - start); // make sure we limit it to the requested length.\n}\n\nexport function convertToUint32Array(txt) { // Building back the indices from the diffs.\n    var output = [];\n\n    if (txt !== \"\") {\n        var last = 0;\n        txt.split(\"\\t\").forEach(x => {\n            var y = Number(x) + last;\n            output.push(y);\n            last = y;\n        });\n    }\n\n    return new Uint32Array(output);\n}\n\n/**\n * @param {Array} arrays - Array of arrays over which to compute the intersection.\n * @return {Array} Intersection of all arrays in `arrays`.\n */\nexport function intersect(arrays) {\n    if (arrays.length == 0) {\n        return [];\n    } else if (arrays.length == 1) {\n        return arrays[0];\n    }\n\n    let ref = new Set(arrays[0]);\n    for (var i = 1; i < arrays.length; i++) {\n        let running = new Set;\n        for (const x of arrays[i]) {\n            if (ref.has(x)) {\n                running.add(x);\n            }\n        }\n        ref = running;\n    }\n\n    return Array.from(ref);\n}\n\nasync function fetch_sizes_internal(species, _sizes, full, initialize, funSizes, funFound) {\n    let sizes = _sizes.get(species);\n    if (typeof sizes == \"undefined\") {\n        let found = await full(species, { download: false });\n\n        if (found !== null) {\n            // Pulling it from the full info instead, if we already got it.\n            return funFound(found);\n        }\n\n        await initialize(species);\n        sizes = _sizes.get(species);\n    }\n\n    return funSizes(sizes);\n}\n\nexport function fetchSizes(species, _sizes, full, initialize) {\n    return fetch_sizes_internal(\n        species, \n        _sizes, \n        full, \n        initialize, \n        x => x, \n        y => {\n            let tmp_sizes = [];\n            for (const x of y) {\n                tmp_sizes.push(x.size);\n            }\n            _sizes.set(species, tmp_sizes);\n            return tmp_sizes;\n        }\n    );\n}\n\nexport function fetchNumber(species, _sizes, full, initialize) {\n    return fetch_sizes_internal(\n        species,\n        _sizes,\n        full,\n        initialize,\n        x => x.length,\n        x => x.length\n    );\n}\n","import * as bioc from \"bioconductor\";\nimport * as df from \"./DataFrame.js\";\nimport { MockSparseMatrix, MockNormalizedMatrix } from \"./assays.js\";\nimport { MockReducedDimensionMatrix } from \"./reducedDimensions.js\";\n\nexport async function formatSingleCellExperiment(state, { reportOneIndex = false, storeModalityColumnData = false } = {}) {\n    let all_rowdata = state.inputs.fetchFeatureAnnotations();\n    let modalities = Object.keys(all_rowdata);\n    let main = \"RNA\";\n    if (!(main in all_rowdata)) {\n        main = modalities[0];\n    }\n\n    let all_metadata = {};\n    for (const m of modalities) {\n        all_metadata[m] = new bioc.List;\n    }\n\n    let all_coldata = df.formatColumnData(\n        state,\n        modalities,\n        main,\n        all_metadata,\n        storeModalityColumnData\n    );\n\n    // Setting up the SEs.\n    let all_se = {}\n    for (const m of modalities) {\n        let mat = state.cell_filtering.fetchFilteredMatrix().get(m);\n        let assays = { counts: new MockSparseMatrix(mat) };\n        let reddim = {}; \n        let metadata;\n        if (m in all_metadata) {\n            metadata = all_metadata[m];\n        } else {\n            metadata = new bioc.List;\n        }\n\n        let step = null;\n        switch (m) {\n            case \"RNA\":\n                step = state.rna_normalization;\n                break;\n            case \"ADT\":\n                step = state.adt_normalization;\n                break;\n            case \"CRISPR\":\n                step = state.crispr_normalization;\n                break;\n        }\n        if (step !== null) {\n            let sf = step.fetchSizeFactors();\n            assays.logcounts = new MockNormalizedMatrix(mat, sf);\n        }\n\n        step = null;\n        switch (m) {\n            case \"RNA\":\n                step = state.rna_pca;\n                break;\n            case \"ADT\":\n                step = state.adt_pca;\n                break;\n            case \"CRISPR\":\n                step = state.crispr_pca;\n                break;\n        }\n        if (step !== null) {\n            let pcs = step.fetchPCs();\n            reddim.pca = new MockReducedDimensionMatrix(pcs.numberOfCells(), pcs.numberOfPCs(), pcs.principalComponents({ copy: \"view\" }));\n            let tv = pcs.totalVariance();\n            metadata.set(\"pca\", { variance_explained: pcs.varianceExplained({ copy: \"view\" }).map(x => x / tv) }, { inPlace: true });\n        }\n\n        all_se[m] = new bioc.SingleCellExperiment(\n            assays,\n            {\n                rowData: all_rowdata[m],\n                rowNames: all_rowdata[m].rowNames(),\n                columnData: all_coldata[m],\n                columnNames: all_coldata[m].rowNames(),\n                metadata: metadata,\n                reducedDimensions: reddim\n            }\n        );\n    }\n\n    // Saving the dimensionality reduction results.\n    for (const name of [ \"tsne\", \"umap\" ]) {\n        let res = await state[name].fetchResults({ copy: false });\n        let payload = new Float64Array(res.x.length * 2);\n        payload.set(res.x);\n        payload.set(res.y, res.x.length);\n        all_se[main].setReducedDimension(name, new MockReducedDimensionMatrix(res.x.length, 2, payload), { inPlace: true });\n    }\n\n    // Saving extra metadata.\n    {\n        let customs = state.custom_selections.fetchSelections({ copy: true, force: \"Int32Array\" });\n        if (reportOneIndex) {\n            for (const [k, v] of Object.entries(customs)) { // incrementing by 1, if requested.\n                v.forEach((x, i) => { v[i] = x + 1; });\n            }\n        }\n        let meta = all_se[main].metadata();\n        meta.set(\"custom_selections\", customs, { inPlace: true });\n        all_se[main].setMetadata(meta, { inPlace: true });\n    }\n\n    let main_se = all_se[main];\n    for (const mod of modalities) {\n        if (mod !== main) {\n            main_se.setAlternativeExperiment(mod, all_se[mod], { inPlace: true });\n        }\n    }\n\n    return main_se;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as gesel from \"gesel\";\n\nimport * as utils from \"./utils/general.js\";\nimport * as mutils from \"./utils/markers.js\";\nimport * as rutils from \"../readers/index.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\nimport * as markers_module from \"./marker_detection.js\";\n\nexport const step_name = \"feature_set_enrichment\";\n\n/********************************************\n ******** Internals for collections *********\n ********************************************/\n\nclass FeatureSetManager {\n    #cache;\n\n    constructor() {\n        this.#cache = {};\n    }\n\n    free() {\n        utils.freeCache(this.#cache.set_buffer);\n        this.#cache = {};\n    }\n\n    static flush() {\n        // TODO: call a gesel flush() function.\n        return;\n    }\n\n    static setDownload(fun) {\n        console.warn(\"'FeatureSetState.setDownload' is a no-op, uses 'gesel.setReferenceDownload' and 'gesel.setGeneDownload' instead\");\n        return;\n    }\n\n    async #prepare(feats, species, gene_id_column, gene_id_type) {\n        let data_id_col;\n        if (gene_id_column == null) {\n            data_id_col = feats.rowNames();\n            if (data_id_col == null) {\n                // If there truly is no annotation, then we avoid throwing,\n                // and we just make the rest of this function a no-op.\n                species = []; \n            }\n        } else {\n            data_id_col = feats.column(gene_id_column);\n        }\n\n        let search_options = { types: [ gene_id_type.toLowerCase() ] };\n\n        // To avoid repeated rellocations on array resizing, we create\n        // preallocated arrays within each species and then do a single COMBINE\n        // across species. We provide an initial element so that COMBINE works\n        // correctly when there are no species.\n        let collection_offset = 0;\n        let all_collection_names = [[]];\n        let all_collection_descriptions = [[]];\n        let all_collection_species = [[]];\n\n        let set_offset = 0;\n        let all_set_names = [[]];\n        let all_set_descriptions = [[]];\n        let all_set_indices = [[]];\n        let all_set_sizes = [new Int32Array];\n        let all_set_collections = [new Int32Array];\n\n        let mapped_genes = new Set;\n        let remapped = new Array(feats.numberOfRows());\n        for (var r = 0; r < remapped.length; r++) {\n            remapped[r] = [];\n        }\n\n        for (const spec of species) {\n            // Mapping our features to those in the gesel database. \n            let gene_mapping = await gesel.searchGenes(spec, data_id_col, search_options);\n            for (var i = 0; i < gene_mapping.length; i++) {\n                if (gene_mapping[i].length > 0) {\n                    mapped_genes.add(i);\n                }\n            }\n\n            // Formatting the details for each set. This includes reindexing\n            // the gesel gene IDs to refer to row indices of 'feats'.\n            let all_sets2genes = await gesel.fetchGenesForAllSets(spec);\n            let set_indices = gesel.reindexGenesForAllSets(gene_mapping, all_sets2genes);\n\n            let all_sets = await gesel.fetchAllSets(spec);\n            let nsets = all_sets.length;\n            let set_names = new Array(nsets);\n            let set_descriptions = new Array(nsets);\n            let set_sizes = new Int32Array(nsets);\n            let set_collections = new Int32Array(nsets);\n\n            for (var i = 0; i < nsets; i++) {\n                let current = all_sets[i];\n                set_names[i] = current.name;\n                set_descriptions[i] = current.description;\n                set_collections[i] = current.collection + collection_offset; // offset effectively \"namespaces\" collections from different species.\n                set_sizes[i] = set_indices[i].length;\n            }\n\n            all_set_names.push(set_names);\n            all_set_descriptions.push(set_descriptions);\n            all_set_indices.push(set_indices);\n            all_set_sizes.push(set_sizes);\n            all_set_collections.push(set_collections);\n\n            // Updating the gene->set mapping for input features.\n            let all_genes2sets = await gesel.fetchSetsForAllGenes(spec);\n            let current_remapped = gesel.reindexSetsForAllGenes(gene_mapping, all_genes2sets);\n            for (var i = 0; i < gene_mapping.length; i++) {\n                let current = current_remapped[i];\n                for (var j = 0; j < current.length; j++) {\n                    current[j] += set_offset; // offset effectively \"namespaces\" sets from different species.\n                }\n                remapped[i].push(current);\n            }\n\n            // Sticking the collection details somewhere.\n            let all_collections = await gesel.fetchAllCollections(spec);\n            let ncollections = all_collections.length;\n            let collection_names = new Array(ncollections);\n            let collection_descriptions = new Array(ncollections);\n            let collection_species = new Array(ncollections);\n\n            for (var i = 0; i < ncollections; i++) {\n                collection_names[i] = all_collections[i].title;\n                collection_descriptions[i] = all_collections[i].description;\n                collection_species[i] = spec;\n            }\n\n            all_collection_names.push(collection_names);\n            all_collection_descriptions.push(collection_descriptions);\n            all_collection_species.push(collection_species);\n\n            set_offset += nsets;\n            collection_offset += ncollections;\n        }\n\n        this.#cache.universe = (new Int32Array(mapped_genes)).sort();\n\n        this.#cache.sets = {\n            names: bioc.COMBINE(all_set_names),\n            descriptions: bioc.COMBINE(all_set_descriptions),\n            sets: bioc.COMBINE(all_set_indices),\n            sizes: bioc.COMBINE(all_set_sizes),\n            collections: bioc.COMBINE(all_set_collections)\n        };\n\n        this.#cache.collections = {\n            names: bioc.COMBINE(all_collection_names),\n            descriptions: bioc.COMBINE(all_collection_descriptions),\n            species: bioc.COMBINE(all_collection_species)\n        };\n\n        if (species.length > 0) {\n            for (var r = 0; r < remapped.length; r++) {\n                remapped[r] = bioc.COMBINE(remapped[r]);\n            }\n        } else {\n            for (var r = 0; r < remapped.length; r++) {\n                remapped[r] = new Uint32Array;\n            }\n        }\n        this.#cache.mapping_to_sets = remapped;\n\n        return;\n    }\n\n    async buildCollections(old_parameters, guess_ids, species, gene_id_column, gene_id_type, annofun, guessfun) {\n        if (\n            guess_ids !== old_parameters.guess_ids ||\n            (\n                !guess_ids && \n                (\n                    old_parameters.gene_id_column !== gene_id_column || \n                    old_parameters.gene_id_type !== gene_id_type ||\n                    utils.changedParameters(old_parameters.species, species)\n                )\n            )\n        ) {\n            let gene_id_column2 = gene_id_column;\n            let gene_id_type2 = gene_id_type;\n            let species2 = species;\n\n            if (guess_ids) {\n                let auto = configure_feature_parameters(guessfun());\n                gene_id_column2 = auto.gene_id_column;\n                gene_id_type2 = auto.gene_id_type;\n                species2 = auto.species;\n            }\n\n            await this.#prepare(annofun(), species2, gene_id_column2, gene_id_type2);\n            return true;\n        }\n\n        return false;\n    }\n\n    fetchCollectionDetails() {\n        return this.#cache.collections;\n    }\n\n    fetchSetDetails() {\n        return { \n            names: this.#cache.sets.names,\n            descriptions: this.#cache.sets.descriptions,\n            sizes: this.#cache.sets.sizes,\n            collections: this.#cache.sets.collections\n        };\n    }\n\n    fetchUniverseSize() {\n        return this.#cache.universe.length;\n    }\n\n    computeEnrichment(group, effect_size, summary, markers, top_markers) {\n        // Renaming things for back-compatibility.\n        if (effect_size == \"delta_detected\") {\n            effect_size = \"deltaDetected\";\n        } else if (effect_size == \"cohen\") {\n            effect_size = \"cohensD\";\n        } else if (effect_size == \"lfc\") {\n            effect_size = \"deltaDetected\";\n        }\n        if (summary == \"min_rank\") {\n            summary = \"min-rank\";\n        }\n\n        let use_largest = true;\n        let min_threshold = null;\n        if (summary == \"min-rank\") {\n            use_largest = false;\n        } else {\n            min_threshold = (effect_size == \"auc\" ? 0.5 : 0);\n        }\n\n        let stats = markers[effect_size](group, { summary: summary, copy: false });\n        let in_set = scran.chooseTopMarkers(\n            bioc.SLICE(stats, this.#cache.universe),\n            top_markers,\n            {\n                useLargest: use_largest,\n                threshold: min_threshold\n            }\n        );\n        in_set.forEach((x, i) => {\n            let gene = this.#cache.universe[x];\n            in_set[i] = this.#cache.mapping_to_sets[gene];\n        });\n\n        let overlaps = gesel.countSetOverlaps(in_set);\n        let set_ids = new Int32Array(overlaps.length);\n        let counts = new Int32Array(overlaps.length);\n        let sizes = new Int32Array(overlaps.length);\n        let indices = new Int32Array(overlaps.length);\n        for (var i = 0; i < overlaps.length; i++) {\n            indices[i] = i;\n            let x = overlaps[i];\n            set_ids[i] = x.id;\n            counts[i] = x.count;\n            sizes[i] = this.#cache.sets.sizes[x.id];\n        }\n\n        let num_top = in_set.length;\n        let pvalues = scran.hypergeometricTest(counts, num_top, sizes, this.#cache.universe.length);\n        indices.sort((a, b) => pvalues[a] - pvalues[b]); // Sorting by p-value.\n        return {\n            set_ids: bioc.SLICE(set_ids, indices),\n            counts: bioc.SLICE(counts, indices),\n            pvalues: bioc.SLICE(pvalues, indices),\n            num_markers: num_top\n        };\n    }\n\n    fetchFeatureSetIndices(set_id) {\n        return this.#cache.sets.sets[set_id];\n    }\n\n    computePerCellScores(set_id, normalized, block) {\n        let indices = this.fetchFeatureSetIndices(set_id);\n        // console.log(bioc.SLICE(this.#inputs.fetchFeatureAnnotations().RNA.column(\"id\"), indices));\n\n        let features = utils.allocateCachedArray(normalized.numberOfRows(), \"Uint8Array\", this.#cache, \"set_buffer\");\n        features.fill(0);\n        let farr = features.array();\n        indices.forEach(x => { farr[x] = 1; }); \n\n        return scran.scoreGsdecon(normalized, features, { block: block });\n    }\n}\n\n/*******************************************\n ******** Internals for parameters *********\n *******************************************/\n\nfunction all_defaults() {\n    return {\n        skip: false,\n        guess_ids: true,\n        species: [],\n        gene_id_column: null, \n        gene_id_type: \"ENSEMBL\", \n        top_markers: 100\n    };\n}\n\nfunction configure_feature_parameters(guesses) {\n    let best_key = null;\n    let best = { type: \"symbol\", species: \"9606\", confidence: 0 };\n\n    if (\"row_names\" in guesses) {\n        let val = guesses.row_names;\n        if (val.confidence > best.confidence) {\n            best = val;\n        }\n    }\n\n    for (const [key, val] of Object.entries(guesses.columns)) {\n        if (val.confidence > best.confidence) {\n            best = val;\n            best_key = key;\n        }\n    }\n\n    return {\n        gene_id_column: best_key,\n        gene_id_type: best.type.toUpperCase(),\n        species: [best.species]\n    };\n}\n\nfunction dereference_parameters(parameters) {\n    parameters.species = bioc.CLONE(parameters.species); // make a copy to avoid pass-by-ref behavior.\n    return parameters;\n}\n\nfunction fetch_parameters(parameters) {\n    // Avoid pass-by-reference behavior.\n    let out = { ...parameters };\n    out.species = bioc.CLONE(out.species);\n    return out;\n}\n\n/************************\n ******** State *********\n ************************/\n\n/**\n * This step tests for enrichment of particular feature sets in the set of top marker genes,\n * based on marker rankings from {@linkplain MarkerDetectionState}.\n * It wraps the [`testFeatureSetEnrichment`](https://kanaverse.github.io/scran.js/global.html#testFeatureSetEnrichment) \n * and [`scoreGsdecon`](https://kanaverse.github.io/scran.js/global.html#scoreGsdecon) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * This class uses the [**gesel**](https://npmjs.org/package/gesel) package to download the default gene set databases for the relevant organisms.\n * Its behavior can be tuned by setting global **gesel** variables, e.g., using the [`referenceDownload`](https://ltla.github.io/gesel/global.html#referenceDownload) function.\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class FeatureSetEnrichmentState {\n    #inputs;\n    #filter;\n    #normalized;\n\n    #parameters;\n    #manager;\n\n    constructor(inputs, filter, normalized, markers, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(normalized instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'normalized' should be a RnaNormalizationState object from './rna_normalization.js'\");\n        }\n        this.#normalized = normalized;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#manager = new FeatureSetManager;\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        this.#manager.free();\n        return; \n    }\n\n    valid() {\n        let mat = this.#inputs.fetchCountMatrix();\n        return mat.has(\"RNA\");\n    }\n\n    /**\n     * Obtain the details about the feature set collections in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {object} Object with the following properties:\n     *\n     * - `names`: Array of strings of length equal to the number of feature set collections, containing the names of the collections.\n     * - `descriptions`: Array of strings of length equal to `names`, containing the descriptions for all collections.\n     * - `species`: Array of strings of length equal to `names`, containing the taxonomy IDs for all collections.\n     */\n    fetchCollectionDetails() {\n        return this.#manager.fetchCollectionDetails();\n    }\n\n    /**\n     * Obtain the details about the feature sets in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {object} Object with the following properties:\n     *\n     * - `names`: Array of strings of length equal to the number of feature sets across all collections, containing the names of those sets.\n     * - `descriptions`: Array of strings of length equal to `names`, containing the set descriptions.\n     * - `sizes`: Int32Array of length equal to `names`, containing the set sizes.\n     *   Each set's size is defined as the number of features in the dataset that are successfully mapped to a member of the set.\n     * - `collections`: Int32Array of length equal to `names`, specifying the collection to which the set belongs.\n     *   This is interpreted as the index of the arrays in {@linkcode fetchCollectionDetails}.\n     */\n    fetchSetDetails() {\n        return this.#manager.fetchSetDetails();\n    }\n\n    /**\n     * Obtain the size of the universe of features that were successfully mapped to features in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {number} Number of features from the input dataset that were successfully mapped to at least one gene in the reference database.\n     */\n    fetchUniverseSize() {\n        return this.#manager.fetchUniverseSize();\n    }\n\n    /**\n     * Compute enrichment of top markers in each feature set.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {external:ScoreMarkersResults} markers - Arbitrary marker detection results for an RNA modality, with the same order and identity of genes as from the upstream {@linkplain InputsState}.\n     * This is most typically the output from {@linkcode MarkerDetectionState#fetchResults MarkerDetectionState.fetchResults} or equivalents from {@linkplain CustomSelectionsState}.\n     * @param {number} group - Index of the group of interest inside `markers`.\n     * @param {string} effect_size - Effect size to use for ranking.\n     * This should be one of `\"cohen\"`, `\"auc\"`, `\"lfc\"` or `\"delta_detected\"`.\n     * @param {string} summary - Summary statistic to use for ranking.\n     * This should be one of `\"min\"`, `\"mean\"` or `\"min_rank\"`.\n     *\n     * @return {object} Object containing the following properties:\n     *\n     * - `set_ids`: Int32Array of length equal to the number of sets, containing the set IDs.\n     *   Each entry is an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     * - `counts`: Int32Array of length equal to `set_ids`, containing the number of markers present in each set.\n     * - `pvalues`: Float64Array of length equal to `counts`, containing the enrichment p-values for each set.\n     * - `num_markers`: number of markers selected for testing.\n     *\n     * Sets are guaranteed to be sorted by increasing p-value in `pvalues`.\n     */\n    computeEnrichment(markers, group, effect_size, summary) {\n        return this.#manager.computeEnrichment(group, effect_size, summary, markers, this.#parameters.top_markers);\n    }\n\n    /**\n     * Extract row indices of the members of a desired feature set of interest.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Int32Array} Array containing the row indices of the RNA count matrix corresponding to the genes in the specified set.\n     */\n    fetchFeatureSetIndices(set_id) {\n        return this.#manager.fetchFeatureSetIndices(set_id);\n    }\n\n    /**\n     * Compute per-cell scores for the activity of a feature set.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Object} Object containing:\n     *\n     * - `indices`: Int32Array containing the row indices of the genes in the set, relative to the RNA count matrix.\n     * - `weights`: Float64Array containing the weights of each gene in the set.\n     * - `scores`: Float64Array containing the feature set score for each cell.\n     */\n    computePerCellScores(set_id) {\n        return this.#manager.computePerCellScores(set_id, this.#normalized.fetchNormalizedMatrix(), this.#filter.fetchFilteredBlock());\n    }\n\n    // Soft-deprecated.\n    fetchPerCellScores(collection, set_index) {\n        return this.computePerCellScores(collection, set_index);\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    static flush() {\n        return;\n    }\n\n    static setDownload(fun) {\n        return FeatureSetManager.setDownload(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellFilteringState#compute compute} for details.\n     */\n    static defaults() {\n        return all_defaults();\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `feature_set_enrichment` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.skip - Whether to skip the preparation of feature set collections.\n     * If `true`, none of the other methods (e.g., {@linkcode FeatureSetEnrichmentState#computeEnrichment computeEnrichment},\n     * {@linkcode FeatureSetEnrichmentState#computePerCellScores computePerCellScores}) should be called.\n     * @param {boolean} parameters.guess_ids - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column`, `gene_id_type`.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) supported by **gesel**.\n     * This is used internally to filter `collections` to the entries relevant to these species. \n     * Ignored if `guess_ids = true`.\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the RNA entry of\n     * {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `guess_ids = true`.\n     * @param {string} parameters.gene_id_type - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `guess_ids = true`.\n     * @param {number} parameters.top_markers - Number of top markers to use when testing for enrichment.\n     *\n     * @return The state is updated with new results.\n     */\n    async compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, FeatureSetEnrichmentState.defaults());\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            this.changed = true;\n        }\n        if (parameters.skip !== this.#parameters.skip) {\n            this.changed = true;\n        }\n\n        if (this.valid() && !parameters.skip) {\n            if (this.changed) { // Force an update.\n                this.#parameters = {};\n            }\n\n            let modified = await this.#manager.buildCollections(\n                this.#parameters, \n                parameters.guess_ids, \n                parameters.species, \n                parameters.gene_id_column, \n                parameters.gene_id_type, \n                () => this.#inputs.fetchFeatureAnnotations()[\"RNA\"],\n                () => this.#inputs.guessRnaFeatureTypes()\n            );\n            if (modified) {\n                this.changed = true;\n            }\n\n            if (parameters.top_markers !== this.#parameters.top_markers) {\n                this.changed = true;\n            }\n        }\n\n        this.#parameters = dereference_parameters(parameters);\n        return;\n    }\n}\n\n/*****************************\n ******** Standalone *********\n *****************************/\n\n/**\n * Standalone version of {@linkplain FeatureSetEnrichmentState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own annotations to prepare the collections for enrichment calculations.\n * Users should await on the return value of the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method after construction.\n * Once resolved, other methods in this class may be used.\n *\n * This class uses the [**gesel**](https://npmjs.org/package/gesel) package to download the default gene set databases for the relevant organisms.\n * Its behavior can be tuned by setting global **gesel** variables, e.g., using the [`referenceDownload`](https://ltla.github.io/gesel/global.html#referenceDownload) function.\n */\nexport class FeatureSetEnrichmentStandalone {\n    #annotations;\n    #guesses;\n\n    #normalized;\n    #block;\n    #backmap;\n\n    #pre_parameters;\n    #parameters;\n    #manager;\n\n    /**\n     * @param {external:DataFrame} annotations - A {@linkplain external:DataFrame DataFrame} of per-gene annotations, where each row corresponds to a gene.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(external:ScranMatrix)} [options.normalized=null] - A {@linkcode external:ScranMatrix ScranMatrix} of log-normalized expression values,\n     * to be used in {@linkcode FeatureSetEnrichmentStandalone#computePerCellScores FeatureSetEnrichmentStandalone.computePerCellScores}.\n     * Each row corresponds to a gene in the same order as `annotations`. \n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in `normalized`, containing the block assignments for each column. \n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(annotations, { normalized = null, block = null } = {}) {\n        this.#annotations = annotations;\n        this.#guesses = null;\n\n        this.#normalized = null;\n        this.#block = null;\n        this.#backmap = null;\n\n        if (normalized !== null) {\n            if (normalized.numberOfRows() !== this.#annotations.numberOfRows()) {\n                throw new Error(\"number of rows of 'annotations' and 'normalized' should be identical\");\n            }\n\n            if (block !== null) {\n                if (normalized.numberOfColumns() !== block.length) {\n                    throw new Error(\"number of columns of 'normalized' should equal the length of 'block'\");\n                }\n\n                let dump = utils.subsetInvalidFactors([ block ]);\n                if (dump.retain !== null) {\n                    this.#normalized = scran.subsetColumns(normalized, dump.retain);\n                    this.#backmap = dump.retain;\n                } else {\n                    this.#normalized = normalized.clone();\n                }\n\n                this.#block = dump.arrays[0].ids;\n            } else {\n                this.#normalized = normalized.clone();\n            }\n        }\n\n        this.#pre_parameters = FeatureSetEnrichmentStandalone.defaults();\n        this.#parameters = {};\n        this.#manager = new FeatureSetManager; \n    }\n\n    #guessFeatureTypes() {\n        if (this.#guesses == null) {\n            this.#guesses = utils.guessFeatureTypes(this.#annotations);\n        }\n        return this.#guesses;\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#normalized;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#block);\n        scran.free(this.#normalized);\n        this.#manager.free();\n        return; // nothing extra to free here.\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode FeatureSetEnrichmentStandalone#setParameters setParameters} for details.\n     */\n    static defaults() {\n        return all_defaults();\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode FeatureSetEnrichmentStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see {@linkcode FeatureSetEnrichmentState#compute FeatureSetEnrichmentState.compute} for details.\n     *\n     * @return The object is updated with new parameters.\n     * Note that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method should be called in order for the new parameters to take effect.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, FeatureSetEnrichmentStandalone.defaults(), [\"automatic\"]);\n\n        // For some back-compatibility.\n        if (typeof parameters.guess_ids == \"undefined\") {\n            parameters.guess_ids = parameters.automatic;\n        }\n\n        this.#pre_parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * This should be called after construction and/or {@linkcode FeatureSetEnrichmentStandalone#setParameters setParameters}. \n     * Users should wait for the return value to resolve before calling any other methods of this class.\n     * \n     * @return Feature set collections are loaded into memory. \n     * @async\n     */\n    async ready() {\n        let { guess_ids, species, gene_id_column, gene_id_type, top_markers } = this.#pre_parameters;\n\n        // For some back-compatibility.\n        if (typeof guess_ids == \"undefined\") {\n            guess_ids = parameters.automatic;\n        }\n\n        await this.#manager.buildCollections(\n            this.#parameters,\n            guess_ids, \n            species, \n            gene_id_column, \n            gene_id_type, \n            () => this.#annotations,\n            () => this.#guessFeatureTypes()\n        );\n\n        this.#parameters = this.#pre_parameters;\n    }\n\n    /**\n     * Obtain the details about the feature set collections in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {object} Object containing the details about the available feature set collections,\n     * see {@linkcode FeatureSetEnrichmentState#fetchCollectionDetails FeatureSetEnrichmentState.fetchCollectionDetails} for more details.\n     */\n    fetchCollectionDetails() {\n        return this.#manager.fetchCollectionDetails();\n    }\n\n    /**\n     * Obtain the details about the feature sets in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {object} Object containing the details about the available feature sets,\n     * see {@linkcode FeatureSetEnrichmentState#fetchSetDetails FeatureSetEnrichmentState.fetchSetDetails} for more details.\n     */\n    fetchSetDetails() {\n        return this.#manager.fetchSetDetails();\n    }\n\n    /**\n     * Obtain the size of the universe of features that were successfully mapped to features in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {number} Number of features from the input dataset that were successfully mapped to at least one gene in the reference database.\n     */\n    fetchUniverseSize() {\n        return this.#manager.fetchUniverseSize();\n    }\n\n    /**\n     * Compute enrichment of top markers in each feature set.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {external:ScoreMarkersResults} markers - Marker detection results for an RNA modality.\n     * @param {number} group - Group index of interest.\n     * @param {string} effect_size - Effect size to use for ranking.\n     * This should be one of `\"cohen\"`, `\"auc\"`, `\"lfc\"` or `\"delta_detected\"`.\n     * @param {string} summary - Summary statistic to use for ranking.\n     * This should be one of `\"min\"`, `\"mean\"` or `\"min_rank\"`.\n     *\n     * @return {object} Object containing statistics for the enrichment of the top marker genes in each feature set.\n     * See {@linkcode FeatureSetEnrichmentState#computeEnrichment FeatureSetEnrichmentState.computeEnrichment} for more details.\n     */\n    computeEnrichment(markers, group, effect_size, summary) {\n        return this.#manager.computeEnrichment(group, effect_size, summary, markers, this.#parameters.top_markers);\n    }\n\n    /**\n     * Extract row indices of the members of a desired feature set of interest.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentStandalone#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Int32Array} Array containing the row indices of the RNA count matrix corresponding to the genes in the specified set.\n     */\n    fetchFeatureSetIndices(set_id) {\n        return this.#manager.fetchFeatureSetIndices(set_id);\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#pre_parameters);\n    }\n\n    /**\n     * Compute per-cell scores for the activity of a feature set.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentStandalone#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Object} Object containing the per-cell scores for the feature set activity.\n     * See {@linkcode FeatureSetEnrichmentState#computePerCellScores FeatureSetEnrichmentState.computePerCellScores} for more details.\n     */\n    computePerCellScores(set_id) {\n        if (this.#normalized == null) {\n            throw new Error(\"no normalized matrix supplied in constructor\");\n        }\n\n        let output = this.#manager.computePerCellScores(set_id, this.#normalized, this.#block);\n\n        if (this.#backmap !== null) {\n            let backfilled = new Float64Array(output.scores.length);\n            backfilled.fill(Number.NaN);\n            this.#backmap.forEach((x, i) => {\n                backfilled[x] = output.scores[i];\n            });\n            output.scores = backfilled;\n        }\n\n        return output;\n    }\n}\n","import { DataFrame, List, IntegerList, NumberList, BooleanList, StringList } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, formatNumberArrayForHdf5, formatIntegerArrayForHdf5, formatStringArrayForHdf5, formatBooleanArrayForHdf5, jsonBuffer } from \"./utils.js\";\nimport { readAnnotatedMetadata, saveAnnotatedMetadata } from \"./metadata.js\";\n\n/**\n * A data frame of columnar data.\n * @external DataFrame\n * @see {@link https://ltla.github.io/bioconductor.js/DataFrame.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:DataFrame DataFrame}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function|boolean} [options.DataFrame_readNested=true] - How to read columns containing nested objects.\n * If `true`, {@linkcode readObject} is used, while if `false`, nested objects will be skipped.\n * If a function is provided, it should accept `nrow` (the number of rows in the data frame) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `nrow`. \n * @param {function|boolean} [options.DataFrame_readMetadata=true] - How to read the metadata.\n * If `true`, {@linkcode readObject} is used, while if `false`, metadata will be skipped.\n * If a function is provided, it should accept `path`, `metadata`, `globals` and `options` (as described above), and return a {@link external:List List}.\n * @param {boolean} [options.DataFrame_toTypedArray=false] - Whether to report integer/number vectors without missing values as TypedArrays.\n * If `false`, vectors are reported as instances of an appropriately-typed {@link List} subclass.\n *\n * @return {external:DataFrame} The data frame.\n * @async\n */\nexport async function readDataFrame(path, metadata, globals, options = {}) {\n    let read_nested = true; \n    if (\"DataFrame_readNested\" in options) {\n        read_nested = options.DataFrame_readNested;\n    } \n    let typedarray = true;\n    if (\"DataFrame_toTypedArray\" in options) {\n        typedarray = options.DataFrame_toTypedArray;\n    }\n\n    let fhandle = await globals.h5open(joinPath(path, \"basic_columns.h5\")); \n    let handle_stack = [fhandle];\n    try {\n        let ghandle = fhandle.open(\"data_frame\");\n        handle_stack.push(ghandle);\n        let dhandle = ghandle.open(\"data\");\n        handle_stack.push(dhandle);\n\n        let cnhandle = ghandle.open(\"column_names\");\n        handle_stack.push(cnhandle);\n        let nrows = Number(ghandle.readAttribute(\"row-count\").values[0]);\n        let colnames = cnhandle.values();\n        cnhandle.close();\n        handle_stack.pop();\n\n        let collected = {};\n        let skip_nested = false;\n        let kids = dhandle.children();\n        for (const [i, k] of Object.entries(colnames)) {\n            let iname = String(i)\n            if (kids.indexOf(iname) < 0) {\n                if (read_nested !== false) {\n                    let nest_path = joinPath(path, \"other_columns\", iname);\n                    let nest_meta = await readObjectFile(nest_path, globals);\n                    if (read_nested === true) {\n                        collected[k] = await readObject(nest_path, nest_meta, globals, options);\n                    } else {\n                        collected[k] = await read_nested(nrows, nest_path, nest_meta, globals, options);\n                    }\n                } else {\n                    skip_nested = true;\n                }\n                continue;\n            }\n\n            let child_handle = dhandle.open(iname);\n            handle_stack.push(child_handle);\n\n            if (child_handle instanceof H5DataSet) {\n                let vals;\n                let rawvals = child_handle.values();\n                let type = child_handle.readAttribute(\"type\").values[0];\n\n                let child_attrs = child_handle.attributes();\n                let has_missing = child_attrs.indexOf(\"missing-value-placeholder\") >= 0;\n                let missing_attr;\n                if (has_missing) {\n                    missing_attr = child_handle.readAttribute(\"missing-value-placeholder\").values[0];\n                }\n\n                if (type == \"number\") {\n                    if (has_missing || !typedarray) {\n                        vals = Array.from(rawvals)\n                        if (Number.isNaN(missing_attr)) {\n                            for (let i = 0; i < vals.length; i++) {\n                                if (Number.isNaN(vals[i])) {\n                                    vals[i] = null;\n                                }\n                            }\n                        } else {\n                            for (let i = 0; i < vals.length; i++) {\n                                if (vals[i] == missing_attr) {\n                                    vals[i] = null;\n                                }\n                            }\n                        }\n                        vals = new NumberList(vals);\n                    } else {\n                        vals = new Float64Array(rawvals); // force it to be floating-point.\n                    }\n\n                } else if (type == \"boolean\") {\n                    vals = new Array(rawvals.length)\n                    if (has_missing) {\n                        for (let i = 0; i < rawvals.length; i++) {\n                            if (rawvals[i] == missing_attr) {\n                                vals[i] = null;\n                            } else {\n                                vals[i] = (rawvals[i] != 0);\n                            }\n                        }\n                    } else {\n                        for (let i = 0; i < rawvals.length; i++) {\n                            vals[i] = (rawvals[i] != 0);\n                        }\n                    }\n                    vals = new BooleanList(vals);\n\n                } else if (type == \"integer\") {\n                    if (has_missing || !typedarray) {\n                        vals = Array.from(rawvals);\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                        vals = new IntegerList(vals);\n                    } else {\n                        vals = new Int32Array(rawvals);\n                    }\n\n                } else if (type == \"string\") {\n                    vals = rawvals.slice(); // make a copy, to be safe.\n                    if (has_missing) {\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                    }\n                    vals = new StringList(vals);\n\n                } else {\n                    throw new Error(\"unknown type '\" + type + \"' in column '\" + k + \"' of a DataFrame at '\" + path + \"'\");\n                }\n\n                collected[k] = vals;\n\n            } else if (child_handle instanceof H5Group) {\n                let type = child_handle.readAttribute(\"type\").values[0];\n\n                if (type == \"factor\") {\n                    let lhandle = child_handle.open(\"levels\");\n                    handle_stack.push(lhandle);\n                    let levels = lhandle.values();\n                    lhandle.close();\n                    handle_stack.pop();\n\n                    let cohandle = child_handle.open(\"codes\");\n                    handle_stack.push(cohandle);\n                    let codes = cohandle.values();\n                    let code_attrs = cohandle.attributes();\n\n                    // Just reading factors as string vectors here, as we don't have a separate\n                    // representation in Javascript for a factor.\n                    let vals = Array(codes.length);\n                    if (code_attrs.indexOf(\"missing-value-placeholder\") >= 0) {\n                        let missing_attr = cohandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (let i = 0; i < codes.length; i++) {\n                            if (codes[i] == missing_attr) {\n                                vals[i] = null;\n                            } else {\n                                vals[i] = levels[codes[i]];\n                            }\n                        }\n                    } else {\n                        for (let i = 0; i < codes.length; i++) {\n                            vals[i] = levels[codes[i]];\n                        }\n                    }\n\n                    collected[k] = new StringList(vals);\n                    cohandle.close();\n                    handle_stack.pop();\n\n                } else if (type == \"vls\") {\n                    let hhandle = child_handle.open(\"heap\");\n                    handle_stack.push(hhandle);\n                    let heap = hhandle.values();\n                    hhandle.close();\n                    handle_stack.pop();\n\n                    let phandle = child_handle.open(\"pointers\");\n                    handle_stack.push(phandle);\n                    let pointers = phandle.values();\n                    let pointer_attrs = phandle.attributes();\n\n                    let vals = new Array(pointers.length);\n                    let dec = new TextDecoder;\n                    for (let i = 0; i < pointers.length; i++) {\n                        const { offset, length } = pointers[i];\n                        let current = heap.slice(Number(offset), Number(offset + length));\n                        let early = current.indexOf(0);\n                        if (early >= 0) {\n                            current = current.slice(0, early);\n                        }\n                        vals[i] = dec.decode(current);\n                    }\n\n                    if (pointer_attrs.indexOf(\"missing-value-placeholder\") >= 0) {\n                        let missing_attr = phandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                    }\n\n                    collected[k] = new StringList(vals);\n                    phandle.close();\n                    handle_stack.pop();\n\n                } else {\n                    throw new Error(\"unknown type '\" + type + \"' in column '\" + k + \"' of a DataFrame at '\" + path + \"'\");\n                }\n\n            } else {\n                throw new Error(\"unknown type for column '\" + k + \"' at path '\" + path + \"'\");\n            }\n\n            child_handle.close();\n            handle_stack.pop();\n        }\n\n        let rownames = null;\n        let gkids = ghandle.children();\n        if (gkids.indexOf(\"row_names\") >= 0) {\n            let rnhandle = ghandle.open(\"row_names\");\n            handle_stack.push(rnhandle);\n            rownames = rnhandle.values();\n            rnhandle.close();\n            handle_stack.pop();\n        }\n\n        if (skip_nested) {\n            let new_colnames = [];\n            for (const cn of colnames) {\n                if (cn in collected) {\n                    new_colnames.push(cn);\n                }\n            }\n            colnames = new_colnames;\n        }\n\n        let metadata = await readAnnotatedMetadata(joinPath(path, \"other_annotations\"), globals, options, \"DataFrame_readMetadata\")\n        return new DataFrame(collected, { columnOrder: colnames, numberOfRows: nrows, rowNames: rownames, metadata: metadata });\n\n    } finally {\n        for (const handle of handle_stack.toReversed()) {\n            handle.close();\n        }\n        await globals.h5close(fhandle);\n    }\n}\n\n/**\n * @param {external:DataFrame} x - The data frame.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function} [?options.DataFrame_saveOther=null] - Function to save custom class instances as columns of a data frame, without resorting to a reference to an external object.\n * This should accept `y`, an instance of a custom object; `handle`, the {@link H5Group} in which `y` is to be saved; and `name`, the name of the child of `handle` in which to save `y`. \n * It should return `true` if `y` was saved and `false` otherwise (e.g., if it does not know how to handle the class of`y`).\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveDataFrame(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer({ type: \"data_frame\", data_frame: { version: \"1.1\" } }));\n\n    let externals = {};\n    let success = false;\n\n    let fhandle = await globals.h5create(joinPath(path, \"basic_columns.h5\"));\n    let handle_stack = [fhandle];\n    try {\n        let ghandle = fhandle.createGroup(\"data_frame\");\n        handle_stack.push(ghandle);\n        ghandle.writeAttribute(\"row-count\", \"Uint64\", [], [x.numberOfRows()]);\n        ghandle.createDataSet(\"column_names\", \"String\", [ x.numberOfColumns() ], { data: x.columnNames() }).close();\n        if (x.rowNames() != null) {\n            ghandle.createDataSet(\"row_names\", \"String\", [ x.numberOfRows() ], { data: x.rowNames() }).close();\n        }\n\n        let dhandle = ghandle.createGroup(\"data\");\n        for (const [i, k] of Object.entries(x.columnNames())) {\n            let iname = String(i);\n            let col = x.column(k);\n\n            if (col instanceof Uint8Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint8\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int8Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int8\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Uint16Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint16\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int16Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int16\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Uint32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BigUint64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BigInt64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Float32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Float64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof IntegerList) {\n                let formatted = formatIntegerArrayForHdf5(col.toArray());\n                let dtype;\n                let htype;\n                if (formatted.integer) {\n                    dtype = \"integer\";\n                    htype = \"Int32\";\n                } else {\n                    dtype = \"number\";\n                    htype = \"Float64\";\n                }\n                let chandle = dhandle.createDataSet(iname, htype, [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [dtype]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", htype, [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof NumberList) {\n                let formatted = formatNumberArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"Float64\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof StringList) {\n                let formatted = formatStringArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"String\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"string\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"String\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BooleanList) {\n                let formatted = formatBooleanArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"Int8\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"boolean\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"Int8\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Array) {\n                // Try to guess the type of everything.\n                let types = new Set;\n                let has_missing = false;\n                for (const entry of col) {\n                    if (entry == null) {\n                        has_missing = true;\n                    } else {\n                        types.add(typeof entry);\n                    }\n                }\n\n                let okay = false;\n                if (types.size == 0) {\n                    let chandle = dhandle.createDataSet(iname, \"Uint8\", [ df.numberOfRows() ], { data: new Uint8Array(df.numberOfRows()) });\n                    handle_stack.push(chandle);\n                    chandle.writeAttribute(\"type\", \"String\", [], [ \"boolean\" ]);\n                    chandle.close();\n                    handle_stack.pop();\n                    okay = true;\n\n                } else if (types.size == 1) {\n                    // Javascript doesn't have native integers, so we'll save it all as 'number'.\n                    if (types.has(\"number\")) {\n                        let formatted = formatNumberArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                        if (formatted.placeholder !== null) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"Float64\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n\n                    } else if (types.has(\"boolean\")) {\n                        let formatted = formatBooleanArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"Uint8\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"boolean\"]);\n                        if (formatted.placeholder !== null) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"Uint8\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n\n                    } else if (types.has(\"string\")) {\n                        let formatted = formatStringArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"String\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"string\"]);\n                        if (has_missing) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"String\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n                    }\n                }\n\n                if (!okay) {\n                    externals[iname] = new List(col);\n                }\n\n            } else {\n                let handled = false;\n                if (\"DataFrame_saveOther\" in options) {\n                    handled = options.DataFrame_saveOther(col, dhandle, iname);\n                }\n                if (!handled) {\n                    externals[iname] = col;\n                }\n            }\n        }\n\n        success = true;\n    } finally {\n        for (const handle of handle_stack.toReversed()) {\n            handle.close();\n        }\n        await globals.h5finish(fhandle, !success);\n    }\n\n    let external_array = Object.entries(externals);\n    if (external_array.length > 0) {\n        let other_dir = joinPath(path, \"other_columns\");\n        await globals.mkdir(other_dir);\n        for (const [iname, col] of external_array) {\n            await saveObject(col, joinPath(other_dir, iname), globals, options);\n        }\n    }\n\n    await saveAnnotatedMetadata(x.metadata(), joinPath(path, \"other_annotations\"), globals, options);\n}\n","import * as wa from \"wasmarrays.js\";\nimport * as bioc from \"bioconductor\";\n\n// Monkey-patching these methods so that we can use these WasmArrays as columns in a bioc.DataFrame.\nwa.Uint8WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\nwa.Int32WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\nwa.Float64WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\n\nexport function formatColumnData(state, all_modalities, main_modality, all_other_metadata, store_per_modality) {\n    let keep_raw = state.cell_filtering.fetchKeep();\n    let keep = [];\n    if (keep_raw !== null) {\n        keep_raw.forEach((x, i) => {\n            if (x) { keep.push(i); }\n        });\n    }\n\n    let all_coldata = {};\n    {\n        let full = state.inputs.fetchCellAnnotations();\n        all_coldata[main_modality] = (keep_raw === null ? full : bioc.SLICE(full, keep));\n\n        let nrows = all_coldata[main_modality].numberOfRows();\n        for (const k of all_modalities) {\n            if (k !== main_modality) {\n                all_coldata[k] = new bioc.DataFrame({}, { numberOfRows: nrows });\n            }\n        }\n    }\n\n    // Quality control.\n    if (state.rna_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::RNA::quality_control\");\n        let target = (store_per_modality ? \"RNA\" : main_modality);\n\n        let rdf = all_coldata[target];\n        rdf = rdf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().sum({ copy: false })));\n        rdf = rdf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().detected({ copy: false })));\n        rdf = rdf.setColumn(prefix + \"::proportions\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().subsetProportion(0, { copy: false })));\n        all_coldata[target] = rdf;\n\n        all_other_metadata[target].set(\n            prefix,\n            { \n                \"filters\": {\n                    \"sums\": state.rna_quality_control.fetchFilters().sum(),\n                    \"detected\": state.rna_quality_control.fetchFilters().detected(),\n                    \"proportions\": state.rna_quality_control.fetchFilters().subsetProportion(0)\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (state.adt_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::ADT::quality_control\");\n        let target = (store_per_modality ? \"ADT\" : main_modality);\n\n        let adf = all_coldata[target];\n        adf = adf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().sum({ copy: false })));\n        adf = adf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().detected({ copy: false })));\n        adf = adf.setColumn(prefix + \"::igg_totals\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().subsetSum(0, { copy: false })));\n        all_coldata[target] = adf;\n\n        all_other_metadata[target].set(\n            prefix,\n            {\n                \"filters\": {\n                    \"detected\": state.adt_quality_control.fetchFilters().detected(),\n                    \"igg_totals\": state.adt_quality_control.fetchFilters().subsetSum(0)\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (state.crispr_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::CRISPR::quality_control\");\n        let target = (store_per_modality ? \"CRISPR\" : main_modality);\n\n        let cdf = all_coldata[target];\n        cdf = cdf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().sum({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().detected({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::max_proportion\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().maxProportion({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::max_index\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().maxIndex({ copy: false })));\n        all_coldata[target] = cdf;\n\n        all_other_metadata[target].set(\n            prefix,\n            {\n                \"filters\": {\n                    \"max_count\": state.crispr_quality_control.fetchFilters().maxValue()\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (keep_raw !== null) {\n        all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::quality_control::retained_indices\", keep);\n    }\n\n    // Size Factors.\n    if (state.rna_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::RNA::size_factors\");\n        let target = (store_per_modality ? \"RNA\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.rna_normalization.fetchSizeFactors());\n    }\n\n    if (state.adt_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::ADT::size_factors\");\n        let target = (store_per_modality ? \"ADT\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.adt_normalization.fetchSizeFactors());\n    }\n\n    if (state.crispr_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::CRISPR::size_factors\");\n        let target = (store_per_modality ? \"CRISPR\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.crispr_normalization.fetchSizeFactors());\n    }\n\n    {\n        // Incrementing to avoid cluster names starting from 0. Note that there's\n        // no need to respect the reportOneIndex setting, as cluster names are\n        // not indices with respect to anything. The only thing they need to match\n        // with is the marker table names, and we increment there (in markers.js) as well.\n        let clusters = state.choose_clustering.fetchClusters().map(x => x + 1);\n        all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::clusters\", clusters);\n    }\n\n    {\n        let block = state.cell_filtering.fetchFilteredBlock();\n        if (block !== null) {\n            let stringy = new Array(block.length);\n            let levels = state.inputs.fetchBlockLevels();\n            block.forEach((x, i) => { stringy[i] = levels[x]; }); \n            all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::block\", stringy);\n        }\n    }\n\n    // Custom selections, stored as boolean arrays.\n    {\n        let customs = state.custom_selections.fetchSelections({ copy: false });\n        let nrows = all_coldata[main_modality].numberOfRows();\n        for (const [v, k] of Object.entries(customs)) {\n            let as_bool = new Array(nrows);\n            as_bool.fill(false);\n            k.forEach(index => { as_bool[index] = true; });\n            all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::custom_selections::\" + v, as_bool);\n        }\n    }\n\n    return all_coldata;\n}\n","import { fetchSetSizes } from \"./fetchSingleSet.js\";\nimport { fetchSetsForGene, effectiveNumberOfGenes } from \"./fetchSetsForGene.js\";\nimport * as enrich from \"./testEnrichment.js\";\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {Array} genes - Array of unique integers containing user-supplied gene IDs, see {@linkcode fetchAllGenes} for details.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.includeSize=true] - Whether to include the size of each set in the output.\n * @param {boolean} [options.testEnrichment=true] - Whether to compute the enrichment p-value for each set with {@linkcode testEnrichment}.\n * The list and universe sizes will only count genes that are involved in at least one set, by checking {@linkcode fetchSetsForGene} and {@linkcode effectiveNumberOfGenes} respectively.\n * @param {boolean} [options.forceDownload=false] - See {@linkcode fetchSetsForGene}.\n *\n * @return {Array} An array of objects, where each object corresponds to a set that has non-zero overlaps with `genes`.\n * Each object contains:\n *\n * - `id`: the ID of the set in {@linkcode fetchAllSets}.\n * - `count`: the number of genes in the set that overlap with genes in `genes`.\n * - `size`: the size of each set.\n *   Only included if `includeSize = true`.\n * - `pvalue`: the enrichment p-value.\n *   Only included if `testEnrichment = true`.\n *\n * @async\n */\nexport async function findOverlappingSets(species, genes, { includeSize = true, testEnrichment = true, forceDownload = false } = {}) {\n    await fetchSetsForGene(species, null, { forceDownload });\n\n    let promises = [];\n    let queried = new Set;\n    for (const g of genes) {\n        if (!queried.has(g)) {\n            promises.push(fetchSetsForGene(species, g));\n            queried.add(g);\n        }\n    }\n\n    let collected = await Promise.all(promises);\n    let output = countSetOverlaps(collected);\n\n    let sets_sizes = (includeSize || testEnrichment ? await fetchSetSizes(species) : null);\n    if (includeSize) {\n        for (const details of output) {\n            details.size = sets_sizes[details.id];\n        }\n    }\n    if (testEnrichment) {\n        let effective_list = 0; // only considering genes involved in at least one set.\n        for (const v of collected) {\n            effective_list += (v.length > 0);\n        }\n        let universe = await effectiveNumberOfGenes(species);\n        for (const details of output) {\n            details.pvalue = enrich.testEnrichment(details.count, effective_list, sets_sizes[details.id], universe);\n        }\n    }\n\n    return output;\n}\n\n/**\n * This is a utility function that is called internally by {@linkcode findOverlappingSets}.\n * However, it can be used directly to obtain overlap counts if the gene-to-set mappings are manually obtained.\n *\n * @param {Array} setsForSomeGenes - Array where each entry corresponds to a gene and contains an array of the set IDs containing that gene.\n * Each inner array is typically the result of calling {@linkcode fetchSetsForGene}.\n *\n * @return {Array} An array of objects, where each object corresponds to a set that is present in at least one entry of `setsForSomeGenes`.\n * Each object contains:\n *\n * - `id`: the ID of the set in {@linkcode fetchAllSets}.\n * - `count`: the number of genes in the set that overlap with genes in `genes`.\n */\nexport function countSetOverlaps(setsForSomeGenes) {\n    var set_count = new Map;\n    for (const found of setsForSomeGenes) {\n        for (const set of found) {\n            let current = set_count.get(set);\n            if (typeof current == \"undefined\") {\n                set_count.set(set, 1);\n            } else {\n                set_count.set(set, current + 1);\n            }\n        }\n    }\n\n    let output = [];\n    for (const [id, count] of set_count) {\n        let id0 = Number(id);\n        let details = { \n            \"id\": id0,\n            \"count\": count\n        };\n        output.push(details);\n    }\n\n    return output;\n}\n\n","import * as readers from \"./readers/index.js\";\nimport * as anal from \"./analysis.js\";\nimport { bakana_version } from \"./version.js\";\n\n/**\n * Format a collection of {@linkplain Dataset} objects so that they can be saved to file.\n *\n * @param {object} datasets - Object containing Dataset instances, just like that used in {@linkcode InputsState#compute InputsState.compute}.\n * @param {function} saver - Function that converts a {@linkplain SimpleFile} instance into an identifier string.\n * Specifically, it should accept three arguments:\n *\n * 1. A string containing the name of the Dataset.\n * 2. A string containing the format of the Dataset, e.g., `\"10X\"`, `\"MatrixMarket\"`.\n * 3. A SimpleFile object representing one of the files of that Dataset.\n *\n * It should then return a string that uniquely identifies this file within `datasets`.\n * The nature of this string is left to the application, e.g., it may be a file path for Node.js, a virtual file path in the browser, or some database identifier.\n * This function may be async.\n *\n * @return {object} Object containing information about the files and datasets in `datasets`.\n * @async\n */\nexport async function serializeDatasets(datasets, saver) {\n    let output = {};\n\n    for (const [key, val] of Object.entries(datasets)) {\n        let dformat = val.constructor.format();\n        let { files, options } = await val.serialize();\n\n        let current = {\n            format: dformat,\n            options: options,\n            files: []\n        };\n\n        for (const obj of files) {\n            current.files.push({\n                type: obj.type,\n                name: obj.file.name(),\n                id: await saver(key, dformat, obj.file)\n            });\n        }\n\n        output[key] = current;\n    }\n\n    return output;\n}\n\n/**\n * Unserialize dataset information into their corresponding {@linkplain Dataset} instances.\n * This assumes that {@linkcode availableReaders} has been configured for all dataset formats that might be present.\n *\n * @param {object} serialized - Object containing the output of {@linkcode serializeDatasets}.\n * @param {function} loader - Function that accepts a single argument, the identifier string produced by `saver` in {@linkcode serializeDatasets};\n * and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n * This may be async.\n *\n * @return {object} An object containing {@linkplain Dataset} instances that can be directly used in {@linkcode InputsState#compute InputsState.compute}.\n * @async\n */\nexport async function unserializeDatasets(serialized, loader) {\n    let output = {};\n    let known = readers.availableReaders;\n\n    for (const [key, val] of Object.entries(serialized)) {\n        if (!(val.format in known)) {\n            throw new Error(\"unknown dataset format '\" + val.format + \"'\");\n        }\n        let cls = readers.availableReaders[val.format];\n\n        let handles = [];\n        for (const obj of val.files) {\n            let b = await loader(obj.id);\n            let handle = new readers.SimpleFile(b, { name: obj.name }) \n            handles.push({ type: obj.type, file: handle });\n        }\n\n        output[key] = await cls.unserialize(handles, val.options);\n    }\n\n    return output;\n}\n\n/**\n * Save the analysis configuration to file, including the parameters and datasets.\n * This can be stringified and saved to file, or it can be used in {@linkcode unserializeConfiguration}.\n *\n * @param {object} state - State object produced by {@linkcode createAnalysis} and run through {@linkcode runAnalysis}.\n * @param {function} saver - Function to save files, see {@linkcode serializeDatasets} for more details.\n *\n * @return {object} Object containing the serialized analysis configuration, with the following properties:\n *\n * - `parameters`, an object containing parameters that can be used in {@linkcode runAnalysis}.\n * - `datasets`, an object containing serialized datasets that can be used in {@linkcode unserializeDatasets}.\n * - `other`, an object containing more parameters that need special handling outside of `parameters`.\n *   This typically involves calling setter functions directly on the State objects:\n *   - `inputs.direct_subset` contains a direct subset that can be used in {@linkcode InputsState#setDirectSubset InputsState.setDirectSubset} before calling {@linkcode runAnalysis}.\n *   - `custom_selections.selections` contains selections that can be used in {@linkcode CustomSelectionsState#addSelection CustomSelectionsState.addSelection} after {@linkcode runAnalysis}.\n *\n * @async\n */\nexport async function serializeConfiguration(state, saver) {\n    let parameters = anal.retrieveParameters(state);\n    let datasets = await serializeDatasets(state.inputs.fetchDatasets(), saver);\n\n    let isub = state.inputs.fetchDirectSubset({ copy: false });\n    if (isub !== null) {\n        isub = Array.from(isub);\n    }\n\n    return {\n        version: bakana_version,\n        parameters: parameters,\n        datasets: datasets,\n\n        // Other parameters that need special handling.\n        other: {\n            inputs: {\n                direct_subset: isub,\n            },\n            custom_selections: {\n                selections: state.custom_selections.fetchSelections({ force: \"Array\" })\n            }\n        }\n    };\n}\n\n/**\n * Load the analysis configuration from its serialized format.\n * This is effectively the reverse operation of {@linkcode serializeConfiguration}.\n *\n * @param {object} serialized - Configuration object produced by {@linkcode serializeConfiguration}.\n * @param {function} loader - Function to load files, see {@linkcode unserializeDatasets} for more details.\n * @param {object} [options={}] - Optional parameters.\n * @param {object} [options.state=null] - Existing state object to fill with parameters, typically created by {@linkcode createAnalysis}.\n * This may need to be specified by the caller when `state` is also required to define the `startFun` and `finishFun` callbacks.\n * If `null`, a new state object is created within this function.\n * @param {?function} [options.startFun=null] - Passed directly to {@linkcode runAnalysis}.\n * @param {?function} [options.finishFun=null] - Passed directly to {@linkcode runAnalysis}.\n *\n * @return {object} State object containing analysis results.\n * This is identical to the `state` passed into {@linkcode serializeConfiguration}.\n *\n * If `state` is supplied, it is used directly as the return value.\n * @async\n */\nexport async function unserializeConfiguration(serialized, loader, { state = null, startFun = null, finishFun = null } = {}) {\n    if (state === null) {\n        state = await anal.createAnalysis();\n    }\n\n    // Set this before running the analysis.\n    if (\"other\" in serialized && \"inputs\" in serialized.other && \"direct_subset\" in serialized.other.inputs) {\n        if (serialized.other.inputs.direct_subset !== null) {\n            state.inputs.setDirectSubset(new Int32Array(serialized.other.inputs.direct_subset));\n        }\n    }\n\n    let datasets = await unserializeDatasets(serialized.datasets, loader);\n    await anal.runAnalysis(state, datasets, serialized.parameters, { startFun, finishFun });\n\n    // Set this after the analysis is done, as the markers get computed directly.\n    if (\"other\" in serialized && \"custom_selections\" in serialized.other && \"selections\" in serialized.other.custom_selections) {\n        for (const [k, v] of Object.entries(serialized.other.custom_selections.selections)) {\n            state.custom_selections.addSelection(k, new Int32Array(v), { copy: false });\n        }\n    }\n\n    return state;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction load_listData_names(lhandle) {\n    let ndx = lhandle.findAttribute(\"names\");\n    if (ndx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let names;\n    try {\n        nhandle = lhandle.attribute(ndx);\n        names = nhandle.values();\n    } catch(e) {\n        throw new Error(\"failed to load listData names; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    if (names.length != lhandle.length()) {\n        throw new Error(\"expected names to have same length as listData\");\n    }\n    return names;\n}\n\nconst acceptable_df_subclasses = { \"DFrame\": \"S4Vectors\" };\n\nfunction load_data_frame(handle) {\n    check_class(handle, acceptable_df_subclasses, \"DFrame\");\n\n    let columns = {};\n    let colnames = [];\n    let lhandle;\n    try {\n        lhandle = handle.attribute(\"listData\");\n        if (!(lhandle instanceof scran.RdsGenericVector)) {\n            throw new Error(\"listData slot should be a generic list\");\n        }\n\n        colnames = load_listData_names(lhandle);\n        if (colnames == null) {\n            throw new Error(\"expected the listData list to be named\");\n        }\n\n        for (var i = 0; i < lhandle.length(); i++) {\n            let curhandle;\n            try {\n                curhandle = lhandle.load(i);\n\n                if (curhandle instanceof scran.RdsVector && !(curhandle instanceof scran.RdsGenericVector)) {\n                    let curcol = curhandle.values();\n\n                    // Expand factors, if we detect them.\n                    if (curhandle.findAttribute(\"class\") >= 0) {\n                        let clshandle;\n                        let levhandle;\n                        try {\n                            clshandle = curhandle.attribute(\"class\");\n                            if (clshandle.values().indexOf(\"factor\") >= 0 && curhandle.findAttribute(\"levels\") >= 0) {\n                                levhandle = curhandle.attribute(\"levels\");\n                                let copy = curcol.slice();\n                                copy.forEach((x, i) => { copy[i] = x - 1 }); // get back to 0-based indices.\n                                curcol = bioc.SLICE(levhandle.values(), copy);\n                            }\n                        } finally {\n                            scran.free(clshandle);\n                            scran.free(levhandle);\n                        }\n                    }\n\n                    columns[colnames[i]] = curcol;\n\n                } else if (curhandle instanceof scran.RdsS4Object && check_acceptable_class(curhandle, acceptable_df_subclasses)) {\n                    // Handle nested DataFrames.\n                    columns[colnames[i]] = load_data_frame(curhandle);\n                }\n\n            } finally {\n                scran.free(curhandle);\n            }\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve data from DataFrame's listData; \" + e.message);\n    } finally {\n        scran.free(lhandle);\n    }\n\n    // Loading the row names.\n    let rnhandle;\n    let rownames = null;\n    try {\n        rnhandle = handle.attribute(\"rownames\");\n        if (rnhandle instanceof scran.RdsStringVector) {\n            rownames = rnhandle.values();\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve row names from DataFrame; \" + e.message);\n    } finally {\n        scran.free(rnhandle);\n    }\n\n    // Loading the number of rows.\n    let nrows = null;\n    if (colnames.length == 0 && rownames == null) {\n        let nrhandle;\n        try {\n            nrhandle = handle.attribute(\"nrows\");\n            if (!(nrhandle instanceof scran.RdsIntegerVector)) {\n                throw new Error(\"expected an integer vector as the 'nrows' slot\");\n            }\n            let NR = nrhandle.values();\n            if (NR.length != 1) {\n                throw new Error(\"expected an integer vector of length 1 as the 'nrows' slot\");\n            }\n            nrows = NR[0];\n        } catch (e) {\n            throw new Error(\"failed to retrieve nrows from DataFrame; \" + e.message);\n        } finally {\n            scran.free(nrhandle);\n        }\n    }\n\n    return new bioc.DataFrame(columns, { columnOrder: colnames, rowNames: rownames, numberOfRows: nrows });\n}\n\nfunction check_acceptable_class(handle, accepted) {\n    for (const [k, v] of Object.entries(accepted)) {\n        if (handle.className() == k && handle.packageName() == v) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction check_class(handle, accepted, base) {\n    if (!(handle instanceof scran.RdsS4Object)) {\n        throw new Error(\"expected an S4 object as the data frame\");\n    }\n    if (!check_acceptable_class(handle, accepted)) {\n        throw new Error(\"object is not a \" + base + \" or one of its recognized subclasses\");\n    }\n}\n\nfunction extract_NAMES(handle) {\n    let nidx = handle.findAttribute(\"NAMES\");\n    if (nidx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let output = null;\n    try {\n        nhandle = handle.attribute(nidx);\n        if (nhandle instanceof scran.RdsStringVector) {\n            output = nhandle.values();\n        }\n    } catch(e) {\n        throw new Error(\"failed to extract NAMES; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    return output;\n}\n\nfunction extract_features(handle) {\n    let rowdata;\n    let names = null;\n\n    let rrdx = handle.findAttribute(\"rowRanges\");\n    if (rrdx < 0) {\n        // This is a base SummarizedExperiment.\n        let rhandle;\n        try {\n            rhandle = handle.attribute(\"elementMetadata\");\n            rowdata = load_data_frame(rhandle);\n        } catch(e) {\n            throw new Error(\"failed to extract features from the rowData; \" + e.message);\n        } finally {\n            scran.free(rhandle);\n        }\n        names = extract_NAMES(handle);\n\n    } else {\n        // Everything else is assumed to be an RSE.\n        let rrhandle;\n        let output;\n        try {\n            rrhandle = handle.attribute(rrdx);\n            let ehandle = rrhandle.attribute(\"elementMetadata\");\n            try {\n                rowdata = load_data_frame(ehandle);\n            } catch(e) {\n                throw new Error(\"failed to extract mcols from the rowRanges; \" + e.message);\n            } finally {\n                scran.free(ehandle);\n            }\n\n            let pidx = rrhandle.findAttribute(\"partitioning\");\n            if (pidx < 0) { // if absent, we'll assume it's a GRanges.\n                let r2handle;\n                try {\n                    r2handle = rrhandle.attribute(\"ranges\");\n                    names = extract_NAMES(r2handle);\n                } catch(e) {\n                    throw new Error(\"failed to extract names from the rowRanges; \" + e.message);\n                } finally {\n                    scran.free(r2handle);\n                }\n            } else { // otherwise, it's a GRangesList.\n                let phandle;\n                try {\n                    phandle = rrhandle.attribute(pidx);\n                    names = extract_NAMES(phandle);\n                } catch(e) {\n                    throw new Error(\"failed to extract names from the rowRanges; \" + e.message);\n                } finally {\n                    scran.free(phandle);\n                }\n            }\n\n        } catch(e) {\n            throw new Error(\"failed to extract features from the rowRanges; \" + e.message);\n        } finally {\n            scran.free(rrhandle);\n        }\n    }\n\n    if (names !== null) {\n        rowdata.$setRowNames(names);\n    }\n    return rowdata;\n}\n\nfunction extract_assay_names(handle) {\n    let output;\n    let ahandle;\n    let dhandle;\n    let lhandle;\n\n    try {\n        ahandle = handle.attribute(\"assays\");\n        dhandle = ahandle.attribute(\"data\");\n        lhandle = dhandle.attribute(\"listData\");\n\n        output = load_listData_names(lhandle);\n        if (output == null) {\n            output = new Array(lhandle.length());\n            output.fill(\"\");\n        }\n    } catch(e) {\n        throw new Error(\"failed to extract assay data; \" + e.message);\n    } finally {\n        scran.free(ahandle);\n        scran.free(lhandle);\n        scran.free(dhandle);\n    }\n\n    return output;\n}\n\nfunction extract_assay(handle, assay, forceInteger) {\n    let output;\n    let ahandle;\n    let dhandle;\n    let lhandle;\n\n    try {\n        ahandle = handle.attribute(\"assays\");\n        dhandle = ahandle.attribute(\"data\");\n        lhandle = dhandle.attribute(\"listData\");\n\n        // Choosing the assay index.\n        let chosen = null;\n        if (typeof assay == \"string\") {\n            let names = load_listData_names(lhandle);\n            if (assay !== null && names != null) {\n                for (var n = 0; n < names.length; n++) {\n                    if (names[n] == assay) {\n                        chosen = n;\n                        break;\n                    }\n                }\n            }\n            if (chosen == null) {\n                throw new Error(\"no assay named '\" + assay + \"'\");\n            }\n        } else {\n            if (assay >= lhandle.length()) {\n                throw new Error(\"assay index \" + String(assay) + \" out of range\");\n            }\n            chosen = assay;\n        }\n\n        let xhandle;\n        try {\n            xhandle = lhandle.load(chosen);\n            output = scran.initializeSparseMatrixFromRds(xhandle, { forceInteger });\n        } catch(e) {\n            throw new Error(\"failed to initialize sparse matrix from assay; \" + e.message);\n        } finally {\n            scran.free(xhandle);\n        }\n\n    } catch(e) {\n        throw new Error(\"failed to extract assay data; \" + e.message);\n    } finally {\n        scran.free(ahandle);\n        scran.free(lhandle);\n        scran.free(dhandle);\n    }\n\n    return output;\n}\n\nfunction extract_main_exp_name(handle) {\n    let int_handle;\n    let name_handle;\n    let me_handle;\n\n    try {\n        let int_dx = handle.findAttribute(\"int_metadata\");\n        if (int_dx < 0) {\n            return \"\";\n        }\n        int_handle = handle.attribute(int_dx);\n\n        let name_dx = int_handle.findAttribute(\"names\");\n        if (name_dx < 0) {\n            return \"\";\n        }\n\n        name_handle = int_handle.attribute(name_dx);\n        let names = name_handle.values();\n        let me_dx = names.indexOf(\"mainExpName\");\n        if (me_dx < 0) {\n            return \"\";\n        }\n\n        me_handle = int_handle.load(me_dx);\n        let me_name = me_handle.values();\n        if (me_name.length != 1 || typeof me_name[0] !== \"string\") {\n            return \"\";\n        } else {\n            return me_name[0];\n        }\n    } finally {\n        scran.free(int_handle);\n        scran.free(name_handle);\n        scran.free(me_handle);\n    }\n}\n\nfunction extract_alt_exps(handle) {\n    let output = { handles: {}, order: [] };\n    let indx = handle.findAttribute(\"int_colData\");\n    if (indx < 0) {\n        return output;\n    }\n\n    let in_handle;\n    let inld_handle;\n    let innn_handle;\n    let ae_handle;\n    let aeld_handle;\n    let aenn_handle;\n\n    try {\n        in_handle = handle.attribute(indx);\n        let inld_dx = in_handle.findAttribute(\"listData\");\n        if (inld_dx < 0) {\n            return output;\n        }\n\n        inld_handle = in_handle.attribute(inld_dx);\n        let innn_dx = inld_handle.findAttribute(\"names\");\n        if (innn_dx < 0) {\n            return output;\n        }\n\n        innn_handle = inld_handle.attribute(innn_dx);\n        let in_names = innn_handle.values();\n        let ae_dx = in_names.indexOf(\"altExps\");\n        if (ae_dx < 0) {\n            return output;\n        }\n\n        ae_handle = inld_handle.load(ae_dx);\n        let aeld_dx = ae_handle.findAttribute(\"listData\");\n        if (aeld_dx < 0) {\n            return output;\n        }\n\n        aeld_handle = ae_handle.attribute(aeld_dx);\n        let aenn_dx = aeld_handle.findAttribute(\"names\");\n        if (aenn_dx < 0) {\n            return output;\n        }\n\n        aenn_handle = aeld_handle.attribute(aenn_dx);\n        let ae_names = aenn_handle.values();\n\n        for (var i = 0; i < ae_names.length; i++) {\n            let curhandle;\n            try {\n                curhandle = aeld_handle.load(i);\n                let asehandle = curhandle.attribute(\"se\");\n                output.handles[ae_names[i]] = asehandle;\n                output.order.push(ae_names[i]);\n                check_for_se(asehandle);\n            } catch (e) {\n                throw new Error(\"failed to load alternative Experiment '\" + ae_names[i] + \"'; \" + e.message);\n            } finally {\n                scran.free(curhandle);\n            }\n        }\n\n    } catch(e) {\n        for (const v of Object.values(output.handles)) {\n            scran.free(v);\n        }\n        throw e;\n\n    } finally {\n        scran.free(aenn_handle);\n        scran.free(aeld_handle);\n        scran.free(innn_handle);\n        scran.free(inld_handle);\n        scran.free(in_handle);\n    }\n\n    return output;\n}\n\nfunction extract_reduced_dims(handle) {\n    let output = { handles: {}, order: [] };\n    let indx = handle.findAttribute(\"int_colData\");\n    if (indx < 0) {\n        return output;\n    }\n\n    let in_handle;\n    let inld_handle;\n    let innn_handle;\n    let rd_handle;\n    let rdld_handle;\n    let rdnn_handle;\n\n    try {\n        in_handle = handle.attribute(indx);\n        let inld_dx = in_handle.findAttribute(\"listData\");\n        if (inld_dx < 0) {\n            return output;\n        }\n\n        inld_handle = in_handle.attribute(inld_dx);\n        let innn_dx = inld_handle.findAttribute(\"names\");\n        if (innn_dx < 0) {\n            return output;\n        }\n\n        innn_handle = inld_handle.attribute(innn_dx);\n        let in_names = innn_handle.values();\n        let rd_dx = in_names.indexOf(\"reducedDims\");\n        if (rd_dx < 0) {\n            return output;\n        }\n\n        rd_handle = inld_handle.load(rd_dx);\n        let rdld_dx = rd_handle.findAttribute(\"listData\");\n        if (rdld_dx < 0) {\n            return output;\n        }\n\n        rdld_handle = rd_handle.attribute(rdld_dx);\n        let rdnn_dx = rdld_handle.findAttribute(\"names\");\n        if (rdnn_dx < 0) {\n            return output;\n        }\n\n        rdnn_handle = rdld_handle.attribute(rdnn_dx);\n        let rd_names = rdnn_handle.values();\n\n        for (var i = 0; i < rd_names.length; i++) {\n            let curhandle;\n            try {\n                curhandle = rdld_handle.load(i);\n                let okay = false;\n\n                if (curhandle.type() == \"double\" && curhandle.findAttribute(\"dim\") >= 0) { // only accepting double-precision matrics.\n                    let dimhandle = curhandle.attribute(\"dim\");\n                    if (dimhandle.length() == 2) {\n                        output.handles[rd_names[i]] = { handle: curhandle, dimensions: dimhandle.values() };\n                        output.order.push(rd_names[i]);\n                        okay = true;\n                    }\n                }\n\n                if (!okay) {\n                    scran.free(curhandle);\n                }\n            } catch (e) {\n                throw new Error(\"failed to load reduced dimension '\" + rd_names[i] + \"'; \" + e.message);\n            }\n        }\n\n    } catch(e) {\n        for (const v of Object.values(output.handles)) {\n            scran.free(v.handle);\n        }\n        throw e;\n\n    } finally {\n        scran.free(rdnn_handle);\n        scran.free(rdld_handle);\n        scran.free(innn_handle);\n        scran.free(inld_handle);\n        scran.free(in_handle);\n    }\n\n    return output;\n}\n\nfunction check_for_se(handle) {\n    check_class(handle, { \n        \"SummarizedExperiment\": \"SummarizedExperiment\",\n        \"RangedSummarizedExperiment\": \"SummarizedExperiment\",\n        \"SingleCellExperiment\": \"SingleCellExperiment\",\n        \"SpatialExperiment\": \"SpatialExperiment\"\n    }, \"SummarizedExperiment\");\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment object (or one of its subclasses) inside an RDS file.\n */\nexport class SummarizedExperimentDataset {\n    #rds_file;\n\n    #rds_handle;\n    #se_handle;\n\n    #main_exp_name;\n    #alt_handles;\n    #alt_handle_order;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"rds\", file: fun(this.#rds_file) }];\n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} rdsFile - Contents of a RDS file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(rdsFile) {\n        if (rdsFile instanceof afile.SimpleFile) {\n            this.#rds_file = rdsFile;\n        } else {\n            this.#rds_file = new afile.SimpleFile(rdsFile);\n        }\n\n        this.#options = SummarizedExperimentDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode SummarizedExperimentDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"Gene Expression\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode SummarizedExperimentDataset#load load} (but not {@linkcode SummarizedExperimentDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?string} [options.rnaExperiment] - Name of the main/alternative experiment containing gene expression data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no RNA data is assumed to be present.\n     * @param {?string} [options.adtExperiment] - Name of the main/alternative experiment containing ADT data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no ADTs are assumed to be present.\n     * @param {?string} [options.crisprExperiment] - Name of the main/alternative experiment containing CRISPR guide data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no CRISPR guides are assumed to be present.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode SummarizedExperimentDataset#load load} or {@linkcodeSummarizedExperimentDataset#summary summary}.\n     */\n    clear() {\n        scran.free(this.#se_handle);\n        if (typeof this.#alt_handles != 'undefined' && this.#alt_handles !== null) {\n            for (const v of Object.values(this.#alt_handles)) {\n                scran.free(v);\n            }\n        }\n        scran.free(this.#rds_handle);\n\n        this.#se_handle = null;\n        this.#alt_handles = null;\n        this.#rds_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"SummarizedExperiment\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #initialize() {\n        if (this.#rds_handle !== null) {\n            return;\n        }\n\n        this.#rds_handle = scran.readRds(this.#rds_file.content());\n        this.#se_handle = this.#rds_handle.value();\n        try {\n            check_for_se(this.#se_handle);\n            const { handles, order } = extract_alt_exps(this.#se_handle);\n            this.#alt_handles = handles;\n            this.#alt_handle_order = order;\n            this.#main_exp_name = extract_main_exp_name(this.#se_handle);\n        } catch (e) {\n            this.#se_handle.free();\n            this.#rds_handle.free();\n            throw e;\n        }\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#initialize();\n        this.#raw_features = {};\n        this.#raw_features[this.#main_exp_name] = extract_features(this.#se_handle);\n\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in this.#raw_features)) {\n                try {\n                    this.#raw_features[k] = extract_features(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#initialize();\n        let chandle = this.#se_handle.attribute(\"colData\");\n        try {\n            this.#raw_cells = load_data_frame(chandle);\n        } catch(e) {\n            throw new Error(\"failed to extract colData from a SummarizedExperiment; \" + e.message);\n        } finally {\n            scran.free(chandle);\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    If a modality's assays are unnamed, an array of empty strings is returned instead.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    summary({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let assays = {};\n        assays[this.#main_exp_name] = extract_assay_names(this.#se_handle);\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in assays)) {\n                try {\n                    assays[k] = extract_assay_names(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: assays\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode SummarizedExperimentDataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n\n        let fmapping = { \n            RNA: this.#options.rnaExperiment,\n            ADT: this.#options.adtExperiment,\n            CRISPR: this.#options.crisprExperiment\n        };\n\n        let preview = futils.extractRemappedPrimaryIds(this.#raw_features, this.#alt_handle_order, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode SummarizedExperimentDataset#defaults defaults} or with {@linkcode SummarizedExperimentDataset#setOptions setOptions}.\n     */\n    load({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null) {\n                    continue;\n                }\n\n                let handle;\n                if (v.exp === this.#main_exp_name) {\n                    handle = this.#se_handle;\n                } else if (v.exp in this.#alt_handles) {\n                    handle = this.#alt_handles[v.exp];\n                } else {\n                    continue;\n                }\n\n                let loaded = extract_assay(handle, v.assay, true);\n                output.matrix.add(k, loaded);\n                output.features[k] = this.#raw_features[v.exp];\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode SummarizedExperimentDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {SummarizedExperimentDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"rds\") {\n            throw new Error(\"expected exactly one file of type 'rds' for SummarizedExperiment unserialization\");\n        }\n        let output = new SummarizedExperimentDataset(files[0].file);\n        output.setOptions(options);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) inside an RDS file.\n */\nexport class SummarizedExperimentResult {\n    #rds_file;\n\n    #rds_handle;\n    #se_handle;\n\n    #main_exp_name;\n    #alt_handles;\n    #alt_handle_order;\n\n    #raw_features;\n    #raw_cells;\n    #rd_handles;\n    #rd_handle_order;\n\n    #options;\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} rdsFile - Contents of a RDS file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(rdsFile) {\n        if (rdsFile instanceof afile.SimpleFile) {\n            this.#rds_file = rdsFile;\n        } else {\n            this.#rds_file = new afile.SimpleFile(rdsFile);\n        }\n\n        // Cloning to avoid pass-by-reference links.\n        this.#options = SummarizedExperimentResult.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbResult#load load} (but not {@linkcode AbstractArtifactdbResult#summary summary}).\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode SummarizedExperimentResult#load load} or {@linkcodeSummarizedExperimentResult#summary summary}.\n     */\n    clear() {\n        scran.free(this.#se_handle);\n\n        if (typeof this.#alt_handles != 'undefined' && this.#alt_handles !== null) {\n            for (const v of Object.values(this.#alt_handles)) {\n                scran.free(v);\n            }\n        }\n\n        if (typeof this.#rd_handles != 'undefined' && this.#rd_handles !== null) {\n            for (const v of Object.values(this.#rd_handles)) {\n                scran.free(v.handle);\n            }\n        }\n\n        scran.free(this.#rds_handle);\n\n        this.#se_handle = null;\n        this.#alt_handles = null;\n        this.#rds_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    #initialize() {\n        if (this.#rds_handle !== null) {\n            return;\n        }\n\n        this.#rds_handle = scran.readRds(this.#rds_file.content());\n        this.#se_handle = this.#rds_handle.value();\n        try {\n            check_for_se(this.#se_handle);\n\n            {\n                const { handles, order } = extract_alt_exps(this.#se_handle);\n                this.#alt_handles = handles;\n                this.#alt_handle_order = order;\n                this.#main_exp_name = extract_main_exp_name(this.#se_handle);\n            }\n\n            {\n                const { handles, order } = extract_reduced_dims(this.#se_handle);\n                this.#rd_handles = handles;\n                this.#rd_handle_order = order;\n            }\n\n        } catch (e) {\n            this.#se_handle.free();\n            this.#rds_handle.free();\n            throw e;\n        }\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#initialize();\n        this.#raw_features = {};\n        this.#raw_features[this.#main_exp_name] = extract_features(this.#se_handle);\n\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in this.#raw_features)) {\n                try {\n                    this.#raw_features[k] = extract_features(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#initialize();\n        let chandle = this.#se_handle.attribute(\"colData\");\n        try {\n            this.#raw_cells = load_data_frame(chandle);\n        } catch(e) {\n            throw new Error(\"failed to extract colData from a SummarizedExperiment; \" + e.message);\n        } finally {\n            scran.free(chandle);\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode SummarizedExperimentResult#load load}.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    summary({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let assays = {};\n        assays[this.#main_exp_name] = extract_assay_names(this.#se_handle);\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in assays)) {\n                try {\n                    assays[k] = extract_assay_names(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: assays,\n            reduced_dimension_names: this.#rd_handle_order\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode SummarizedExperimentResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    load({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells,\n            reduced_dimensions: {}\n        };\n\n        // Fetch the reduced dimensions first.\n        let reddims = this.#options.reducedDimensionNames;\n        if (reddims == null) {\n            reddims = this.#rd_handle_order;\n        }\n\n        for (const k of reddims) {\n            let v = this.#rd_handles[k];\n            let acquired = [];\n            let dims = v.dimensions;\n            let contents = v.handle.values();\n            for (var d = 0; d < dims[1]; d++) {\n                acquired.push(contents.slice(d * dims[0], (d + 1) * dims[0]));\n            }\n            output.reduced_dimensions[k] = acquired;\n        }\n\n        // Now fetching the assay matrix.\n        try {\n            for (const [k, v] of Object.entries(this.#raw_features)) {\n                let curassay = this.#options.primaryAssay;\n                if (typeof curassay == \"object\") {\n                    if (k in curassay) {\n                        curassay = curassay[k];\n                    } else {\n                        continue;\n                    }\n                }\n\n                let curnormalized = this.#options.isPrimaryNormalized;\n                if (typeof curnormalized == \"object\") {\n                    if (k in curnormalized) {\n                        curnormalized = curnormalized[k];\n                    } else {\n                        curnormalized = true;\n                    }\n                }\n\n                let handle;\n                if (k === this.#main_exp_name) {\n                    handle = this.#se_handle;\n                } else {\n                    handle = this.#alt_handles[k];\n                }\n\n                let loaded = extract_assay(handle, curassay, !curnormalized);\n                output.matrix.add(k, loaded);\n\n                if (!curnormalized) {\n                    let normed = scran.normalizeCounts(loaded, { allowZeros: true });\n                    output.matrix.add(k, normed);\n                }\n\n                output.features[k] = this.#raw_features[k];\n            }\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n","import JSZip from \"jszip\";\nimport * as jsp from \"jaspagate\";\nimport * as adb from \"./alabaster-abstract.js\";\nimport * as afile from \"./abstract/file.js\";\n\nclass ZippedProjectNavigator {\n    #zipfile;\n    #ziphandle;\n    #prefix;\n\n    constructor(zipfile, ziphandle, prefix) {\n        this.#zipfile = zipfile;\n        this.#ziphandle = null;\n        this.#prefix = prefix;\n    }\n\n    async get(path, asBuffer) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n        // We always return a buffer.\n        return this.#ziphandle.file(jsp.joinPath(this.#prefix, path)).async(\"uint8array\");\n    }\n\n    exists(path) {\n        return this.#ziphandle.file(jsp.joinPath(this.#prefix, path)) !== null; \n    }\n\n    clean(path) {}\n};\n\n/**\n * Search a ZIP file for SummarizedExperiments to use in {@linkplain ZippedAlabasterDataset} or {@linkplain ZippedAlabasterResult}.\n *\n * @param {JSZip} handle - A handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n * \n * @return {Map} Object where the keys are the paths/names of possible SummarizedExperiment objects,\n * and each value is a 2-element array of dimensions.\n */\nexport async function searchZippedAlabaster(handle) {\n    let candidates = [];\n    for (const name of Object.keys(handle.files)) {\n        if (name == \"OBJECT\") {\n            candidates.push(\"\");\n        } else if (name.endsWith(\"/OBJECT\")) {\n            candidates.push(name.slice(0, name.length - 6));\n        }\n    }\n    candidates.sort();\n\n    const nonchildren = new Map;\n    let counter = 0;\n    while (counter < candidates.length) {\n        let prefix = candidates[counter];\n        counter++;\n        let contents = await handle.file(prefix + \"OBJECT\").async(\"string\");\n\n        let meta = {};\n        try {\n            meta = JSON.parse(contents);\n        } catch(e) {\n            ;\n        }\n\n        if (\"summarized_experiment\" in meta) {\n            nonchildren.set(prefix == \"\" ? \".\" : prefix.slice(0, prefix.length - 1), meta.summarized_experiment.dimensions);\n            while (counter < candidates.length) {\n                if (!candidates[counter].startsWith(prefix)) {\n                    break;\n                }\n                counter++;\n            }\n        }\n    }\n\n    return nonchildren;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset as a ZIP file containing a SummarizedExperiment in the **alabaster** representation.\n * Specifically, the ZIP file should contain the contents of an **alabaster** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractAlabasterDataset\n */\nexport class ZippedAlabasterDataset extends adb.AbstractAlabasterDataset {\n    #zipfile;\n    #prefix;\n\n    /**\n     * @param {string} prefix - Name of the SummarizedExperiment object inside the ZIP file.\n     * This should be `.` if the `OBJECT` file is stored at the root of the ZIP file,\n     * otherwise it should be the relative path to the object directory containing the `OBJECT` file.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedAlabasterDataset instance.\n     */\n    constructor(prefix, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle, prefix);\n        super(nav);\n        this.#zipfile = zipfile;\n        this.#prefix = prefix;\n    }\n\n    /**\n     * @return {string} String specifying the format for this dataset.\n     */\n    static format() {\n        return \"alabaster-zipped\";\n    }\n\n    #dump_summary(fun) {\n        let files = [ { type: \"zip\", file: fun(this.#zipfile) } ]; \n        let opt = this.options();\n        opt.datasetPrefix = this.#prefix; // storing the name as a special option... can't be bothered to store it as a separate file.\n        return { files: files, options: opt };\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { \n            return { size: f.size(), name: f.name() }\n        });\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ZippedAlabasterDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ZippedAlabasterDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"zip\") {\n            throw new Error(\"expected exactly one file of type 'zip' for Zipped alabaster unserialization\");\n        }\n\n        let prefix = options.datasetPrefix;\n        delete options.datasetPrefix;\n\n        let output = new ZippedAlabasterDataset(prefix, files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Result as a ZIP file containing a SummarizedExperiment in the **alabaster** representation,\n * Specifically, the ZIP file should contain the contents of an **alabaster** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractAlabasterResult\n */\nexport class ZippedAlabasterResult extends adb.AbstractAlabasterResult {\n    /**\n     * @param {string} prefix - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedAlabasterDataset instance.\n     */\n    constructor(prefix, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle, prefix);\n        super(nav);\n    }\n}\n","import * as sce from \"./SingleCellExperiment.js\";\nimport * as markers from \"./markers.js\";\nimport * as ass from \"./assays.js\";\nimport * as rd from \"./reducedDimensions.js\";\nimport * as internal from \"./abstract/dump.js\";\nimport { AlabasterGlobalsInterface } from \"./interfaces.js\";\nimport * as jsp from \"jaspagate\";\nimport * as wa from \"wasmarrays.js\";\n\nfunction saveOtherDataFrameColumns(y, handle, name) {\n    if (y instanceof wa.Float64WasmArray) {\n        let chandle = handle.createDataSet(name, \"Float64\", [ y.length ], { data: y });\n        try {\n            chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n        } finally {\n            chandle.close();\n        }\n        return true;\n\n    } else if (y instanceof wa.Int32WasmArray) {\n        let chandle = handle.createDataSet(name, \"Int32\", [ y.length ], { data: y });\n        try {\n            chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n        } finally {\n            chandle.close();\n        }\n        return true;\n\n    } else if (y instanceof wa.Uint8WasmArray) {\n        let chandle = handle.createDataSet(name, \"Uint8\", [ y.length ], { data: y });\n        try {\n            chandle.writeAttribute(\"type\", \"String\", [], [\"boolean\"]);\n        } finally {\n            chandle.close();\n        }\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Save the analysis results into a SingleCellExperiment using the [**takane**](https://github.com/ArtifactDB/takane) format.\n * This uses a language-agnostic format mostly based on HDF5 and JSON, which can be read into a variety of frameworks like R and Python.\n * The aim is to facilitate downstream analysis procedures that are not supported by **bakana** itself; \n * for example, a bench scientist can do a first pass with **kana** before passing the results to a computational collaborator for deeper inspection.\n *\n * @param {object} state - Existing analysis state containing results, after one or more runs of {@linkcode runAnalysis}.\n * @param {string} name - Name of the SingleCellExperiment.\n * This may also contain forward slashes, in which case it is treated as a local path.\n * If a local filesystem is present and `directory` is supplied, `name` defines the subdirectory within `directory` in which the SingleCellExperiment is to be saved.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.reportOneIndex=false] - Whether to report 1-based indices, for use in 1-based languages like R.\n * Currently, this only refers to the column indices of the custom selections reported in the SingleCellExperiment's metadata.\n * @param {boolean} [options.storeModalityColumnData=false] - Whether to store modality-specific per-cell statistics (e.g., QC metrics, size factors) in the column data of the associated alternative Experiment.\n * This can yield a cleaner SingleCellExperiment as statistics are assigned to the relevant modalities.\n * That said, the default is still `false` as many applications (including **bakana** itself, via the {@linkcode AbstractArtifactdbDataset} and friends) will not parse the column data of alternative Experiments. \n * In such cases, all modality-specific metrics are stored in the main experiment's column data with a modality-specific name, e.g., `kana::ADT::quality_control::sums`.\n * @param {?string} [options.directory=null] - Directory in which to save the components of the SingleCellExperiment.\n * If `null` or if no local file system exists, files are stored in memory as Uint8Arrays.\n *\n * @return {?Object} If `directory` is supplied and a local filesystem exists, the components are saved to disk and `null` is returned.\n * Otherwise, if `directory = null` or a local filesystem does not exist, an object is returned where each key is a local path to a component file and each value is a Uint8Array with the file contents.\n */\nexport async function saveSingleCellExperiment(state, name, { reportOneIndex = false, storeModalityColumnData = false, directory = null } = {}) {\n    let my_sce = await sce.formatSingleCellExperiment(state, { reportOneIndex, storeModalityColumnData });\n\n    if (!(internal.fsexists())) {\n        directory = null;\n    }\n    let files = {};\n    let globals = new AlabasterGlobalsInterface(directory, files);\n\n    jsp.saveObjectRegistry.push([ ass.MockSparseMatrix, ass.saveSparseMatrix ]);\n    jsp.saveObjectRegistry.push([ ass.MockNormalizedMatrix, ass.saveNormalizedMatrix ]); \n    jsp.saveObjectRegistry.push([ rd.MockReducedDimensionMatrix, rd.saveReducedDimensionMatrix]); \n    try {\n        await jsp.saveObject(my_sce, name, globals, { DataFrame_saveOther: saveOtherDataFrameColumns });\n    } finally {\n        jsp.saveObjectRegistry.pop();\n        jsp.saveObjectRegistry.pop();\n        jsp.saveObjectRegistry.pop();\n    }\n\n    if (directory === null) {\n        return files;\n    } else {\n        return null;\n    }\n}\n\n/**\n * Save the per-gene analysis results as data frames in the [**takane**](https://github.com/ArtifactDB/takane) format.\n * This includes the marker tables for the clusters and custom selections, as well as the variance modelling statistics from the feature selection step.\n * Each data frames has the same order of rows as the SingleCellExperiment saved by {@linkcode saveSingleCellExperiment};\n * for easier downstream use, we set the row names of each data frame to row names of the SingleCellExperiment\n * (or if no row names are available, we set each data frame's row names to the first column of the `rowData`).\n *\n * @param {object} state - Existing analysis state containing results, after one or more runs of {@linkcode runAnalysis}.\n * @param {?string} path - Local path in which to save all results.\n * If a local filesystem is present and `directory` is supplied, `path` defines the subdirectory within `directory` in which the SingleCellExperiment is to be saved.\n * If `null`, results are directly saved to `directory` itself.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.includeMarkerDetection=true] - Whether to save the marker detection results.\n * @param {boolean} [options.includeCustomSelections=true] - Whether to save the custom selection results.\n * @param {boolean} [options.includeFeatureSelection=true] - Whether to save the feature selection results.\n * @param {?string} [options.directory=null] - Directory in which to save the data frames. \n * If `null` or if no local file system exists, files are stored in memory as Uint8Arrays.\n *\n * @return {?Object} If `directory` is supplied and a local filesystem exists, the data frame components are saved to disk and `null` is returned.\n * Otherwise, if `directory = null` or a local filesystem does not exist, an object is returned where each key is a local path to a component file and each value is a Uint8Array with the file contents.\n */\nexport async function saveGenewiseResults(state, path, { includeMarkerDetection = true, includeCustomSelections = true, includeFeatureSelection = true, directory = null } = {}) {\n    let modalities = {};\n    let anno = state.inputs.fetchFeatureAnnotations();\n    for (const [k, v] of Object.entries(anno)) {\n        let rn = v.rowNames();\n        if (rn === null && v.numberOfColumns() > 0) {\n            rn = v.column(0);\n        }\n        modalities[k] = rn;\n    }\n\n    if (!(internal.fsexists())) {\n        directory = null;\n    }\n    let files = {};\n    let globals = new AlabasterGlobalsInterface(directory, files);\n\n    if (includeMarkerDetection) {\n        let dir = \"marker_detection\";\n        if (path !== null) {\n            dir = jsp.joinPath(path, dir);\n        }\n        let all = markers.formatMarkerDetectionResults(state, modalities);\n        for (const [k, v] of Object.entries(all)) {\n            await jsp.saveObject(v, jsp.joinPath(dir, k), globals, { DataFrame_saveOther: saveOtherDataFrameColumns });\n        }\n    }\n\n    if (includeCustomSelections) {\n        let dir = \"custom_selections\";\n        if (path !== null) {\n            dir = jsp.joinPath(path, dir);\n        }\n        let all = markers.formatCustomSelectionResults(state, modalities);\n        for (const [k, v] of Object.entries(all)) {\n            await jsp.saveObject(v, jsp.joinPath(dir, k), globals, { DataFrame_saveOther: saveOtherDataFrameColumns });\n        }\n    }\n\n    if (state.feature_selection.valid() && includeFeatureSelection) {\n        let dir = \"feature_selection\";\n        if (path !== null) {\n            dir = jsp.joinPath(path, dir);\n        }\n        let df = markers.formatFeatureSelectionResults(state, modalities.RNA);\n        await jsp.saveObject(df, dir, globals, { DataFrame_saveOther: saveOtherDataFrameColumns });\n    }\n\n    if (directory === null) {\n        return files;\n    } else {\n        return null;\n    }\n}\n","import { SingleCellExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { readRangedSummarizedExperiment, saveRangedSummarizedExperiment } from \"./RangedSummarizedExperiment.js\"; \nimport { joinPath, jsonBuffer } from \"./utils.js\";\n\n/**\n * A single-cell experiment.\n * @external SingleCellExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/SingleCellExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:SingleCellExperiment SingleCellExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function|boolean} [options.SingleCellExperiment_readReducedDimension=true] - How to read each dimensionality reduction result.\n * If `true`, {@linkcode readObject} is used, while if `false`, the reduced dimensions will be skipped.\n * If a function is provided, it should accept `ncol` (the number of columns in the SingleCellExperiment) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `ncol`. \n * @param {function|boolean} [options.SingleCellExperiment_readAlternativeExperiment=true] - How to read each alternative experiment.\n * If `true`, {@linkcode readObject} is used, while if `false`, the alternative experiments will be skipped.\n * If a function is provided, it should accept `ncol` (the number of columns in the SingleCellExperiment) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return a {@link external:SummarizedExperiment SummarizedExperiment} (possibly asynchronously)\n * for which [`NUMBER_OF_COLUMNS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_COLUMNS) is equal to `ncol`. \n *\n * @return {external:SingleCellExperiment} The single-cell experiment object.\n * @async\n */\nexport async function readSingleCellExperiment(path, metadata, globals, options = {}) {\n    let rse = await readRangedSummarizedExperiment(path, metadata, globals, options);\n\n    let sce = new SingleCellExperiment(\n        rse.assays(),\n        {\n            assayOrder: rse.assayNames(),\n            rowRanges: rse.rowRanges(),\n            rowData: rse.rowData(),\n            columnData: rse.columnData(),\n            rowNames: rse.rowNames(),\n            columnNames: rse.columnNames(),\n            metadata: rse.metadata(),\n        }\n    );\n\n    if (\"main_experiment_name\" in metadata.single_cell_experiment) {\n        sce.setMainExperimentName(metadata.single_cell_experiment.main_experiment_name, { inPlace: true });\n    }\n\n    let read_rd = true;\n    if (\"SingleCellExperiment_readReducedDimension\" in options) {\n        read_rd = options.SingleCellExperiment_readReducedDimension;\n    }\n    if (read_rd !== false) {\n        const rdpath = joinPath(path, \"reduced_dimensions/names.json\");\n        if (await globals.exists(rdpath)) {\n            let names_contents = await globals.get(rdpath, { asBuffer: true });\n            const dec = new TextDecoder;\n            const reddim_names = JSON.parse(dec.decode(names_contents));\n            for (const [i, rname] of Object.entries(reddim_names)) {\n                let rdpath = joinPath(path, \"reduced_dimensions\", String(i));\n                let rdmeta = await readObjectFile(rdpath, globals);\n                let currd;\n                if (read_rd === true) {\n                    currd = await readObject(rdpath, rdmeta, globals, options);\n                } else {\n                    currd = await read_rd(sce.numberOfColumns(), rdpath, rdmeta, globals, options);\n                }\n                sce.setReducedDimension(rname, currd, { inPlace: true });\n            }\n        }\n    }\n\n    let read_ae = true;\n    if (\"SingleCellExperiment_readAlternativeExperiment\" in options) {\n        read_ae = options.SingleCellExperiment_readAlternativeExperiment;\n    }\n    if (read_ae !== false) {\n        const aepath = joinPath(path, \"alternative_experiments/names.json\");\n        if (await globals.exists(aepath)) {\n            let names_contents = await globals.get(aepath, { asBuffer: true });\n            const dec = new TextDecoder;\n            const altexp_names = JSON.parse(dec.decode(names_contents));\n            for (const [i, aname] of Object.entries(altexp_names)) {\n                let aepath = joinPath(path, \"alternative_experiments\", String(i));\n                let aemeta = await readObjectFile(aepath, globals);\n                let curae;\n                if (read_ae === true) {\n                    curae = await readObject(aepath, aemeta, globals, options);\n                } else {\n                    curae = await read_ae(sce.numberOfColumns(), aepath, aemeta, globals, options);\n                }\n                sce.setAlternativeExperiment(aname, curae, { inPlace: true });\n            }\n        }\n    }\n\n    return sce;\n}\n\n/**\n * @param {external:SingleCellExperiment} x - The single-cell experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveSingleCellExperiment(x, path, globals, options = {}) {\n    await saveRangedSummarizedExperiment(x, path, globals, options);\n\n    const existing = await readObjectFile(path, globals);\n    existing.type = \"single_cell_experiment\";\n    existing.single_cell_experiment = { \"version\": \"1.0\" };\n    let mexp = x.mainExperimentName();\n    if (mexp !== null) {\n        existing.single_cell_experiment.main_experiment_name = mexp;\n    }\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(existing));\n\n    const reddim_names = x.reducedDimensionNames();\n    if (reddim_names.length > 0) {\n        let rddir = joinPath(path, \"reduced_dimensions\");\n        await globals.mkdir(rddir);\n        await globals.write(joinPath(rddir, \"names.json\"), jsonBuffer(reddim_names));\n        for (const [i, rname] of Object.entries(reddim_names)) {\n            await saveObject(x.reducedDimension(rname), joinPath(rddir, String(i)), globals, options);\n        }\n    }\n\n    const altexp_names = x.alternativeExperimentNames();\n    if (altexp_names.length > 0) {\n        let aedir = joinPath(path, \"alternative_experiments\")\n        await globals.mkdir(aedir);\n        await globals.write(joinPath(aedir, \"names.json\"), jsonBuffer(altexp_names));\n        for (const [i, aname] of Object.entries(altexp_names)) {\n            await saveObject(x.alternativeExperiment(aname), joinPath(aedir, String(i)), globals, options);\n        }\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction extract_assay_details(handle) {\n    if (handle instanceof scran.H5DataSet) {\n        return {\n            rows: handle.shape[0],\n            columns: handle.shape[1],\n            sparse: false\n        };\n\n    } else if (handle instanceof scran.H5Group) {\n        let shape_info = handle.readAttribute(\"shape\");\n        let enc_info = handle.readAttribute(\"encoding-type\");\n        // Yes, the flip is deliberate, because of how H5AD puts its features in the columns.\n        return {\n            rows: shape_info.values[1],\n            columns: shape_info.values[0],\n            sparse: true,\n            csc: enc_info.values[0] == \"csr_matrix\" \n        }\n\n    } else {\n        throw new Error(\"unknown type for a H5AD assay matrix\");\n    }\n}\n\nfunction fetch_assay_details(handle, path) {\n    let available = [];\n    let types = {};\n    if (\"X\" in handle.children) {\n        available.push(\"X\");\n        types[\"X\"] = extract_assay_details(handle.open(\"X\"));\n    } \n\n    if (\"layers\" in handle.children) {\n        let lhandle = handle.open(\"layers\");\n        if (!(lhandle instanceof scran.H5Group)) {\n            throw new Error(\"expected a 'layers' group in a H5AD file\");\n        }\n        for (const k of Object.keys(lhandle.children)) {\n            const aname = \"layers/\" + k;\n            available.push(aname);\n            types[aname] = extract_assay_details(lhandle.open(k));\n        }\n    }\n\n    if (available.length == 0) {\n        throw new Error(\"failed to find any assay in the H5AD file\");\n    }\n\n    let deets = types[available[0]];\n    return {\n        names: available,\n        rows: deets.rows,\n        columns: deets.columns,\n        details: types\n    };\n}\n\nfunction load_data_frame(handle) {\n    let columns = {};\n\n    for (const [key, val] of Object.entries(handle.children)) {\n        if (val == \"DataSet\") {\n            let dhandle = handle.open(key, { load: true });\n            if (dhandle.type === \"Enum\") {\n                let dvals = dhandle.values;\n                let options = new Array(dvals.length);\n                let levels = dhandle.levels;\n                dvals.forEach((x, i) => {\n                    options[i] = levels[x];\n                });\n                columns[key] = options;\n            } else if (dhandle.type !== \"Other\") {\n                columns[key] = dhandle.values;\n            }\n\n        } else if (val == \"Group\") {\n            // Factor encoding for H5AD versions >= 0.8.0.\n            let subhandle = handle.open(key);\n            if (\"categories\" in subhandle.children && \"codes\" in subhandle.children) {\n                let current_levels = eutils.extractHdf5Strings(subhandle, \"categories\");\n                let codes = subhandle.open(\"codes\", { load: true }).values;\n                columns[key] = bioc.SLICE(current_levels, codes);\n            }\n        }\n    }\n\n    // Factor encoding for H5AD versions < 0.8.0.\n    if (\"__categories\" in handle.children && handle.children[\"__categories\"] == \"Group\") {\n        let chandle = handle.open(\"__categories\");\n\n        for (const [key, val] of Object.entries(chandle.children)) {\n            if (key in columns) {\n                let current_levels = eutils.extractHdf5Strings(chandle, key);\n                if (!current_levels) {\n                    console.warn(`ignoring invalid levels for nominally categorical key '${key}' in the H5AD reader`)\n                    continue;\n                }\n                columns[key] = bioc.SLICE(current_levels, columns[key]);\n            }\n        }\n    }\n\n    if (Object.keys(columns).length == 0) {\n        return null;\n    } else {\n        let rn = null;\n        if (\"_index\" in columns) {\n            rn = columns._index;\n            delete columns._index;\n        }\n        return new bioc.DataFrame(columns, { rowNames: rn });\n    }\n}\n\nfunction fetch_features(handle) {\n    if (\"var\" in handle.children && handle.children[\"var\"] == \"Group\") {\n        let vhandle = handle.open(\"var\");\n        return load_data_frame(vhandle);\n    }\n    return null;\n}\n\nfunction fetch_cells(handle) {\n    if (\"obs\" in handle.children && handle.children[\"obs\"] == \"Group\") {\n        let ohandle = handle.open(\"obs\");\n        return load_data_frame(ohandle);\n    }\n    return null;\n}\n\nfunction load_matrix(path, name, details, options) {\n    if (details.sparse) {\n        return scran.initializeSparseMatrixFromHdf5Group(path, name, details.rows, details.columns, !(details.csc), options);\n    } else {\n        return scran.initializeSparseMatrixFromHdf5Dataset(path, name, options);\n    }\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset in the H5AD format.\n */\nexport class H5adDataset {\n    #h5_file;\n    #h5_path;\n    #h5_flush;\n    #h5_handle;\n\n    #raw_features;\n    #raw_cells;\n    #assay_details;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"h5\", file: fun(this.#h5_file) }]; \n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a H5AD file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = H5adDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode H5adDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            countMatrixName: null, \n            featureTypeColumnName: null, \n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: null,\n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode H5adDataset#load load} (but not {@linkcode H5adDataset#summary summary}).\n     * @param {?string} [options.countMatrixName] - Name of the layer containing the count matrix.\n     * If `null`, the \"X\" dataset is used if it is present in the file, or the first available layer if no \"X\" dataset is present.\n     * @param {?string} [options.featureTypeColumnName] - Name of the per-feature annotation column containing the feature types.\n     * If `null`, no column is assumed to contain feature type information.\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset (i.e., `featureTypeColumnName = null`), all features are considered to be genes by default.\n     * This behavior can also be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #instantiate() {\n        if (this.#h5_path != null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n        this.#h5_handle = new scran.H5File(this.#h5_path);\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory. \n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode H5adDataset#load load} or {@linkcodeH5adDataset#summary summary}.\n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n        this.#h5_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#assay_details = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"H5AD\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #fetch_assay_details() {\n        if (this.#assay_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        this.#assay_details = fetch_assay_details(this.#h5_handle, this.#h5_path);\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let feats = fetch_features(this.#h5_handle);\n        if (feats == null) {\n            this.#fetch_assay_details();\n            feats = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.rows });\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let cells = fetch_cells(this.#h5_handle);\n        if (cells === null) {\n            this.#fetch_assay_details();\n            cells = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.columns })\n        }\n\n        this.#raw_cells = cells;\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `all_features`: a {@linkplain external:DataFrame DataFrame} of per-feature annotations.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `all_assay_names`: an Array of strings containing names of potential count matrices.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n\n        let output = {\n            all_features: this.#raw_features,\n            cells: this.#raw_cells,\n            all_assay_names: this.#assay_details.names\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode H5adDataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, this.#options.featureTypeColumnName, this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode H5adDataset#defaults defaults} or with {@linkcode H5adDataset#setOptions setOptions}.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n\n        let chosen_assay = this.#options.countMatrixName;\n        if (chosen_assay == null) {\n            chosen_assay = this.#assay_details.names[0];\n        }\n\n        let loaded = load_matrix(this.#h5_path, chosen_assay, this.#assay_details.details[chosen_assay], { forceInteger: true, layered: true }); \n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, this.#options.featureTypeColumnName, this.#feature_type_mapping(), \"RNA\");\n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode H5adDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {H5adDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"h5\") {\n            throw new Error(\"expected exactly one file of type 'h5' for H5AD unserialization\");\n        }\n        let output = new H5adDataset(files[0].file);\n        output.setOptions(options);\n        return output;\n    }\n}\n\n/************************\n ******* Results ********\n ************************/\n\n/**\n * Pre-computed analysis results in the H5AD format.\n */\nexport class H5adResult {\n    #h5_file;\n    #h5_path;\n    #h5_flush;\n    #h5_handle;\n\n    #raw_features;\n    #raw_cells;\n    #assay_details;\n    #reddim_details;\n\n    #options;\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a H5AD file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = H5adResult.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode H5adResult#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryMatrixName: null, \n            isPrimaryNormalized: true,\n            featureTypeColumnName: null, \n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode H5adResult#load load} (but not {@linkcode H5adResult#summary summary}).\n     * @param {?string} [options.primaryMatrixName] - Name of the layer containing the primary matrix.\n     * If `null`, the \"X\" dataset is used if it is present in the file, or the first available layer if no \"X\" dataset is present.\n     * @param {boolean} [options.isPrimaryNormalized] - Whether the primary matrix is already normalized.\n     * If `false`, it is assumed to contain count data and is subjected to library size normalization within each modality.\n     * @param {?string} [options.featureTypeColumnName] - Name of the per-feature annotation column containing the feature types.\n     * If `null`, no column is assumed to contain the feature types, and all features are assumed to be genes (i.e., only the RNA modality is present).\n     * @param {?Array} [options.reducedDimensionNames=null] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            if (k == \"reducedDimensionNames\") {\n                this.#options[k] = bioc.CLONE(v); // avoid pass-by-reference links.\n            } else {\n                this.#options[k] = v;\n            }\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory. \n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode H5adResult#load load} or {@linkcode H5adResult#summary summary}.\n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n        this.#h5_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#assay_details = null;\n        this.#reddim_details = null;\n    }\n\n    #instantiate() {\n        if (this.#h5_path != null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n        this.#h5_handle = new scran.H5File(this.#h5_path);\n    }\n\n    #fetch_assay_details() {\n        if (this.#assay_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        this.#assay_details = fetch_assay_details(this.#h5_handle, this.#h5_path);\n        return;\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let feats = fetch_features(this.#h5_handle);\n        if (feats == null) {\n            this.#fetch_assay_details();\n            feats = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.rows });\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let cells = fetch_cells(this.#h5_handle);\n        if (cells === null) {\n            this.#fetch_assay_details();\n            cells = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.columns })\n        }\n\n        this.#raw_cells = cells;\n        return;\n    }\n\n    #fetch_reddim_details() {\n        if (this.#reddim_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        \n        let available = [];\n        if (\"obsm\" in this.#h5_handle.children && this.#h5_handle.children[\"obsm\"] == \"Group\") {\n            let ohandle = this.#h5_handle.open(\"obsm\");\n            for (const [k, v] of Object.entries(ohandle.children)) {\n                if (v == \"DataSet\") {\n                    available.push(k);\n                }\n            }\n        }\n\n        this.#reddim_details = { names: available };\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode H5adResult#load load}.\n     * If `true`, users should consider calling {@linkcode H5adResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `all_features`: a {@linkplain external:DataFrame DataFrame} of per-feature annotations.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `all_assay_names`: an Array of strings containing names of potential primary matrices.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n        this.#fetch_reddim_details();\n\n        let output = {\n            all_features: this.#raw_features,\n            cells: this.#raw_cells,\n            all_assay_names: this.#assay_details.names,\n            reduced_dimension_names: this.#reddim_details.names\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode H5adResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode H5adResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n        this.#fetch_reddim_details();\n\n        let chosen_assay = this.#options.primaryMatrixName;\n        if (chosen_assay == null) {\n            chosen_assay = this.#assay_details.names[0];\n        }\n        let loaded = load_matrix(this.#h5_path, chosen_assay, this.#assay_details.details[chosen_assay], { forceInteger: !this.#options.isPrimaryNormalized });\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, this.#options.featureTypeColumnName, null, \"\");\n        output.cells = this.#raw_cells;\n\n        if (!this.#options.isPrimaryNormalized) {\n            for (const mod of output.matrix.available()) {\n                let mat = output.matrix.get(mod);\n                output.matrix.add(mod, scran.normalizeCounts(mat, { allowZeros: true }));\n            }\n        }\n\n        // Loading the dimensionality reduction results.\n        let chosen_reddims = this.#options.reducedDimensionNames;\n        if (chosen_reddims == null) {\n            chosen_reddims = this.#reddim_details.names;\n        }\n\n        let reddims = {};\n        if (chosen_reddims.length) {\n            let ohandle = this.#h5_handle.open(\"obsm\");\n            for (const k of chosen_reddims) {\n                let loaded = ohandle.open(k, { load: true });\n                let shape = loaded.shape;\n                let ncells = shape[0];\n                let ndims = shape[1];\n                let transposed = scran.transposeMatrix(ncells, ndims, loaded.values, { columnMajor: false }); // HDF5 stores matrices in row-major format.\n                let contents = [];\n                for (var d = 0; d < ndims; d++) {\n                    let offset = d * ncells;\n                    contents.push(transposed.slice(offset, offset + ncells));\n                }\n                reddims[k] = contents;\n            }\n        }\n        output.reduced_dimensions = reddims;\n        \n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n}\n","import * as adb from \"./ArtifactDB-abstract.js\";\nimport JSZip from \"jszip\";\nimport * as afile from \"./abstract/file.js\";\n\nclass ZippedProjectNavigator {\n    #zipfile;\n    #ziphandle;\n\n    constructor(zipfile, ziphandle) {\n        this.#zipfile = zipfile;\n        this.#ziphandle = null;\n    }\n\n    async file(path) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n        return await this.#ziphandle.file(path).async(\"uint8array\");\n    }\n\n    async metadata(path) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n\n        while (1) {\n            if (!path.endsWith(\".json\")) { \n                path += \".json\";\n            }\n\n            let contents = await this.#ziphandle.file(path).async(\"string\");\n            let values = JSON.parse(contents);\n\n            if (values[\"$schema\"].startsWith(\"redirection/\")){\n                path = values.redirection.targets[0].location;\n            } else {\n                return values;\n            }\n        }\n    }\n\n    clear() {\n        this.#ziphandle = null;\n    }\n};\n\n/**\n * Search a ZIP file for SummarizedExperiments to use in {@linkplain ZippedArtifactdbDataset} or {@linkplain ZippedArtifactdbResult}.\n *\n * @param {JSZip} handle - A handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n * \n * @return {Map} Object where the keys are the paths/names of possible SummarizedExperiment objects,\n * and each value is a 2-element array of dimensions.\n */\nexport async function searchZippedArtifactdb(handle) {\n    // Sorting by the number of slashes.\n    let all_json = [];\n    for (const name of Object.keys(handle.files)) {\n        if (name.endsWith(\".json\")) {\n            all_json.push({ name: name, path: name.split(\"/\") });\n        }\n    }\n    all_json.sort((a, b) => a.path.length - b.path.length);\n\n    let found_se = new Map;\n    let nonchildren = new Map;\n    let redirects = new Map;\n\n    for (const x of all_json) {\n        // Avoid loading JSONs for files in subdirectories of known SEs.\n        let current = found_se;\n        let already_found = false;\n\n        for (const comp of x.path) {\n            let val = current.get(comp);\n            if (typeof val === \"undefined\") {\n                val = new Map;\n                current.set(comp, val);\n            } else if (val === null) {\n                already_found = true;\n                break;\n            }\n            current = val;\n        }\n\n        // Otherwise, we load it in and peel out some information.\n        if (!already_found) {\n            let contents = await handle.file(x.name).async(\"string\");\n            let values = JSON.parse(contents);\n            if (\"summarized_experiment\" in values) {\n                nonchildren.set(values.path, values.summarized_experiment.dimensions);            \n            } else if (values[\"$schema\"].startsWith(\"redirection/\")) {\n                redirects.set(values.path, values.redirection.targets[0].location);\n            }\n        }\n    }\n\n    for (const [rr, loc] of redirects) {\n        let found = nonchildren.get(loc);\n        if (typeof found !== \"undefined\") {\n            nonchildren.delete(loc);\n            nonchildren.set(rr, found);\n        }\n    }\n\n    return nonchildren;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset as a ZIP file containing a SummarizedExperiment in the **ArtifactDB** representation,\n * e.g., as produced by {@linkcode saveSingleCellExperiment}.\n * Specifically, the ZIP file should contain the contents of an **ArtifactDB** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractArtifactdbDataset\n */\nexport class ZippedArtifactdbDataset extends adb.AbstractArtifactdbDataset {\n    #zipfile;\n    #name;\n\n    /**\n     * @param {string} name - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedArtifactdbDataset instance.\n     */\n    constructor(name, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle);\n        super(name, nav);\n        this.#zipfile = zipfile;\n        this.#name = name;\n    }\n\n    /**\n     * @return {string} String specifying the format for this dataset.\n     */\n    static format() {\n        return \"ArtifactDB-zipped\";\n    }\n\n    #dump_summary(fun) {\n        let files = [ { type: \"zip\", file: fun(this.#zipfile) } ]; \n        let opt = this.options();\n        opt.datasetName = this.#name; // storing the name as a special option... can't be bothered to store it as a separate file.\n        return { files: files, options: opt };\n\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { \n            return { size: f.size(), name: f.name() }\n        });\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ZippedArtifactdbDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ZippedArtifactdbDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"zip\") {\n            throw new Error(\"expected exactly one file of type 'zip' for Zipped ArtifactDB unserialization\");\n        }\n\n        let name = options.datasetName;\n        delete options.datasetName;\n\n        let output = new ZippedArtifactdbDataset(name, files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Result as a ZIP file containing a SummarizedExperiment in the **ArtifactDB** representation,\n * e.g., as produced by {@linkcode saveSingleCellExperiment}.\n * Specifically, the ZIP file should contain the contents of an **ArtifactDB** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractArtifactdbResult\n */\nexport class ZippedArtifactdbResult extends adb.AbstractArtifactdbResult {\n    /**\n     * @param {string} name - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedArtifactdbDataset instance.\n     */\n    constructor(name, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle);\n        super(name, nav);\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\nclass IndexedNames {\n    constructor(names) {\n        this._names = names;\n        this._lookup = new Map;\n    }\n\n    names() {\n        return this._names;\n    }\n\n    nameToIndexUncached(name) {\n        if (this._lookup.has(name)) {\n            return this._lookup.get(name);\n        }\n        return this._names.indexOf(name);\n    }\n\n    nameToIndex(name, { error = true } = {}) {\n        if (this._lookup.has(name)) {\n            return this._lookup.get(name);\n        }\n\n        for (var i = this._lookup.size; i < this._names.length; i++) {\n            const current = this._names[i];\n            if (this._lookup.has(current)) {\n                continue; // only keep the first instance of a duplicated name.\n            }\n            this._lookup.set(current, i);\n            if (this._names[i] == name) {\n                return i;\n            }\n        }\n\n        if (error) {\n            throw new Error(\"no matching name for '\" + name + \"' in this \" + this.constructor.className);\n        } else {\n            return -1;\n        }\n    }\n\n    indexToName(i) {\n        return this._names[i];\n    }\n\n    append(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        }\n        target._names.push(name);\n        return target;\n    }\n\n    set(i, name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        } else {\n            if (target._lookup.size > i) { // if the lookup never got to that point, we don't have to wipe it.\n                target._lookup = new Map;\n            }\n        }\n        target._names[i] = name;\n        return target;\n    }\n\n    delete(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        } else {\n            if (target._lookup.size > i) { // i.e., if the lookup never got to that point, we don't have to wipe it.\n                target._lookup = new Map;\n            }\n        }\n        target._names.splice(i, 1);\n        return target;\n    }\n\n    _bioconductor_CLONE({ deepCopy = true }) {\n        let output = new this.constructor;\n        output._names = cutils.cloneField(this._names, deepCopy);\n        output._lookup = cutils.cloneField(this._lookup, deepCopy);\n        return output;\n    }\n}\n\n/**\n * An R-style list with optional names.\n * Callers can get/set individual elements by positional index or name.\n * Operations like slicing and combining will apply to both the values and names.\n *\n * The List defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * We explicitly allow duplicates in the names to avoid errors when slicing or combining.\n * Otherwise, it would be impossible to construct a slice with duplicate indices or to combine multiple `List` instances with shared names.\n *\n * Constructors of List subclasses should be callable with no arguments, possibly creating an empty object with no properties.\n * This will be used by the `_bioconductor_CLONE`, `_bioconductor_SLICE` and `_bioconductor_COMBINE` methods to return an instance of the subclass.\n */\nexport class List {\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * For Maps or objects, the values (in order of iteration) are used as the List elements.\n     * If no argument is supplied, it defaults to an empty Array.\n     * @param {Object} [options={}] - Further options.\n     * @param {?Array} [options.names=null] - An array of strings containing the names of the List elements.\n     * If provided, this should be of the same length as `values`.\n     * If `values` is a Map or object, `names` should have the same keys.\n     * If `values` is an array, the names may contain duplicate strings.\n     * If `null` and `values` is an array, the List will be unnamed.\n     */\n    constructor(values, { names = null } = {}) {\n        if (arguments.length == 0) {\n            this._values = [];\n            this._names = null;\n            return;\n        }\n\n        if (values instanceof Array) {\n            if (names !== null) {\n                if (names.length != values.length) {\n                    throw new Error(\"'names' and 'values' should have the same length\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                }\n                names = new IndexedNames(names);\n            }\n\n            this._values = values;\n            this._names = names;\n\n        } else if (values instanceof Map) {\n            let arr = [];\n            if (names == null) {\n                names = [];\n                for (const [n, v] of values) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"keys of 'values' should be strings\");\n                    }\n                    names.push(n);\n                    arr.push(v);\n                }\n\n            } else {\n                if (names.length != values.size) {\n                    throw new Error(\"size of 'values' should be equal to length of 'names'\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                    if (!values.has(n)) {\n                        throw new Error(\"missing name '\" + n + \"' in 'values'\");\n                    }\n                    arr.push(values.get(n));\n                }\n            }\n\n            this._values = arr;\n            this._names = new IndexedNames(names);\n\n        } else {\n            let arr = [];\n            if (names == null) {\n                names = [];\n                for (const [n, v] of Object.entries(values)) {\n                    names.push(n);\n                    arr.push(v);\n                }\n\n            } else {\n                if (names.length != Object.keys(values).length) {\n                    throw new Error(\"size of 'values' should be equal to length of 'names'\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                    if (!(n in values)) {\n                        throw new Error(\"missing name '\" + n + \"' in 'values'\");\n                    }\n                    arr.push(values[n]);\n                }\n            }\n\n            this._values = arr;\n            this._names = new IndexedNames(names);\n        }\n    }\n\n    /**\n     * @return {?Array} Array of names of the List elements, or `null` if the List is unnamed.\n     */\n    names() {\n        if (this._names == null) {\n            return null;\n        } else {\n            return this._names.names();\n        }\n    }\n\n    /**\n     * @return {Array} Array containing the List elements.\n     */\n    values() {\n        return this._values;\n    }\n\n    /**\n     * @return {number} Length of the list.\n     */\n    length() {\n        return this._values.length;\n    }\n\n    static className = \"List\";\n\n    /***********************************************/\n\n    #check_index(i) {\n        if (i < 0 || i >= this._values.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to retrieve.\n     * This should be non-negative and less than {@linkcode List#length length}.\n     * @return The `i`-th List element.\n     */\n    getByIndex(i) {\n        this.#check_index(i);\n        return this._values[i];\n    }\n\n    /**\n     * @param {string} name - Name of the List element to retrieve.\n     * This should be present in {@linkcode List#names names}.\n     * @return The List element corresponding to `name`.\n     * If duplicates of `name` are present in the list, the first occurrence is returned.\n     */\n    getByName(name) {\n        if (this._names === null) {\n            throw new Error(\"no available names in this \" + this.constructor.className);\n        }\n        let candidate = this._names.nameToIndex(name);\n        return this._values[candidate];\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the List element to retrieve.\n     * Numbers are passed to {@linkcode List#getByIndex getByIndex} and strings are passed to {@linkcode List#getByName getByName}.\n     * @return The List element at/for `i`.\n     */\n    get(i) {\n        if (typeof i == \"number\") {\n            return this.getByIndex(i);\n        } else {\n            return this.getByName(i);\n        }\n    }\n\n    /**\n     * @param {string} name - Name of a List element.\n     * @return {boolean} Whether the name exists in this List.\n     */\n    has(name) {\n        return this.nameToIndex(name) >= 0;\n    }\n\n    /**\n     * @param {string} name - Name of a List element.\n     * @return {number} Index of the name in {@linkcode List#names names}.\n     * If duplicate names are present, the first occurrence is returned.\n     * If the name is not present, -1 is returned.\n     */\n    nameToIndex(name) {\n        return this._names.nameToIndex(name, { error: false });\n    }\n\n    /***********************************************/\n\n    /**\n     * @return {Array} Array of values, equivalent to {@linkcode List#values values}.\n     */\n    toArray() {\n        return this._values;\n    }\n\n    /**\n     * @return {Map} Map of name-value pairs.\n     * If duplicate names are present, only the value for the first occurrence is reported.\n     * If the List is unnamed, an error is thrown.\n     */\n    toMap() {\n        if (this._names == null) {\n            throw new Error(\"no available names in this '\" + this.constructor.className + \"'\");\n        }\n        let output = new Map;\n        let names = this._names.names();\n        for (var i = 0; i < this._values.length; i++) {\n            const curname = names[i];\n            if (output.has(curname)) {\n                continue;\n            }\n            output.set(curname, this._values[i]);\n        }\n        return output;\n    }\n\n    /**\n     * @return {Object} Object of name-value pairs.\n     * If duplicate names are present, only the value for the first occurrence is reported.\n     * If the List is unnamed, an error is thrown.\n     */\n    toObject() {\n        if (this._names == null) {\n            throw new Error(\"no available names in this '\" + this.constructor.className + \"'\");\n        }\n        let output = {};\n        let names = this._names.names();\n        for (var i = 0; i < this._values.length; i++) {\n            const curname = names[i];\n            if (curname in output) {\n                continue;\n            }\n            output[curname] = this._values[i];\n        }\n        return output;\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} i - Index of the List element to set.\n     * This should be non-negative and no greater than {@linkcode List#length length}.\n     * If `i` is less than `length`, the `i`-th element is replaced by `x`.\n     * If `i` is equal to `length`, `x` is appended to the end of the list.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - Name for the List element at `i`.\n     * If `i` is less than `length`, the name of the `i`-th element is replaced by `name`.\n     * If `i` is equal to `length`, the name of the newly-appended element is set to `name`.\n     * If the List did not previously have any names, the names of all other elements are set to an empty string.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setByIndex(i, x, { name = null, inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (i < 0 || i > this._values.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n\n        if (i == target._values.length) {\n            target._values.push(x);\n            if (name == null) {\n                if (target._names != null) {\n                    target._names = target._names.append(\"\", { inPlace });\n                }\n\n            } else {\n                if (typeof name != \"string\") {\n                    throw new Error(\"'name' should be a string\");\n                }\n                if (target._names == null) {\n                    const new_names = new Array(target._values.length).fill(\"\");\n                    new_names[i] = name;\n                    target._names = new IndexedNames(new_names);\n                } else {\n                    target._names = target._names.append(name, { inPlace });\n                }\n            }\n\n        } else {\n            target._values[i] = x;\n            if (name !== null) {\n                if (target._names === null) {\n                    const new_names = new Array(target._values.length).fill(\"\");\n                    new_names[i] = name;\n                    target._names = new IndexedNames(new_names);\n                } else {\n                    target._names = target._names.set(i, name, { inPlace });\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set.\n     * If this already exists in {@linkcode List#names names}, the corresponding element is replaced by `x`.\n     * Otherwise, `x` is appended to the List with the name `name`.\n     * If the List did not previously have any names, the names of all other elements are set to an empty string.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setByName(name, x, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (target._names !== null) {\n            let candidate = target._names.nameToIndex(name, { error: false });\n            if (candidate < 0) {\n                target._values.push(x);\n                target._names = target._names.append(name, { inPlace });\n            } else {\n                target._values[candidate] = x;\n            }\n        } else {\n            const new_names = new Array(target._values.length).fill(\"\");\n            new_names.push(name);\n            target._names = new IndexedNames(new_names);\n            target._values.push(x);\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the list element to set.\n     * Numbers are passed to {@linkcode List#setByIndex setByIndex} and strings are passed to {@linkcode List#setByName setByName}.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * Only used if `i` is a number.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    set(i, x, { name = null, inPlace = false } = {}) {\n        if (typeof i == \"number\") {\n            return this.setByIndex(i, x, { name, inPlace });\n        } else {\n            return this.setByName(i, x, { inPlace });\n        }\n    }\n\n    /**\n     * @param {?Array} names - Array of strings of length equal to {@linkcode List#length length}.\n     * This may contain duplicates.\n     * Alternatively `null`, to remove existing names.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after replacing the names with `names`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (names !== null) {\n            if (names.length != this._values.length) {\n                throw new Error(\"'names' and 'values' should have the same length\");\n            }\n            for (const n of names) {\n                if (typeof n != \"string\") {\n                    throw new Error(\"'names' should be an array of strings\");\n                }\n            }\n        }\n\n        target._names = new IndexedNames(names);\n        return target;\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} i - Index of the List element to delete.\n     * This should be non-negative and no less than {@linkcode List#length length}.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `i`-th element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    deleteByIndex(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        this.#check_index(i);\n        target._values.splice(i, 1);\n        if (target._names !== null) {\n            target._names = target._names.delete(i, { inPlace });\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string} name - Name of the List element to delete.\n     * This should already exist in {@linkcode List#names names}.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `name`d element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    deleteByName(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (target._names == null) {\n            throw new Error(\"no available names in this \" + this.constructor.className);\n        }\n\n        // Don't cache as we're going to reset the lookup immediately, so it would be needlessly inefficient.\n        let candidate = this._names.nameToIndexUncached(name);\n        if (candidate < 0) {\n            throw new Error(\"no matching name for '\" + name + \"' in this \" + this.constructor.className);\n        }\n\n        target._values.splice(candidate, 1);\n        if (target._names !== null) {\n            target._names = target._names.delete(candidate, { inPlace });\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the List element to delete.\n     * Numbers are passed to {@linkcode List#deleteByIndex deleteByIndex} and strings are passed to {@linkcode List#deleteByName deleteByName}.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `i`-th element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    delete(i, { inPlace = false } = {}) {\n        if (typeof i == \"number\") {\n            return this.deleteByIndex(i, { inPlace });\n        } else {\n            return this.deleteByName(i, { inPlace });\n        }\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} start - Index of the first element in the slice.\n     * @param {number} end - Index past the last element in the slice.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} A List that is sliced to `[start, end)`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceRange(start, end, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        target._values = target._values.slice(start, end);\n        if (this._names !== null) {\n            target._names = new IndexedNames(target._names.names().slice(start, end));\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} indices - Array of numbers or strings specifying the List elements to retain in the slice.\n     * Numbers are interpreted as positional indices while strings are interpreted as names.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} A List containing the specified elements in `indices`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceIndices(indices, { inPlace = false } = {}) {\n        let new_names = [];\n        let new_values = [];\n\n        for (let i of indices) {\n            if (typeof i == \"string\") {\n                if (this._names == null) {\n                    throw new Error(\"no available names in this \" + this.constructor.className);\n                }\n                i = this._names.nameToIndex(i);\n            } else {\n                this.#check_index(i);\n            }\n\n            new_values.push(this._values[i]);\n            if (this._names !== null) {\n                new_names.push(this._names.indexToName(i));\n            }\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._values = new_values;\n        if (this._names !== null) {\n            target._names = new IndexedNames(new_names);\n        }\n\n        target._lookup = new Map;\n        return target;\n    }\n\n    /***********************************************/\n\n    /**\n     * @return {iterator} An iterable iterator that can be used in, e.g., `for...of` constructs to loop over the List.\n     * The list values are directly returned during iteration, i.e., names are ignored.\n     */\n    [Symbol.iterator]() {\n        let counter = 0;\n        let all_values = this._values;\n        return {\n            next: function() {\n                if (counter < all_values.length) {\n                    let val = all_values[counter];\n                    counter++;\n                    return { done: false, value: val };\n                } else {\n                    return { done: true };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        }\n    }\n\n    /***********************************************/\n\n    _bioconductor_LENGTH() {\n        return this.length();\n    }\n\n    _bioconductor_SLICE(i, { allowView = false }) {\n        let sliced = this.sliceIndices(i);\n        let output = new this.constructor;\n        output._values = sliced._values;\n        output._names = sliced._names;\n        return output;\n    }\n\n    _bioconductor_CLONE({ deepCopy = true }) {\n        let output = new this.constructor;\n        output._values = cutils.cloneField(this._values, deepCopy);\n        output._names = cutils.cloneField(this._names, deepCopy);\n        return output;\n    }\n\n    _bioconductor_COMBINE(objects) {\n        let all_values = this._values.slice();\n        let all_names = null;\n        if (this._names !== null) {\n            all_names = this.names().slice();\n        }\n\n        for (let x of objects) {\n            if (!(x instanceof List)) {\n                x = new List(x);\n            }\n\n            const xvals = x.values();\n            for (const y of xvals) {\n                all_values.push(y);\n            }\n\n            const xnames = x.names();\n            if (xnames === null) {\n                if (all_names !== null) {\n                    for (const y of xvals) {\n                        all_names.push(\"\");\n                    }\n                }\n            } else {\n                if (all_names === null) {\n                    all_names = new Array(all_values.length - xvals.length).fill(\"\");\n                }\n                for (const yn of xnames) {\n                    all_names.push(yn);\n                }\n            }\n        }\n\n        let output = new this.constructor;\n        output._values = all_values;\n        output._names = new IndexedNames(all_names);\n        return output;\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains integers or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class IntegerList extends List {\n    #sanitize(x) {\n        if (x !== null && !Number.isInteger(x)) {\n            throw new Error(\"only integers or nulls can be stored in an IntegerList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain integers or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?number} x - Value of a List element as an integer or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?number} x - Value of a List element as an integer or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains numbers or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class NumberList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"number\") {\n            throw new Error(\"only numbers or nulls can be stored in a NumberList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain numbers or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?number} x - Value of a List element as a number or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?number} x - Value of a List element as a number or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains strings or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class StringList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"string\") {\n            throw new Error(\"only strings or nulls can be stored in a StringList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain strings or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?boolean} x - Value of a List element as a string or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?boolean} x - Value of a List element as a string or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains booleans or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class BooleanList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"boolean\") {\n            throw new Error(\"only booleans or nulls can be stored in a StringList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain booleans or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?boolean} x - Value of a List element as a boolean or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?boolean} x - Value of a List element as a boolean or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as rutils from \"../readers/index.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as norm_module from \"./rna_normalization.js\";\n\nconst baseUrl = \"https://github.com/kanaverse/singlepp-references/releases/download/2023-04-28\";\n\nexport const step_name = \"cell_labelling\";\n\n/************************************\n ****** Internals for loading *******\n ************************************/\n\nvar download_fun  = utils.defaultDownload;\n\nfunction set_download(fun) {\n    let previous = download_fun;\n    download_fun = fun;\n    return previous;\n}\n\nasync function acquire_file(name, suffix) {\n    let full = name + \"_\" + suffix;\n    let b = await download_fun(baseUrl + \"/\" + full);\n    return new rutils.SimpleFile(b, { name: full })\n}\n\nconst all_loaded = {};\n\nfunction flush_prepared(cache) {\n    if (\"prepared\" in cache) {\n        for (const v of Object.values(cache.prepared)) {\n            v.built.raw.free();\n        }\n        delete cache.prepared;\n    }\n}\n\nasync function process_genes(file) {\n    let gene_lines = await rutils.readLines2(file.content(), { compression: \"gz\" }); // gene names\n    let acquired = [];\n\n    for (const x of gene_lines) {\n        let val = null;\n        if (x !== \"\") {\n            val = x.split(\"\\t\");\n            if (val.length == 1) {\n                val = val[0];\n            }\n        }\n        acquired.push(val);\n    }\n\n    return acquired;\n}\n\nasync function load_reference(name, gene_id_type) {\n    let gene_suffix = \"genes_\" + gene_id_type.toLowerCase() + \".csv.gz\";\n\n    if (name in all_loaded) {\n        let output = all_loaded[name];\n        let known_genes = output.genes;\n        if (!(gene_id_type in known_genes)) {\n            known_genes[gene_id_type] = await process_genes(await acquire_file(name, gene_suffix));\n        }\n        return output;\n    }\n\n    const suffixes = [ \n        \"labels_fine.csv.gz\",\n        \"label_names_fine.csv.gz\",\n        \"markers_fine.gmt.gz\",\n        \"matrix.csv.gz\",\n        gene_suffix\n    ];\n\n    let contents = await Promise.all(suffixes.map(x => acquire_file(name, x)));\n\n    let loaded;\n    let stored;\n    try {\n        loaded = scran.loadLabelCellsReferenceFromBuffers(\n            contents[3].buffer(), // rank matrix\n            contents[2].buffer(), // markers\n            contents[0].buffer()  // label per sample\n        );\n\n        let labels = await rutils.readLines2(contents[1].content(), { compression: \"gz\" }); // full label names\n        stored = {\n            \"raw\": loaded, \n            \"labels\": labels,\n            \"genes\": {}\n        };\n\n        stored.genes[gene_id_type] = await process_genes(contents[4]);\n        all_loaded[name] = stored;\n\n    } catch (e) {\n        utils.freeCache(loaded);\n        throw e;\n    }\n\n    return stored;\n}\n\nfunction flush_loaded() {\n    for (const [k, v] of Object.entries(all_loaded)) {\n        v.raw.free();\n        delete all_loaded[k];\n    }\n}\n\n/*************************************\n ****** Internals for building *******\n *************************************/\n\nconst available_references = {\n    \"9606\": [ \"BlueprintEncode\", \"DatabaseImmuneCellExpression\", \"HumanPrimaryCellAtlas\", \"MonacoImmune\", \"NovershternHematopoietic\" ],\n    \"10090\": [ \"ImmGen\", \"MouseRNAseq\" ]\n};\n\nfunction internal_build_reference(name, gene_ids, gene_id_type) {\n    let built;\n    let output;\n    try {\n        let current = all_loaded[name];\n        let loaded = current.raw;\n\n        if (!(gene_id_type in current.genes)) {\n            throw new Error(\"unknown gene type '\" + gene_id_type + \"'\");\n        }\n        let chosen_ids = current.genes[gene_id_type];\n\n        built = scran.trainLabelCellsReference(gene_ids, loaded, chosen_ids); \n        output = {\n            \"loaded\": current,\n            \"built\": {\n                \"features\": chosen_ids,\n                \"raw\": built\n            }\n        };\n\n    } catch (e) {\n        utils.freeCache(built);\n        throw e;\n    }\n\n    return output;\n}\n\nasync function build_reference(cache, references, guess_ids, species, gene_id_column, gene_id_type, old_parameters, annofun, guessfun) {\n    if (\n        guess_ids !== old_parameters.guess_ids ||\n        utils.changedParameters(references, old_parameters.references) ||\n        (\n            !guess_ids &&\n            (\n                species !== old_parameters.species ||\n                gene_id_column !== old_parameters.gene_id_column ||\n                gene_id_type !== old_parameters.gene_id_type\n            )\n        )\n    ) {\n        let species2 = species;\n        let gene_id_column2 = gene_id_column;\n        let gene_id_type2 = gene_id_type;\n\n        if (guess_ids) {\n            let auto = CellLabellingState.configureFeatureParameters(guessfun());\n            species2 = auto.species;\n            gene_id_column2 = auto.gene_id_column;\n            gene_id_type2 = auto.gene_id_type;\n        }\n\n        let allowable = new Set;\n        for (const s of species2) {\n            if (s in available_references) {\n                available_references[s].forEach(x => { allowable.add(x); });\n            }\n        }\n\n        // Building each individual reference.\n        let feats = annofun();\n        let gene_ids = (gene_id_column2 == null ? feats.rowNames() : feats.column(gene_id_column2));\n        cache.gene_ids = gene_ids;\n\n        let valid = {};\n        if (gene_ids !== null) {\n            if (references == null) {\n                references = Array.from(allowable);\n            }\n            for (const ref of references) {\n                if (allowable.has(ref)) {\n                    await load_reference(ref, gene_id_type2);\n                    valid[ref] = internal_build_reference(ref, gene_ids, gene_id_type2);\n                }\n            }\n        }\n\n        flush_prepared(cache);\n        cache.prepared = valid;\n\n        // Building an integrated reference, if necessary.\n        let used_refs = Object.keys(valid);\n        if (used_refs.length > 1) {\n            let arr = Object.values(valid);\n            let loaded = arr.map(x => x.loaded.raw);\n            let feats = arr.map(x => x.built.features);\n            let built = arr.map(x => x.built.raw);\n\n            utils.freeCache(cache.integrated);\n            cache.integrated = scran.integrateLabelCellsReferences(gene_ids, loaded, feats, built);\n        } else {\n            utils.freeCache(cache.integrated);\n            delete cache.integrated;\n        }\n        cache.used_refs = used_refs;\n\n       return true;\n    }\n\n    return false;\n}\n\nfunction create_defaults() {\n    return {\n        references: null,\n        guess_ids: true,\n        species: [],\n        gene_id_column: null,\n        gene_id_type: \"ENSEMBL\"\n    };\n}\n\nfunction dereference_parameters(parameters) {\n    parameters.references = bioc.CLONE(parameters.references); // make a copy to avoid pass-by-reference behavior.\n    parameters.species = bioc.CLONE(parameters.species);\n    return parameters;\n}\n\nfunction fetch_parameters(parameters) {\n    // Avoid pass-by-reference behavior.\n    let out = { ...parameters };\n    out.references = bioc.CLONE(out.references);\n    out.species = bioc.CLONE(out.species);\n    return out;\n}\n\n/************************************\n ****** Internals for compute *******\n ************************************/\n\nfunction transform_results(names, results, assigned) {\n    let nclusters = results.numberOfCells();\n    let ntargets = names.length;\n    let output = new Array(nclusters);\n\n    for (var r = 0; r < nclusters; r++) {\n        let all_scores = {};\n        let cscores = results.scoreForCell(r);\n        for (var l = 0; l < ntargets; l++) {\n            all_scores[names[l]] = cscores[l];\n        }\n        output[r] = { best: names[assigned[r]], all: all_scores };\n    }\n\n    return output;\n}\n\nfunction assign_labels_internal(x, cache) {\n    let matrix = x;\n    let temp_cluster_means;\n    let temp_matrix;\n\n    // Converting marker results into means.\n    if (x instanceof scran.ScoreMarkersResults) {\n        let ngroups = x.numberOfGroups();\n\n        if (cache.gene_ids === null) {\n            matrix = null;                \n        } else {\n            let ngenes = cache.gene_ids.length;\n\n            // Creating a column-major array of mean vectors for each cluster.\n            temp_cluster_means = scran.createFloat64WasmArray(ngroups * ngenes);\n            for (var g = 0; g < ngroups; g++) {\n                let means = x.mean(g, { copy: false }); // Warning: direct view in wasm space - be careful.\n                if (means.length !== ngenes) {\n                    throw new Error(\"unexpected number of genes in marker results\");\n                }\n                let cluster_array = temp_cluster_means.array();\n                cluster_array.set(means, g * ngenes);\n            }\n\n            matrix = scran.initializeDenseMatrixFromDenseArray(ngenes, ngroups, temp_cluster_means, { columnMajor: true });\n        }\n    } else {\n        if (cache.gene_ids !== null && x.numberOfRows() !== cache.gene_ids.length) {\n            throw new Error(\"unexpected number of genes in the input matrix\"); \n        }\n    }\n\n    // Running classifications; this is a no-op if gene_ids = null as 'valid' should be empty.\n    let valid = cache.prepared;\n    let results = { per_reference: {} };\n    let raw = {};\n    for (const [key, ref] of Object.entries(valid)) {\n        let current = scran.labelCells(matrix, ref.built.raw);\n        raw[key] = current;\n        results.per_reference[key] = transform_results(ref.loaded.labels, current, current.predicted({ copy: false }));\n    }\n\n    if (\"integrated\" in cache) {\n        let single_results = [];\n        for (const key of cache.used_refs) { // enforce correct order.\n            single_results.push(raw[key]);\n        }\n\n        let current = scran.integrateLabelCells(matrix, single_results, cache.integrated);\n        results.integrated = transform_results(cache.used_refs, current, current.predicted({ copy: false }));\n        current.free();\n    }\n\n    for (const v of Object.values(raw)) {\n        v.free();\n    }\n    utils.freeCache(temp_matrix);\n    utils.freeCache(temp_cluster_means);\n\n    return results;\n}\n\nfunction assign_labels(x, group, cache) {\n    if (group === null) {\n        return assign_labels_internal(x, cache);\n    }\n\n    let to_collect = [];\n    let output;\n    try {\n        let dump = utils.subsetInvalidFactors([group]);\n        to_collect.push(dump.arrays[0].ids);\n\n        let mat = x;\n        if (dump.retain !== null) {\n            let sub = scran.subsetColumns(x, dump.retain);\n            to_collect.push(sub);\n            mat = sub;\n        }\n\n        let aggr = scran.aggregateAcrossCells(mat, dump.arrays[0].ids, { average: true });\n        to_collect.push(aggr);\n\n        let all_sums = aggr.allSums({ asTypedArray: false });\n        to_collect.push(all_sums);\n\n        let aggrmat = scran.initializeDenseMatrixFromDenseArray(\n            mat.numberOfRows(), \n            aggr.numberOfGroups(), \n            all_sums,\n            { columnMajor: true }\n        );\n        to_collect.push(aggrmat);\n\n        output = assign_labels_internal(aggrmat, cache);\n        output.groups = dump.arrays[0].levels;\n    } finally {\n        to_collect.forEach(utils.freeCache);\n    }\n\n    return output;\n}\n\n/********************\n ****** State *******\n ********************/\n\n/**\n * Cell labelling involves assigning cell type labels to clusters using the [**SingleR** algorithm](https://github.com/LTLA/CppSingleR),\n * based on [pre-formatted reference expression profiles](https://github.com/clusterfork/singlepp-references).\n * This wraps [`labelCells`](https://kanaverse.github.io/scran.js/global.html#labelCells)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * In theory, we could do this at the single-cell level, but we use clusters instead to expedite the computation and simplify interpretation.\n * If multiple references are requested, we will use each for assignment before attempting to choose the best label for each cluster across references.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CellLabellingState {\n    #inputs;\n    #parameters;\n    #cache;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let mat = this.#inputs.fetchCountMatrix();\n        return mat.has(\"RNA\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Avoid any pass-by-reference activity.\n        let out = { ...this.#parameters };\n        out.references = bioc.CLONE(out.references);\n        out.species = bioc.CLONE(out.species);\n        return out;\n    }\n\n    /**\n     * @return {object} Object where each key is the name of a reference and each value is the number of shared features between the test and reference daatasets.\n     */\n    fetchNumberOfSharedFeatures() {\n        let output = {};\n        for (const key of this.#cache.used_refs) {\n            output[key] = this.#cache.prepared[key].built.raw.numberOfFeatures();\n        }\n        return output;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellLabellingState#compute compute} for details.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    static configureFeatureParameters(guesses) {\n        let best_key = null;\n        let best = { type: \"symbol\", species: \"9606\", confidence: 0 };\n\n        if (\"row_names\" in guesses) {\n            let val = guesses.row_names;\n            if (val.confidence > best.confidence) {\n                best = val;\n            }\n        }\n\n        for (const [key, val] of Object.entries(guesses.columns)) {\n           if (val.confidence > best.confidence) {\n                best = val;\n                best_key = key;\n            }\n        }\n\n        return {\n            gene_id_column: best_key,\n            species: [best.species],\n            gene_id_type: best.type.toUpperCase()\n        };\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, {@linkcode CellLabellingState#compute compute} will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingState} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode freeAnalysis}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `cell_labelling` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {?Array} [parameters.references] - Array of strings specifying the names of the reference datasets, \n     * see {@linkcode CellLabellingState#availableReferences availableReferences} for more details.\n     * If `null`, all reference datasets from all species are used, and `guess_ids` is set to `true` to determine the relevant species.\n     * @param {boolean} [parameters.guess_ids] - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column` and `gene_id_type`.\n     * @param {Array} [parameters.species] - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be an NCBI taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode CellLabellingState#availableReferences availableReferences}.\n     * This is used internally to filter `references` to the entries relevant to these species. \n     * Ignored if `guess_ids = true`.\n     * @param {?(string|number)} [parameters.gene_id_column] - Name or index of the column of the RNA entry of\n     * {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `guess_ids = true`.\n     * @param {string} [parameters.gene_id_type] - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `guess_ids = true`.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CellLabellingState.defaults());\n        if (!(\"references\" in parameters)) {\n            parameters.guess_ids = true;\n        }\n\n        this.changed = false;\n\n        if (this.valid()) {\n            this.changed = await build_reference(\n                this.#cache, \n                parameters.references, \n                parameters.guess_ids, \n                parameters.species, \n                parameters.gene_id_column, \n                parameters.gene_id_type, \n                this.#parameters, \n                () => this.#inputs.fetchFeatureAnnotations()[\"RNA\"],\n                () => this.#inputs.guessRnaFeatureTypes()\n            );\n        }\n\n        this.#parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in the upstream {@linkcode InputsState}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain externl:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n\n/*****************************\n ******** Standalone *********\n *****************************/\n\n/**\n * Standalone version of {@linkplain CellLabellingState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own feature annotations to build the reference datasets prior to label assignment.\n * Users should await on the return value of the {@linkcode CellLabellingStandalone#ready ready} method after construction.\n * Once resolved, other methods in this class may be used.\n */\nexport class CellLabellingStandalone {\n    #parameters;\n    #cache;\n    #annotations;\n    #guesses;\n    #pre_parameters;\n\n    /**\n     * @param {external:DataFrame} annotations - Feature annotations for the dataset.\n     */\n    constructor(annotations) {\n        this.#parameters = {};\n        this.#pre_parameters = CellLabellingStandalone.defaults();\n        this.#annotations = annotations;\n        this.#cache = {};\n        this.#guesses = null;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellLabellingStandalone#setParameters setParameters} for details.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#pre_parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, this class will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingStandlone} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode CellLabellingStandalone#free free}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #guessFeatureTypes() {\n        if (this.#guesses == null) {\n            this.#guesses = utils.guessFeatureTypes(this.#annotations);\n        }\n        return this.#guesses;\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode CellLabellingStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see {@linkcode CellLabellingState#compute CellLabellingState.compute} for details.\n     * @return The object is updated with the new parameters.\n     * Note that this will not affect existing results computed by {@linkcode CellLabellingStandalone#computeLabels computeLabels}.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CellLabellingStandalone.defaults());\n        this.#pre_parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * This should be called after construction and/or calling {@linkcode CellLabellingStandalone#setParameters setParameters}. \n     * Users should wait for the return value to resolve before calling any other methods of this class.\n     * \n     * @return Reference datasets are loaded into memory. \n     * @async\n     */\n    async ready() {\n        await build_reference(\n            this.#cache, \n            this.#pre_parameters.references, \n            this.#pre_parameters.guess_ids, \n            this.#pre_parameters.species, \n            this.#pre_parameters.gene_id_column, \n            this.#pre_parameters.gene_id_type, \n            this.#parameters, \n            () => this.#annotations,\n            () => this.#guessFeatureTypes()\n        );\n\n        this.#parameters = this.#pre_parameters;\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in `annotations` in the constructor of this instance.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n","import * as h5 from \"./hdf5.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Write a sparse {@linkplain ScranMatrix} into HDF5 file, in the form of its compressed sparse components.\n * This can be considered the reverse operation of {@linkcode initializeSparseMatrixFromHDF5}.\n *\n * @param {ScranMatrix} x - An input sparse matrix.\n * @param {string} path - Path to the HDF5 file.\n * A new file will be created if no file is present.\n * @param {string} name - Name of the group inside the HDF5 file in which to save `x`.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.format=\"tenx_matrix\"] - Format to use for saving `x`.\n * This can be one of:\n *\n * - `tenx_matrix`, a compressed sparse column layout where the dimensions are stored in the `shape` dataset.\n * - `csr_matrix`, a compressed sparse column (yes, column) layout where the dimensions are stored in the `shape` attribute of the HDF5 group.\n *   The discrepancy between the name and the layout is a consequence of the original framework operating on the transposed matrix (i.e., features in columns).\n * - `csc_matrix`, a compressed sparse row layout where the dimensions are stored in the `shape` attribute of the group.\n *   Discrepancy is for the same reason as described for `csr_matrix`.\n *\n * @param {boolean} [options.forceInteger=false] - Whether to force non-integer values in `x` to be coerced to integers.\n * @param {boolean} [options.saveShape=true] - Whether to save the dimensions of `x`.\n * This will be stored as a `shape` dataset (for `format = \"tenx_matrix\")` or attribute (otherwise) in the specified `name`.\n * If `false`, the dimensions are not saved into `name`. \n * @param {boolean} [options.overwrite=true] - Whether to overwrite an existing HDF5 file at `path`.\n * If `false`, any existing file will be opened in read-write mode, and `x` will be saved into `name` in that file.\n *\n * @return `x` is written to `path` at `name`.\n */\nexport function writeSparseMatrixToHdf5(x, path, name, options = {}) {\n    const { format = \"tenx_matrix\", forceInteger = false, saveShape = true, overwrite = true, ...others } = options;\n    utils.checkOtherOptions(others);\n\n    let csc = true;\n    if (format == \"tenx_matrix\") {\n        ;\n    } else if (format == \"csc_matrix\") { // yes, the flip is deliberate, rows are columns because H5AD transposes everything.\n        csc = false;\n    } else if (format == \"csr_matrix\") {\n        ;\n    } else {\n        throw new Error(\"unknown format '\" + format + \"'\");\n    }\n    wasm.call(module => module.write_sparse_matrix_to_hdf5(x.matrix, path, name, csc, forceInteger, overwrite));\n\n    if (saveShape) {\n        let handle = new h5.H5Group(path, name);\n        let shape = [x.numberOfRows(), x.numberOfColumns()];\n\n        if (format == \"tenx_matrix\") {\n            handle.writeDataSet(\"shape\", \"Int32\", null, shape);\n        } else if (format == \"csr_matrix\") {\n            handle.writeAttribute(\"encoding-type\", \"String\", null, \"csr_matrix\");\n            handle.writeAttribute(\"shape\", \"Int32\", null, shape.reverse()); // yes, because H5AD transposes everything, and so must we.\n        } else if (format == \"csc_matrix\") {\n            handle.writeAttribute(\"encoding-type\", \"String\", null, \"csc_matrix\");\n            handle.writeAttribute(\"shape\", \"Int32\", null, shape.reverse());\n        } else {\n            throw new Error(\"unknown format '\" + format + \"'\");\n        }\n    }\n\n    return;\n}\n","import { readObject, saveObject, readObjectFile } from \"./general.js\";\n\nexport async function readAnnotatedMetadata(path, globals, options, optname) {\n    if (!(await globals.exists(path + \"/OBJECT\"))) { // check existence of file, not directory.\n        return {};\n    }\n\n    if (optname in options) {\n        let optional = options[optname];\n        if (optional === false) {\n            return {};\n        } else if (optional !== true) {\n            let meta = await readObjectFile(path, globals);\n            return optional(path, meta, globals, options);\n        }\n    }\n\n    return readObject(path, null, globals, options);\n}\n\nexport async function saveAnnotatedMetadata(x, path, globals, options) {\n    if (x.length() === 0) {\n        return;\n    }\n    await saveObject(x, path, globals, options);\n}\n","export const bakana_version=\"3.1.3\";\n","import * as scran from \"scran.js\";\nimport * as utils from \"./general.js\";\nimport * as aworkers from \"./abstract/workers_parent.js\";\n\nvar animateFun = (x, y, i) => null;\n\n/**\n * Specify a function to handle animation iterations for the low-dimensional embeddings.\n * The exact nature of this handling is arbitrary - developers may post the contents to another thread, save them to file, etc.\n *\n * @param {function} fun - Function to process each animation iteration.\n * This should accept four arguments, in the following order:\n * - A string containing either `\"tsne\"` or `\"umap\"`.\n * - A `Float64Array` containing the x-coordinates for each cell.\n * - A `Float64Array` containing the y-coordinates for each cell.\n * - An integer specifying the iteration number.\n *\n * @return `fun` is set as the global animator function for t-SNE and UMAP.\n * The _previous_ value of the animator is returned.\n */\nexport function setVisualizationAnimate(fun) {\n    let previous = animateFun;\n    animateFun = fun;\n    return previous;\n}\n\nexport var scranOptions = { numberOfThreads: 1 };\n\nexport function computeNeighbors(index, k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = scran.createInt32WasmArray(results.numberOfCells());\n        ibuf = scran.createInt32WasmArray(results.size());\n        dbuf = scran.createFloat64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nconst worker_registry = [];\nconst worker_cache_registry = [];\n\nfunction message_type(info) {\n    return info.type;\n}\n\nfunction handle_message(functions, info) {\n    if (message_type(info) == \"error\") {\n        functions.reject(info.error);\n    } else {\n        functions.resolve(info.data);\n    }\n}\n\nexport function sendTask(worker_id, payload, transferrable = []) {\n    let worker = worker_registry[worker_id];\n    let cache = worker_cache_registry[worker_id];\n\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        let functions = { \"resolve\": resolve, \"reject\": reject };\n        if (i in cache.promises) {\n            // Not sure if the JS engine guarantees that the resolve/reject is\n            // set up before the worker returns the message; for all we know,\n            // we could send the message (and hit the worker callback) before\n            // we run the set-up code. If that's the case, we simply resolve \n            // this Promise using the information provided in the callback.\n            handle_message(functions, cache.promises[i]);\n            delete cache.promises[i];\n        } else {\n            cache.promises[i] = functions;\n        }\n    });\n\n    cache.counter++;\n    payload.id = i;\n    aworkers.sendMessage(worker, payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, scranOptions) { \n    let n = worker_registry.length;\n    worker_registry.push(worker);\n    let cache = { counter: 0, promises: {} };\n    worker_cache_registry.push(cache);\n\n    aworkers.registerCallback(worker, msg => {\n        var type = message_type(msg.data);\n        if (type.endsWith(\"_iter\")) {\n            animateFun(type.slice(0, -5), msg.data.x, msg.data.y, msg.data.iteration);\n            return;\n        }\n\n        var id = msg.data.id;\n        if (id in cache.promises) {\n            handle_message(cache.promises[id], msg.data);\n            delete cache.promises[id];\n        } else {\n            // If the Promise setup in sendTask has not yet been scheduled in\n            // the event loop, we store the message so that it can be used\n            // directly to resolve the Promise during setup.\n            cache.promises[id] = msg.data;\n        }\n    });\n\n    return {\n        \"worker_id\": n,\n        \"ready\": sendTask(n, { \"cmd\": \"INIT\", scranOptions: scranOptions })\n    };\n}\n\nexport async function killWorker(worker_id) {\n    await sendTask(worker_id, { \"cmd\": \"KILL\" });\n    let worker = worker_registry[worker_id];\n    worker_registry[worker_id] = null;\n    return aworkers.terminateWorker(worker);\n}\n\nexport function killAllWorkers() {\n    let p = [];\n    for (var i = 0; i < worker_registry.length; i++) {\n        if (worker_registry[i] !== null) {\n            let p_ = killWorker(i);\n            if (p_) { // not null, not undefined.\n                p.push(p_);\n            }\n        }\n    }\n    return Promise.all(p).then(x => null);\n}\n\nexport function runWithNeighbors(worker_id, args, nn_out) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        transferrable = [\n            nn_out.runs.buffer,\n            nn_out.indices.buffer,\n            nn_out.distances.buffer\n        ];\n        run_msg.neighbors = nn_out;\n    }\n\n    return sendTask(worker_id, run_msg, transferrable);\n}\n","import * as scran from \"scran.js\";\n\nimport * as inputs from \"./steps/inputs.js\";\n\nimport * as qc from \"./steps/rna_quality_control.js\";\nimport * as qcadt from \"./steps/adt_quality_control.js\";\nimport * as qccrispr from \"./steps/crispr_quality_control.js\";\nimport * as filters from \"./steps/cell_filtering.js\";\n\nimport * as normalization from \"./steps/rna_normalization.js\";\nimport * as normadt from \"./steps/adt_normalization.js\";\nimport * as normcrispr from \"./steps/crispr_normalization.js\";\n\nimport * as variance from \"./steps/feature_selection.js\";\n\nimport * as pca from \"./steps/rna_pca.js\";\nimport * as pcaadt from \"./steps/adt_pca.js\";\nimport * as pcacrispr from \"./steps/crispr_pca.js\";\nimport * as combine from \"./steps/combine_embeddings.js\";\nimport * as correct from \"./steps/batch_correction.js\";\n\nimport * as index from \"./steps/neighbor_index.js\";\nimport * as cluster_choice from \"./steps/choose_clustering.js\";\nimport * as kmeans_cluster from \"./steps/kmeans_cluster.js\";\nimport * as snn_cluster from \"./steps/snn_graph_cluster.js\";\n\nimport * as tsne from \"./steps/tsne.js\";\nimport * as umap from \"./steps/umap.js\";\n\nimport * as cluster_markers from \"./steps/marker_detection.js\";\nimport * as label_cells from \"./steps/cell_labelling.js\";\nimport * as custom_markers from \"./steps/custom_selections.js\";\n\nimport * as feature_set_enrichment from \"./steps/feature_set_enrichment.js\";\n\nexport { setCreateLink, setResolveLink } from \"./steps/inputs.js\";\nexport { MarkerDetectionState } from \"./steps/marker_detection.js\";\nexport { CustomSelectionsState } from \"./steps/custom_selections.js\";\n\nconst step_inputs = inputs.step_name;\nconst step_qc = qc.step_name;\nconst step_qc_adt = qcadt.step_name;\nconst step_qc_crispr = qccrispr.step_name;\nconst step_filter = filters.step_name;\nconst step_norm = normalization.step_name;\nconst step_norm_adt = normadt.step_name;\nconst step_norm_crispr = normcrispr.step_name;\nconst step_feat = variance.step_name;\nconst step_pca = pca.step_name;\nconst step_pca_adt = pcaadt.step_name;\nconst step_pca_crispr = pcacrispr.step_name;\nconst step_combine = combine.step_name;\nconst step_correct = correct.step_name;\nconst step_neighbors = index.step_name;\nconst step_tsne = tsne.step_name;\nconst step_umap = umap.step_name;\nconst step_kmeans = kmeans_cluster.step_name;\nconst step_snn = snn_cluster.step_name;\nconst step_choice = cluster_choice.step_name;\nconst step_markers = cluster_markers.step_name;\nconst step_labels = label_cells.step_name;\nconst step_custom = custom_markers.step_name;\nconst step_enrichment = feature_set_enrichment.step_name;\n\nconst load_flag = \"_loaded\";\n\n/**\n * Create a new analysis state in preparation for calling {@linkcode runAnalysis}.\n * Multiple states can be created and used interchangeably within the same Javascript runtime.\n *\n * @return A promise that resolves to an object containing states for all analysis steps.\n * This object can be used as input into {@linkcode runAnalysis}.\n */\nexport async function createAnalysis() {\n    return create_analysis(new inputs.InputsState);\n}\n\nfunction create_analysis(input_state) {\n    let output = {};\n    output[step_inputs] = input_state;\n\n    output[step_qc] = new qc.RnaQualityControlState(output[step_inputs]);\n    output[step_qc_adt] = new qcadt.AdtQualityControlState(output[step_inputs]);\n    output[step_qc_crispr] = new qccrispr.CrisprQualityControlState(output[step_inputs]);\n\n    let qc_states = { \"RNA\": output[step_qc], \"ADT\": output[step_qc_adt], \"CRISPR\": output[step_qc_crispr] }\n    output[step_filter] = new filters.CellFilteringState(output[step_inputs], qc_states);\n\n    output[step_norm] = new normalization.RnaNormalizationState(output[step_qc], output[step_filter]);\n    output[step_norm_adt] = new normadt.AdtNormalizationState(output[step_qc_adt], output[step_filter]);\n    output[step_norm_crispr] = new normcrispr.CrisprNormalizationState(output[step_qc_crispr], output[step_filter]);\n\n    output[step_feat] = new variance.FeatureSelectionState(output[step_filter], output[step_norm]);\n\n    output[step_pca] = new pca.RnaPcaState(output[step_filter], output[step_norm], output[step_feat]);\n    output[step_pca_adt] = new pcaadt.AdtPcaState(output[step_filter], output[step_norm_adt]);\n    output[step_pca_crispr] = new pcacrispr.CrisprPcaState(output[step_filter], output[step_norm_crispr]);\n\n    let pca_states = { \"RNA\": output[step_pca], \"ADT\": output[step_pca_adt], \"CRISPR\": output[step_pca_crispr] }\n    output[step_combine] = new combine.CombineEmbeddingsState(pca_states);\n    output[step_correct] = new correct.BatchCorrectionState(output[step_filter], output[step_combine]);\n\n    output[step_neighbors] = new index.NeighborIndexState(output[step_correct]);\n\n    output[step_tsne] = new tsne.TsneState(output[step_neighbors]);\n    output[step_umap] = new umap.UmapState(output[step_neighbors]);\n\n    output[step_kmeans] = new kmeans_cluster.KmeansClusterState(output[step_correct]);\n    output[step_snn] = new snn_cluster.SnnGraphClusterState(output[step_neighbors]);\n    output[step_choice] = new cluster_choice.ChooseClusteringState(output[step_snn], output[step_kmeans]);\n\n    let norm_states = { \"RNA\": output[step_norm], \"ADT\": output[step_norm_adt], \"CRISPR\": output[step_norm_crispr] };\n    output[step_markers] = new cluster_markers.MarkerDetectionState(output[step_filter], norm_states, output[step_choice]);\n    output[step_labels] = new label_cells.CellLabellingState(output[step_inputs]);\n    output[step_enrichment] = new feature_set_enrichment.FeatureSetEnrichmentState(output[step_inputs], output[step_filter], output[step_norm]);\n    output[step_custom] = new custom_markers.CustomSelectionsState(output[step_filter], norm_states);\n\n    return Promise.all([output[step_tsne].ready(), output[step_umap].ready()]).then(val => output);\n}\n\n/**\n * Free the contents of an analysis state.\n * This releases memory on the **scran.js** Wasm heap and terminates any workers associated with this analysis.\n *\n * @param state An existing analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n *\n * @return A promise that resolves to `null` when all states are freed.\n */\nexport function freeAnalysis(state) {\n    let promises = [];\n    for (const [k, v] of Object.entries(state)) {\n        if (k == load_flag) {\n            continue;\n        }\n        let p = v.free();\n        if (p) { // not null, not undefined.\n            promises.push(p); \n        }\n    }\n    return Promise.all(promises).then(x => null);\n}\n\n/**\n * Run a basic single-cell RNA-seq analysis with the specified files and parameters.\n * This will cache the results from each step so that, if the parameters change, only the affected steps will be rerun.\n *\n * @param {object} state - Object containing the analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n * @param {object} datasets - Object where each (arbitrarily named) property corresponds to an input dataset.\n * Each dataset should be a object that satisfies the {@linkplain Dataset} contract.\n *\n * Alternatively, `datasets` may be `null` if the input datasets were already loaded and cached in `state`.\n * This avoids the need to respecify the inputs after a previous call to {@linkcode runAnalysis} or from {@linkcode loadAnalysis}.\n * @param {object} params - An object containing parameters for all steps.\n * See {@linkcode analysisDefaults} for more details.\n * @param {object} [options] - Optional parameters.\n * @param {?function} [options.startFun=null] - Function that is called when each step is started.\n * This should accept a single argument - the name of the step.\n * The return value is ignored, but any promises will be awaited before the analysis proceeds to the next step.\n * If `null`, nothing is executed.\n * @param {?function} [options.finishFun=null] - Function that is called on successful execution of each step.\n * This should accept a single argument - the name of the step.\n * The return value is ignored, but any promises will be awaited before the analysis proceeds to the next step.\n * If `null`, nothing is executed.\n * \n * @return A promise that resolves to `null` when all asynchronous analysis steps are complete.\n * The contents of `state` are modified by reference to reflect the latest state of the analysis with the supplied parameters.\n */\nexport async function runAnalysis(state, datasets, params, { startFun = null, finishFun = null } = {}) {\n    let quickStart = async step => {\n        if (startFun !== null) {\n            await startFun(step);\n        }\n    }\n\n    let quickFinish = async step => {\n        if (finishFun !== null) {\n            await finishFun(step);\n        }\n    }\n\n    let promises = [];\n    let deferredQuickFinish = (step, p) => {\n        if (finishFun !== null) {\n            if (state[step].changed) {\n                p = p.then(out => finishFun(step, state[step]));\n            } else {\n                p = p.then(out => finishFun(step));\n            }\n        }\n        promises.push(p);\n    }\n\n    /*** Loading ***/\n    await quickStart(step_inputs);\n    await state[step_inputs].compute(datasets, params[step_inputs]);\n    await quickFinish(step_inputs);\n\n    if (load_flag in state) {\n        // Force recompute for all downstream steps. This avoids mixing results\n        // from different versions if we're re-running off a reloaded state; if\n        // some steps rerun, but others don't, we end up with a bastard state\n        // from possibly different versions of this pipeline. It's also\n        // difficult to guarantee that enough results were saved for use in\n        // downstream steps, given that not everything is saved to file (and\n        // indeed, the requirements of downstream steps may change in future\n        // versions). So we just keep it simple and flush the whole state.\n        state[step_inputs].changed = true;\n        delete state[load_flag];\n    }\n\n    /*** Preprocessing steps ***/\n    let basic_steps = [\n        step_qc, step_qc_adt, step_qc_crispr,\n        step_filter,\n        step_norm, step_norm_adt, step_norm_crispr,\n        step_feat,\n        step_pca, step_pca_adt, step_pca_crispr,\n        step_combine,\n        step_correct,\n        step_neighbors\n    ];\n\n    for (const step of basic_steps) {\n        await quickStart(step);\n        await state[step].compute(params[step]);\n        await quickFinish(step);\n    }\n\n    /*** Visualization ***/\n    for (const step of [ step_tsne, step_umap ]) {\n        await quickStart(step);\n        let p = state[step].compute(params[step]);\n        deferredQuickFinish(step, p);\n    }\n\n    /*** Clustering ***/\n    let method = params[step_choice][\"method\"];\n\n    await quickStart(step_kmeans);\n    state[step_kmeans].compute(method == \"kmeans\", params[step_kmeans]);\n    await quickFinish(step_kmeans);\n\n    await quickStart(step_snn);\n    state[step_snn].compute(method == \"snn_graph\", params[step_snn]);\n    await quickFinish(step_snn);\n\n    await quickStart(step_choice);\n    state[step_choice].compute(params[step_choice]);\n    await quickFinish(step_choice);\n\n    /*** Markers and labels ***/\n    let remaining = [\n        step_markers,\n        step_labels,\n        step_custom,\n        step_enrichment\n    ];\n\n    for (const step of remaining) {\n        await quickStart(step);\n        await state[step].compute(params[step]);\n        await quickFinish(step);\n    }\n\n    await Promise.all(promises);\n    return null;\n}\n\n/**\n * Retrieve analysis parameters from a state object.\n *\n * @param {object} state - Object containing the analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n *\n * @return {object} Object containing the analysis parameters for each step, similar to that created by {@linkcode analysisDefaults}.\n */\nexport function retrieveParameters(state) {\n    let params = {};\n    for (const [k, v] of Object.entries(state)) {\n        if (k == load_flag) {\n            continue;\n        }\n        params[k] = v.fetchParameters();\n    }\n    return params;\n}\n\n/**\n * Create a new analysis state object consisting of a subset of cells from an existing analysis state.\n * This assumes that the existing state already contains loaded matrix data in its `inputs` property,\n * which allows us to create a cheap reference without reloading the data into memory.\n *\n * @param {object} state - State object such as that produced by {@linkcode createAnalysis} or {@linkcode linkAnalysis}.\n * This should already contain loaded data, e.g., after a run of {@linkcode runAnalysis}.\n * @param {TypedArray|Array} indices - Array containing the indices for the desired subset of cells.\n * This should be sorted and non-duplicate.\n * Any existing subset in `state` will be overridden by `indices`.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.copy=true] - Whether to make a copy of `indices` before storing it inside the returned state object.\n * If `false`, it is assumed that the caller makes no further use of the passed `indices`.\n * @param {boolean} [options.onOriginal=false] - Whether `indices` contains indices on the original dataset or on the dataset in `state`.\n * This distinction is only relevant if `state` itself contains an analysis of a subsetted dataset.\n * If `false`, the `indices` are assumed to refer to the columns of the already-subsetted dataset that exists in `state`;\n * if `true`, the `indices` are assumed to refer to the columns of the original dataset from which the subset in `state` was created.\n *\n * @return {object} A state object containing loaded matrix data in its `inputs` property.\n * Note that the other steps do not have any results, so this object should be passed through {@linkcode runAnalysis} before it can be used.\n */\nexport async function subsetInputs(state, indices, { copy = true, onOriginal = false } = {}) {\n    return create_analysis(state.inputs.createDirectSubset(indices, { copy: copy, onOriginal: onOriginal }));\n}\n"],"names":["availableReaders","TenxHdf5Dataset","TenxMatrixMarketDataset","H5adDataset","SummarizedExperimentDataset","ZippedArtifactdbDataset","async","readObjectFile","path","globals","payload","get","joinPath","asBuffer","dec","TextDecoder","JSON","parse","decode","clean","readObjectRegistry","readObject","metadata","options","arguments","length","undefined","objtype","defaults","list","df","se","rse","sce","Error","saveObjectRegistry","saveObject","x","i","cls","meth","bioc","fun","constructor","name","correctible_pca_steps","pca","pcaadt","pcacrispr","configureBatchCorrection","parameters","method","correct_method","pca_blocker","correct","block_method","approximatable_steps","combine","index","configureApproximateNeighbors","approximate","step","initialize","numberOfThreads","localFile","s","scran","vizutils","then","toStringType","data","maxStringLength","_handle","WeakMap","AlabasterH5Group","jsp","handle","super","_classPrivateFieldInitSpec","_classPrivateFieldSet","this","writeAttribute","type","shape","_classPrivateFieldGet","open","out","AlabasterH5DataSet","children","createGroup","createDataSet","writeDataSet","close","_handle2","write","_directory","_files","AlabasterGlobalsInterface","directory","files","internal","localPath","contents","mkdir","copy","from","to","h5create","actual_path","latest","output","_path","tmppath","_intended","h5finish","failed","fsexists","read","dir","step_name","RAW_SUBSET_OVERRIDE","_parameters","_cache","_abbreviated","_preserve_dataset_cache","_InputsState_brand","WeakSet","InputsState","cache","abbreviated","_classPrivateMethodInitSpec","changed","free","utils","matrix","raw_matrix","block_ids","raw_block_ids","multi_block_ids","fetchCountMatrix","fetchFeatureAnnotations","genes","fetchCellAnnotations","annotations","fetchBlock","fetchBlockLevels","block_levels","fetchParameters","_this$constructor","_objectSpread","subset","_assertClassBrand","_cloneSubset","call","fetchDatasets","datasets","fetchDirectSubset","candidate","slice","guessRnaFeatureTypes","inferred_rna_types","block_factor","enableDatasetCache","compute","tmp_abbreviated","key","val","Object","entries","format","details","abbreviate","new_datasets","preserve_dataset_cache","res","names","keys","sort","loaded","push","load","e","single","available","features","k","known_modalities","has","add","cells","rename_dataset","blocks","common_modes","mod","okay","l","current","bind_single_modality","annos","map","ncells","Array","forEach","numberOfColumns","nice_barr","$setColumn","bind_datasets","load_datasets","raw_annotations","multi_block_levels","load_and_cache","anno_batch","column","converted","action","placeholder","invalid_block_id","ids","levels","view","raw_block_levels","block_and_cache","subset_and_cache","undoSubset","indices","max_index","keep","harvest_subset_indices","setDirectSubset","onOriginal","_configureIndices","createDirectSubset","new_cache","clone","new_params","values","ranges","modality","gnames","mats","primary_id","primary_ids","String","merged","hasColumn","field","anno","allowed","Set","r","bids","array","keep2","new_annotations","new_matrix","new_block_ids","new_block_levels","subsetted","link2file","setResolveLink","previous","_flush","flush","attributes","readAttribute","attr","ares","members","_navigator","navigator","exists","h5open","realized","h5close","_nrow","_ncol","MockMatrix","nrow","ncol","_bioconductor_NUMBER_OF_ROWS","_bioconductor_NUMBER_OF_COLUMNS","realize","forceInteger","forceSparse","extract_matrix","extract_delayed","fhandle","dhandle","layout","transposed","indexOf","dtype","optype","seed","arg","along","right","inPlace","base","logBase","perm","mat","ihandle","shandle","seeds","nchildren","childen","c","atype","is_native","file","is_csr","seed_path","seed_metadata","readMockAssay","readMockReducedDimension","apply_over_experiments","main_experiment_name","is_sce","mainExperimentName","alt","alternativeExperimentNames","alternativeExperiment","extract_all_features","rowData","extract_all_assay_names","assayNames","simplify_List_columns","columnNames","col","setColumn","toArray","_navigator2","_raw_se","_options","_AbstractAlabasterDataset_brand","AbstractAlabasterDataset","rnaCountAssay","adtCountAssay","crisprCountAssay","rnaExperiment","adtExperiment","crisprExperiment","primaryRnaFeatureIdColumn","primaryAdtFeatureIdColumn","primaryCrisprFeatureIdColumn","setOptions","v","clear","summary","_populate","modality_features","columnData","modality_assay_names","previewPrimaryIds","fmapping","RNA","ADT","CRISPR","raw_features","altnames","preview","futils","_primary_mapping","mapping","exp","assay","experiments_by_name","chosen_se","_create_globals","DataFrame_readNested","DataFrame_readMetadata","SummarizedExperiment_readAssay","SummarizedExperiment_readMetadata","SingleCellExperiment_readReducedDimension","y","_navigator3","_raw_se2","_options2","_AbstractAlabasterResult_brand","AbstractAlabasterResult","primaryAssay","isPrimaryNormalized","reducedDimensionNames","_populate2","reduced_dimension_names","reduced_dimensions","chosen_rd","reducedDimension","_create_globals2","collected","curassay","curnormalized","normed","allowZeros","_SelectionManager_brand","SelectionManager","selections","_selections","results","buffer","_liberate","markers","versus","addSelection","id","selection","to_use","matfun","block","lfc_threshold","compute_auc","fill","tmp","element","threshold","computeAuc","removeSelection","fetchResults","raw","fetchSelectionIndices","fetchSelections","force","replacement","store","needs_copy","Int32Array","computeVersus","left","cache_info","left_index","left_small","right_index","run","matrices","leftsel","rightsel","triplets","a","b","new_clusters","cluster","cached","_filter","_norm_states","_manager","_CustomSelectionsState_brand","CustomSelectionsState","filter","norm_states","filter_module","rna_norm_module","adt_norm_module","crispr_norm_module","_addSelection","value","fetchNormalizedMatrix","fetchFilteredBlock","SingleCellExperiment","assays","reducedDimensions","reducedDimensionOrder","alternativeExperiments","alternativeExperimentOrder","rowRanges","ncols","_reducedDimensions","il","className","message","cause","entry","generics","_alternativeExperiments","_mainExperimentName","removeReducedDimension","target","cutils","delete","$removeReducedDimension","setReducedDimension","set","$setReducedDimension","setReducedDimensionNames","setNames","$setReducedDimensionNames","setReducedDimensions","newOrder","sce_nc","$setReducedDimensions","sliceReducedDimensions","$sliceReducedDimensions","removeAlternativeExperiment","$removeAlternativeExperiment","setAlternativeExperiment","$setAlternativeExperiment","setAlternativeExperimentNames","$setAlternativeExperimentNames","setAlternativeExperiments","$setAlternativeExperiments","sliceAlternativeExperiments","$sliceAlternativeExperiments","setMainExperimentName","$setMainExperimentName","_bioconductor_SLICE_2D","rows","columns","_ref","allowView","apply","_bioconductor_COMBINE_ROWS","objects","_bioconductor_COMBINE_COLUMNS","all_rd","all_ae","parallelCombine","_bioconductor_CLONE","_ref2","deepCopy","_defineProperty","_matrix","MockSparseMatrix","numberOfRows","_matrix2","_sf","MockNormalizedMatrix","sf","saveSparseMatrix","ypath","external_Matrix_store","f","handle_stack","success","saveShape","overwrite","ghandle","reverse","stringify","compressed_sparse_matrix","version","saveNormalizedMatrix","vhandle","Math","log","l1phandle","sfhandle","xhandle","seed_dir","delayed_array","_values","_nr","_nc","MockReducedDimensionMatrix","nr","nc","saveReducedDimensionMatrix","dense_array","load_number","Number","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","load_vector","typedarray","vals","scalar","List_toScalar","every","List_toTypedArray","_jaspalite_scalar","load_json_list","List","IntegerList","NumberList","Float64Array","StringList","BooleanList","readList","simple_list","decompressed_stream","Blob","stream","pipeThrough","DecompressionStream","chunks","counter","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_step","_iterator","_asyncIterator","next","done","chunk","err","return","decompressed_final","Uint8Array","str","dump_number_array","isNaN","dump_vector","_jaspagate_scalar","dump_json_list","state","all_strings","all_bools","all_numbers","exceedsInt32","Int8Array","Int16Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Float32Array","List_saveOther","odir","curdex","saveList","jsonBuffer","stringified","compressed_stream","CompressionStream","_iteratorError2","_iteratorAbruptCompletion2","_didIteratorError2","_step2","_iterator2","compressed_final","_a","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","rejected","result","SuppressedError","Mutex","mutex","lock","begin","dispatch","fn","unlock","globalObject","globalThis","self","window","global","nodeBuffer","Buffer","textEncoder","TextEncoder","hexCharCodesToInt","writeHexToUInt8","buf","size","charCodeAt","alpha","digit","getDigestHex","tmpBuffer","input","hashLength","p","nibble","fromCharCode","getUInt8Buffer","byteOffset","isBuffer","ArrayBuffer","isView","byteLength","encode","base64Chars","base64Lookup","getDecodeBase64Length","bufferLength","floor","len","decodeBase64","bytes","encoded1","encoded2","encoded3","encoded4","MAX_HEAP","WASM_FUNC_HASH_LENGTH","wasmMutex","wasmModuleCache","Map","WASMInterface","binary","wasmInstance","memoryView","initialized","WebAssembly","getStateSize","DataView","exports","memory","getUint32","STATE_SIZE","loadWASMPromise","asm","promise","compile","module","instantiate","init","bits","Hash_Init","update","subarray","Hash_Update","updateUInt8Array","digestChars","digest","outputType","padding","Hash_Final","isDataShort","canSimplify","initParam","setupInterface","arrayOffset","Hash_GetBuffer","memoryBuffer","getMemory","writeMemory","offset","getExports","setMemorySize","totalSize","Hash_SetMemorySize","save","stateOffset","Hash_GetState","stateLength","internalState","prefixedState","hash","overallLength","concat","strIndex","hexStringEqualsUInt8","calculate","digestParam","Hash_Calculate","lockedCreate","wasm","wasmJson$d","mutex$e","wasmCache$e","md5","translate_effects","formatMarkerDetectionResults","modality_names","translate_summary","do_auc","marker_detection","all_rowdata","inputs","all_output","m","rn","ngroups","numberOfGroups","nfeatures","group","mdf","rowNames","eff","trans_eff","summ","trans_summ","formatCustomSelectionResults","custom_selections","all_sel","sel","formatFeatureSelectionResults","rna_names","feature_selection","mean","means","variance","variances","fitted","residual","residuals","columnOrder","readRangedSummarizedExperiment","readSummarizedExperiment","RangedSummarizedExperiment","assayOrder","saveRangedSummarizedExperiment","saveSummarizedExperiment","existing","ranged_summarized_experiment","upper","lower","substitutePlaceholder","outclass","formatIntegerArrayForHdf5","has_missing","some","integer","everything","formatNumberArrayForHdf5","MAX_VALUE","chosen","sorted","isFinite","formatStringArrayForHdf5","formatBooleanArrayForHdf5","obj","read_assay","se_options","name_path","names_contents","assay_names","aname","assay_path","assay_meta","summarized_experiment","dimensions","cd","DataFrame","readAnnotatedMetadata","SummarizedExperiment","adir","setRowNames","saveAnnotatedMetadata","searchGenes","species","queries","types","ignoreCase","promises","t","mapGenesByIdentifier","lowerCase","resolved","all","toLowerCase","findings","j","default_download","start","end","url","fetch","headers","Range","reference_base_url","referenceBaseUrl","reference_download","referenceDownload","prev","gene_base_url","geneBaseUrl","gene_download","geneDownload","setGeneDownload","decompressLines","pako","lines","split","convertToUint32Array","txt","last","intersect","arrays","ref","running","formatSingleCellExperiment","reportOneIndex","storeModalityColumnData","modalities","main","all_metadata","all_coldata","all_se","cell_filtering","fetchFilteredMatrix","counts","reddim","rna_normalization","adt_normalization","crispr_normalization","fetchSizeFactors","logcounts","rna_pca","adt_pca","crispr_pca","pcs","fetchPCs","numberOfCells","numberOfPCs","principalComponents","tv","totalVariance","variance_explained","varianceExplained","customs","meta","setMetadata","main_se","_FeatureSetManager_brand","FeatureSetManager","set_buffer","setDownload","console","warn","buildCollections","old_parameters","guess_ids","gene_id_column","gene_id_type","annofun","guessfun","gene_id_column2","gene_id_type2","species2","auto","guesses","best_key","best","confidence","row_names","toUpperCase","configure_feature_parameters","_prepare","fetchCollectionDetails","collections","fetchSetDetails","sets","descriptions","sizes","fetchUniverseSize","universe","computeEnrichment","effect_size","top_markers","use_largest","min_threshold","stats","in_set","useLargest","gene","mapping_to_sets","overlaps","gesel","set_ids","count","num_top","pvalues","num_markers","fetchFeatureSetIndices","set_id","computePerCellScores","normalized","farr","feats","data_id_col","search_options","collection_offset","all_collection_names","all_collection_descriptions","all_collection_species","set_offset","all_set_names","all_set_descriptions","all_set_indices","all_set_sizes","all_set_collections","mapped_genes","remapped","spec","gene_mapping","all_sets2genes","set_indices","all_sets","nsets","set_names","set_descriptions","set_sizes","set_collections","description","collection","all_genes2sets","current_remapped","all_collections","ncollections","collection_names","collection_descriptions","collection_species","title","dereference_parameters","fetch_parameters","_inputs","_normalized","FeatureSetEnrichmentState","inputs_module","norm_module","valid","fetchPerCellScores","set_index","skip","readDataFrame","read_nested","DataFrame_toTypedArray","cnhandle","nrows","colnames","pop","skip_nested","kids","iname","nest_path","nest_meta","child_handle","H5DataSet","missing_attr","rawvals","H5Group","lhandle","cohandle","codes","code_attrs","hhandle","heap","phandle","pointers","pointer_attrs","early","rownames","rnhandle","new_colnames","cn","toReversed","saveDataFrame","data_frame","externals","chandle","htype","formatted","handled","DataFrame_saveOther","external_array","other_dir","formatColumnData","all_modalities","main_modality","all_other_metadata","store_per_modality","keep_raw","fetchKeep","full","rna_quality_control","prefix","rdf","applyFilter","fetchMetrics","sum","detected","subsetProportion","fetchFilters","adt_quality_control","adf","subsetSum","crispr_quality_control","cdf","maxProportion","maxIndex","maxValue","clusters","choose_clustering","fetchClusters","stringy","as_bool","wa","prototype","_bioconductor_LENGTH","countSetOverlaps","setsForSomeGenes","set_count","found","serializeConfiguration","saver","anal","dformat","serialize","serializeDatasets","isub","bakana_version","other","direct_subset","unserializeConfiguration","serialized","loader","startFun","finishFun","known","readers","handles","unserialize","unserializeDatasets","load_listData_names","nhandle","ndx","findAttribute","attribute","acceptable_df_subclasses","load_data_frame","check_class","curhandle","curcol","clshandle","levhandle","check_acceptable_class","nrhandle","NR","accepted","packageName","extract_NAMES","nidx","extract_features","rowdata","rrdx","rhandle","rrhandle","ehandle","pidx","r2handle","$setRowNames","extract_assay_names","ahandle","extract_assay","n","extract_main_exp_name","int_handle","name_handle","me_handle","int_dx","name_dx","me_dx","me_name","extract_alt_exps","in_handle","inld_handle","innn_handle","ae_handle","aeld_handle","aenn_handle","order","indx","inld_dx","innn_dx","ae_dx","aeld_dx","aenn_dx","ae_names","asehandle","check_for_se","_rds_file","_rds_handle","_se_handle","_main_exp_name","_alt_handles","_alt_handle_order","_raw_features","_raw_cells","_SummarizedExperimentDataset_brand","rdsFile","afile","_dump_summary","_initialize","_features","_cells","content","_zipfile","_ziphandle","_prefix","ZippedProjectNavigator","zipfile","ziphandle","JSZip","_zipfile2","_prefix2","_ZippedAlabasterDataset_brand","ZippedAlabasterDataset","adb","existingHandle","datasetPrefix","opt","saveOtherDataFrameColumns","saveSingleCellExperiment","my_sce","ass","rd","saveGenewiseResults","includeMarkerDetection","includeCustomSelections","includeFeatureSelection","readSingleCellExperiment","single_cell_experiment","read_rd","rdpath","reddim_names","rname","currd","rdmeta","read_ae","SingleCellExperiment_readAlternativeExperiment","aepath","altexp_names","curae","aemeta","mexp","rddir","aedir","extract_assay_details","sparse","shape_info","enc_info","csc","fetch_assay_details","deets","dvals","subhandle","current_levels","eutils","_index","fetch_features","fetch_cells","load_matrix","_h5_file","_h5_path","_h5_flush","_h5_handle","_assay_details","_H5adDataset_brand","h5File","countMatrixName","featureTypeColumnName","featureTypeRnaName","featureTypeAdtName","featureTypeCrisprName","_fetch_assay_details","all_features","all_assay_names","_feature_type_mapping","chosen_assay","layered","_instantiate","info","endsWith","startsWith","redirection","targets","location","_name","_ZippedArtifactdbDataset_brand","datasetName","IndexedNames","_names","_lookup","nameToIndexUncached","nameToIndex","error","indexToName","append","splice","_List_brand","arr","getByIndex","_check_index","getByName","toMap","curname","toObject","setByIndex","new_names","setByName","deleteByIndex","deleteByName","sliceRange","sliceIndices","new_values","Symbol","iterator","all_values","_bioconductor_SLICE","sliced","_ref3","_bioconductor_COMBINE","all_names","xvals","xnames","yn","_IntegerList_brand","_sanitize","isInteger","_NumberList_brand","_sanitize2","_StringList_brand","_sanitize3","_BooleanList_brand","_sanitize4","download_fun","set_download","acquire_file","suffix","baseUrl","rutils","all_loaded","flush_prepared","prepared","built","process_genes","gene_lines","compression","acquired","load_reference","gene_suffix","known_genes","suffixes","stored","flush_loaded","available_references","internal_build_reference","gene_ids","chosen_ids","build_reference","references","CellLabellingState","configureFeatureParameters","allowable","used_refs","integrated","transform_results","assigned","nclusters","ntargets","all_scores","cscores","scoreForCell","assign_labels_internal","temp_cluster_means","ngenes","g","columnMajor","per_reference","labels","predicted","single_results","temp_matrix","assign_labels","to_collect","dump","retain","sub","aggr","average","all_sums","allSums","asTypedArray","aggrmat","groups","fetchNumberOfSharedFeatures","numberOfFeatures","computeLabels","_parameters2","_cache2","_annotations","_guesses","_pre_parameters","_CellLabellingStandalone_brand","CellLabellingStandalone","setParameters","ready","_guessFeatureTypes","writeSparseMatrixToHdf5","others","_objectWithoutProperties","_excluded","write_sparse_matrix_to_hdf5","h5","optname","optional","animateFun","setVisualizationAnimate","scranOptions","computeNeighbors","nn_index","fetchIndex","rbuf","ibuf","dbuf","runs","distances","worker_registry","worker_cache_registry","message_type","handle_message","functions","sendTask","worker_id","transferrable","worker","aworkers","initializeWorker","msg","iteration","killWorker","runWithNeighbors","args","nn_out","run_msg","neighbors","step_inputs","step_qc","qc","step_qc_adt","qcadt","step_qc_crispr","qccrispr","step_filter","filters","step_norm","normalization","step_norm_adt","normadt","step_norm_crispr","normcrispr","step_feat","step_pca","step_pca_adt","step_pca_crispr","step_combine","step_correct","step_neighbors","step_tsne","tsne","step_umap","umap","step_kmeans","kmeans_cluster","step_snn","snn_cluster","step_choice","cluster_choice","step_markers","cluster_markers","step_labels","label_cells","step_custom","custom_markers","step_enrichment","feature_set_enrichment","load_flag","createAnalysis","create_analysis","input_state","qc_states","pca_states","runAnalysis","params","quickStart","quickFinish","deferredQuickFinish","basic_steps","remaining","retrieveParameters"],"sourceRoot":""}