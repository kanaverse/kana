{"version":3,"file":"static/js/705.4ba25ce9.chunk.js","mappings":"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","sources":["../node_modules/wasmarrays.js/src/subset.js","../node_modules/scran.js/browser/guessFeatures.js","../node_modules/scran.js/browser/modelGeneVar.js","../node_modules/scran.js/browser/suggestAdtQcFilters.js","../node_modules/bioconductor/src/miscellaneous.js","../node_modules/bakana/browser/steps/tsne.js","../node_modules/bakana/browser/steps/snn_graph_cluster.js","../node_modules/scran.js/browser/suggestCrisprQcFilters.js","../node_modules/bakana/browser/steps/kmeans_cluster.js","../node_modules/bakana/browser/steps/utils/normalization.js","../node_modules/scran.js/browser/chooseHVGs.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/scran.js/browser/logNormCounts.js","../node_modules/bioconductor/src/clone-utils.js","../node_modules/gesel/src/fetchSingleCollection.js","../node_modules/bakana/browser/steps/crispr_pca.js","../node_modules/bakana/browser/steps/utils/abstract/workers_parent.js","../node_modules/scran.js/browser/scaleByNeighbors.js","../node_modules/gesel/src/reindexSetsForAllGenes.js","../node_modules/bakana/browser/steps/rna_quality_control.js","../node_modules/wasmarrays.js/src/derived.js","../node_modules/bioconductor/src/Annotated.js","../node_modules/gesel/src/fetchSingleSet.js","../node_modules/bioconductor/src/overlap-utils.js","../node_modules/bioconductor/src/DataFrame.js","../node_modules/scran.js/browser/quickAdtSizeFactors.js","../node_modules/gesel/src/fetchSetsForGene.js","../node_modules/bakana/browser/readers/mtx.js","../node_modules/bioconductor/src/SingleCellExperiment.js","../node_modules/gesel/src/fetchGenesForSet.js","../node_modules/scran.js/browser/ScranMatrix.js","../node_modules/bakana/browser/readers/utils/abstract/stream.js","../node_modules/scran.js/browser/perCellCrisprQcMetrics.js","../node_modules/bakana/browser/readers/ArtifactDB-abstract.js","../node_modules/bakana/browser/steps/umap.js","../node_modules/scran.js/browser/labelCells.js","../node_modules/gesel/src/reindexGenesForAllSets.js","../node_modules/gesel/src/fetchGenesForAllSets.js","../node_modules/gesel/src/mapGenesByIdentifier.js","../node_modules/bakana/browser/steps/adt_normalization.js","../node_modules/gesel/src/searchSetText.js","../node_modules/scran.js/browser/block.js","../node_modules/bioconductor/src/GRanges.js","../node_modules/bakana/browser/steps/utils/markers.js","../node_modules/scran.js/browser/clusterSNNGraph.js","../node_modules/scran.js/browser/runPCA.js","../node_modules/randomcolor/randomColor.js","../node_modules/gesel/src/fetchAllGenes.js","../node_modules/bakana/browser/steps/cell_filtering.js","../node_modules/gesel/src/fetchAllSets.js","../node_modules/bakana/browser/steps/combine_embeddings.js","../node_modules/bakana/browser/steps/abstract/worker_parent.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/bakana/browser/readers/utils/features.js","../node_modules/bioconductor/src/DenseMatrix.js","../node_modules/scran.js/browser/groupedSizeFactors.js","../node_modules/bakana/browser/steps/crispr_quality_control.js","../node_modules/scran.js/browser/subset.js","../node_modules/scran.js/browser/initializeSparseMatrix.js","../node_modules/bakana/browser/steps/feature_selection.js","../node_modules/scran.js/browser/abstract/realize.js","../node_modules/scran.js/browser/mnnCorrect.js","../node_modules/bioconductor/src/IRanges.js","../node_modules/scran.js/browser/internal/computePerCellQcMetrics.js","../node_modules/papaparse/papaparse.min.js","../node_modules/scran.js/browser/cbind.js","../node_modules/bakana/browser/steps/adt_quality_control.js","../node_modules/bakana/browser/steps/neighbor_index.js","../node_modules/scran.js/browser/factorize.js","../node_modules/bakana/browser/readers/abstract/file.js","../node_modules/scran.js/browser/suggestRnaQcFilters.js","../node_modules/scran.js/browser/perCellRnaQcMetrics.js","../node_modules/bakana/browser/steps/rna_normalization.js","../node_modules/bakana/browser/steps/choose_clustering.js","../node_modules/scran.js/browser/filterCells.js","../node_modules/bioconductor/src/RangedSummarizedExperiment.js","../node_modules/scran.js/browser/wasm.js","../node_modules/scran.js/browser/perCellAdtQcMetrics.js","../node_modules/bakana/browser/steps/batch_correction.js","../node_modules/bioconductor/src/AllGenerics.js","../node_modules/bakana/browser/readers/utils/extract.js","../node_modules/scran.js/browser/clusterKmeans.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/rds.js","../node_modules/bakana/browser/steps/marker_detection.js","../node_modules/scran.js/browser/runTSNE.js","../node_modules/scran.js/browser/hypergeometricTest.js","../node_modules/scran.js/browser/MultiMatrix.js","../node_modules/bioconductor/src/Vector.js","../node_modules/gesel/src/fetchSetsForAllGenes.js","../node_modules/bakana/browser/steps/rna_pca.js","../node_modules/bakana/browser/readers/10x.js","../node_modules/scran.js/browser/internal/computePerCellQcFilters.js","../node_modules/wasmarrays.js/src/create.js","../node_modules/bioconductor/src/SummarizedExperiment.js","../node_modules/bioconductor/src/GroupedGRanges.js","../node_modules/bakana/browser/steps/crispr_normalization.js","../node_modules/scran.js/browser/scoreFeatureSet.js","../node_modules/gesel/src/fetchEmbeddings.js","../node_modules/gesel/src/fetchAllCollections.js","../node_modules/bioconductor/src/utils.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/bioconductor/src/InternalList.js","../node_modules/scran.js/browser/aggregateAcrossCells.js","../node_modules/bakana-remotes/src/utils.js","../node_modules/bakana-remotes/src/ExperimentHub.js","../node_modules/artifactdb/src/HttpError.js","../node_modules/bakana-remotes/src/CollaboratorDB.js","../node_modules/scran.js/browser/scoreMarkers.js","../node_modules/bakana/browser/steps/adt_pca.js"],"sourcesContent":["import { createWasmArray } from \"./create.js\";\n\n/**\n * Helper utility to determine the length of a subset, for use in allocations.\n *\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {?boolean} filter - How to interpret `subset`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {number} targetLength - Length of the target vector to be subsetted by `subset`.\n * @param {string} targetName - Name of the target vector, for use in error messages.\n *\n * @return {number} Length of the subsetted vector.\n */\nexport function checkSubsetLength(subset, filter, targetLength, targetName) {\n    if (filter === null) {\n        subset.forEach(i => {\n            if (i < 0 || i >= targetLength) {\n                throw new Error(\"'subset' contains out-of-range indices for '\" + targetName + \"'\");\n            }\n        });\n        return subset.length;\n    } \n\n    if (subset.length != targetLength) {\n        throw new Error(\"'subset' and '\" + targetName + \"' should have the same length\");\n    }\n\n    let sum = 0;\n    subset.forEach(x => { sum += (x != 0); });\n    if (filter) {\n        return subset.length - sum;\n    } \n\n    return sum;\n}\n\n/**\n * Helper utility to fill a subset from one TypedArray to another.\n *\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {?boolean} filter - How to interpret `subset`.\n * See the argument of the same name in {@linkcode subsetWasmArray} for more details.\n * @param {TypedArray} input - Input array to subset.\n * @param {TypedArray} output - Output array to store the subset, of length defined by {@linkcode checkSubsetLength}.\n *\n * @return `output` is filled with the specified subset of values from `input`.\n */\nexport function fillSubset(subset, filter, input, output) {\n    if (filter == null) {\n        subset.forEach((s, i) => {\n            output[i] = input[s];\n        });\n    } else if (filter) {\n        let j = 0;\n        subset.forEach((y, i) => {\n            if (y == 0) {\n                output[j] = input[i];\n                j++;\n            }\n        });\n    } else {\n        let j = 0;\n        subset.forEach((y, i) => {\n            if (y !== 0) {\n                output[j] = input[i];\n                j++;\n            }\n        });\n    }\n}\n\n/**\n * Create a new WasmArray from a subset of an existing WasmArray.\n * \n * @param {WasmArray} x - The input WasmArray.\n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n * \n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?WasmArray} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to `subset`, if `filter = null`; \n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {WasmArray} Array of the same type of `x` and in the same space, containing the desired subset `subset`.\n * If `buffer` is supplied, it is directly returned.\n */\nexport function subsetWasmArray(x, subset, { filter = null, buffer = null } = {}) {\n    let len = checkSubsetLength(subset, filter, x.length, \"x\"); \n\n    if (buffer == null) {\n        // Function better be a no-throw from now on.\n        buffer = createWasmArray(x.space, len, x.constructor);\n    } else if (buffer.length !== len) {\n        throw new Error(\"length of 'buffer' is not consistent with 'subset'\");\n    }\n\n    let barr = buffer.array();\n    let xarr = x.array();\n    fillSubset(subset, filter, xarr, barr);\n\n    return buffer;\n}\n","/**\n * Guess the identity of the features from their names.\n *\n * @param {Array} features - Array of strings containing feature identifiers, typically Ensembl IDs or gene symbols.\n * Elements may also be `null` or undefined if an identifier is missing.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceTaxonomy=false] - Whether to force the use of taxonomy IDs for human and mouse.\n * This is `false` for back compatibility.\n *\n * @return {object} An object containing:\n *\n * - `species`, the inferred species as a string.\n *   This can be either `\"human\"` or `\"mouse\"`, or an NCBI taxonomy ID (one of 6239, 10116, 9541, 7227, 7955, 9598).\n *   If `forceTaxonomy = true`, human and mouse are replaced with 9606 and 10090, respectively.\n * - `type`: the feature identifier type.\n *   This can either be `\"ensembl\"` or `\"symbol\"`.\n * - `confidence`: the percentage of entries in `x` that are consistent with the inferred identity.\n */\nexport function guessFeatures(features, { forceTaxonomy = false } = {}) {\n    let ntotal = features.length;\n    let early_threshold = Math.ceil(ntotal / 2);\n    let format = payload => {\n        payload.confidence /= ntotal;\n        return payload;\n    };\n\n    // Duplicated entries only count as one match, so as to avoid problems with\n    // chromosome positions, feature type specifications, etc. Note that we\n    // still need to use the full length to compute 'ntotal', otherwise we\n    // wouldn't be penalizing the duplicates properly.\n    let unique_features = new Set;\n    for (const f of features) {\n        if (typeof f == \"string\") {\n            unique_features.add(f);\n        }\n    }\n\n    let ensembl_human = 0;\n    let ensembl_mouse = 0;\n    let ensembl_6239 = 0;\n    let ensembl_10116 = 0; // Ensembl only, Rat symbols are indistiguishable from mice.\n    let ensembl_9541 = 0; // Ensembl only, Mfac symbols are indistiguishable from human.\n    let ensembl_7227 = 0; // Ensembl only, fly symbols are crazy.\n    let ensembl_7955 = 0;\n    let ensembl_9598 = 0; // Ensembl only, Chimp symbols are indistinguishable from human.\n\n    let symbol_human = 0;\n    let symbol_mouse = 0;\n    let symbol_6239 = 0;\n    let symbol_7955 = 0;\n\n    let hsid = (forceTaxonomy ? \"9606\" : \"human\");\n    let mmid = (forceTaxonomy ? \"10090\" : \"mouse\");\n    let collected = [];\n\n    // Checking if it's any type of Ensembl.\n    let any_ens = 0;\n    for (const x of unique_features) {\n        if (x && x.match(/^ENS[A-Z]*G[0-9]{11}$/)) {\n            any_ens++;\n        }\n    }\n\n    if (any_ens) {\n        for (const x of unique_features) {\n            if (x) {\n                if (x.startsWith(\"ENSG\")) {\n                    ensembl_human++;\n                } else if (x.startsWith(\"ENSMUSG\")) {\n                    ensembl_mouse++;\n                } else if (x.startsWith(\"ENSRNOG\")) {\n                    ensembl_10116++;\n                } else if (x.startsWith(\"ENSMFAG\")) {\n                    ensembl_9541++;\n                } else if (x.startsWith(\"ENSDARG\")) {\n                    ensembl_7955++;\n                } else if (x.startsWith(\"ENSPTRG\")) {\n                    ensembl_9598++;\n                }\n            }\n        }\n\n        collected.push({ species: hsid, type: \"ensembl\", confidence: ensembl_human });\n        collected.push({ species: mmid, type: \"ensembl\", confidence: ensembl_mouse });\n        collected.push({ species: \"10116\", type: \"ensembl\", confidence: ensembl_10116 });\n        collected.push({ species: \"9541\", type: \"ensembl\", confidence: ensembl_9541 });\n        collected.push({ species: \"7955\", type: \"ensembl\", confidence: ensembl_7955 });\n        collected.push({ species: \"9598\", type: \"ensembl\", confidence: ensembl_9598 });\n\n        // See if we can quit early and avoid the other checks.\n        for (const x of collected) {\n            if (x.confidence >= early_threshold) {\n                return format(x);\n            }\n        }\n    }\n\n    // Human symbol; starts with upper case, no lower case, and not an Ensembl of any kind.\n    // We also ignore VEGA gene identifiers, as these are antiquated; and MGI identifiers,\n    // which are all-caps and thus confusing.\n    for (const x of unique_features) {\n        if (x && x.match(/^[A-Z][^a-z]+$/) && !x.match(/^ENS[A-Z]+[0-9]{11}/) && !x.match(/^OTT.{4}[0-9]{11}/) && !x.match(/^MGI:[0-9]+/)) {\n            symbol_human++;\n        }\n    }\n    {\n        let payload = { species: hsid, type: \"symbol\", confidence: symbol_human };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Mouse symbol; starts with upper case, but no upper case after that.\n    for (const x of unique_features) {\n        if (x && x.match(/^[A-Z][^A-Z]+$/)) {\n            symbol_mouse++;\n        }\n    }\n    {\n        let payload = { species: mmid, type: \"symbol\", confidence: symbol_mouse };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Worm Ensembl (WormBase).\n    for (const x of unique_features) {\n        if (x && x.match(/^WBGene[0-9]+$/)) {\n            ensembl_6239++;\n        }\n    }\n    {\n        let payload = { species: \"6239\", type: \"ensembl\", confidence: ensembl_6239 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Fly Ensembl (FlyBase).\n    for (const x of unique_features) {\n        if (x && x.match(/^FBgn[0-9]+$/)) {\n            ensembl_7227++;\n        }\n    }\n    {\n        let payload = { species: \"7227\", type: \"ensembl\", confidence: ensembl_7227 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Worm symbols; at least three lower case with a dash and numbers.\n    for (const x of unique_features) {\n        if (x && x.match(/^[a-z]{3,}-[0-9]+$/)) {\n            symbol_6239++;\n        }\n    }\n    {\n        let payload = { species: \"6239\", type: \"symbol\", confidence: symbol_6239 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Zebrafish symbols; at least three lower case letters, no dash, followed by numbers and/or more lower case.\n    for (const x of unique_features) {\n        if (x && x.match(/^[a-z]{3,}[0-9a-z]+$/)) {\n            symbol_7955++;\n        }\n    }\n    {\n        let payload = { species: \"7955\", type: \"symbol\", confidence: symbol_7955 };\n        if (payload.confidence >= early_threshold) {\n            return format(payload);\n        }\n        collected.push(payload);\n    }\n\n    // Picking the best.\n    let highest = collected[0];\n    for (var i = 1; i < collected.length; i++) {\n        if (collected[i].confidence > highest.confidence) {\n            highest = collected[i];\n        }\n    }\n\n    return format(highest);\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Wrapper for the variance modelling results, produced by {@linkcode modelGeneVar}.\n * @hideconstructor\n */\nexport class ModelGeneVarResults {\n    #id;\n    #results;\n\n    #filledMeans;\n    #filledVariances;\n    #filledFitted;\n    #filledResiduals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledMeans = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledVariances = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledFitted = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n        this.#filledResiduals = utils.spawnArray(this.numberOfBlocks() + 1, filled);\n\n        return;\n    }\n\n    #extract(block, copy, fillable, fillcheck, method) {\n        let fillindex = block;\n        if (block == null) {\n            let nblocks = this.numberOfBlocks();\n            fillindex = (nblocks > 1 ? nblocks : 0);\n            block = -1;\n        }\n\n        return utils.checkFillness(\n            fillable, \n            copy, \n            fillcheck[fillindex], \n            () => { fillcheck[fillindex] = true }, \n            COPY => utils.possibleCopy(this.#results[method](block), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the mean log-expression across all cells in the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    means({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledMeans, \"means\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the variance of log-expression across all cells in the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    variances({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledVariances, \"variances\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the fitted value of the mean-variance trend for the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    fitted({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledFitted, \"fitted\");\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the residuals from the mean-variance trend for the specified `block`\n     * (or the average across all blocks, if `block < 0`).\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    residuals({ block = null, copy = true, fillable = false } = {}) {\n        return this.#extract(block, copy, fillable, this.#filledResiduals, \"residuals\");\n    }\n\n    /**\n     * @return {number} Number of blocks used.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Model the mean-variance trend across genes.\n *\n * @param {ScranMatrix} x - The normalized log-expression matrix.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to fit the mean-variance trend within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {number} [options.span=0.3] - Span to use for the LOWESS trend fitting.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {ModelGeneVarResults} Object containing the variance modelling results.\n */\nexport function modelGeneVar(x, { block = null, span = 0.3, numberOfThreads = null } = {}) {\n    var block_data;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.model_gene_var(x.matrix, use_blocks, bptr, span, nthreads),\n            ModelGeneVarResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n    \n    return output;\n}\n\n/**\n * Create an empty {@linkplain ModelGeneVarResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode chooseHVGs} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfGenes - Number of genes in the dataset.\n * @param {number} numberOfBlocks - Number of blocks in the dataset.\n *\n * @return {ModelGeneVarResults} Object with allocated memory to store variance modelling statistics, but no actual values.\n */\nexport function emptyModelGeneVarResults(numberOfGenes, numberOfBlocks) {\n    return gc.call(\n        module => new module.ModelGeneVar_Results(numberOfGenes, numberOfBlocks),\n        ModelGeneVarResults,\n        /* filled = */ false\n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellAdtQcMetricsResults } from \"./perCellAdtQcMetrics.js\";\n\n/**\n * Wrapper class for the ADT-based QC filtering results, produced by {@linkcode suggestAdtQcFilters}.\n * @hideconstructor\n */\nexport class SuggestAdtQcFiltersResults {\n    #results;\n    #id;\n\n    #filledDetected;\n    #filledSubsetTotals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledDetected = filled;\n        this.#filledSubsetTotals = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the number of detected ADTs for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsDetected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the total counts for subset `i` in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSubsetTotals(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetTotals[i], \n            () => { this.#filledSubsetTotals[i] = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_subset_totals(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellAdtQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellAdtQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestAdtQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellAdtQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellAdtQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics from the ADT count matrix.\n *\n * @param {PerCellAdtQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellAdtQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {number} [options.minDetectedDrop=0.1] - Minimum relative drop in the number of detected ADTs before a cell is to be considered a low-quality cell.\n * By default, cells must exhibit at least a 10% decrease from the median before filtering is applied.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestAdtQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestAdtQcFilters(metrics, { numberOfMADs = 3, minDetectedDrop = 0.1, block = null } = {}) {\n    if (!(metrics instanceof PerCellAdtQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellAdtQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics, \n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_adt_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs, minDetectedDrop),\n            SuggestAdtQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestAdtQcFiltersResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode filterCells} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfSubsets Number of feature subsets.\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestAdtQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestAdtQcFiltersResults(numberOfSubsets, numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestAdtQcFilters_Results(numberOfSubsets, numberOfBlocks),\n        SuggestAdtQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","/**\n * @param {Array|TypedArray} x - Array of values to be interpreted as truthy or falsey.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.not=false] - Whether to select the entries of `x` that are falsey.\n *\n * @return {Array} Array of indices of the entries of `x` that are truthy (if `not=false`) or falsey (if `not=true`).\n * This array is guaranteed to be sorted in ascending order.\n */\nexport function which(x, { not = false } = {}) {\n    let output = [];\n    x.forEach((y, i) => {\n        if ((!y) == not) {\n            output.push(i);\n        }\n    });\n    return output;\n}\n\n/**\n * Given a factor, return the indices corresponding to each level.\n * This can be used in subsequent {@linkcode splitRows} calls.\n *\n * @param {Array|TypedArray} factor - Array containing the factor of interest.\n *\n * @return {Object} Object where each key is a factor level and each value is an array containing the indices corresponding to that level in `factor`.\n */\nexport function presplitFactor(factor) {\n    let by = {};\n    factor.forEach((x, i) => {\n        if (!(x in by)) {\n            by[x] = [];\n        }\n        by[x].push(i);\n    });\n    return by;\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./utils/viz_parent.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\nimport * as aworkers from \"./abstract/worker_parent.js\";\n\n/**\n * This creates a t-SNE embedding based on the neighbor index constructed by {@linkplain NeighborIndexState}.\n * This wraps [`runTSNE`](https://kanaverse.github.io/scran.js/global.html#runTSNE)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class TsneState {\n    #index;\n    #parameters;\n    #reloaded;\n\n    #worker_id;\n\n    #ready;\n    #run;\n\n    constructor(index, parameters = null, reloaded = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#reloaded = reloaded;\n        this.changed = false;\n\n        let worker = aworkers.createTsneWorker();\n        let { worker_id, ready } = vizutils.initializeWorker(worker, vizutils.scranOptions);\n        this.#worker_id = worker_id;\n        this.#ready = ready;\n\n        this.#run = null;\n    }\n\n    ready() {\n        // It is assumed that the caller will await the ready()\n        // status before calling any other methods of this instance.\n        return this.#ready;\n    }\n\n    free() {\n        return vizutils.killWorker(this.#worker_id);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to create a copy of the coordinates,\n     * if the caller might mutate them.\n     *\n     * @return {object} Object containing:\n     *\n     * - `x`: a Float64Array containing the x-coordinate for each cell.\n     * - `y`: a Float64Array containing the y-coordinate for each cell.\n     * - `iterations`: the number of iterations processed.\n     *\n     * @async\n     */\n    async fetchResults({ copy = true } = {}) {\n        if (this.#reloaded !== null) {\n            let output = {\n                x: this.#reloaded.x,\n                y: this.#reloaded.y\n            };\n\n            if (copy) {\n                output.x = output.x.slice();\n                output.y = output.y.slice();\n            }\n        \n            output.iterations = this.#parameters.iterations;\n            return output;\n        } else {\n            // Vectors that we get from the worker are inherently\n            // copied, so no need to do anything extra here.\n            await this.#run;\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"FETCH\" });\n        }\n    }\n\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #core(perplexity, iterations, animate, reneighbor) {\n        var nn_out = null;\n        if (reneighbor) {\n            var k = scran.perplexityToNeighbors(perplexity);\n            nn_out = vizutils.computeNeighbors(this.#index, k);\n        }\n\n        let args = {\n            \"perplexity\": perplexity,\n            \"iterations\": iterations,\n            \"animate\": animate\n        };\n\n        // This returns a promise but the message itself is sent synchronously,\n        // which is important to ensure that the t-SNE runs in its worker in\n        // parallel with other analysis steps. Do NOT put the runWithNeighbors\n        // call in a .then() as this may defer the message sending until \n        // the current thread is completely done processing.\n        this.#run = vizutils.runWithNeighbors(this.#worker_id, args, nn_out);\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `tsne` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.perplexity - Number specifying the perplexity for the probability calculations.\n     * @param {number} parameters.iterations - Number of iterations to run the algorithm.\n     * @param {boolean} parameters.animate - Whether to process animation iterations, see {@linkcode setVisualizationAnimate} for details.\n     *\n     * @return t-SNE coordinates are computed in parallel on a separate worker thread.\n     * A promise is returned that resolves when those calculations are complete.\n     */\n    compute(parameters) {\n        let { perplexity, iterations, animate } = parameters;\n\n        let same_neighbors = (!this.#index.changed && perplexity === this.#parameters.perplexity);\n        if (same_neighbors && iterations == this.#parameters.iterations) {\n            this.changed = false;\n            return new Promise(resolve => resolve(null));\n        }\n\n        // In the reloaded state, we must send the neighbor\n        // information, because it hasn't ever been sent before.\n        if (this.#reloaded !== null) {\n            same_neighbors = false;\n            this.#reloaded = null;\n        }\n\n        this.#core(perplexity, iterations, animate, !same_neighbors);\n\n        this.#parameters.perplexity = perplexity;\n        this.#parameters.iterations = iterations;\n        this.#parameters.animate = animate;\n\n        this.changed = true;\n        return this.#run;\n    }\n\n    /***************************\n     ******* Animators *********\n     ***************************/\n\n    /**\n     * Repeat the animation iterations.\n     * It is assumed that {@linkcode setVisualizationAnimate} has been set appropriately to process each iteration.\n     *\n     * @return A promise that resolves on successful completion of all iterations.\n     */\n    animate() {\n        if (this.#reloaded !== null) {\n            this.#reloaded = null;\n\n            // We need to reneighbor because we haven't sent the neighbors across yet.\n            this.#core(this.#parameters.perplexity, this.#parameters.iterations, true, true);\n\n            // Mimicking the response from the re-run.\n            return this.#run\n                .then(contents => {\n                    return {\n                        \"type\": \"tsne_rerun\",\n                        \"data\": { \"status\": \"SUCCESS\" }\n                    };\n                });\n        } else {\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"RERUN\" });\n        }\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport async function unserialize(handle, index) {\n    let ghandle = handle.open(\"tsne\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            perplexity: phandle.open(\"perplexity\", { load: true }).values[0],\n            iterations: phandle.open(\"iterations\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let reloaded;\n    {\n        let rhandle = ghandle.open(\"results\");\n        reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    let output = new TsneState(index, parameters, reloaded);\n    await output.ready();\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\n\nexport const step_name = \"snn_graph_cluster\";\n\n/**\n * This step does SNN graph clustering based on the neighbor search index built by {@linkplain NeighborIndexState}.\n * This wraps [`clusterSNNGraph`](https://kanaverse.github.io/scran.js/global.html#clusterSNNGraph) \n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class SnnGraphClusterState {\n    #index;\n    #parameters;\n    #cache;\n\n    constructor(index, parameters = null, cache = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.neighbors);\n        utils.freeCache(this.#cache.graph);\n        utils.freeCache(this.#cache.clusters);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode SnnGraphClusterState#compute compute}.\n     */\n    fetchClusters() {\n        if (!this.#valid()) {\n            throw \"cannot fetch SNN clusters from an invalid state\";\n        } else {\n            return this.#cache.clusters.membership({ copy: \"view\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #valid() {\n        return \"clusters\" in this.#cache;\n    }\n\n    #compute_neighbors(k) {\n        this.#cache.neighbors = scran.findNearestNeighbors(this.#index.fetchIndex(), k);\n        return;\n    }\n\n    #compute_graph(scheme) {\n        if (!(\"neighbors\" in this.#cache)) { // need to check as reloaded state will not populate the internals.\n            this.#compute_neighbors(this.#parameters.k);\n        }\n        this.#cache.graph = scran.buildSNNGraph(this.#cache.neighbors, { scheme: scheme });\n        return;\n    }\n\n    #compute_clusters(algorithm, multilevel_resolution, leiden_resolution, walktrap_steps) {\n        if (!(\"graph\" in this.#cache)) {\n            this.#compute_graph(this.#parameters.scheme);\n        }\n        this.#cache.clusters = scran.clusterSNNGraph(this.#cache.graph, {\n            method: algorithm,\n            multiLevelResolution: multilevel_resolution,\n            leidenResolution: leiden_resolution,\n            leidenModularityObjective: true, // avoid problems with unstable interpretation of leidenResolution.\n            walktrapSteps: walktrap_steps\n        });\n        return;\n    }\n\n    static defaults() {\n        return { \n            k: 10,\n            scheme: \"rank\",\n            algorithm: \"multilevel\",\n            multilevel_resolution: 1,\n            leiden_resolution: 1,\n            walktrap_steps: 4\n        };\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {boolean} run_me - Whether or not to run this step, depending on the clustering method chosen by the user (see {@linkplain ChooseClusteringState}).\n     * @param {object} parameters - Parameter object, equivalent to the `snn_graph_cluster` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.k - Number of nearest neighbors used to construct the graph.\n     * @param {string} parameters.scheme - Weighting scheme for graph construction.\n     * This can be one of `\"rank\"`, `\"number\"` or `\"jaccard\"`.\n     * @param {string} parameters.algorithm - Algorithm to use for community detection.\n     * This can be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n     * @param {number} parameters.multilevel_resolution - Resolution of the multi-level community detection.\n     * @param {number} parameters.leiden_resolution - Resolution of the Leiden community detection.\n     * @param {number} parameters.walktrap_steps - Number of merge steps for the Walktrap algorithm.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(run_me, parameters) {\n        let { k, scheme, algorithm, multilevel_resolution, leiden_resolution, walktrap_steps } = parameters;\n        this.changed = false;\n\n        if (this.#index.changed || k !== this.#parameters.k) {\n            utils.freeCache(this.#cache.neighbors);\n            if (run_me) {\n                this.#compute_neighbors(k);\n            } else {\n                delete this.#cache.neighbors; // ensuring that this is re-run on future calls to compute() with run_me = true.\n            }\n            this.#parameters.k = k;\n            this.changed = true;\n        }\n\n        if (this.changed || scheme !== this.#parameters.scheme) {\n            utils.freeCache(this.#cache.graph);\n            if (run_me) {\n                this.#compute_graph(scheme);\n            } else {\n                delete this.#cache.graph;\n            }\n            this.#parameters.scheme = scheme;\n            this.changed = true \n        }\n\n        if (this.changed \n            || algorithm !== this.#parameters.algorithm \n            || multilevel_resolution !== this.#parameters.multilevel_resolution \n            || leiden_resolution !== this.#parameters.leiden_resolution \n            || walktrap_steps !== this.#parameters.walktrap_steps \n            || (!this.#valid() && run_me))\n        {\n            utils.freeCache(this.#cache.clusters);\n            if (run_me) {\n                this.#compute_clusters(algorithm, multilevel_resolution, leiden_resolution, walktrap_steps);\n            } else {\n                delete this.#cache.clusters;\n            }\n\n            this.#parameters.algorithm = algorithm;\n            this.#parameters.multilevel_resolution = multilevel_resolution;\n            this.#parameters.leiden_resolution = leiden_resolution;\n            this.#parameters.walktrap_steps = walktrap_steps;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, index) {\n    let ghandle = handle.open(\"snn_graph_cluster\");\n\n    let parameters = SnnGraphClusterState.defaults();\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters.k = phandle.open(\"k\", { load: true }).values[0];\n\n        parameters.scheme = phandle.open(\"scheme\", { load: true }).values[0];\n        if (typeof parameters.scheme !== \"string\") { // because I stuffed up and tried to save a string as an int in v1.0, oops.\n            parameters.scheme = \"rank\";\n        }\n\n        if (\"algorithm\" in phandle.children) {\n            // v3.0\n            parameters.algorithm = phandle.open(\"algorithm\", { load: true }).values[0];\n            parameters.multilevel_resolution = phandle.open(\"multilevel_resolution\", { load: true }).values[0];\n            parameters.leiden_resolution = phandle.open(\"leiden_resolution\", { load: true }).values[0];\n            parameters.walktrap_steps = phandle.open(\"walktrap_steps\", { load: true }).values[0];\n        } else {\n            // v2.0\n            parameters.multilevel_resolution = phandle.open(\"resolution\", { load: true }).values[0];\n        }\n    }\n\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n        if (\"clusters\" in rhandle.children) {\n            let clusters = rhandle.open(\"clusters\", { load: true }).values;\n            cache.clusters = scran.emptyClusterSNNGraphResults(clusters.length, 1);\n            cache.clusters.setBest(0); // whatever.\n            cache.clusters.membership({ fillable: true }).set(clusters);\n        }\n    }\n\n    return new SnnGraphClusterState(index, parameters, cache);\n}\n\n\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellCrisprQcMetricsResults } from \"./perCellCrisprQcMetrics.js\";\n\n/**\n * Wrapper class for the filtering results, produced by {@linkcode computeSuggestCrisprQcFilters}.\n * @hideconstructor\n */\nexport class SuggestCrisprQcFiltersResults {\n    #id;\n    #results;\n\n    #filledMaxCount;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledMaxCount = filled;\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the maximum count in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsMaxCount({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxCount, \n            () => { this.#filledMaxCount = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_max_count(), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellCrisprQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellCrisprQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestCrisprQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellCrisprQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellCrisprQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics for CRISPR guide counts.\n *\n * @param {PerCellCrisprQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellCrisprQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestCrisprQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestCrisprQcFilters(metrics, { numberOfMADs = 3, block = null } = {}) {\n    if (!(metrics instanceof PerCellCrisprQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellCrisprQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics,\n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_crispr_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs),\n            SuggestCrisprQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestCrisprQcFiltersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestCrisprQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestCrisprQcFiltersResults(numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestCrisprQcFilters_Results(numberOfBlocks),\n        SuggestCrisprQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as correct_module from \"./batch_correction.js\";\n\n/**\n * This step performs k-means clustering on the PCs, \n * wrapping the [`clusterKmeans`](https://kanaverse.github.io/scran.js/global.html#clusterKmeans) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class KmeansClusterState {\n    #correct;\n    #parameters;\n    #cache;\n\n    constructor(correct, parameters = null, cache = null) {\n        if (!(correct instanceof correct_module.BatchCorrectionState)) {\n            throw new Error(\"'correct' should be a BatchCorrectionState object\");\n        }\n        this.#correct = correct;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.raw);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode KmeansClusterState#compute compute}.\n     */\n    fetchClusters() {\n        if (!this.#valid()) {\n            throw new Error(\"cannot fetch k-means clusters from an invalid state\");\n        } else {\n            return this.#cache.raw.clusters({ copy: \"view\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters };\n    };\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #valid() {\n        return \"raw\" in this.#cache;\n    }\n\n    /** \n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {boolean} run_me - Whether or not to run this step, depending on the clustering method chosen by the user (see {@linkplain ChooseClusteringState}).\n     * @param {object} parameters - Parameter object, equivalent to the `choose_clustering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.k - Number of clusters to create.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(run_me, parameters) {\n        let { k } = parameters;\n        this.changed = false;\n\n        if (this.#correct.changed || k != this.#parameters.k || (!this.#valid() && run_me)) {\n            utils.freeCache(this.#cache.raw);\n\n            if (run_me) {\n                var pcs = this.#correct.fetchCorrected();\n                this.#cache.raw = scran.clusterKmeans(pcs, k, { \n                    numberOfDims: this.#correct.fetchNumberOfDimensions(),\n                    numberOfCells: this.#correct.fetchNumberOfCells(),\n                    initMethod: \"pca-part\" \n                });\n            } else {\n                delete this.#cache.raw; // ensure this step gets re-run later when run_me = true. \n            }\n\n            this.#parameters.k = k;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca) {\n    let parameters = {\n        k: 10\n    };\n    let cache = {};\n\n    // Protect against old analysis states that don't have kmeans_cluster.\n    if (\"kmeans_cluster\" in handle.children) {\n        let ghandle = handle.open(\"kmeans_cluster\");\n\n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.k = phandle.open(\"k\", { load: true }).values[0];\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            if (\"clusters\" in rhandle.children) {\n                let clusters = rhandle.open(\"clusters\", { load: true }).values;\n                cache.raw = scran.emptyClusterKmeansResults(clusters.length, parameters.k, pca.fetchNumberOfDimensions());\n                cache.raw.clusters({ fillable: true }).set(clusters);\n            }\n        }\n    }\n\n    return new KmeansClusterState(pca, parameters, cache);\n}\n","import * as utils from \"./general.js\";\n\nexport function subsetSums(qc, filter, mat, cache, name) {\n    let output = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache, name);\n    let discards = filter.fetchDiscards();\n\n    // unsafe, so no more Wasm allocations past this point. \n    let sums = qc.fetchMetrics().sums({ copy: false }); \n\n    if (discards == null) {\n        output.set(sums);\n    } else {\n        let oarr = output.array();\n        var j = 0;\n        discards.forEach((x, i) => {\n            if (!x) {\n                if (j == output.length) {\n                    throw new Error(\"normalization and filtering are not in sync\");\n                }\n                oarr[j] = sums[i];\n                j++;\n            }\n        });\n        if (j !== output.length) {\n            throw new Error(\"normalization and filtering are not in sync\");\n        }\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport { ModelGeneVarResults } from \"./modelGeneVar.js\";\n\n/**\n * Compute the filter threshold required to retain the top `number` values.\n *\n * @param {Array|TypedArray} x - Array of numeric values, typically per-gene statistics.\n * @param {number} number - Number of top values to retain after filtering on the returned threshold.\n * This may be approximate in the presence of ties.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.largest=true] - Whether the top values in `x` are defined as the largest numeric values.\n * If `false`, the top values are considered to be the smallest.\n * @param {boolean} [options.copy=true] - Whether to copy `x` before sorting.\n * If `false`, `x` may be modified in-place.\n *\n * @return {number} Threshold to be applied to `x` to obtain the top (approximately) `number` values.\n * If `largest = true`, filtering is performed by taking all values in `x` that are greater than or equal to the returned threshold;\n * if `false`, filtering is performed by taking all values in `x` that are less than or equal to the returned threshold.\n * If `x` is zero-length, NaN is returned.\n */\nexport function computeTopThreshold(x, number, { copy = true, largest = true } = {}) {\n    if (copy) {\n        x = x.slice();\n    }\n\n    if (x instanceof Array) {\n        x.sort((a, b) => a - b); // just in case...\n    } else {\n        x.sort();\n    }\n\n    if (x.length == 0) {\n        return Number.NaN;\n    }\n\n    if (largest) {\n        return x[Math.max(0, x.length - number)]; \n    } else {\n        return x[Math.min(number, x.length) - 1]; \n    }\n}\n\n/**\n * Choose the highly variable genes from variance modelling statistics.\n *\n * @param {(TypedArray|ModelGeneVarResults)} x -\n * A TypedArray of statistics, where larger values correspond to higher variability;\n * or a {@linkplain ModelGeneVarResults} object, in which case the residuals are used as the statistics.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.number=4000] - Number of highly variable genes to select.\n * @param {number} [options.minimum=0] - Minimum value of the residual to consider for a highly variable gene.\n * By default, a highly variable gene must have a non-negative residual.\n *\n * @return {Uint8WasmArray} Array of length equal to the total number of genes,\n * where the chosen highly variable genes are marked with a value of 1 and all other genes have values of zero.\n */\nexport function chooseHVGs(x, { number = 4000, minimum = 0 } = {}) {\n    let stat; \n    if (x instanceof ModelGeneVarResults) {\n        stat = x.residuals();\n    } else {\n        stat = x.slice();\n    }\n\n    let threshold = computeTopThreshold(stat, number, { largest: true, copy: false });\n    if (threshold < minimum) {\n        threshold = minimum;\n    }\n\n    let features = utils.createUint8WasmArray(stat.length);\n    try {\n        // Do this AFTER the features allocation, so that\n        // we can set copy = false for the input array.\n        if (x instanceof ModelGeneVarResults) {\n            stat = x.residuals({ copy: false });\n        } else {\n            stat = x;\n        }\n\n        let farr = features.array();\n        stat.forEach((x, i) => {\n            farr[i] = x >= threshold;\n        });\n\n    } catch (e) {\n        features.free();\n        throw e;\n    }\n\n    return features;\n}\n","import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as wasm from \"./wasm.js\";\n\n/**\n * Compute log-transformed normalized expression values.\n *\n * @param {ScranMatrix} x The count matrix, usually after filtering.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Float64WasmArray|Array|TypedArray)} [options.sizeFactors=null] - Array of positive numbers containing the size factor for each cell in `x`.\n * This should have length equal to the number of columns in `x`.\n * If `null`, size factors are computed from the column sums of `x`.\n * @param {boolean} [options.center=true] - Whether to center the size factors so that the normalized expression values are comparable in magnitude to the input counts.\n * Set this to `false` if `sizeFactors` are provided and already centered, e.g., with {@linkcode centerSizeFactors}.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to adjust the scaling of cells in different blocks, to avoid excessive up-scaling of low-coverage blocks.\n *\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * This option is ignored if `center = false`, in which case it is assumed that scaling has already been provided in the input `sizeFactors`.\n * @param {boolean} [options.allowZeros=false] - Whether size factors of zero should be allowed.\n * If `true`, no scaling normalization is performed for the corresponding cells, under the assumption they are all-zero libraries.\n * If `false`, an error is raised instead.\n *\n * @return {ScranMatrix} A matrix of the same type as `x` containing log-transformed normalized expression values.\n */\nexport function logNormCounts(x, { sizeFactors = null, center = true, block = null, allowZeros = false } = {}) {\n    var sf_data;\n    var block_data;\n    var output;\n\n    try {\n        var sfptr = 0;\n        var use_sf = false;\n\n        if (sizeFactors !== null) {\n            sf_data = utils.wasmifyArray(sizeFactors, \"Float64WasmArray\");\n            if (sf_data.length != x.numberOfColumns()) {\n                throw new Error(\"length of 'sizeFactors' must be equal to number of columns in 'x'\");\n            }\n            sfptr = sf_data.offset;\n            use_sf = true;\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.log_norm_counts(x.matrix, use_sf, sfptr, use_blocks, bptr, center, allowZeros),\n            x.constructor\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(sf_data);\n        utils.free(block_data);\n    }\n    \n    return output;\n}\n\n/**\n * Center size factors in preparation for log-transformation.\n * This is usually called by {@linkcode logNormCounts} internally, but can also be directly called by users to reconstitute the size factors used in the log-normalized matrix.\n *\n * @param {TypedArray|WasmArray} sizeFactors - Array of non-negative size factors, one per cell.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell, see {@linkcode logNormCounts}.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output size factors.\n * Length should be equal to that of `sizeFactors`.\n * If `null`, an array is allocated by the function.\n *\n * @return {Float64WasmArray} Array containing the centered size factors.\n * If `buffer` is provided, it is returned directly.\n */\nexport function centerSizeFactors(sizeFactors, { block = null, buffer = null } = {}) {\n    let local_buffer;\n    let block_data;\n\n    try {\n        if (buffer === null) {\n            local_buffer = utils.createFloat64WasmArray(sizeFactors.length);\n            buffer = local_buffer;\n        }\n\n        if (buffer !== sizeFactors) {\n            buffer.set(sizeFactors instanceof wa.WasmArray ? sizeFactors.array() : sizeFactors);\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != buffer.length) {\n                throw new Error(\"'block' must be of length equal to that of 'sizeFactors'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        wasm.call(module => module.center_size_factors(buffer.length, buffer.offset, use_blocks, bptr));\n\n    } catch(e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n\n    return buffer;\n}\n","import * as generics from \"./AllGenerics.js\";\n\nexport function setterTarget(object, inPlace) {\n    return (inPlace ? object : generics.CLONE(object, { deepCopy: false }));\n}\n\nexport function cloneField(value, deepCopy) {\n    return (deepCopy ? generics.CLONE(value) : value);\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchAllCollections.js\";\n\nconst _cache = new Map;\nconst _ranges = new Map;\nconst _sizes = new Map;\nconst _starts = new Map;\n\nasync function initialize(species) {\n    let res = await utils.retrieveRangesWithExtras(species + \"_collections.tsv\");\n    _ranges.set(species, res.ranges);\n    _sizes.set(species, res.extra);\n\n    let first = 0;\n    let starts = [];\n    for (const s of res.extra) {\n        starts.push(first);\n        first += s;\n    }\n    _starts.set(species, starts);\n\n    _cache.set(species, new Map);\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {Array} Number of sets in each collection.\n * Each value corresponds to a collection in {@linkcode fetchAllCollections}.\n * @async\n */\nexport async function fetchCollectionSizes(species) {\n    return utils.fetchSizes(species, _sizes, full.fetchAllCollections, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {number} Total number of collections for this species.\n * @async\n */\nexport async function numberOfCollections(species) {\n    return utils.fetchNumber(species, _sizes, full.fetchAllCollections, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} collection - Collection ID, see {@linkcode fetchAllCollections} for details.\n * \n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a request to the server.\n * By default, the return value is extracted from the full collection details if {@linkcode fetchAllCollections} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all collection details up-front to avoid range requests.\n * This is done by calling {@linkcode fetchAllCollections}.\n * Ignored if `forceRequest = true`.\n *\n * @return {object} Object containing the details of the collection.\n * This should be identical to the corresponding entry of the array returned by {@linkcode fetchAllCollections}.\n *\n * If `collection = null`, no return value is provided.\n * @async\n */\nexport async function fetchSingleCollection(species, collection, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchAllCollections(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (collection !== null) {\n                return ffound[collection];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let cached = _cache.get(species);\n    if (typeof cached === \"undefined\") {\n        await initialize(species);\n        cached = _cache.get(species);\n    }\n\n    if (collection == null) {\n        return;\n    }\n\n    let cfound = cached.get(collection);\n    if (typeof cfound !== \"undefined\") {\n        return cfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_collections.tsv\", _ranges.get(species), collection);\n    let split = text.split(\"\\t\");\n    let output = {\n        title: split[0],\n        description: split[1],\n        species: split[2],\n        maintainer: split[3],\n        source: split[4],\n        start: _starts.get(species)[collection],\n        size: _sizes.get(species)[collection]\n    };\n\n    cached.set(collection, output);\n    return output;\n}\n\n\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"crispr_pca\";\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise CRISPR abundance data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprPcaState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm' should be a CrisprNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized CRISPR abundance matrix,\n     * available after running {@linkcode CrisprPcaState#compute compute}.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be `\"none\"`, `\"regress\"` or `\"weight\"`, see comments in {@linkplain RnaPcaState}.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            if (this.valid()) {\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                utils.freeCache(this.#cache.pcs);\n                this.#cache.pcs = scran.runPCA(mat, { numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm) {\n    let cache = {};\n    let parameters = CrisprPcaState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"var_exp\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n\n            output = new CrisprPcaState(filter, norm, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.pcs);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        output = new CrisprPcaState(filter, norm, parameters, cache);\n    }\n\n    return output;\n}\n","export function registerCallback(worker, callback) {\n    worker.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(worker, message, transfer) {\n    worker.postMessage(message, transfer);\n    return;\n}\n\nexport function terminateWorker(worker) {\n    worker.terminate();\n    return;\n}\n","import * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { buildNeighborSearchIndex, BuildNeighborSearchIndexResults } from \"./findNearestNeighbors.js\"; \n\n/**\n * Scale embeddings based on the variation between neighboring cells.\n * This aims to equalize the noise across embeddings for the same population of cells across different data modalities,\n * allowing them to be combined into a single embedding for coordinated downstream analyses.\n *\n * @param {Array} embeddings - Array of Float64WasmArrays containing column-major matrices where rows are dimensions and columns are cells.\n * All entries of this array should contain data for the same number and ordering of cells.\n * @param {number} numberOfCells - Number of cells in all embeddings.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.neighbors=20] - Number of neighbors to use for quantifying variation.\n * Larger values provide a more stable calculation but assume larger subpopulations.\n * @param {?Array} [options.indices=null] - Array of {@linkplain BuildNeighborSearchIndexResults} objects, \n * where each entry is constructed from the corresponding entry of `embeddings` (see {@linkcode buildNeighborSearchIndex}).\n * This can be used to avoid redundant calculation of indices if they are already available.\n * @param {?Float64WasmArray} [options.buffer=null] - Array in which to store the combined embedding.\n * This should have length equal to the product of `numberOfCells` and the sum of dimensions of all embeddings.\n * @param {boolean} [options.approximate=true] - Should we construct an approximate search index if `indices` is not supplied?\n * @param {?(Array|TypedArray|Float64WasmArray)} [options.weights=null] - Array of length equal to the number of embeddings, containing a non-enegative relative weight for each embedding.\n * This is used to scale each embedding if non-equal noise is desired in the combined embedding.\n * If `null`, all embeddings receive the same weight.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array containing the combined embeddings in column-major format, i.e., dimensions in rows and cells in columns.\n *\n * If `buffer` was supplied, it is used as the return value.\n */\nexport function scaleByNeighbors(embeddings, numberOfCells, { neighbors = 20, indices = null, buffer = null, approximate = true, weights = null, numberOfThreads = null } = {}) {\n    let nembed = embeddings.length;\n    let embed_ptrs, index_ptrs;\n    let holding_ndims;\n    let holding_weights;\n    let local_buffer;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    let deletable = [];\n    try {\n        // Fetching the pointers.\n        embed_ptrs = utils.createBigUint64WasmArray(nembed);\n        let embed_arr = embed_ptrs.array();\n        for (var i = 0; i < nembed; i++) {\n            embed_arr[i] = BigInt(embeddings[i].offset);\n        }\n\n        let weight_offset = 0;\n        let use_weights = false;\n        if (weights !== null) {\n            use_weights = true;\n            holding_weights = utils.wasmifyArray(weights, \"Float64WasmArray\");\n            if (holding_weights.length != nembed) {\n                throw new Error(\"length of 'weights' should be equal to the number of embeddings\");\n            }\n            weight_offset = holding_weights.offset;\n        }\n\n        // Allocating output space, if necessary; and then scaling.\n        let allocator = (total_ndim) => {\n            let total_len = total_ndim * numberOfCells;\n            if (buffer === null) {\n                local_buffer = utils.createFloat64WasmArray(total_len);\n                buffer = local_buffer;\n            } else if (total_len !== buffer.length) {\n                throw new Error(\"length of 'buffer' should be equal to the product of 'numberOfCells' and the total number of dimensions\");\n            }\n        }\n\n        if (indices !== null) {\n            if (nembed !== indices.length) {\n                throw new Error(\"'indices' and 'embeddings' should have the same length\");\n            }\n\n            index_ptrs = utils.createBigUint64WasmArray(nembed);\n            let index_arr = index_ptrs.array();\n            let total_ndim = 0;\n\n            for (var i = 0; i < nembed; i++) {\n                let index = indices[i];\n                if (numberOfCells != index.numberOfCells()) {\n                    throw new Error(\"each element of 'indices' should have the same number of cells as 'numberOfCells'\");\n                }\n                if (embeddings[i].length != index.numberOfCells() * index.numberOfDims()) {\n                    throw new Error(\"length of arrays in 'embeddings' should equal the length of arrays used to build 'indices'\");\n                }\n\n                index_arr[i] = BigInt(indices[i].index.$$.ptr);\n                total_ndim += indices[i].numberOfDims();\n            }\n\n            allocator(total_ndim);\n            wasm.call(module => module.scale_by_neighbors_indices(\n                numberOfCells, \n                nembed, \n                embed_ptrs.offset, \n                index_ptrs.offset, \n                buffer.offset, \n                neighbors, \n                use_weights, \n                weight_offset,\n                nthreads\n            ));\n\n        } else {\n            holding_ndims = utils.createInt32WasmArray(nembed);\n            let ndims_arr = holding_ndims.array();\n            let total_ndim = 0;\n\n            for (var i = 0; i < nembed; i++) {\n                let n = embeddings[i].length;\n                ndims_arr[i] = Math.floor(n / numberOfCells);\n                if (numberOfCells * ndims_arr[i] !== n) {\n                    throw new Error(\"length of arrays in 'embeddings' should be a multiple of 'numberOfCells'\");\n                }\n                total_ndim += ndims_arr[i];\n            }\n\n            allocator(total_ndim);\n            wasm.call(module => module.scale_by_neighbors_matrices(\n                numberOfCells, \n                nembed, \n                holding_ndims.offset, \n                embed_ptrs.offset, \n                buffer.offset, \n                neighbors, \n                use_weights, \n                weight_offset,\n                approximate,\n                nthreads\n            ));\n        }\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        for (const x of deletable) {\n            x.free();\n        }\n        utils.free(embed_ptrs);\n        utils.free(index_ptrs);\n        utils.free(holding_weights);\n        utils.free(holding_ndims);\n    }\n\n    return buffer;\n}\n","/**\n * Reindex the gene-to-set mappings for a user-defined gene universe.\n * This is helpful for applications that know their own gene universe and want to create a mapping of all sets containing each of their own genes.\n *\n * @param {Array} geneMapping - Array of length equal to the number of genes in a user-defined gene universe.\n * Each entry corresponds to one gene in the user's universe and should be an array containing the corresponding **gesel** gene ID(s) (see {@linkcode fetchAllGenes} for details).\n * @param {Array} setsForGenes - Array of length equal to the number of **gesel** gene IDs.\n * Each entry corresponds to a **gesel** gene ID and is an array containing the set IDs for all sets containing that gene.\n * This is typically obtained from {@linkcode fetchSetsForAllGenes}.\n *\n * @return {Array} Array of length equal to `geneMapping`.\n * Each entry corresponds to a gene in the user-supplied universe and is a Uint32Array where the elements are the **gesel** set IDs containing that gene.\n * If a gene in `geneMapping` maps to multiple **gesel** IDs, we report all sets containing any of its mapped **gesel** gene IDs.\n */\nexport function reindexSetsForAllGenes(geneMapping, setsForGenes) {\n    let remapped = new Array(geneMapping.length);\n    for (var i = 0; i < geneMapping.length; i++) {\n        let collected = new Set;\n        for (const gesel_gene of geneMapping[i]) {\n            for (const set of setsForGenes[gesel_gene]) {\n                collected.add(set);\n            }\n        }\n        remapped[i] = (new Uint32Array(collected)).sort();\n    }\n    return remapped;\n}\n","import * as scran from \"scran.js\"; \nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as rutils from \"../readers/index.js\";\n\nconst baseUrl = \"https://github.com/kanaverse/kana-special-features/releases/download/v1.0.0\";\n\nexport const step_name = \"rna_quality_control\";\n\n/**\n * Results of computing per-cell RNA-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellRnaQcMetricsResults.html) for details.\n *\n * @external PerCellRnaQcMetricsResults\n */\n\n/**\n * Suggested filters for the RNA-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestRnaQcFiltersResults.html) for details.\n *\n * @external SuggestRnaQcFiltersResults\n */\n\n/**\n * This step applies quality control on the RNA count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellRnaQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellRnaQcMetrics)\n * and [`suggestRnaQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestRnaQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n    #automatic;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be an InputsState object\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.#automatic = false;\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n    \n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"RNA\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        let output = { ...this.#parameters }; // avoid pass-by-reference links.\n        output.species = bioc.CLONE(output.species);\n        return output;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:SuggestRnaQcFiltersResults} Result of filtering on the RNA-derived QC metrics.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {external:PerCellRnaQcMetricsResults} RNA-derived QC metrics.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    static defaults () {\n        return {\n            automatic: true,\n            gene_id_column: null,\n            use_reference_mito: true,\n            species: [],\n            gene_id_type: \"ENSEMBL\",\n            mito_prefix: \"mt-\",\n            nmads: 3\n        };\n    }\n\n    static configureFeatureParameters(use_reference_mito, guesses) {\n        let best_key = null;\n        let best = { type: \"symbol\", species: \"human\", confidence: 0 };\n\n        if (\"row_names\" in guesses) {\n            let val = guesses.row_names;\n            if (val.confidence > best.confidence && (use_reference_mito || val.type == \"symbol\")) {\n                best = val;\n            }\n        }\n\n        for (const [key, val] of Object.entries(guesses.columns)) {\n            if (val.confidence > best.confidence && (use_reference_mito || val.type == \"symbol\")) {\n                best = val;\n                best_key = key;\n            }\n        }\n\n        return {\n            gene_id_column: best_key,\n            species: [best.species],\n            gene_id_type: best.type.toUpperCase()\n        };\n    }\n\n    /**\n     * Array of strings containing the taxonomy IDs for species where mitochondrial gene lists are available.\n     * @type {Array}\n     */\n    static mitochondriaSpecies = [ \n        \"9606\",  // Mouse\n        \"10090\", // Human\n        \"6239\",  // C. elegans\n        \"10116\", // Rat\n        \"9541\",  // M. fascicularis\n        \"7227\",  // Fly\n        \"7955\",  // Zebrafish\n        \"9598\"   // Chimp\n    ];\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    async #acquire_reference(species, feature_type) {\n        let output = new Set;\n        let mito_lists = RnaQualityControlState.#mito_lists;\n\n        for (const s of species) {\n            let target = s + \"-mito-\" + feature_type.toLowerCase() + \".txt.gz\";\n            if (!(target in mito_lists)) {\n                let contents = await RnaQualityControlState.#downloadFun(baseUrl + \"/\" + target);\n                let lines = await rutils.readLines2(contents, { compression: \"gz\" });\n                mito_lists[target] = lines;\n            }\n\n            mito_lists[target].forEach(x => { output.add(x); });\n        }\n\n        return output;\n    }\n\n    static #mito_lists = {};\n\n    /**\n     * Flush all cached lists of mitochondrial genes.\n     *\n     * By default, {@linkcode RnaQualityControlState#compute compute} will cache the mitochondrial gene lists in a static member for re-use across {@linkplain RnaQualityControlState} instances.\n     * These cached lists are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode freeAnalysis}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        RnaQualityControlState.#mito_lists = {};\n        return;\n    }\n\n    static #downloadFun = utils.defaultDownload;\n\n    /**\n     * Specify a function to download the reference mitochondrial gene lists.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        let previous = RnaQualityControlState.#downloadFun;\n        RnaQualityControlState.#downloadFun = fun;\n        return previous;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If set to `true`, the following logic is applied:\n     *\n     * - If `use_reference_mito = true`, the annotation column that best matches human/mouse Ensembl/symbols is set as `gene_id_column`.\n     *   Based on the identified species and feature type, `species` and `gene_id_type` are also set.\n     * - If `use_reference_mito = false`, the annotation column that best matches human/mouse symbols is set as `gene_id_column`.\n     *\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the feature annotations that contains the gene identifiers for the RNA modality.\n     * If `null`, the row names are used.\n     * Ignored if `automatic = true`.\n     * @param {boolean} parameters.use_reference_mito - Whether to use the reference lists of mitochondrial genes.\n     * If `false`, mitochondrial genes are instead identified from their prefix.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species to use to obtain a reference list of mitochondrial genes.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode RnaQualityControlState#mitochondriaSpecies mitochondriaSpecies}).\n     * Ignored if `automatic = true`.\n     * @param {string} parameters.gene_id_type - Name of the feature type in the reference list of mitochondrial genes.\n     * This can be any one of `\"ENSEMBL\"`, `\"SYMBOL\"`, or `\"ENTREZ\"`.\n     * Ignored if `automatic = true`.\n     * @param {?string} parameters.mito_prefix - Case-insensitive prefix to use to identify mitochondrial genes from the dataset.\n     * Only used when `use_reference_mito = false`; in such cases, `gene_id_column` should point to symbols.\n     * If `null`, no prefix-based identification is performed.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold for each metric.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async compute(parameters) {\n        let { mito_prefix, nmads } = parameters;\n        let automatic;\n        let use_reference_mito;\n        let gene_id_column;\n        let species;\n        let gene_id_type;\n\n        // Some back-compatibility here.\n        if (\"use_reference_mito\" in parameters) {\n            automatic = parameters.automatic;\n            use_reference_mito = parameters.use_reference_mito;\n            gene_id_column = parameters.gene_id_column;\n            species = parameters.species;\n            gene_id_type = parameters.gene_id_type;\n        } else {\n            automatic = true;\n            use_reference_mito = parameters.use_mito_default;\n            let def = RnaQualityControlState.defaults();\n            gene_id_column = def.gene_id_column;\n            species = def.species;\n            gene_id_type = def.gene_id_type;\n        }\n\n        this.changed = false;\n\n        if (\n            this.#inputs.changed || \n            automatic !== this.#parameters.automatic ||\n            use_reference_mito !== this.#parameters.use_reference_mito || \n            (\n                !automatic && \n                (\n                    gene_id_column !== this.#parameters.gene_id_column || \n                    (!use_reference_mito && mito_prefix !== this.#parameters.mito_prefix) ||\n                    (\n                        use_reference_mito && \n                        (\n                            utils.changedParameters(species, this.#parameters.species) || \n                            gene_id_type !== this.#parameters.gene_id_type\n                        )\n                    )\n                )\n            ) \n        ) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                let gene_id_column2 = gene_id_column;\n                let species2 = species;\n                let gene_id_type2 = gene_id_type;\n\n                if (automatic) {\n                    let guesses = this.#inputs.guessRnaFeatureTypes();\n                    let backcomp = RnaQualityControlState.configureFeatureParameters(use_reference_mito, guesses);\n                    gene_id_column2 = backcomp.gene_id_column;\n                    species2 = backcomp.species;\n                    gene_id_type2 = backcomp.gene_id_type;\n                }\n\n                var gene_info = this.#inputs.fetchFeatureAnnotations()[\"RNA\"];\n                let val = (gene_id_column2 == null ? gene_info.rowNames() : gene_info.column(gene_id_column2));\n                var subsets = utils.allocateCachedArray(gene_info.numberOfRows(), \"Uint8Array\", this.#cache, \"metrics_buffer\");\n                subsets.fill(0);\n\n                if (val !== null) {\n                    if (use_reference_mito) {\n                        let lists = await this.#acquire_reference(species2, gene_id_type2);\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => {\n                            if (lists.has(x)) {\n                                sub_arr[i] = 1;\n                            }\n                        });\n                    } else if (mito_prefix !== null) {\n                        var lower_mito = mito_prefix.toLowerCase();\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => {\n                            if(x.toLowerCase().startsWith(lower_mito)) {\n                                sub_arr[i] = 1;\n                            }\n                        });\n                    }\n                }\n\n                var mat = this.#inputs.fetchCountMatrix().get(\"RNA\");\n                this.#cache.metrics = scran.perCellRnaQcMetrics(mat, [subsets]);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        this.#parameters.automatic = automatic;\n        this.#parameters.gene_id_column = gene_id_column;\n        this.#parameters.use_reference_mito = use_reference_mito;\n        this.#parameters.species = bioc.CLONE(species); // avoid pass-by-reference behavior.\n        this.#parameters.gene_id_type = gene_id_type;\n        this.#parameters.mito_prefix = mito_prefix;\n\n        if (this.changed || nmads !== this.#parameters.nmads) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestRnaQcFilters(this.#cache.metrics, { numberOfMADs: nmads, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let ghandle = handle.open(\"rna_quality_control\" in handle.children ? \"rna_quality_control\" : \"quality_control\");\n\n    let parameters = RnaQualityControlState.defaults(); \n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.use_mito_default = phandle.open(\"use_mito_default\", { load: true }).values[0] > 0;\n        parameters.mito_prefix = phandle.open(\"mito_prefix\", { load: true }).values[0];\n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n    }\n\n    let output;\n    let cache = {};\n    try {\n        let rhandle = ghandle.open(\"results\");\n\n        if (\"metrics\" in rhandle.children) { // QC metrics may not be reported if skipped.\n            let mhandle = rhandle.open(\"metrics\");\n            let sums = mhandle.open(\"sums\", { load: true }).values;\n\n            cache.metrics = scran.emptyPerCellRnaQcMetricsResults(sums.length, 1);\n            cache.metrics.sums({ fillable: true }).set(sums);\n\n            let detected = mhandle.open(\"detected\", { load: true }).values;\n            cache.metrics.detected({ fillable: true }).set(detected);\n            let proportions = mhandle.open(\"proportion\", { load: true }).values;\n            cache.metrics.subsetProportions(0, { fillable: true }).set(proportions);\n        }\n\n        if (\"thresholds\" in rhandle.children) { // if skip=true, QC thresholds may not be reported.\n            let discards = rhandle.open(\"discards\", { load: true }).values; \n            cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n            cache.discard_buffer.set(discards);\n\n            let thandle = rhandle.open(\"thresholds\");\n            let thresholds_sums = thandle.open(\"sums\", { load: true }).values;\n            let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n            let thresholds_proportion = thandle.open(\"proportion\", { load: true }).values;\n\n            cache.filters = scran.emptySuggestRnaQcFiltersResults(1, thresholds_sums.length);\n            cache.filters.thresholdsSums({ fillable: true }).set(thresholds_sums);\n            cache.filters.thresholdsDetected({ fillable: true }).set(thresholds_detected);\n            cache.filters.thresholdsSubsetProportions(0, { fillable: true }).set(thresholds_proportion);\n        }\n\n        output = new RnaQualityControlState(inputs, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.metrics);\n        utils.freeCache(cache.filters)\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return {Uint8Array} A Uint8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string}\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return {Int8Array} An Int8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number}\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return {Uint16Array} A Uint16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return {Int16Array} An Int16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return {Uint32Array} A Uint32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return {Int32Array} An Int32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return {BigUint64Array} A BigUint64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return {BigInt64Array} An BigInt64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return {Float32Array} A Float32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return {Float64Array} A Float64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return {class} Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * The Annotated class provides a store for arbitrary object-wide metadata.\n * It is intended as a base class for other structures and should not be constructed directly.\n */\nexport class Annotated {\n    /**\n     * @param {Object|Map} metadata - Object or Map containing arbitrary metadata as key-value pairs.\n     */\n    constructor(metadata) {\n        if (arguments.length == 0) {\n            return;\n        }\n\n        this._metadata = utils.object2map(metadata);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Map} Map containing arbitrary metadata.\n     */\n    metadata() {\n        return this._metadata;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object|Map} value - Object containing the metadata.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Annotated instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Annotated} The Annotated object after replacing the metadata.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setMetadata(value, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._metadata = utils.object2map(value);\n        return target;\n    }\n\n    /**\n     * @param {Object} value - Object containing the metadata.\n     * @return {Annotated} A reference to this Annotated object.\n     */\n    $setMetadata(value) {\n        return this.setMetadata(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        output._metadata = cutils.cloneField(this._metadata, deepCopy);\n        return;\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchAllSets.js\";\nimport { fetchCollectionSizes } from \"./fetchSingleCollection.js\";\n\nconst _cache = new Map;\nconst _ranges = new Map;\nconst _sizes = new Map;\nconst _starts = new Map;\nconst _parents = new Map;\nconst _internal_number = new Map;\n\nasync function initialize(species) {\n    const [ sres, csizes ] = await Promise.all([ \n        utils.retrieveRangesWithExtras(species + \"_sets.tsv\"), \n        fetchCollectionSizes(species) \n    ]);\n    _ranges.set(species, sres.ranges);\n    _sizes.set(species, sres.extra);\n\n    let parents = [];\n    let internal_number = [];\n    var totals = 0;\n    for (var i = 0; i < csizes.length; i++) {\n        let colsize = csizes[i];\n        for (var j = 0; j < colsize; j++) {\n            parents.push(i);\n            internal_number.push(j);\n        }\n        totals += colsize;\n    }\n\n    if (totals != sres.extra.length) {\n        throw new Error(\"discrepancy between number of sets and sum of collection sizes\");\n    }\n\n    _parents.set(species, parents);\n    _internal_number.set(species, internal_number);\n    _cache.set(species, new Map);\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {Array} Number of genes in each set.\n * Each value corresponds to a set in {@linkcode fetchAllSets}.\n * @async\n */\nexport async function fetchSetSizes(species) {\n    return utils.fetchSizes(species, _sizes, full.fetchAllSets, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @return {number} Total number of sets for this species.\n * @async\n */\nexport async function numberOfSets(species) {\n    return utils.fetchNumber(species, _sizes, full.fetchAllSets, initialize);\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} set - Set ID, see {@linkcode fetchAllSets} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a request to the server.\n * By default, the return value is extracted from the full set details if {@linkcode fetchAllSets} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all set details up-front to avoid range requests.\n * This is done by calling {@linkcode fetchAllSets}.\n * Ignored if `forceRequest = true`.\n *\n * @return {object} Object containing the details of the set.\n * This should be identical to the corresponding entry of the array returned by {@linkcode fetchAllSets}.\n *\n * If `set = null`, no return value is provided.\n * @async\n */\nexport async function fetchSingleSet(species, set, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchAllSets(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (set !== null) {\n                return ffound[set];\n            } else {\n                console.log(set);\n                return;\n            }\n        }\n    }\n\n    let cached = _cache.get(species);\n    if (typeof cached === \"undefined\") {\n        await initialize(species);\n        cached = _cache.get(species);\n    }\n\n    if (set == null) {\n        return;\n    }\n\n    let sfound = cached.get(set);\n    if (typeof sfound !== \"undefined\") {\n        return sfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_sets.tsv\", _ranges.get(species), set);\n    let split = text.split(\"\\t\");\n    let output = {\n        name: split[0],\n        description: split[1],\n        size: _sizes.get(species)[set],\n        collection: _parents.get(species)[set],\n        number: _internal_number.get(species)[set]\n    };\n\n    cached.set(set, output);\n    return output;\n}\n\n\n","import * as utils from \"./utils.js\";\n\nexport function convertPositionToRank(start, end, { slice = null } = {}) {\n    let n = (slice == null ? start.length : slice.length);\n\n    let positions = new Int32Array(n * 2);\n    let add = new Uint8Array(n * 2);\n    let index = new Int32Array(n * 2);\n\n    {\n        let counter = 0;\n        let fillIndex = i => {\n            let at = counter * 2;\n            let next = at + 1;\n            positions[at] = start[i];\n            positions[next] = end[i];\n            add[at] = 1;\n            add[next] = 0;\n            index[at] = counter;\n            index[next] = counter;\n            counter++;\n        };\n\n        if (slice === null) {\n            for (var i = 0; i < n; i++) {\n                fillIndex(i);                                \n            }\n        } else {\n            for (const i of slice) {\n                fillIndex(i);\n            }\n        }\n    }\n\n    let order = utils.createSequence(positions.length);\n    order.sort((i, j) => positions[i] - positions[j]);\n\n    let rank2position = [];\n    let new_starts = new Int32Array(n);\n    let new_ends = new Int32Array(n);\n\n    let last = null;\n    for (const i of order) {\n        let pos = positions[i];\n        let idx = index[i];\n\n        if (pos !== last) {\n            rank2position.push(pos);\n            last = pos;\n        }\n\n        if (add[i]) {\n            new_starts[idx] = rank2position.length - 1;\n        } else {\n            new_ends[idx] = rank2position.length - 1;\n        }\n    }\n\n    return { rank2position, startRanks: new_starts, endRanks: new_ends };\n}\n\nexport function buildIntervalTree(start, end, { slice = null } = {}) {\n    let { rank2position, startRanks, endRanks } = convertPositionToRank(start, end, { slice });\n\n    // Now, building an nicely balanced interval tree based on the ranks.\n    let tree = [ create_node(0, rank2position.length) ];\n    if (slice === null) {\n        for (var i = 0; i < startRanks.length; i++) {\n            recursive_build_tree(startRanks[i], endRanks[i], i, tree, 0);\n        }\n    } else {\n        for (var i = 0; i < startRanks.length; i++) {\n            recursive_build_tree(startRanks[i], endRanks[i], slice[i], tree, 0);\n        }\n    }\n\n    // Running a clean-up operation to convert ranks back to positions.\n    let one_past_the_end = (rank2position.length > 0 ? rank2position[rank2position.length - 1] + 1 : 1);\n    rank2position.push(one_past_the_end);\n\n    for (const x of tree) {\n        x.left_bound = rank2position[x.left_bound];\n        x.right_bound = rank2position[x.right_bound];\n        x.center = rank2position[x.center];\n\n        // Also sorting ranges by increasing start and DECREASING end positions.\n        let start_overlaps_sorted = x.overlaps.slice().sort((a, b) => start[a] - start[b]);\n        let end_overlaps_sorted = x.overlaps.sort((a, b) => end[b] - end[a]) // reversed order - deliberate!\n        x.overlaps = {\n            start: start_overlaps_sorted.map(i => [start[i], i]),\n            end: end_overlaps_sorted.map(i => [end[i], i])\n        };\n    }\n\n    return tree;\n}\n\nfunction create_node(left_bound, right_bound) {\n    return { \n        left_bound: left_bound,\n        right_bound: right_bound,\n        center: left_bound + Math.floor((right_bound - left_bound) / 2),\n        left_node: null,\n        right_node: null,\n        overlaps: []\n    };\n}\n\nfunction recursive_build_tree(start, end, index, tree, node) {\n    let current = tree[node];\n\n    if (start > current.center) {\n        if (current.right_node === null) {\n            current.right_node = tree.length;\n            tree.push(create_node(current.center, current.right_bound));\n        }\n        recursive_build_tree(start, end, index, tree, current.right_node);\n\n    } else if (end < current.center || (end == current.center && end > start)) { // Let 0-length ranges fall through to the next clause if they lie exactly on the center.\n        if (current.left_node === null) {\n            current.left_node = tree.length;\n            tree.push(create_node(current.left_bound, current.center));\n        }\n        recursive_build_tree(start, end, index, tree, current.left_node);\n\n    } else {\n        // At some point, every range ends up here. This is because left_bound\n        // == center upon successive halving to create new nodes, so every\n        // range will eventually overlap a center at its own start position.\n        current.overlaps.push(index);\n    }\n}\n\nexport function queryIntervalTree(start, end, tree) {\n    let results = [];\n    if (start > tree.right_bound) {\n        return results;\n    }\n\n    if (end < tree.left_bound || (end == tree.left_bound && end > start)) { // Still allow 0-length ranges to fall through for search.\n        return results;\n    }\n\n    recursive_query_tree(start, end, tree, 0, results); \n    return results;\n}\n\nfunction recursive_query_tree(start, end, tree, node, results) {\n    let current = tree[node];\n\n    if (start > current.center) {\n        for (const overlap of current.overlaps.end) {\n            if (overlap[0] > start) {\n                results.push(overlap[1]);\n            } else {\n                break;\n            }\n        }\n        if (current.right_node !== null) {\n            recursive_query_tree(start, end, tree, current.right_node, results);\n        }\n\n    } else if (end < current.center || (end == current.center && end > start)) { // Again, let zero-length ranges fall through if they lie directly on the center.\n        for (const overlap of current.overlaps.start) {\n            if (overlap[0] < end || (overlap[0] == end && start == end)) { // handle zero-length ranges directly on the start position of the center-overlapping range.\n                results.push(overlap[1]);\n            } else {\n                break;\n            }\n        }\n        if (current.left_node !== null) {\n            recursive_query_tree(start, end, tree, current.left_node, results);\n        }\n\n    } else {\n        for (const overlap of current.overlaps.start) {\n            results.push(overlap[1]);\n        }\n\n        if (end > current.center) {\n            if (current.right_node !== null) {\n                recursive_query_tree(start, end, tree, current.right_node, results);\n            }\n        }\n        if (start < current.center) {\n            if (current.left_node !== null) {\n                recursive_query_tree(start, end, tree, current.left_node, results);\n            }\n        }\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as ann from \"./Annotated.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A DataFrame is a collection of equilength vector-like objects as \"columns\".\n * The number of rows in the DataFrame is equal to the length of the columns, where the i-th row consists of the i-th element from each column.\n *\n * This class supports optional row names, which are either `null` or an array of strings of length equal to the number of rows.\n *\n * This class supports empty instances with a non-zero number of rows, which may be useful for piece-wise construction.\n *\n * The vector-like object for each column is expected to have methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * The DataFrame itself defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @augments Annotated\n */\nexport class DataFrame extends ann.Annotated {\n    /**\n     * @param {Object|Map} columns - Object or Map where keys are the column names and the values are equilength vector-like objects.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?number} [options.numberOfRows=null] - Non-negative value specifying the number of rows in the DataFrame.\n     * If `null`, this is automatically determined from the length of the vectors in `columns`, or from the length of `rowNames`.\n     * If non-`null`, this should not conflict with the inferred lengths from `columns` or `rowNames`.\n     * @param {?Array} [options.rowNames=null] - Array of strings containing the names for each row.\n     * If non-`null`, this should have the same length as the vectors inside `columns`, if any exist.\n     * If `null`, no row names are used.\n     * @param {?Array} [options.columnOrder=null] - Array of strings specifying the ordering of the columns.\n     * If non-`null`, this should have the same values as the keys of `columns`.\n     * If `null`, an arbitrary ordering is obtained from `columns`.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(columns, { numberOfRows = null, rowNames = null, columnOrder = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n        this._numberOfRows = numberOfRows;\n        this._rowNames = rowNames;\n        \n        try {\n            this._columns = new il.InternalList(columns, columnOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize columns for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n\n        for (const k of this._columns.names()) {\n            let n = generics.LENGTH(this._columns.entry(k));\n            if (this._numberOfRows == null) {\n                this._numberOfRows = n;\n            } else if (n != this._numberOfRows) {\n                throw new Error(\"expected all arrays in 'columns' to have equal length\");\n            }\n        }\n\n        if (rowNames != null) {\n            if (this._numberOfRows == null) {\n                this._numberOfRows = rowNames.length;\n            }\n            utils.checkNamesArray(rowNames, \"'rowNames'\", this._numberOfRows, \"'numberOfRows' or the length of arrays in 'columns'\");\n        }\n\n        if (this._numberOfRows == null) {\n            this._numberOfRows = 0;\n        }\n    }\n\n    static className = \"DataFrame\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {?Array} Array of strings containing row names, or `null` if no row names are available.\n     */\n    rowNames() {\n        return this._rowNames;\n    }\n\n    /**\n     * @return {Array} Array of strings containing the column names in the specified order.\n     */\n    columnNames() {\n        return this._columns.names();\n    }\n\n    /**\n     * @param {string} name - Name of a column.\n     * @return {boolean} Whether the column exists in this DataFrame.\n     */\n    hasColumn(name) {\n        return this._columns.has(name);\n    }\n\n    /**\n     * @return {number} Number of rows in this DataFrame.\n     */\n    numberOfRows() {\n        return this._numberOfRows;\n    }\n\n    /**\n     * @return {number} Number of columns in this DataFrame.\n     */\n    numberOfColumns() {\n        return this._columns.numberOfEntries();\n    }\n\n    /**\n     * @param {string|number} i - Column to retrieve, either by name or index.\n     * @return {*} The contents of column `i` as a vector-like object.\n     */\n    column(i) {\n        return this._columns.entry(i);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Column to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     * \n     * @return {DataFrame} The DataFrame after removing the specified column.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeColumn(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.delete(i, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Column to remove, either by name or index.\n     * @return {DataFrame} A reference to this DataFrame after removing the specified column.\n     */\n    $removeColumn(i) {\n        return this.removeColumn(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the column to add, either by name or index.\n     * - If `i` is a number, the column at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of columns.\n     * - If `i` is a string, any column with the same name is replaced.\n     *   If no such column exists, a new column is appended to the DataFrame.\n     * @param {*} value - Array-like column to set/add as the column.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame after adding/replacing the specified column.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumn(i, value, { inPlace = false } = {}) {\n        if (generics.LENGTH(value) != this._numberOfRows) {\n            throw new Error(\"expected 'value' to have the same length as the number of rows in 'x'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the column to add, either by name or index.\n     * - If `i` is a number, the column at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of columns.\n     * - If `i` is a string, any column with the same name is replaced.\n     *   If no such column exists, a new column is appended to the DataFrame.\n     * @param {*} value - Array-like column to set/add as the column.\n     *\n     * @return {DataFrame} A reference to this DataFrame after adding/replacing the specified column.\n     */\n    $setColumn(i, value) {\n        return this.setColumn(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of unique strings containing the new name for each column.\n     * This should have the same length as {@linkcode DataFrame#columnNames DataFrame.columnNames}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = target._columns.setNames(names, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of unique strings containing the new name for each column.\n     * This should have the same length as {@linkcode DataFrame#columnNames DataFrame.columnNames}.\n     * @return {DataFrame} A reference to this DataFrame with modified column names.\n     */\n    $setColumnNames(names) {\n        return this.setColumnNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {?Array} names - Array of unique strings containing the new name for each row.\n     * This should have the same length as {@linkcode DataFrame#numberOfRows DataFrame.numberOfRows}.\n     *\n     * Alternatively, this may be `null` to remove any existing column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} The DataFrame with modified row names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowNames(names, { inPlace = false } = {}) {\n        if (names != null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this._numberOfRows, \"'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowNames = names;\n        return target;\n    }\n\n    /**\n     * @param {?Array} names - Array of unique strings containing the new name for each row.\n     * This should have the same length as {@linkcode DataFrame#numberOfRows DataFrame.numberOfRows}.\n     *\n     * Alternatively, this may be `null` to remove any existing column names.\n     * @return {DataFrame} A reference to this DataFrame with modified row names.\n     */\n    $setRowNames(names) {\n        return this.setRowNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the columns to retain in the slice.\n     * This should refer to unique column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} Reference to this DataFrame after slicing to the specified columns.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceColumns(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._columns = this._columns.slice(i, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the columns to retain in the slice.\n     * This should refer to unique column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DataFrame instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DataFrame} Reference to this DataFrame after slicing to the specified columns.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    $sliceColumns(i) {\n        return this.sliceColumns(i, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        let options = { allowView };\n\n        let new_columns = this._columns.apply(v => generics.SLICE(v, i, options));\n        let new_rowNames = (this._rowNames == null ? null : generics.SLICE(this._rowNames, i, options));\n\n        let new_numberOfRows;\n        if (i.constructor == Object) {\n            new_numberOfRows = i.end - i.start;\n        } else {\n            new_numberOfRows = i.length;\n        }\n\n        output._rowNames = new_rowNames;\n        output._columns = new_columns;\n        output._numberOfRows = new_numberOfRows;\n        output._metadata = this._metadata;\n        return; \n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        let new_columns = il.InternalList.parallelCombine(objects.map(x => x._columns), generics.COMBINE);\n\n        let all_n = [];\n        let all_l = [];\n        for (const yi of objects) {\n            all_n.push(yi.rowNames());\n            all_l.push(yi.numberOfRows());\n        }\n\n        let new_numberOfRows = utils.sum(all_l);\n        let new_rowNames = utils.combineNames(all_n, all_l, new_numberOfRows);\n\n        output._rowNames = new_rowNames;\n        output._columns = new_columns;\n        output._numberOfRows = new_numberOfRows;\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._columns = cutils.cloneField(this._columns, deepCopy);\n        output._rowNames = cutils.cloneField(this._rowNames, deepCopy);\n        output._numberOfRows = this._numberOfRows;\n        return;\n    }\n};\n\n/**\n * Flexibly combine multiple DataFrames by row by filling in missing columns with an array of `null`s.\n * This is equivalent to calling {@linkcode COMBINE} on an array of DataFrames that may have mismatching columns.\n *\n * @param {Array} objects - Array of {@linkplain DataFrame}s to be combined.\n *\n * @return {DataFrame} The combined DataFrame, where the number of rows is equal to sum of rows across `objects`,\n * and the columns is equal to the union of columns across `objects`.\n */\nexport function flexibleCombineRows(objects) {\n    let ckeys = new Set();\n    let corder = [];\n    for (const current of objects) {\n        let cnames = current.columnNames();\n        for (const a of cnames) {\n            if (!ckeys.has(a)) {\n                ckeys.add(a);\n                corder.push(a);\n            }\n        }\n    }\n\n    let copies = [];\n    for (const current of objects) {\n        let dummy = new Array(current.numberOfRows());\n        dummy.fill(null);\n        let copy = generics.CLONE(current, { deepCopy: false });\n\n        for (const a of corder) {\n            if (!current.hasColumn(a)) {\n                copy.$setColumn(a, dummy);\n            }\n        }\n\n        copy._columns = copy._columns.reorder(corder);\n        copies.push(copy);\n    }\n\n    return generics.COMBINE(copies);\n}\n","import { clusterKmeans } from \"./clusterKmeans.js\";\nimport { logNormCounts } from \"./logNormCounts.js\";\nimport { groupedSizeFactors } from \"./groupedSizeFactors.js\";\nimport { runPCA } from \"./runPCA.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Quickly compute size factors for an ADT count matrix.\n * This generates k-means clusters from a matrix of PCs before calling {@linkcode groupedSizeFactors}.\n * The aim is to account for composition biases that are common in ADT-based data, while avoiding problems with per-cell sparsity.\n *\n * @param {ScranMatrix} x - An ADT count matrix.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfClusters=20] - Number of clusters to create.\n * More clusters improves the accuracy of the size factors at the cost of precision.\n * @param {number} [options.numberOfPCs=25] - Number of PCs to use.\n * More PCs captures more biological signal at the cost of increasing noise.\n * @param {?(Float64WasmArray|Array|TypedArray)} [options.totals=null] - Array containing the total count for each column in `x`, to speed up the initial normalization.\n * If `null`, this is computed from `x`.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Blocking level for each column in `x`, see {@linkcode logNormCounts} and {@linkcode runPCA}.\n * For PCA, this is used to equalize the contribution of blocks of differing size.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output size factors.\n * Length should be equal to the number of columns in `x`.\n * If `null`, an array is allocated by the function.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * \n * @return {Float64WasmArray} Per-cell size factors for each column of `x`.\n *\n * If `buffer` is supplied, it is directly used as the return value.\n */\nexport function quickAdtSizeFactors(x, { numberOfClusters = 20, numberOfPCs = 25, totals = null, block = null, buffer = null, numberOfThreads = null } = {}) {\n    let norm, pcs;\n    try {\n        norm = logNormCounts(x, { sizeFactors: totals, block: block });\n        pcs = runPCA(norm, { numberOfPCs: Math.min(norm.numberOfRows() - 1, numberOfPCs), numberOfThreads: numberOfThreads, block: block, blockMethod: \"weight\" });\n    } finally {\n        utils.free(norm);\n    }\n\n    let clust;\n    try {\n        clust = clusterKmeans(pcs, numberOfClusters, { numberOfThreads: numberOfThreads });\n    } finally {\n        utils.free(pcs);\n    }\n\n    let local_buffer;\n    try {\n        if (buffer === null) {\n            local_buffer = utils.createFloat64WasmArray(x.numberOfColumns());\n            buffer = local_buffer;\n        } else if (buffer.length !== x.numberOfColumns()) {\n            throw new Error(\"length of 'buffer' should be equal to the number of columns in 'x'\");\n        }\n        groupedSizeFactors(x, clust.clusters({ copy: \"view\" }), { buffer: buffer, numberOfThreads: numberOfThreads });\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(clust);\n    }\n\n    return buffer;\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchSetsForAllGenes.js\";\n\nconst _ranges = new Map;\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n *\n * @return {number} Number of genes that belong to at least one set for `species`.\n * This can be used as a more appropriate universe size in {@linkcode testEnrichment}.\n */\nexport async function effectiveNumberOfGenes(species) {\n    let ffound = await full.fetchSetsForAllGenes(species, { download: false });\n    if (ffound !== null) {\n        let okay = 0;\n        for (const x of ffound) {\n            okay += x.length > 0;\n        }\n        return okay;\n    }\n\n    let ranged = _ranges.get(species);\n    if (typeof ranged === \"undefined\") {\n        _cache.set(species, new Map);\n        ranged = await utils.retrieveRanges(species + \"_gene2set.tsv\")\n        _ranges.set(species, ranged);\n    }\n\n    let okay = 0;\n    for (var i = 1; i < ranged.length; i++) {\n        if (ranged[i] > ranged[i-1] + 1) {\n            okay++;\n        }\n    }\n\n    return okay;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} gene - Gene ID, see {@linkcode fetchAllGenes} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a range request to the server.\n * By default, the return value is extracted from the full gene-to-set mappings if {@linkcode fetchSetsForAllGenes} was called before this function. \n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all gene-to-set mappings up-front to avoid range requests.\n * This is done by calling {@linkcode fetchSetsForAllGenes}\n * Ignored if `forceRequest = true`.\n *\n * @return {Uint32Array} Array of integers containing the IDs of all sets containing the gene.\n * IDs are treated as indices into the return value of {@linkcode fetchAllSets} or as input to {@linkcode fetchSingleSet}.\n *\n * If `gene = null`, no return value is provided.\n * \n * @async\n */\nexport async function fetchSetsForGene(species, gene, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchSetsForAllGenes(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (gene !== null) {\n                return ffound[gene];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let spfound = _cache.get(species);\n    if (typeof spfound === \"undefined\") {\n        spfound = new Map;\n        _cache.set(species, spfound);\n        _ranges.set(species, await utils.retrieveRanges(species + \"_gene2set.tsv\"));\n    }\n    if (gene == null) {\n        return;\n    }\n\n    let gfound = spfound.get(gene);\n    if (typeof gfound !== \"undefined\") {\n        return gfound;\n    }\n\n    let text = await utils.retrieveBytesByIndex(species + \"_gene2set.tsv\", _ranges.get(species), gene);\n    let output = utils.convertToUint32Array(text);\n    spfound.set(gene, output);\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**\n * Dataset in the 10X Matrix Market format, see [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/matrices) for details.\n */\nexport class TenxMatrixMarketDataset {\n    #matrix_file;\n    #feature_file;\n    #barcode_file;\n\n    #dimensions;\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"mtx\", file: fun(this.#matrix_file) }];\n\n        if (this.#feature_file !== null) {\n            files.push({ type: \"genes\", file: fun(this.#feature_file) });\n        }\n\n        if (this.#barcode_file !== null) {\n            files.push({ type: \"annotations\", file: fun(this.#barcode_file) });\n        }\n\n        let options = this.options(); \n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} matrixFile - A Matrix Market file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {?(SimpleFile|string|Uint8Array|File)} featureFile - Contents of a feature annotation file.\n     * If `null`, it is assumed that no file was available.\n     * @param {?(SimpleFile|string|Uint8Array|File)} barcodeFile - Contents of a barcode annotation file.\n     * If `null`, it is assumed that no file was available.\n     */\n    constructor(matrixFile, featureFile, barcodeFile, { \n        featureTypeRnaName = \"Gene Expression\", \n        featureTypeAdtName = \"Antibody Capture\", \n        featureTypeCrisprName = \"CRISPR Guide Capture\", \n        primaryRnaFeatureIdColumn = 0, \n        primaryAdtFeatureIdColumn = 0,\n        primaryCrisprFeatureIdColumn = 0\n    } = {}) {\n        if (matrixFile instanceof afile.SimpleFile) {\n            this.#matrix_file = matrixFile;\n        } else {\n            this.#matrix_file = new afile.SimpleFile(matrixFile);\n        }\n\n        if (featureFile instanceof afile.SimpleFile || featureFile == null) {\n            this.#feature_file = featureFile;\n        } else {\n            this.#feature_file = new afile.SimpleFile(featureFile);\n        }\n\n        if (barcodeFile instanceof afile.SimpleFile || barcodeFile == null) {\n            this.#barcode_file = barcodeFile;\n        } else {\n            this.#barcode_file = new afile.SimpleFile(barcodeFile);\n        }\n\n        this.#options = TenxMatrixMarketDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode TenxMatrixMarketDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: 0, \n            primaryAdtFeatureIdColumn: 0,\n            primaryCrisprFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode TenxMatrixMarketDataset#load load} (but not {@linkcode TenxMatrixMarketDataset#summary summary}).\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset, all features are considered to be genes by default.\n     * This behavior can be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode TenxMatrixMarketDataset#load load} or {@linkcodeTenxMatrixMarketDataset#summary summary}. \n     */\n    clear() {\n        this.#dimensions = null;\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"MatrixMarket\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset,\n     * in a form that can be cheaply stringified.\n     */\n    abbreviate(args) {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #fetch_dimensions() {\n        if (this.#dimensions !== null) {\n            return;\n        }\n        var is_gz = this.#matrix_file.name().endsWith(\".gz\");\n        let headers = scran.extractMatrixMarketDimensions(this.#matrix_file.content(), { \"compressed\": is_gz });\n        this.#dimensions = [headers.rows, headers.columns];\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#fetch_dimensions();\n        let NR = this.#dimensions[0];\n        if (this.#feature_file == null) {\n            this.#raw_features = new bioc.DataFrame({}, { numberOfRows: NR });\n            return;\n        }\n\n        let fname = this.#feature_file.name();\n        var is_gz = fname.endsWith(\".gz\");\n        let parsed = await eutils.readTable2(this.#feature_file.content(), { compression: (is_gz ? \"gz\" : \"none\") });\n\n        if (parsed.length == NR + 1) {\n            // If it seems to have a header, we just use that directly.\n            let output = {};\n            let headers = parsed.shift();\n            headers.forEach((x, i) => {\n                output[x] = parsed.map(y => y[i]);\n            });\n            this.#raw_features = output;\n            return;\n        }\n\n        // Otherwise, we assume it's standard 10X CellRanger output, without a header.\n        if (parsed.length !== NR) {\n            throw new Error(\"number of matrix rows is not equal to the number of rows in '\" + fname + \"'\");\n        } \n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        let output = new bioc.DataFrame({}, { numberOfRows: NR }); // build it piece-by-piece for a well-defined order.\n        output.$setColumn(\"id\", ids);\n        output.$setColumn(\"name\", symb);\n\n        if (parsed[0].length > 2) {\n            let types = [];\n            parsed.forEach(x => { types.push(x[2]); });\n            output.$setColumn(\"type\", types);\n        }\n\n        this.#raw_features = output;\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#fetch_dimensions();\n        if (this.#barcode_file == null) {\n            this.#raw_cells = new bioc.DataFrame({}, { numberOfRows: this.#dimensions[1] });\n            return;\n        }\n\n        let bname = this.#barcode_file.name();\n        var is_gz = bname.endsWith(\".gz\");\n        let parsed = await eutils.readTable2(this.#barcode_file.content(), { compression: (is_gz ? \"gz\" : \"none\") });\n\n        // Check if a header is present or not. Standard 10X output doesn't have a \n        // header but we'd like to support some kind of customization.\n        let diff = this.#dimensions[1] - parsed.length;\n        let headers;\n        if (diff == 0) {\n            headers = parsed[0]; // whatever, just using the first row. Hope it's unique enough!\n        } else if (diff == -1) {\n            headers = parsed.shift();\n        } else {\n            throw new Error(\"number of matrix columns is not equal to the number of rows in '\" + bname + \"'\");\n        }\n\n        let annotations = {}\n        headers.forEach((x, i) => {\n            annotations[x] = parsed.map(y => y[i]);\n        });\n\n        for (const [k, v] of Object.entries(annotations)) {\n            let conv = eutils.promoteToNumber(v);\n            if (conv !== null) {\n                annotations[k] = conv;\n            }\n        }\n\n        this.#raw_cells = new bioc.DataFrame(annotations);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode TenxMatrixMarketDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     *\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = {\n            \"modality_features\": futils.reportFeatures(this.#raw_features, \"type\"),\n            \"cells\": this.#raw_cells\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode TenxMatrixMarketDataset#load load} but the order of values may be different.\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxMatrixMarketDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRIPSR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode TenxMatrixMarketDataset#defaults defaults} or with {@linkcode TenxMatrixMarketDataset#setOptions setOptions}.\n     *\n     * If the feature annotation file is absent or if it lacks a third column for the feature types,\n     * `load()` will assume that all features are genes (i.e., only the RNA modality is present).\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        var is_gz = this.#matrix_file.name().endsWith(\".gz\");\n        let loaded = scran.initializeSparseMatrixFromMatrixMarket(this.#matrix_file.content(), { \"compressed\": is_gz });\n\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\"); \n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    async serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode TenxMatrixMarketDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {TenxMatrixMarketDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        let args = {};\n        for (const x of files) {\n            if (x.type in args) {\n                throw new Error(\"duplicate file of type '\" + x.type + \"' detected during MatrixMarket unserialization\");\n            }\n            args[x.type] = x.file;\n        }\n\n        if (!(\"mtx\" in args)) {\n            throw new Error(\"expected file of type 'mtx' for during MatrixMarket unserialization\");\n        }\n\n        let feat = null;\n        if (\"genes\" in args) {\n            feat = args.genes;\n        }\n\n        let barcode = null;\n        if (\"annotations\" in args) {\n            barcode = args.annotations;\n        }\n\n        let output = new TenxMatrixMarketDataset(args.mtx, feat, barcode);\n        output.setOptions(options);\n        return output;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SingleCellExperiment is a {@linkplain RangedSummarizedExperiment} subclass that contains additional fields for storing reduced dimensions and alternative experiments.\n * It supports the same set of generics as the {@linkplain SummarizedExperiment}.\n *\n * Each reduced dimension instance should have number of rows equal to the number of columns of the SingleCellExperiment.\n * Each instance is expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode CLONE}\n *\n * Each alternative experiment should be a {@linkplain SummarizedExperiment} with number of columns equal to that of the SingleCellExperiment.\n *\n * @extends RangedSummarizedExperiment\n */\nexport class SingleCellExperiment extends rse.RangedSummarizedExperiment {\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {?(GRanges|GroupedGRanges)} [options.rowRanges=null] - Genomic ranges corresponding to each row, see the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {Object|Map} [options.reducedDimensions={}] - Object containing named reduced dimensions.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns of the assays.\n     * @param {?Array} [options.reducedDimensionOrder=null] - Array containing the order of the reduced dimensions.\n     * This should have the same values as the keys of `reducedDimensions`, and defaults to those keys if `null`.\n     * @param {Object|Map} [options.alternativeExperiments={}] - Object containing named alternative experiments.\n     * Each value should be a 2-dimensional object with number of columns equal to that of the assays.\n     * @param {?Array} [options.alternativeExperimentOrder=null] - Array containing the order of the alternative experiments.\n     * This should have the same values as the keys of `alternativeExperiments`, and defaults to those keys if `null`.\n     */\n    constructor(assays, options={}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        let { reducedDimensions = {}, reducedDimensionOrder = null, alternativeExperiments = {}, alternativeExperimentOrder = null, rowRanges = null } = options;\n        super(assays, rowRanges, options);\n        let ncols = this.numberOfColumns();\n\n        try {\n            this._reducedDimensions = new il.InternalList(reducedDimensions, reducedDimensionOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize reduced dimension list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._reducedDimensions.names()) {\n            let v = this._reducedDimensions.entry(k);\n            if (generics.NUMBER_OF_ROWS(v) !== ncols) {\n                throw new Error(\"number of rows for reduced dimension '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        try {\n            this._alternativeExperiments = new il.InternalList(alternativeExperiments, alternativeExperimentOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize alternative experiment list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._alternativeExperiments.names()) {\n            let v = this._alternativeExperiments.entry(k);\n            if (!(v instanceof se.SummarizedExperiment)) {\n                throw new Error(\"alternative experiment '\" + k + \"' is not a SummarizedExperiment\");\n            }\n            if (v.numberOfColumns(v) !== ncols) {\n                throw new Error(\"number of columns for alternative experiment '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        return;\n    }\n\n    static className = \"SingleCellExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the reduced dimensions.\n     */\n    reducedDimensionNames() {\n        return this._reducedDimensions.names();\n    }\n\n    /**\n     * @param {string|number} i - Reduced dimension to retrieve, either by name or index.\n     * @return {*} The contents of reduced dimension `i` as an multi-dimensional array-like object.\n     */\n    reducedDimension(i) {\n        let output;\n        try {\n            output = this._reducedDimensions.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the alternative experiments.\n     */\n    alternativeExperimentNames() {\n        return this._alternativeExperiments.names();\n    }\n\n    /**\n     * @param {string|number} i - Alternative experiment to retrieve, either by name or index.\n     * @return {SummarizedExperiment} The specified alternative experiment `i`. \n     */\n    alternativeExperiment(i) {\n        let output;\n        try {\n            output = this._alternativeExperiments.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeReducedDimension(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment after removing the specified assay.\n     */\n    $removeReducedDimension(i) {\n        return this.removeReducedDimension(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimension(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) != this.numberOfColumns()) {\n            throw new Error(\"number of rows of 'value' should be the same as the number of columns of this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._reducedDimensions = target._reducedDimensions.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     *\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment with modified reduced dimensions.\n     */\n    $setReducedDimension(i, value) {\n        return this.setReducedDimension(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified reduced dimension names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensionNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the reduced dimension names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified reduced dimension names.\n     */\n    $setReducedDimensionNames(names) {\n        return this.setReducedDimensionNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceReducedDimensions(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = this._reducedDimensions.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the reduced dimensions for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced reduced dimensions.\n     */\n    $sliceReducedDimensions(i) {\n        return this.sliceReducedDimensions(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAlternativeExperiment(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment after removing the specified assay.\n     */\n    $removeAlternativeExperiment(i) {\n        return this.removeAlternativeExperiment(i, { inPlace: true });;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the alternative experiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiment(i, value, { inPlace = false } = {}) {\n        if (!(value instanceof se.SummarizedExperiment) || generics.NUMBER_OF_COLUMNS(value) != this.numberOfColumns()) {\n            throw new Error(\"'value' should be a SummarizedExperiment with the same number of columns as this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._alternativeExperiments = target._alternativeExperiments.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the alternative experiment.\n     *\n     * @return {SingleCellExperiment} A reference to this SingleCellExperiment with modified alternative experiments.\n     */\n    $setAlternativeExperiment(i, value) {\n        return this.setAlternativeExperiment(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified alternative experiment names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperimentNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the alternative experiment names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified alternative experiment names.\n     */\n    $setAlternativeExperimentNames(names) {\n        return this.setAlternativeExperimentNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAlternativeExperiments(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = this._alternativeExperiments.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the alternative experiments for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced alternative experiments.\n     */\n    $sliceAlternativeExperiments(i) {\n        return this.sliceAlternativeExperiments(i, { inPlace: true });\n    }\n\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        super._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n\n        if (columns !== null) {\n            output._reducedDimensions = this._reducedDimensions.apply(v => generics.SLICE_2D(v, columns, null, { allowView }));\n            output._alternativeExperiments = this._alternativeExperiments.apply(v => generics.SLICE_2D(v, null, columns, { allowView }));\n        } else {\n            output._reducedDimensions = this._reducedDimensions;\n            output._alternativeExperiments = this._alternativeExperiments;\n        }\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        super._bioconductor_COMBINE_ROWS(output, objects);\n\n        output._reducedDimensions = this._reducedDimensions;\n        output._alternativeExperiments = this._alternativeExperiments;\n\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        super._bioconductor_COMBINE_COLUMNS(output, objects);\n\n        try {\n            output._reducedDimensions = il.InternalList.parallelCombine(objects.map(x => x._reducedDimensions), generics.COMBINE_ROWS);\n        } catch (e) {\n            throw new Error(\"failed to combine reduced dimensions for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        try {\n            output._alternativeExperiments = il.InternalList.parallelCombine(objects.map(x => x._alternativeExperiments), generics.COMBINE_COLUMNS);\n        } catch (e) {\n            throw new Error(\"failed to combine alternative experiments for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._reducedDimensions = cutils.cloneField(this._reducedDimensions, deepCopy);\n        output._alternativeExperiments = cutils.cloneField(this._alternativeExperiments, deepCopy);\n\n        return;\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as full from \"./fetchGenesForAllSets.js\";\n\nconst _ranges = new Map;\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {?number} set - Set ID, see {@linkcode fetchAllSets} for details.\n *\n * If `null`, no request is performed, but various internal caches are initialized for subsequent calls to this function.\n * This is useful for guaranteeing that caches are available in concurrent calls.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceRequest=false] - Whether to force a range request to the server.\n * By default, the return value is extracted from the full set-to-gene mappings if {@linkcode fetchGenesForAllSets} was called before this function.\n * Setting this to `true` is only useful for testing.\n * @param {boolean} [options.forceDownload=false] - Whether to forcibly download all set-to-gene information up-front to avoid range requests.\n * This is done by calling {@linkcode fetchGenesForAllSets}.\n * Ignored if `forceRequest = true`.\n *\n * @return {Uint32Array} Array of integers containing the IDs for all genes belonging to the set.\n * Gene IDs refer to indices in {@linkcode fetchAllGenes}.\n *\n * If `set = null`, no return value is provided.\n * @async\n */\nexport async function fetchGenesForSet(species, set, { forceRequest = false, forceDownload = false } = {}) {\n    if (!forceRequest) {\n        let ffound = await full.fetchGenesForAllSets(species, { download: forceDownload });\n        if (ffound !== null) {\n            if (set !== null) {\n                return ffound[set];\n            } else {\n                return;\n            }\n        }\n    }\n\n    let spfound = _cache.get(species);\n    if (typeof spfound == \"undefined\") {\n        spfound = new Map;\n        _cache.set(species, spfound);\n        _ranges.set(species, await utils.retrieveRanges(species + \"_set2gene.tsv\"));\n    }\n\n    if (set == null) {\n        return;\n    }\n\n    let sefound = spfound.get(set);\n    if (typeof sefound !== \"undefined\") {\n        return sefound;\n    }\n\n    let ranges = _ranges.get(species);\n    let text = await utils.retrieveBytesByIndex(species + \"_set2gene.tsv\", ranges, set);\n    let output = utils.convertToUint32Array(text);\n    spfound.set(set, output);\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Wrapper around a matrix allocated on the Wasm heap.\n * @hideconstructor\n */\nexport class ScranMatrix {\n    #id;\n    #matrix;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#matrix = raw;\n        return;\n    }\n\n    /**\n     * Create a dense matrix from an existing Wasm-allocated buffer.\n     *\n     * @param {number} rows - Number of rows.\n     * @param {number} columns - Number of columns.\n     * @param {Float64WasmArray} contents - Array of matrix contents.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.columnMajor=true] - Whether the array in `contents` is column-major.\n     * @param {boolean} [options.copy=true] - Whether to copy `contents` when constructing the {@linkplain ScranMatrix}.\n     * If `false`, the returned {@linkplain ScranMatrix} will refer to the same allocation as `contents`,\n     * so callers should make sure that it does not outlive `contents`.\n     *\n     * @return {ScranMatrix} A {@linkplain ScranMatrix} containing the matrix contents.\n     */\n    static createDenseMatrix(rows, columns, contents, { columnMajor = true , copy = true } = {}) {\n        if (!(contents instanceof wa.Float64WasmArray)) {\n            throw new Error(\"'contents' should be a Float64WasmArray\");\n        }\n        if (contents.length != rows * columns) {\n            throw new Error(\"length of 'contents' should equal the product of 'rows' and 'columns'\");\n        }\n        return gc.call(module => new module.NumericMatrix(rows, columns, contents.offset, columnMajor, copy), ScranMatrix);\n    }\n\n    /**\n     * @return {ScranMatrix} A clone of the current ScranMatrix instance.\n     * This can be freed independently of the current instance.\n     */\n    clone() {\n        return gc.call(\n            module => this.#matrix.clone(),\n            ScranMatrix\n        );\n    }\n\n    // Internal use only, not documented.\n    get matrix() {\n        return this.#matrix;\n    }\n\n    /**\n     * @return {number} Number of rows in the matrix.\n     */\n    numberOfRows() {\n        return this.#matrix.nrow();\n    }\n\n    /**\n     * @return {number} Number of columns in the matrix.\n     */\n    numberOfColumns() {\n        return this.#matrix.ncol();\n    }\n\n    /**\n     * @param {number} i - Index of the row to extract.\n     * This should be a non-negative integer less than {@linkcode ScranMatrix#numberOfRows numberOfRows}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer for storing the extracted data.\n     * If supplied, this should have length equal to {@linkcode ScranMatrix#numberOfColumns numberOfColumns}.\n     *\n     * @return {Float64Array} An array containing the contents of row `i`.\n     *\n     * If `buffer` was supplied, the returned array is a view into it.\n     * Note that this may be invalidated on the next allocation on the Wasm heap.\n     */\n    row(i, { buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.row(i, buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createFloat64WasmArray(this.#matrix.ncol());\n            try {\n                this.#matrix.row(i, buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the column to extract.\n     * This should be a non-negative integer less than {@linkcode ScranMatrix#numberOfColumns numberOfColumns}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer for storing the extracted data.\n     * If supplied, this should have length equal to {@linkcode ScranMatrix#numberOfRows numberOfRows}.\n     *\n     * @return {Float64Array} An array containing the contents of column `i`.\n     *\n     * If `buffer` was supplied, the returned array is a view into it.\n     * Note that this may be invalidated on the next allocation on the Wasm heap.\n     */\n    column(i, { buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.column(i, buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createFloat64WasmArray(this.#matrix.nrow());\n            try {\n                this.#matrix.column(i, buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    /** \n     * Free the memory on the Wasm heap for this.#matrix.\n     * This invalidates this object and all of its references.\n     */\n    free() {\n        if (this.#matrix !== null) {\n            gc.release(this.#id);\n            this.#matrix = null;\n        }\n        return;\n    }\n\n    /**\n     * @return {boolean} Whether the matrix is sparse.\n     */\n    isSparse() {\n        return this.#matrix.sparse();\n    }\n\n    // Internal use only, by initialize* functions.\n    isReorganized() {\n        return this.#matrix.reorganized();\n    }\n\n    // Internal use only, by initialize* functions.\n    identities({ buffer = null } = {}) {\n        if (buffer != null) {\n            this.#matrix.identities(buffer.offset);\n            return buffer.array();\n        } else {\n            var output;\n            buffer = utils.createInt32WasmArray(this.#matrix.nrow());\n            try {\n                this.#matrix.identities(buffer.offset);\n                output = buffer.slice();\n            } finally {\n                buffer.free();\n            }\n            return output;\n        }\n    }\n\n    // Internal use only, by initialize* functions.\n    wipeIdentities() {\n        this.#matrix.wipe_identities();\n        return;\n    }\n}\n","export function stream(file, chunkSize, callback, resolve, reject) {\n    reject(\"no support for file paths in the browser context\");\n}\n\nexport function peek(file, n) {\n    throw new Error(\"no support for file paths in the browser context\");\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \n\n/**\n * Wrapper for the CRISPR-based metrics allocated on the Wasm heap, produced by {@linkcode perCellCrisprQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellCrisprQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledMaxProportions;\n    #filledMaxIndex;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledMaxProportions = filled;\n        this.#filledMaxIndex = filled;\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count across guides for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected guides for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY),\n            \"detected\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the proportion of counts in the most abundant guide for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    maxProportions({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxProportions, \n            () => { this.#filledMaxProportions = true }, \n            COPY => utils.possibleCopy(this.#results.max_proportion(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the index of the most abundant guide for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    maxIndex({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMaxIndex, \n            () => { this.#filledMaxIndex = true }, \n            COPY => utils.possibleCopy(this.#results.max_index(), COPY),\n            \"maxIndex\"\n        );\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute per-cell QC metrics from the CRISPR guide count matrix.\n *\n * @param {ScranMatrix} x - The count matrix for CRISPR guides.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellCrisprQcMetricsResults} Object containing the QC metrics.\n */\nexport function perCellCrisprQcMetrics(x, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.per_cell_crispr_qc_metrics(x.matrix, nthreads),\n        PerCellCrisprQcMetricsResults\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellCrisprQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode suggestCrisprQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n *\n * @return {PerCellCrisprQcMetricsResults} Object with allocated memory to store QC metrics, but no actual values.\n */\nexport function emptyPerCellCrisprQcMetricsResults(numberOfCells) {\n    return gc.call(\n        module => new module.PerCellCrisprQcMetrics_Results(numberOfCells),\n        PerCellCrisprQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\n\n/**\n * Any class that satisfies the ArtifactdbProjectNavigator contract, so called as it is intended to \"navigate\" an ArtifactDB project directory.\n * This should provide the following methods:\n * \n * - `metadata(p)`, a (possibly async) method that accepts a string `p` containing a relative path to a resource inside an ArtifactDB project directory,\n *   and returns an object containing the metadata for that object.\n *   Any redirections should be resolved by this method.\n *\n *   Note that {@linkplain AbstractArtifactdbDataset} will automatically cache the outputs of all `metadata()` calls between any invocations of {@linkcode AbstractArtifactdbDataset#clear clear},\n *   to improve efficiency when repeatedly accessing the same metadata.\n *   The same applies to {@linkplain AbstractArtifactdbResult}.\n * - `file(p)`, a (possibly async) method that accepts a string `p` containing a relative path inside a project directory and returns the contents of the file at that path.\n *   The return value should typically be a Uint8Array; on Node.js, methods may alternatively return a string containing a path to the file on the local file system.\n *   The method does not need to handle redirections from `p`.\n *\n * Optionally, the ArtifactdbProjectNavigator class may implement a `clear()` method to remove any cached content.\n * This will be called by {@linkcode AbstractArtifactdbDataset#clear AbstractArtifactdbDataset.clear} and  {@linkcode AbstractArtifactdbResult#clear AbstractArtifactdbResult.clear}.\n *\n * @typedef ArtifactdbProjectNavigator\n */\n\n/**************************\n ******* Internals ********\n **************************/\n\nasync function load_data_frame(info, navigator) {\n    if (typeof info == \"string\") {\n        info = await navigator.metadata(info);\n    }\n    let contents = await navigator.file(info.path);\n\n    let colnames;\n    let columns;\n    let rownames = null;\n\n    if (info[\"$schema\"].startsWith(\"csv_data_frame/\")) {\n        // TODO: replace with comservatory parser.\n        let parsed = await eutils.readTable2(contents, { delim: \",\" });\n        colnames = parsed.shift();\n\n        columns = new Array(colnames.length);\n        for (var i = 0; i < columns.length; i++) {\n            let current = [];\n            for (const x of parsed) {\n                current.push(x[i]);\n            }\n            columns[i] = current;\n        }\n\n        if (info.data_frame.row_names) {\n            rownames = columns.shift();\n            colnames.shift();\n        }\n\n        // Mutating the type... this doesn't quite handle NAs and NaNs properly, but whatever.\n        for (var i = 0; i < columns.length; i++) {\n            let type = info.data_frame.columns[i].type;\n            if (type == \"integer\") {\n                columns[i] = new Int32Array(columns[i]);\n            } else if (type == \"number\") {\n                columns[i] = new Float64Array(columns[i]);\n            } else if (type == \"boolean\") {\n                columns[i] = columns[i].map(x => x == \"true\");\n            }\n        }\n\n    } else if (info[\"$schema\"].startsWith(\"hdf5_data_frame/\")) {\n        let out = scran.realizeFile(contents);\n        try {\n            let handle = new scran.H5File(out.path);\n            let ghandle = handle.open(info.hdf5_data_frame.group);\n\n            colnames = ghandle.open(\"column_names\", { load: true }).values;\n            if (info.data_frame.row_names) {\n                rownames = ghandle.open(\"row_names\", { load: true }).values;\n            }\n\n            columns = [];\n            let chandle = ghandle.open(\"data\");\n            for (var i = 0; i < colnames.length; i++) {\n                if (!(String(i) in chandle.children)) {\n                    columns.push(null);\n                    continue;\n                }\n\n                let dhandle = chandle.open(String(i), { load: true });\n                let current = dhandle.values;\n\n                let type = info.data_frame.columns[i];\n                if (type == \"integer\") {\n                    if (current instanceof Float64Array || current instanceof Float32Array) {\n                        current = new Int32Array(current);\n                    }\n\n                } else if (type == \"number\") {\n                    if (!(current instanceof Float64Array) && !(current instanceof Float32Array)) {\n                        current = new Float64Array(current);\n                    }\n\n                } else if (type == \"boolean\") {\n                    let replacement = new Array(current.length);\n                    for (var i = 0; i < current.length; i++) {\n                        if (current[i] == -2147483648) {\n                            replacement[i] = null;\n                        } else {\n                            replacement[i] = current[i] != 0\n                        }\n                    }\n                    current = replacement;\n\n                } else if (type == \"string\" || type == \"date\") {\n                    if (\"missing-value-placeholder\" in dhandle.attributes) {\n                        let placeholder = dhandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (var i = 0; i < current.length; i++) {\n                            if (current[i] == placeholder) {\n                                current[i] = null;\n                            }\n                        }\n                    }\n                }\n\n                columns.push(current);\n            }\n        } finally {\n            out.flush();\n        }\n\n    } else {\n        throw new Error(\"unknown data_frame schema type '\" + info[\"$schema\"] + \"'\");\n    }\n\n    let new_columns = {};\n    let new_colnames = [];\n    for (var i = 0; i < columns.length; i++) {\n        if (info.data_frame.columns[i].type === \"other\") {\n            let nest_meta = await navigator.metadata(info.data_frame.columns[i].resource.path);\n            try {\n                new_columns[colnames[i]] = await load_data_frame(nest_meta, navigator);\n                new_colnames.push(colnames[i]);\n            } catch (e) {\n                console.warn(e);\n            }\n        } else {\n            new_columns[colnames[i]] = columns[i];\n            new_colnames.push(colnames[i]);\n        }\n    }\n\n    return new bioc.DataFrame(new_columns, { \n        columnOrder: new_colnames, \n        rowNames: rownames, \n        numberOfRows: info.data_frame.dimensions[0] \n    });\n}\n\nconst main_experiment_name = \"\";\n\nasync function extract_all_features(path, navigator) {\n    let extract_features = async se_meta => {\n        if (\"row_data\" in se_meta.summarized_experiment) {\n            let row_path = se_meta.summarized_experiment.row_data.resource.path;\n            return await load_data_frame(row_path, navigator);\n        } else {\n            return new bioc.DataFrame({}, { numberOfRows: se_meta.summarized_experiment.dimensions[0] });\n        }\n    };\n\n    let full_meta = await navigator.metadata(path);\n    let output = {};\n    output[main_experiment_name] = await extract_features(full_meta);\n\n    if (\"single_cell_experiment\" in full_meta) {\n        for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n            try {\n                let alt_meta = await navigator.metadata(alt.resource.path);\n                output[alt.name] = await extract_features(alt_meta);\n            } catch (e) {\n                console.warn(\"failed to extract features for alternative Experiment '\" + alt.name + \"'; \" + e.message);\n            }\n        }\n    }\n\n    return output;\n}\n\nasync function extract_all_assay_names(path, navigator) {\n    let extract_assay_names = se_meta => {\n        let output = [];\n        for (const ass of se_meta.summarized_experiment.assays) {\n            output.push(ass.name);\n        }\n        return output;\n    };\n\n    let full_meta = await navigator.metadata(path);\n    let assays = {};\n    assays[main_experiment_name] = extract_assay_names(full_meta);\n\n    if (\"single_cell_experiment\" in full_meta) {\n        for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n            try {\n                let alt_meta = await navigator.metadata(alt.resource.path);\n                assays[alt.name] = extract_assay_names(alt_meta);\n            } catch (e) {\n                console.warn(\"failed to extract features for alternative Experiment '\" + alt.name + \"'; \" + e.message);\n            }\n        }\n    }\n\n    return assays;\n}\n\n// This specifically loads the log-counts created by the dumper.\n// TODO: replace this with chihaya.js.\nasync function extract_logcounts(handle, navigator) {\n    if (handle.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (handle.readAttribute(\"delayed_operation\").values[0] !== \"unary arithmetic\") {\n        return null;\n    }\n    if (Math.abs(handle.open(\"value\", { load: true }).values[0] - Math.log(2)) > 0.00000001) {\n        return null;\n    }\n    if (handle.open(\"method\", { load: true }).values[0] !== \"/\") {\n        return null;\n    }\n    if (handle.open(\"side\", { load: true }).values[0] !== \"right\") {\n        return null;\n    }\n\n    let ghandle2 = handle.open(\"seed\");\n    if (ghandle2.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (ghandle2.readAttribute(\"delayed_operation\").values[0] !== \"unary math\") {\n        return null;\n    }\n    if (ghandle2.open(\"method\", { load: true }).values[0] !== \"log1p\") {\n        return null;\n    }\n\n    let ghandle3 = ghandle2.open(\"seed\");\n    if (ghandle3.readAttribute(\"delayed_type\").values[0] !== \"operation\") {\n        return null;\n    }\n    if (ghandle3.readAttribute(\"delayed_operation\").values[0] !== \"unary arithmetic\") {\n        return null;\n    }\n    if (ghandle3.open(\"method\", { load: true }).values[0] !== \"/\") {\n        return null;\n    }\n    if (ghandle3.open(\"side\", { load: true }).values[0] !== \"right\") {\n        return null;\n    }\n    if (ghandle3.open(\"along\", { load: true }).values[0] !== 1) {\n        return null;\n    }\n    let sf = ghandle3.open(\"value\", { load: true }).values;\n\n    let ahandle = ghandle3.open(\"seed\");\n    if (ahandle.readAttribute(\"delayed_type\").values[0] !== \"array\") {\n        return null;\n    }\n    if (ahandle.readAttribute(\"delayed_array\").values[0] !== \"custom alabaster local array\") {\n        return null;\n    }\n    let path = ahandle.open(\"path\", { load: true }).values[0];\n\n    let mat;\n    let output = {};\n    try {\n        mat = await extract_assay_raw(path, navigator, false); // don't force it to be integer, but we don't mind if it is.\n        output.matrix = scran.logNormCounts(mat.matrix, { sizeFactors: sf, center: false });\n        output.row_ids = mat.row_ids;\n    } finally {\n        scran.free(mat.matrix);\n    }\n                \n    return output;\n}\n\nasync function extract_assay(meta, assay, navigator, forceInteger) {\n    if (typeof assay == \"string\") {\n        var counter = 0;\n        for (const ass of meta.summarized_experiment.assays) {\n            if (ass.name == assay) {\n                assay = counter;\n                break;\n            }\n            counter++;\n        }\n        if (counter == meta.summarized_experiment.assays.length) {\n            throw new Error(\"assay '\" + assay + \"' not found\");\n        }\n    } else {\n        if (assay >= meta.summarized_experiment.assays.length) {\n            throw new Error(\"assay \" + String(assay) + \" out of range\");\n        }\n    }\n\n    let asspath = meta.summarized_experiment.assays[assay].resource.path;\n    return extract_assay_raw(asspath, navigator, forceInteger);\n}\n\nasync function extract_assay_raw(asspath, navigator, forceInteger) {\n    let assmeta = await navigator.metadata(asspath);\n    let contents = await navigator.file(assmeta.path);\n    let output;\n\n    let schema = assmeta[\"$schema\"];\n    let is_dense = schema.startsWith(\"hdf5_dense_array/\");\n    let is_sparse = schema.startsWith(\"hdf5_sparse_matrix/\");\n\n    if (is_dense || is_sparse) {\n        let name = (is_sparse ?  assmeta.hdf5_sparse_matrix.group : assmeta.hdf5_dense_array.dataset);\n        let stuff = scran.realizeFile(contents);\n        try {\n            output = scran.initializeSparseMatrixFromHDF5(stuff.path, name, { forceInteger });\n        } finally {\n            stuff.flush();\n        }\n\n    } else if (assmeta[\"$schema\"].startsWith(\"hdf5_delayed_array/\")) {\n        let stuff = scran.realizeFile(contents);\n        try {\n            let fhandle = new scran.H5File(stuff.path);\n            let ghandle = fhandle.open(assmeta.hdf5_delayed_array.group);\n\n            // TODO: replace with calls to chihaya.js.\n            output = await extract_logcounts(ghandle, navigator);\n            if (output == null) {\n                throw new Error(\"currently only supporting bakana-generated log-counts for delayed arrays\");\n            }\n        } finally {\n            stuff.flush();\n        }\n\n    } else {\n        throw new Error(\"array schema '\" + assmeta[\"$schema\"] + \"' is currently not supported\");\n    }\n\n    return output;\n}\n\nasync function extract_other_data(other_path, navigator) {\n    let othermeta = await navigator.metadata(other_path);\n    if (!othermeta[\"$schema\"].startsWith(\"json_simple_list/\")) {\n        throw new Error(\"currently only support JSON-formatted lists in the 'other_data'\");\n    }\n\n    let contents = await navigator.file(othermeta.path);\n    let ofile = new afile.SimpleFile(contents, { name: \"list.json\" });\n    let unpacked = eutils.unpackText(ofile.buffer(), { compression: (othermeta.json_simple_list.compression == \"gzip\" ? \"gz\" : \"none\") });\n    let parsed = JSON.parse(unpacked);\n    return extract_list_data_internal(parsed);\n}\n\nfunction extract_list_data_internal(obj) {\n    if (!(\"type\" in obj)) {\n        throw new Error(\"non-standard JSON object for 'json_simple_list' schema\");\n    }\n\n    if (obj.type == \"number\") {\n        if (obj.values instanceof Array) {\n            let output = new Float64Array(obj.values.length);\n            obj.values.forEach((x, i) => {\n                output[i] = (x === null ? Number.NaN : x) \n            });\n            return output;\n        } else {\n            return (obj.values == null ? Number.NaN : obj.values);\n        }\n\n    } else if (obj.type == \"integer\") {\n        if (obj.values instanceof Array) {\n            let output = new Int32Array(obj.values.length);\n            obj.values.forEach((x, i) => {\n                output[i] = (x === null ? -2147483648 : x) \n            });\n            return output;\n        } else {\n            return obj.values;\n        }\n\n    } else if (obj.type == \"boolean\" || obj.type == \"string\") {\n        return obj.values;\n\n    } else if (obj.type == \"list\") {\n        if (\"names\" in obj) {\n            let output = {};\n            for (var i = 0; i < obj.values.length; i++) {\n                output[obj.names[i]] = extract_list_data_internal(obj.values[i]);\n            }\n            return output;\n        } else {\n            let output = [];\n            for (var i = 0; i < obj.values.length; i++) {\n                output.push(extract_list_data_internal(obj.values[i]));\n            }\n            return output;\n        }\n\n    } else if (obj.type == \"nothing\") {\n        return null;\n\n    } else {\n        console.warn(\"JSON simple list containing type '\" + obj.type + \"' is not yet supported\");\n        return null;\n    }\n}\n\n/***********************\n ******* Cacher ********\n ***********************/\n\n// As we'll be using the metadata often, we cache it at this level. This\n// removes the burden of caching on the implementation of the navigator. \nclass MetadataCacheWrapper {\n    #navigator;\n    #metadata_cache;\n\n    constructor(nav) {\n        this.#navigator = nav;\n        this.#metadata_cache = {};\n    }\n\n    clear() {\n        this.#metadata_cache = {};\n        if (\"clear\" in this.#navigator) {\n            this.#navigator.clear();\n        }\n    }\n\n    async metadata(path) {\n        if (path in this.#metadata_cache) {\n            return this.#metadata_cache[path];\n        } else {\n            let content = await this.#navigator.metadata(path);\n            this.#metadata_cache[path] = content;\n            return content;\n        }\n    }\n\n    file(path) {\n        return this.#navigator.file(path);\n    }\n};\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain ArtifactdbProjectNavigator} class.\n * Subclasses should define `abbreviate()` and `serialize()` methods, as well as the static `format()` and `unserialize()` methods - \n * see the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md) for more details.\n */\nexport class AbstractArtifactdbDataset {\n    #path;\n    #navigator;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    /**\n     * @param {string} path - Path to the SummarizedExperiment in the ArtifactDB project directory.\n     * @param {ArtifactdbProjectNavigator} navigator - A navigator object that describes how to obtain the various assets from the project directory containing `path`.\n     */\n    constructor(path, navigator) {\n        this.#path = path;\n        this.#navigator = new MetadataCacheWrapper(navigator);\n        this.#options = AbstractArtifactdbDataset.defaults();\n\n        // Don't call this.clear() here. We don't want to clear the navigator's\n        // cache at this point, as the navigator might contain some cached\n        // values when passed to the constructor. We should respect any caches\n        // until we're specifically told to discard it with clear() or cache =\n        // false in load() or summary().\n        this.#reset_local_caches();\n        return;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbDataset#load load} (but not {@linkcode AbstractArtifactdbDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?(string|number)} [options.rnaExperiment] - Name or index of the alternative experiment containing gene expression data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no RNA data is assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the gene expression data.\n     * @param {?(string|number)} [options.adtExperiment] - Name or index of the alternative experiment containing ADT data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no ADTs are assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the ADT data.\n     * @param {?(string|number)} [options.crisprExperiment] - Name or index of the alternative experiment containing CRISPR guide data.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and no CRISPR guides are assumed to be present.\n     * If `i` is an empty string, the main experiment is assumed to contain the guide data.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #reset_local_caches() {\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractArtifactdbDataset#load load} or {@linkcode AbstractArtifactdbDataset#summary summary}.\n     */\n    clear() {\n        this.#reset_local_caches();\n        this.#navigator.clear();\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#raw_features = await extract_all_features(this.#path, this.#navigator);\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let col_path = full_meta.summarized_experiment.column_data.resource.path;\n        this.#raw_cells = await load_data_frame(col_path, this.#navigator);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     *\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: await extract_all_assay_names(this.#path, this.#navigator)\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode AbstractArtifactdbDataset#load load} but the order of values may be different.\n     *\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n\n        let fmapping = {\n            RNA: this.#options.rnaExperiment, \n            ADT: this.#options.adtExperiment, \n            CRISPR: this.#options.crisprExperiment \n        };\n\n        let preview = futils.extractRemappedPrimaryIds(this.#raw_features, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode AbstractArtifactdbDataset#defaults defaults} or with {@linkcode AbstractArtifactdbDataset#setOptions setOptions}.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let altmap = {};\n        let alts = [];\n        if (\"single_cell_experiment\" in full_meta) {\n            alts = full_meta.single_cell_experiment.alternative_experiments;\n            for (const alt of alts) {\n                altmap[alt.name] = alt.resource.path;\n            }\n        }\n\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null) {\n                    continue;\n                }\n\n                let meta = null;\n                let name = v.exp;\n                if (typeof v.exp == \"string\") {\n                    if (v.exp === \"\") {\n                        meta = full_meta;\n                    } else {\n                        if (!(v.exp in altmap)) {\n                            continue;\n                        }\n                        meta = await this.#navigator.metadata(altmap[v.exp]);\n                    }\n                } else {\n                    if (v.exp >= alts.length) {\n                        continue;\n                    }\n                    name = alts[v.exp].name;\n                    meta = await this.#navigator.metadata(alts[v.exp].resource.path);\n                }\n\n                let loaded = await extract_assay(meta, v.assay, this.#navigator, true);\n                output.matrix.add(k, loaded.matrix);\n                output.features[k] = bioc.SLICE(this.#raw_features[name], loaded.row_ids);\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\nexport const ArtifactDbSummarizedExperimentDatasetBase = AbstractArtifactdbDataset;\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain ArtifactdbProjectNavigator} class.\n */\nexport class AbstractArtifactdbResult {\n    #path;\n    #navigator;\n\n    #raw_features;\n    #raw_cells;\n    #raw_other;\n\n    #options;\n\n    /**\n     * @param {string} path - Path to the SummarizedExperiment in the ArtifactDB project directory.\n     * @param {ArtifactdbProjectNavigator} navigator - A navigator object that describes how to obtain the various assets from the project directory containing `path`.\n     */\n    constructor(path, navigator) {\n        this.#path = path;\n        this.#navigator = new MetadataCacheWrapper(navigator);\n        this.#options = AbstractArtifactdbResult.defaults();\n\n        // Don't call clear() here, see comments above in the Dataset constructor.\n        this.#reset_local_caches();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbResult#load load} (but not {@linkcode AbstractArtifactdbResult#summary summary}.\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    #reset_local_caches() {\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#raw_other = null;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractArtifactdbResult#load load} or {@linkcode AbstractArtifactdbResult#summary summary}.\n     */\n    clear() {\n        this.#reset_local_caches();\n        this.#navigator.clear();\n    }\n\n    async #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#raw_features = await extract_all_features(this.#path, this.#navigator);\n        return;\n    }\n\n    async #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        let full_meta = await this.#navigator.metadata(this.#path);\n        let col_path = full_meta.summarized_experiment.column_data.resource.path;\n        this.#raw_cells = await load_data_frame(col_path, this.#navigator);\n        return;\n    }\n\n    async #other() {\n        if (this.#raw_other !== null) {\n            return;\n        }\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        if (\"other_data\" in full_meta.summarized_experiment) {\n            let other_path = full_meta.summarized_experiment.other_data.resource.path;\n            this.#raw_other = await extract_other_data(other_path, this.#navigator);\n        } else {\n            this.#raw_other = {};\n        }\n        return;\n    }\n\n    async #get_all_reddim_names(rd_meta, store) {\n        for (const red of rd_meta) {\n            let redmeta = await this.#navigator.metadata(red.resource.path);\n            if (redmeta[\"$schema\"].startsWith(\"hdf5_dense_array/\") && redmeta.array.dimensions.length == 2) {\n                store.push(red.name);\n            }\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractArtifactdbResult#load load}.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     * - `other_metadata`: an object containing other metadata.\n     *\n     * @async \n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#other();\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: await extract_all_assay_names(this.#path, this.#navigator),\n            reduced_dimension_names: [],\n            other_metadata: this.#raw_other\n        };\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n        if (\"single_cell_experiment\" in full_meta) {\n            let reddim_meta = full_meta.single_cell_experiment.reduced_dimensions;\n            await this.#get_all_reddim_names(reddim_meta, output.reduced_dimension_names);\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractArtifactdbResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode AbstractArtifactdbResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     * - `other_metadata`: an object containing other metadata.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#other();\n\n        let full_meta = await this.#navigator.metadata(this.#path);\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells,\n            reduced_dimensions: {},\n            other_metadata: this.#raw_other\n        };\n\n        // Fetch the reduced dimensions first.\n        {\n            let reddims = this.#options.reducedDimensionNames;\n            let reddim_meta = full_meta.single_cell_experiment.reduced_dimensions;\n\n            if (reddims == null) {\n                reddims = [];\n                await this.#get_all_reddim_names(reddim_meta, reddims);\n            }\n\n            if (reddims.length > 0) {\n                let redmap = {};\n                for (const red of reddim_meta) {\n                    redmap[red.name] = red.resource.path;\n                }\n\n                for (const k of reddims) {\n                    let redmeta = await this.#navigator.metadata(redmap[k]); // this should be only HDF5 dense matrices.\n                    let dims = redmeta.array.dimensions;\n                    let redcontents = await this.#navigator.file(redmeta.path); \n\n                    let realized = scran.realizeFile(redcontents);\n                    let acquired = [];\n                    try {\n                        let fhandle = new scran.H5File(realized.path);\n                        let dhandle = fhandle.open(redmeta.hdf5_dense_array.dataset, { load: true });\n                        let contents = dhandle.values;\n                        for (var d = 0; d < dims[1]; d++) {\n                            acquired.push(contents.slice(d * dims[0], (d + 1) * dims[0]));\n                        }\n                    } finally {\n                        realized.flush();\n                    }\n\n                    output.reduced_dimensions[k] = acquired;\n                }\n            }\n        }\n\n        // Now fetching the assay matrix.\n        {\n            let altmap = {};\n            if (\"single_cell_experiment\" in full_meta) {\n                for (const alt of full_meta.single_cell_experiment.alternative_experiments) {\n                    altmap[alt.name] = alt.resource.path;\n                }\n            }\n\n            try {\n                for (const [k, v] of Object.entries(this.#raw_features)) {\n                    let curassay = this.#options.primaryAssay;\n                    if (typeof curassay == \"object\") {\n                        if (k in curassay) {\n                            curassay = curassay[k];\n                        } else {\n                            continue;\n                        }\n                    }\n\n                    let curnormalized = this.#options.isPrimaryNormalized;\n                    if (typeof curnormalized == \"object\") {\n                        if (k in curnormalized) {\n                            curnormalized = curnormalized[k];\n                        } else {\n                            curnormalized = true;\n                        }\n                    }\n\n                    let meta;\n                    if (k === \"\") {\n                        meta = full_meta;\n                    } else {\n                        meta = await this.#navigator.metadata(altmap[k]);\n                    }\n\n                    let loaded = await extract_assay(meta, curassay, this.#navigator, !curnormalized);\n                    output.matrix.add(k, loaded.matrix);\n\n                    if (!curnormalized) {\n                        let normed = scran.logNormCounts(loaded.matrix, { allowZeros: true });\n                        output.matrix.add(k, normed);\n                    }\n\n                    if (loaded.row_ids !== null) {\n                        output.features[k] = bioc.SLICE(this.#raw_features[k], loaded.row_ids);\n                    } else {\n                        output.features[k] = this.#raw_features[k];\n                    }\n                }\n\n            } catch (e) {\n                scran.free(output.matrix);\n                throw e;\n            }\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\nexport const ArtifactDbSummarizedExperimentResultBase = AbstractArtifactdbResult;\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./utils/viz_parent.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as neighbor_module from \"./neighbor_index.js\";\nimport * as aworkers from \"./abstract/worker_parent.js\";\n\n/**\n * This creates a UMAP embedding based on the neighbor index constructed at {@linkplain NeighborIndexState}.\n * This wraps [`runUMAP`](https://kanaverse.github.io/scran.js/global.html#runUMAP)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class UmapState {\n    #index;\n    #parameters;\n    #reloaded;\n\n    #worker_id;\n\n    #ready;\n    #run;\n\n    constructor(index, parameters = null, reloaded = null) {\n        if (!(index instanceof neighbor_module.NeighborIndexState)) {\n            throw new Error(\"'index' should be a State object from './neighbor_index.js'\");\n        }\n        this.#index = index;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#reloaded = reloaded;\n        this.changed = false;\n\n        let worker = aworkers.createUmapWorker();\n        let { worker_id, ready } = vizutils.initializeWorker(worker, vizutils.scranOptions);\n        this.#worker_id = worker_id;\n        this.#ready = ready;\n\n        this.#run = null;\n    }\n\n    ready() {\n        // It is assumed that the caller will await the ready()\n        // status before calling any other methods of this instance.\n        return this.#ready;\n    }\n\n    free() {\n        return vizutils.killWorker(this.#worker_id);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to create a copy of the coordinates,\n     * if the caller might mutate them.\n     *\n     * @return {object} Object containing:\n     *\n     * - `x`: a Float64Array containing the x-coordinate for each cell.\n     * - `y`: a Float64Array containing the y-coordinate for each cell.\n     * - `iterations`: the number of iterations processed.\n     *\n     * @async\n     */\n    async fetchResults({ copy = true } = {}) {\n        if (this.#reloaded !== null) {\n            let output = {\n                x: this.#reloaded.x,\n                y: this.#reloaded.y\n            };\n\n            if (copy) {\n                output.x = output.x.slice();\n                output.y = output.y.slice();\n            }\n\n            output.iterations = this.#parameters.num_epochs;\n            return output;\n        } else {\n            // Vectors that we get from the worker are inherently\n            // copied, so no need to do anything extra here.\n            await this.#run;\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"FETCH\" });\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #core(num_neighbors, num_epochs, min_dist, animate, reneighbor) {\n        var nn_out = null;\n        if (reneighbor) {\n            nn_out = vizutils.computeNeighbors(this.#index, num_neighbors);\n        }\n\n        let args = {\n            \"num_neighbors\": num_neighbors,\n            \"num_epochs\": num_epochs,\n            \"min_dist\": min_dist,\n            \"animate\": animate\n        };\n\n        // This returns a promise but the message itself is sent synchronously,\n        // which is important to ensure that the UMAP runs in its worker in\n        // parallel with other analysis steps. Do NOT put the runWithNeighbors\n        // call in a .then() as this may defer the message sending until \n        // the current thread is completely done processing.\n        this.#run = vizutils.runWithNeighbors(this.#worker_id, args, nn_out);\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `umap` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_neighbors - Number of neighbors to use to construct the simplicial sets.\n     * @param {number} parameters.num_epochs - Number of epochs to run the algorithm.\n     * @param {number} parameters.min_dist - Number specifying the minimum distance between points.\n     * @param {boolean} parameters.animate - Whether to process animation iterations, see {@linkcode setVisualizationAnimate} for details.\n     *\n     * @return UMAP coordinates are computed in parallel on a separate worker thread.\n     * A promise that resolves when the calculations are complete.\n     */\n    compute(parameters) {\n        let { num_neighbors, num_epochs, min_dist, animate } = parameters;\n\n        let same_neighbors = (!this.#index.changed && this.#parameters.num_neighbors === num_neighbors);\n        if (same_neighbors && num_epochs === this.#parameters.num_epochs && min_dist === this.#parameters.min_dist) {\n            this.changed = false;\n            return new Promise(resolve => resolve(null));\n        }\n\n        // In the reloaded state, we must send the neighbor\n        // information, because it hasn't ever been sent before.\n        if (this.#reloaded !== null) {\n            same_neighbors = false;\n            this.#reloaded = null;\n        }\n\n        this.#core(num_neighbors, num_epochs, min_dist, animate, !same_neighbors);\n\n        this.#parameters.num_neighbors = num_neighbors;\n        this.#parameters.num_epochs = num_epochs;\n        this.#parameters.min_dist = min_dist;\n        this.#parameters.animate = animate;\n\n        this.changed = true;\n        return this.#run;\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * Repeat the animation iterations.\n     * It is assumed that {@linkcode setVisualizationAnimate} has been set appropriately to process each iteration.\n     *\n     * @return A promise that resolves on successful completion of all iterations.\n     */\n    animate() {\n        if (this.#reloaded !== null) {\n            this.#reloaded = null;\n\n            // We need to reneighbor because we haven't sent the neighbors across yet.\n            this.#core(this.#parameters.num_neighbors, this.#parameters.num_epochs, this.#parameters.min_dist, true, true);\n      \n            // Mimicking the response from the re-run.\n            return this.#run\n                .then(contents => { \n                    return {\n                        \"type\": \"umap_rerun\",\n                        \"data\": { \"status\": \"SUCCESS\" }\n                    };\n                });\n        } else {\n            return vizutils.sendTask(this.#worker_id, { \"cmd\": \"RERUN\" });\n        }\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport async function unserialize(handle, index) {\n    let ghandle = handle.open(\"umap\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            num_neighbors: phandle.open(\"num_neighbors\", { load: true }).values[0],\n            num_epochs: phandle.open(\"num_epochs\", { load: true }).values[0],\n            min_dist: phandle.open(\"min_dist\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let reloaded;\n    {\n        let rhandle = ghandle.open(\"results\");\n        reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    let output = new UmapState(index, parameters, reloaded);\n    await output.ready();\n    return output;\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as init from \"./initializeSparseMatrix.js\";\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around a labelled reference dataset on the Wasm heap, typically produced by {@linkcode loadLabelledReferenceFromBuffers}.\n * @hideconstructor\n */\nclass LoadLabelledReferenceResults {\n    #id;\n    #reference;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#reference = raw;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get reference() {\n        return this.#reference;\n    }\n\n    /**\n     * @return {number} Number of samples in this dataset.\n     */\n    numberOfSamples() {\n        return this.#reference.num_samples();\n    }\n\n    /**\n     * @return {number} Number of features in this dataset.\n     */\n    numberOfFeatures() {\n        return this.#reference.num_features();\n    }\n\n    /**\n     * @return {number} Number of labels in this dataset.\n     */\n    numberOfLabels() {\n        return this.#reference.num_labels();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#reference !== null) {\n            gc.release(this.#id);\n            this.#reference = null;\n        }\n    }\n}\n\n/**\n * Load a reference dataset for annotation.\n * \n * @param {Uint8Array} ranks - Buffer containing the Gzipped CSV file containing a matrix of ranks.\n * Each line corresponds to a sample and contains a comma-separated vector of ranks across all features.\n * All lines should contain the same number of entries.\n * This is effectively a row-major matrix where rows are samples and columns are features.\n * (Advanced users may note that this is transposed in C++.) \n * @param {Uint8Array} markers - Buffer containing the Gzipped GMT file containing the markers for each pairwise comparison between labels.\n * For `markers`, the GMT format is a tab-separated file with possibly variable numbers of fields for each line.\n * Each line corresponds to a pairwise comparison between labels, defined by the first two fields.\n * The remaining fields should contain indices of marker features (referring to columns of `matrix`) that are upregulated in the first label when compared to the second.\n * Markers should be sorted in order of decreasing strength.\n * @param {Uint8Array} labels - Buffer containing the Gzipped text file containing the label for each sample.\n * Each line should contain an integer representing a particular label, from `[0, N)` where `N` is the number of unique labels.\n * The number of lines should be equal to the number of rows in `matrix`.\n * The actual names of the labels are usually held elsewhere.\n * \n * @return {LoadLabelledReferenceResults} Object containing the reference dataset.\n */\nexport function loadLabelledReferenceFromBuffers(ranks, markers, labels) {\n    var output;\n    var matbuf;\n    var markbuf;\n    var labbuf;\n\n    try {\n        matbuf = utils.wasmifyArray(ranks, \"Uint8WasmArray\");\n        markbuf = utils.wasmifyArray(markers, \"Uint8WasmArray\");\n        labbuf = utils.wasmifyArray(labels, \"Uint8WasmArray\");\n        output = gc.call(\n            module => module.load_singlepp_reference(labbuf.offset, labbuf.length, markbuf.offset, markbuf.length, matbuf.offset, matbuf.length),\n            LoadLabelledReferenceResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(matbuf);\n        utils.free(markbuf);\n        utils.free(labbuf);\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around a built labelled reference dataset on the Wasm heap, typically produced by {@linkcode buildLabelledReference}.\n * @hideconstructor\n */\nclass BuildLabelledReferenceResults {\n    #id;\n    #reference;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#reference = raw;\n        return;\n    }\n\n    // internal use only.\n    get reference() {\n        return this.#reference;\n    }\n\n    /**\n     * @return {number} Number of shared features between the test and reference datasets.\n     */\n    sharedFeatures() {\n        return this.#reference.shared_features();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#reference !== null) {\n            gc.release(this.#id);\n            this.#reference = null;\n        }\n    }\n}\n\nfunction register_features(features, id_array) {\n    let registry_contents = new Map;\n\n    // All features in the data are guaranteed to get the a unique ID,\n    // but only non-null and non-duplicated (or the first of a duplicate set)\n    // are actually registered.\n    for (var i = 0; i < features.length; i++) {\n        let id = features[i];\n        if (id !== null) {\n            if (!registry_contents.has(id)) {\n                registry_contents.set(id, i);\n            }\n        }\n        id_array[i] = i;\n    }\n\n    return { contents: registry_contents, counter: features.length };\n}\n\nfunction convert_features(features, registry, id_array) {  \n    let used = new Set;\n    let set = (id, index) => {\n        let found = registry.contents.get(id);\n        if (typeof found !== \"undefined\") {\n            if (!used.has(found)) { // if entries of 'features' match to the same ID, only the first entry gets to match to the ID.\n                id_array[index] = found;\n                used.add(found);\n                return true;\n            }\n        }\n        return false;\n    };\n\n    let counter = registry.counter;\n    for (var i = 0; i < features.length; i++) {\n        let y = features[i];\n        let found = false;\n\n        if (y !== null) {\n            if (y instanceof Array) {\n                for (const z of y) {\n                    if (set(z, i)) { // if an entry of 'features' has multiple names, the first matching name wins.\n                        found = true;\n                        break;\n                    }\n                }\n            } else {\n                found = set(y, i);\n            }\n        }\n\n        // If something isn't found, they get a unique ID.\n        if (!found) {\n            id_array[i] = counter;\n            ++counter;\n        }\n    }\n\n    return;\n}\n\n/**\n * Build the reference dataset for annotation.\n * The build process involves harmonizing the identities of the features available in the test dataset compared to the reference.\n * Specifically, a feature must be present in both datasets in order to be retained. \n * Of those features in the intersection, only the `top` markers from each pairwise comparison are ultimately used for classification.\n *\n * Needless to say, `features` should match up to the rows of the {@linkplain ScranMatrix} that is actually used for annotation in {@linkcode labelCells}.\n *\n * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.\n * Each entry should contain the identifier for the corresponding row of the test matrix.\n * Any `null` entries are considered to be incomparable.\n * If any identifiers are duplicated, only the first occurrence is used and the rest are ignored.\n * @param {LoadLabelledReferenceResults} loaded - A reference dataset, typically loaded with {@linkcode loadLabelledReferenceFromBuffers}.\n * @param {Array} referenceFeatures - An array of feature identifiers (usually strings) of length equal to the number of features in `reference`.\n * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `features` is used.\n * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `features`.\n * Any `null` entries are considered to be incomparable.\n * If multiple entries of `referenceFeatures` match to the same feature in `features`, only the first matching entry is used and the rest are ignored.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.top=20] - Number of top marker features to use.\n * These features are taken from each pairwise comparison between labels.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {BuildLabelledReferenceResults} Object containing the built reference dataset.\n */\nexport function buildLabelledReference(features, loaded, referenceFeatures, { top = 20, numberOfThreads = null } = {}) {\n    var mat_id_buffer;\n    var ref_id_buffer;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var nfeat = features.length;\n        mat_id_buffer = utils.createInt32WasmArray(nfeat);\n        ref_id_buffer = utils.createInt32WasmArray(loaded.numberOfFeatures());\n        if (referenceFeatures.length != ref_id_buffer.length) {\n            throw new Error(\"length of 'referenceFeatures' should be equal to the number of features in 'reference'\");\n        }\n\n        let registry = register_features(features, mat_id_buffer.array());\n        convert_features(referenceFeatures, registry, ref_id_buffer.array());\n\n        output = gc.call(\n            module => module.build_singlepp_reference(nfeat, mat_id_buffer.offset, loaded.reference, ref_id_buffer.offset, top, nthreads),\n            BuildLabelledReferenceResults\n        );\n\n        output.expectedNumberOfFeatures = nfeat;\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(mat_id_buffer);\n        utils.free(ref_id_buffer);\n    }\n\n    return output;\n}\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around the cell labelling results on the Wasm heap, typically produced by {@linkcode labelCells}.\n * @hideconstructor\n */\nclass LabelCellsResults {\n    #id;\n    #results;\n    #cell_buffer;\n    #label_buffer;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of labels used in {@linkcode labelCells}.\n     */\n    numberOfLabels() {\n        return this.#results.num_labels();\n    }\n\n    /**\n     * @return {number} Number of cells that were labelled.\n     */\n    numberOfCells() {\n        return this.#results.num_samples();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,\n     * containing the index of the best label for each cell.\n     */\n    predictedLabels({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.get_best(), copy);\n    }\n\n    /**\n     * @param {number} i - Index of the cell of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfLabels numberOfLabels}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all labels.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForCell(i, { copy = true, buffer = null } = {}) {\n        if (buffer == null) {\n            if (typeof this.#cell_buffer == \"undefined\") {\n                this.#cell_buffer = utils.createFloat64WasmArray(this.#results.num_labels());\n            }\n            this.#results.get_scores_for_sample(i, this.#cell_buffer.offset);\n            return utils.possibleCopy(this.#cell_buffer.array(), copy);\n        } else {\n            if (buffer.length !== this.#results.num_labels()) {\n                throw new Error(\"length of 'buffer' should equal the number of labels\");\n            }\n            this.#results.get_scores_for_sample(i, buffer.offset);\n            return buffer;\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the label of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfCells numberOfCells}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForLabel(i, { copy = true, buffer = null } = {}) {\n        if (buffer == null) {\n            if (typeof this.#label_buffer == \"undefined\") {\n                this.#label_buffer = utils.createFloat64WasmArray(this.#results.num_samples());\n            }\n            this.#results.get_scores_for_label(i, this.#label_buffer.offset);\n            return utils.possibleCopy(this.#label_buffer.array(), copy);\n        } else {\n            if (buffer.length !== this.#results.num_samples()) {\n                throw new Error(\"length of 'buffer' should equal the number of cells\");\n            }\n            this.#results.get_scores_for_label(i, buffer.offset);\n            return utils.possibleCopy(this.#label_buffer.array(), copy);\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,\n     * containing the difference in scores between the best and second-best label during fine-tuning.\n     */\n    fineTuningDelta({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.get_delta(), copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n\n            utils.free(this.#label_buffer);\n            utils.free(this.#cell_buffer);\n        }\n    }\n}\n\nfunction label_cells(x, expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, msg) {\n    var output = null;\n    var matbuf;\n    var tempmat;\n\n    try {\n        let target;\n        if (x instanceof ScranMatrix) {\n            target = x.matrix;\n        } else if (x instanceof wa.Float64WasmArray) {\n            tempmat = init.initializeDenseMatrixFromDenseArray(numberOfFeatures, numberOfCells, x, { forceInteger: false });\n            target = tempmat.matrix;\n        } else {\n            throw new Error(\"unknown type for 'x'\");\n        }\n\n        if (target.nrow() != expectedNumberOfFeatures) {\n            throw new Error(\"number of rows in 'x' should be equal to length of 'features' used to build '\" + msg + \"'\");\n        }\n\n        output = FUN(target);\n\n    } finally {\n        utils.free(matbuf);\n        utils.free(tempmat);\n    }\n\n    return output;\n}\n\n/**\n * Label cells based on similarity in expression to a reference dataset.\n *\n * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.\n * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.\n * @param {BuildLabelledReferenceResults} reference - A built reference dataset, typically generated by {@linkcode buildLabelledReference}.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.\n * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.\n * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {LabelCellsResults} Labelling results for each cell in `x`.\n */\nexport function labelCells(x, reference, { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    let FUN = (target, ptr) => {\n        return gc.call(module => module.run_singlepp(target, reference.reference, quantile, nthreads), LabelCellsResults);\n    };\n    return label_cells(x, reference.expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, \"reference\");\n}\n\n/**************************************************\n **************************************************/\n\n/**\n * Wrapper around integrated reference datasets on the Wasm heap, typically produced by {@linkcode integrateLabelledReferences}.\n * @hideconstructor\n */\nclass IntegrateLabelledReferencesResults {\n    #id;\n    #integrated;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#integrated = raw;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get integrated() {\n        return this.#integrated;\n    }\n\n    /**\n     * @return {number} Number of reference datasets.\n     */\n    numberOfReferences() {\n        return this.#integrated.num_references();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#integrated !== null) {\n            gc.release(this.#id);\n            this.#integrated = null;\n        }\n    }\n}\n\n/**\n * Integrate multiple reference datasets.\n *\n * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.\n * Each entry should contain a single identifier for the corresponding row of the test matrix.\n * Any `null` entries are considered to be incomparable.\n * If any entries are duplicated, only the first occurrence is used and the rest are ignored.\n * @param {Array} loaded - Array of {@linkplain LabelledReference} objects, typically created with {@linkcode loadLabelledReferenceFromBuffers}.\n * @param {Array} referenceFeatures - Array of length equal to `loaded`, \n * containing arrays of feature identifiers (usually strings) of length equal to the number of features the corresponding entry of `loaded`.\n * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `features` is used.\n * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `features`.\n * Any `null` entries are considered to be incomparable.\n * If multiple entries of `referenceFeatures` match to the same feature in `features`, only the first matching entry is used and the rest are ignored.\n * @param {Array} reference - Array of {@linkplain BuildLabelledReferenceResults} objects, typically generated by calling {@linkcode buildLabelledReference} \n * on the same `features` and the corresponding entries of `loaded` and `referenceFeatures`.\n * This should have length equal to that of `loaded`.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {IntegrateLabelledReferencesResults} Object containing the integrated references.\n */\nexport function integrateLabelledReferences(features, loaded, referenceFeatures, built, { numberOfThreads = null } = {}) {\n    let id_arr;\n    let loaded_arr2;\n    let ref_arr2;\n    let built_arr2;\n    let output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    // Checking the inputs.\n    let nrefs = loaded.length;\n    if (referenceFeatures.length != nrefs) {\n        throw new Error(\"'loaded' and 'referenceFeatures' should be of the same length\");\n    }\n    if (built.length != nrefs) {\n        throw new Error(\"'loaded' and 'built' should be of the same length\");\n    }\n    for (var i = 0; i < nrefs; i++) {\n        if (loaded[i].numberOfFeatures() != referenceFeatures[i].length) {\n            throw new Error(\"length of each 'referenceFeatures' should be equal to the number of features in the corresponding 'loaded'\");\n        }\n    }\n\n    let ref_arr = new Array(nrefs);\n    try {\n        id_arr = utils.createInt32WasmArray(features.length);\n        let registry = register_features(features, id_arr.array());\n\n        loaded_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let la2 = loaded_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            la2[i] = BigInt(loaded[i].reference.$$.ptr);\n        }\n\n        ref_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let ra2 = ref_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            let current = referenceFeatures[i];\n            ref_arr[i] = utils.createInt32WasmArray(current.length);\n            convert_features(current, registry, ref_arr[i].array());\n            ra2[i] = BigInt(ref_arr[i].offset);\n        }\n\n        built_arr2 = utils.createBigUint64WasmArray(nrefs);\n        let ba2 = built_arr2.array();\n        for (var i = 0; i < nrefs; i++) {\n            ba2[i] = BigInt(built[i].reference.$$.ptr);\n        }\n        \n        output = gc.call(\n            module => module.integrate_singlepp_references(\n                features.length,\n                id_arr.offset,\n                nrefs,\n                loaded_arr2.offset,\n                ref_arr2.offset,\n                built_arr2.offset,\n                nthreads\n            ),\n            IntegrateLabelledReferencesResults\n        );\n\n        output.expectedNumberOfFeatures = features.length;\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(id_arr);\n        utils.free(loaded_arr2);\n        utils.free(built_arr2);\n        utils.free(ref_arr2);\n        for (const x of ref_arr) {\n            utils.free(x);\n        }\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around the integrated cell labelling results on the Wasm heap, typically produced by {@linkcode labelCells}.\n * @hideconstructor\n */\nclass IntegrateCellLabelsResults {\n    #results;\n\n    constructor(raw) {\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of labels used in {@linkcode integrateCellLabels}.\n     */\n    numberOfReferences() {\n        return this.#results.numberOfLabels();\n    }\n\n    /**\n     * @return {number} Number of cells that were labelled.\n     */\n    numberOfCells() {\n        return this.#results.numberOfCells();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,\n     * containing the index of the best reference for each cell.\n     */\n    predictedReferences({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.predictedLabels(), copy);\n    }\n\n    /**\n     * @param {number} i - Index of the cell of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfLabels numberOfLabels}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all references.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForCell(i, { copy = true, buffer = null } = {}) {\n        return this.#results.scoresForCell(i, { copy, buffer });\n    }\n\n    /**\n     * @param {number} i - Index of the reference of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     * Only used if `buffer` is not supplied.\n     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.\n     * This should have the same length as the {@linkcode LabelCellsResults#numberOfCells numberOfCells}.\n     *\n     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.\n     * If `buffer` is supplied, it is used as the return value.\n     */\n    scoresForReference(i, { copy = true, buffer = null } = {}) {\n        return this.#results.scoresForLabel(i, { copy, buffer });\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,\n     * containing the difference in scores between the best and second-best reference during fine-tuning.\n     */\n    fineTuningDelta({ copy = true } = {}) {\n        return utils.possibleCopy(this.#results.fineTuningDelta(), copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            this.#results.free();\n            this.#results = null;\n        }\n    }\n}\n\n/**\n * Integrate cell labels across multiple reference datasets.\n *\n * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.\n * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.\n * @param {IntegratedLabelledReferences} integrated - An integrated set of reference datasets, typically generated by {@linkcode integrateLabelledReferences}.\n * @param {Array} assigned - An array of length equal to the number of references in `integrated`.\n * This should contain the result of classification of `x` with each individual reference via {@linkcode labelCells}.\n * Each element should be a {@linkplain LabelCells} object; or an Array, TypedArray or Int32WasmArray of length equal to the number of cells in `x`.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.\n * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.\n * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {LabelCellsResults} Integrated labelling results for each cell in `x`.\n */\nexport function integrateCellLabels(x, assigned, integrated, { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) { \n    let nrefs = integrated.numberOfReferences();\n    if (assigned.length != nrefs) {\n        throw new Error(\"length of 'assigned' should be equal to the number of references in 'integrated'\");\n    }\n\n    let output;\n    let aptrs;\n    let assigned_arrs = new Array(nrefs);\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        aptrs = utils.createBigUint64WasmArray(nrefs);\n        let aptrs_arr = aptrs.array();\n        for (var i = 0; i < assigned.length; i++) {\n            let current = assigned[i];\n\n            if (current instanceof LabelCellsResults) {\n                current = current.predictedLabels({ copy: \"view\" });\n            }\n\n            let fail = false;\n            if (x instanceof ScranMatrix) {\n                if (current.length != x.numberOfColumns()) {\n                    fail = true;\n                }\n            } else if (current.length != numberOfCells) {\n                fail = true;\n            }\n            if (fail) {\n                throw new Error(\"length of each element in 'assigned' should be equal to number of columns in 'x'\");\n            }\n\n            assigned_arrs[i] = utils.wasmifyArray(current, \"Int32WasmArray\");\n            aptrs_arr[i] = BigInt(assigned_arrs[i].offset);\n        }\n    \n        let FUN = (target, ptr) => {\n            return gc.call(module => module.integrate_singlepp(target, aptrs_arr.offset, integrated.integrated, quantile, nthreads), LabelCellsResults);\n        };\n        output = label_cells(x, integrated.expectedNumberOfFeatures, numberOfFeatures, numberOfCells, FUN, \"integrated\");\n\n    } finally{\n        utils.free(aptrs);\n        for (const x of assigned_arrs) {\n            utils.free(x);\n        }\n    }\n\n    return new IntegrateCellLabelsResults(output);\n}\n","/**\n * Reindex the gene sets for a user-defined gene universe.\n * This is helpful for applications that know their own gene universe and want to convert the **gesel** gene IDs to indices within that universe.\n *\n * @param {Array} geneMapping - Array of length equal to the number of genes in a user-defined gene universe.\n * Each entry corresponds to one gene in the user's universe and should be an array containing the corresponding **gesel** gene ID(s) (see {@linkcode fetchAllGenes} for details).\n * @param {Array} genesForSets - Array of length equal to the number of reference gene sets.\n * Each entry corresponds to a set and is an array containing **gesel** gene IDs for all genes in that set.\n * This is typically obtained from {@linkcode fetchGenesForAllSets}.\n *\n * @return {Array} Array of length equal to `genesForSets`. \n * Each entry corresponds to a reference gene set and is a Uint32Array where the elements are indices into `geneMapping`, specifying the genes in the user's universe that belong to that set.\n * If a gene in `geneMapping` maps to multiple **gesel** IDs, it is considered to belong to all sets containing any of its mapped **gesel** gene IDs.\n */\nexport function reindexGenesForAllSets(geneMapping, genesForSets) {\n    let reverse_mapping = new Map;\n    for (var i = 0; i < geneMapping.length; i++) {\n        for (const gesel_gene of geneMapping[i]) {\n            let found = reverse_mapping.get(gesel_gene);\n            if (typeof found == \"undefined\") {\n                found = new Set;\n                reverse_mapping.set(gesel_gene, found);\n            }\n            found.add(i);\n        }\n    }\n\n    // Converting everything to an array for easier iteration. \n    for (const [k, v] of reverse_mapping) {\n        reverse_mapping[k] = new Uint32Array(v);\n    }\n\n    let new_sets = new Array(genesForSets.length);\n    for (var i = 0; i < genesForSets.length; i++) {\n        let subset = new Set;\n        for (const gesel_gene of genesForSets[i]) {\n            let found = reverse_mapping.get(gesel_gene);\n            if (typeof found !== \"undefined\") {\n                for (const gene of found) {\n                    subset.add(gene);\n                }\n            }\n        }\n        new_sets[i] = (new Uint32Array(subset)).sort();\n    }\n\n    return new_sets;\n}\n\n","import * as utils from \"./utils.js\";\n\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the set-to-gene mappings if they are not already available.\n * If `false`, `null` is returned if the set-to-gene mappings have not already been loaded into memory.\n *\n * @return {?Array} Array of length equal to the total number of sets for this `species`.\n * Each element corresponds to an entry in {@linkcode fetchAllSets} and is an array of integers containing the IDs for all genes belonging to that set.\n * Gene IDs refer to indices in {@linkcode fetchAllGenes}.\n *\n * If the set-to-gene mappings have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchGenesForAllSets(species, { download = true } = {}) {\n    let found = _cache.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    let res = await utils.reference_download(species + \"_set2gene.tsv.gz\");\n    if (!res.ok) {\n        throw new Error(\"failed to fetch full set-to-gene information for species '\" + species + \"'\");\n    }\n\n    var set_data = utils.decompressLines(await res.arrayBuffer());\n    let loaded = set_data.map(utils.convertToUint32Array);\n    _cache.set(species, loaded);\n    return loaded;\n}\n","import { fetchAllGenes } from \"./fetchAllGenes.js\";\n\nvar by_symbol = new Map;\nvar by_symbol_lower = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {string} type - Type of the identifier to use as the key of the map, e.g., `\"ensembl\"`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.lowerCase=false] - Whether to use lower-case keys in the map.\n *\n * @return {Map} Map where each key is a string containing a (possibly lower-cased) identifier of the specified `type` and each value is an array.\n * Each array contains the **gesel** gene IDs associated with the `type` identifier, see {@linkcode fetchAllGenes} for ore details.\n *\n * @async\n */\nexport async function mapGenesByIdentifier(species, type, { lowerCase = false } = {}) {\n    let host = (lowerCase ? by_symbol_lower : by_symbol);\n\n    let sfound = host.get(species);\n    if (typeof sfound === \"undefined\") {\n        sfound = new Map;\n        host.set(species, sfound);\n    }\n\n    let tfound = sfound.get(type);\n    if (typeof tfound === \"undefined\") {\n        tfound = new Map;\n        sfound.set(type, tfound);\n\n        let _genes = (await fetchAllGenes(species, { types: [ type ] })).get(type);\n        for (var i = 0; i < _genes.length; i++) {\n            for (let y of _genes[i]) {\n                if (lowerCase) {\n                    y = y.toLowerCase();\n                }\n\n                let current = tfound.get(y);\n                if (typeof current !== \"undefined\") {\n                    current.add(i);\n                } else {\n                    tfound.set(y, new Set([i]));\n                }\n            }\n        }\n\n        for (const [key, val] of tfound) {\n            tfound.set(key, Array.from(val));\n        }\n    }\n\n    return tfound;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./adt_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"adt_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered ADT matrix from the {@linkplain CellFilteringState}.\n * It wraps the [`groupedSizeFactors`](https://kanaverse.github.io/scran.js/global.html#groupedSizeFactors) \n * and [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtNormalizationState {\n    #qc;\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.AdtQualityControlState)) {\n            throw new Error(\"'qc' should be a AdtQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.total_buffer);\n        utils.freeCache(this.#cache.sf_buffer);\n        utils.freeCache(this.#cache.centered_sf_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"ADT\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing the normalized ADT values,\n     * available after running {@linkcode AdtNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the ADT-derived size factor for each cell in the (QC-filtered) dataset.\n     * This is available after running {@linkcode AdtNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sf_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sf_buffer.length, \"Float64Array\", this.#cache, \"centered_sf_buffer\");\n            scran.centerSizeFactors(this.#cache.sf_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"ADT\");\n        var block = this.#filter.fetchFilteredBlock();\n\n        var buffer = this.#cache.sf_buffer;\n        if (buffer.length != mat.numberOfColumns()) {\n            throw new Error(\"length of size factor vector should equal number of columns after QC\");\n        }\n\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.remove_bias - Whether to remove composition bias between cell subpopulations.\n     * This is done by clustering cells and computing median-based size factors between the average pseudo-cells for each cluster.\n     * Users can set this to `false` to speed up the compute.\n     * @param {number} parameters.num_pcs - Number of PCs to use for creating a low-dimensional embedding for clustering.\n     * Only used if `remove_bias = true`.\n     * @param {number} parameters.num_clusters - Number of clusters to create with k-means clustering.\n     * Only used if `remove_bias = true`.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        const { num_pcs, num_clusters } = parameters;\n        let remove_bias = true;\n        if (\"remove_bias\" in parameters) {\n            remove_bias = parameters.remove_bias;\n        }\n\n        this.changed = false;\n\n        if (this.#qc.changed || \n            this.#filter.changed || \n            remove_bias !== this.#parameters.remove_bias ||\n            (\n                remove_bias &&\n                (\n                    num_pcs !== this.#parameters.num_pcs || \n                    num_clusters != this.#parameters.num_clusters\n                ) \n            )\n        ) {\n            if (this.valid()) {\n                var mat = this.#filter.fetchFilteredMatrix().get(\"ADT\");\n                let total_buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"total_buffer\");\n                var block = this.#filter.fetchFilteredBlock();\n                var sf_buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", this.#cache, \"sf_buffer\");\n\n                if (remove_bias) {\n                    scran.quickAdtSizeFactors(mat, { \n                        totals: total_buffer, \n                        block: block, \n                        buffer: sf_buffer, \n                        numberOfPCs: num_pcs, \n                        numberOfClusters: num_clusters \n                    });\n                } else {\n                    scran.centerSizeFactors(total_buffer, { buffer: sf_buffer, block: block });\n                }\n\n                this.changed = true;\n            }\n\n        } \n\n        this.#parameters.remove_bias = remove_bias;\n        this.#parameters.num_pcs = num_pcs;\n        this.#parameters.num_clusters = num_clusters;\n\n        if (this.changed) {\n            if (this.valid()) {\n                this.#raw_compute();\n            }\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n           remove_bias: true,\n           num_pcs: 25,\n           num_clusters: 20\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    let cache = {};\n    let parameters = AdtNormalizationState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\");\n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.num_clusters = phandle.open(\"num_clusters\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n            \n            if (\"size_factors\" in rhandle.children) {\n                let sf = rhandle.open(\"size_factors\", { load: true }).values;\n                cache.sf_buffer = scran.createFloat64WasmArray(sf.length);\n                cache.sf_buffer.set(sf);\n            }\n\n            output = new AdtNormalizationState(qc, filter, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.sf_buffer);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        output = new AdtNormalizationState(qc, filter, parameters, cache);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\n\nexport function binarySearch(query, vector) {\n    let left = 0;\n    let right = vector.length;\n\n    while (left < right) {\n        let mid = Math.trunc((left + right) / 2);\n        if (vector[mid] < query) {\n            left = mid + 1;\n        } else if (vector[mid] > query) {\n            right = mid;\n        } else {\n            return mid;\n        }\n    }\n\n    return left;\n}\n\nasync function fetchSetsByToken(species, token, file, all_ranges, all_ordered, all_cache) {\n    let actual_file = species + \"_\" + file;\n\n    let cached = all_cache.get(species);\n    if (typeof cached === \"undefined\") {\n        const { ranges, order } = await utils.retrieveNamedRanges(actual_file);\n        all_ranges.set(species, ranges);\n        all_ordered.set(species, order);\n        cached = new Map;\n        all_cache.set(species, cached);\n    }\n\n    if (token == null) {\n        return;\n    }\n\n    let tfound = cached.get(token);\n    if (typeof tfound !== \"undefined\") {\n        return tfound;\n    }\n\n    let ranges = all_ranges.get(species);\n    let output;\n    if (token.includes(\"*\") || token.includes(\"?\")) {\n        let ordered = all_ordered.get(species);\n\n        // Wildcard handling.\n        let initstub = token.replace(/[*?].*/, \"\")\n        let pos = (initstub == \"\" ? 0 : binarySearch(initstub, ordered));\n        let regex = new RegExp(token.replace(/[*]/g, \".*\").replace(/[?]/g, \".\"));\n\n        let collected = [];\n        let to_cache = [];\n        let union = new Set;\n\n        while (pos < ordered.length) {\n            let candidate = ordered[pos];\n            if (initstub != \"\" && !candidate.startsWith(initstub)) {\n                break;\n            }\n\n            let cfound = cached.get(candidate);\n            if (typeof cfound === \"undefined\") {\n                let rr = ranges.get(candidate);\n                collected.push(utils.retrieveBytes(actual_file, rr[0], rr[1]).then(utils.convertToUint32Array));\n                to_cache.push(candidate);\n            } else {\n                for (const y of cfound) {\n                    union.add(y);\n                }\n            }\n\n            pos++;\n        }\n\n        let resolved = await Promise.all(collected);\n        for (var i = 0; i < resolved.length; i++) {\n            let x = resolved[i];\n            cached.set(to_cache[i], x);\n            for (const y of x) {\n                union.add(y);\n            }\n        }\n\n        output = new Uint32Array(union);\n\n    } else {\n        // Direct handling.\n        let rr = ranges.get(token);\n        if (typeof rr === \"undefined\") {\n            return new Uint32Array;\n        }\n        let text = await utils.retrieveBytes(actual_file, rr[0], rr[1]);\n        output = utils.convertToUint32Array(text);\n    }\n\n    cached.set(token, output);\n    return output;\n}\n\nconst n_cache = new Map;\nconst n_ranges = new Map;\nconst n_ordered = new Map;\n\nasync function fetchSetsByNameToken(species, token) {\n    return fetchSetsByToken(species, token, \"tokens-names.tsv\", n_ranges, n_ordered, n_cache);\n}\n\nconst d_cache = new Map;\nconst d_ranges = new Map;\nconst d_ordered = new Map;\n\nasync function fetchSetsByDescriptionToken(species, token) {\n    return fetchSetsByToken(species, token, \"tokens-descriptions.tsv\", d_ranges, d_ordered, d_cache);\n}\n\nexport async function preloadTokens(species, resp, ordered, cache, msg) {\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch full set of \" + msg + \" tokens for species '\" + species + \"'\");\n    }\n\n    let lines = utils.decompressLines(await resp.arrayBuffer());\n    if (lines.length !== ordered.length) {\n        throw new Error(\"mismatch in lengths between token names and set indices for species '\" + species + \"'\");\n    }\n\n    for (var i = 0; i < lines.length; i++) {\n        cache.set(ordered[i], utils.convertToUint32Array(lines[i]));\n    }\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n *\n * @return Preloads the search indices for use in {@linkcode searchSetText}.\n * This performs a one-off download of the indices such that further calls to {@linkcode searchSetText} do not need to perform HTTP range requests.\n */\nexport async function preloadSearchSetText(species) {\n    let full = await Promise.all([ \n        utils.reference_download(species + \"_tokens-names.tsv.gz\"),\n        utils.reference_download(species + \"_tokens-descriptions.tsv.gz\"),\n        fetchSetsByNameToken(species, null),\n        fetchSetsByDescriptionToken(species, null)\n    ]);\n    await preloadTokens(species, full[0], n_ordered.get(species), n_cache.get(species), \"name\");\n    await preloadTokens(species, full[1], d_ordered.get(species), d_cache.get(species), \"description\");\n    return;\n}\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {string} query - Query string containing multiple words to search in the names and/or descriptions of each set.\n *\n * Each stretch of alphanumeric characters and dashes is treated as a single word.\n * All other characters are treated as punctuation between words, except for the following wildcards:\n *\n * - `*`: match zero or more alphanumeric or dash characters.\n * - `?`: match exactly one alphanumeric or dash character.\n *\n * A set's name and/or description must contain all words in `query` to be considered a match.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inName=true] - Whether to search the name of the set for matching words.\n * @param {boolean} [options.inDescription=true] - Whether to search the description of the set for matching words.\n *\n * @return {Array} Array of indices of the sets with names and/or descriptions that match `query`.\n * @async\n */\nexport async function searchSetText(species, query, { inName = true, inDescription = true } = {}) {\n    // Tokenizing the query using the same logic as in the feedstock repository,\n    // but preserving our wildcards for special handling later.\n    let processed = query.toLowerCase().replace(/[^a-zA-Z0-9-?*]/g, \" \");\n    let tokens = processed.split(/\\s+/);\n    tokens = tokens.filter(x => x !== \"\" || x !== \"-\");\n\n    let init = [];\n    if (inName) {\n        init.push(fetchSetsByNameToken(species, null));\n    }\n    if (inDescription) {\n        init.push(fetchSetsByDescriptionToken(species, null));\n    }\n    await Promise.all(init); // force initialization of all caches.\n\n    let gathered_names = [];\n    if (inName) {\n        let already_queried = new Set;\n        for (const tok of tokens) {\n            if (!already_queried.has(tok)) {\n                gathered_names.push(fetchSetsByNameToken(species, tok));\n                already_queried.add(tok);\n            }\n        }\n    }\n\n    let gathered_descriptions = [];\n    if (inDescription) {\n        let already_queried = new Set;\n        for (const tok of tokens) {\n            if (!already_queried.has(tok)) {\n                gathered_descriptions.push(fetchSetsByDescriptionToken(species, tok));\n                already_queried.add(tok);\n            }\n        }\n    }\n\n    let resolved_names = await Promise.all(gathered_names);\n    let resolved_descriptions = await Promise.all(gathered_descriptions);\n\n    let gathered = [];\n    for (var i = 0; i < tokens.length; i++) {\n        let n = (inName ? resolved_names[i] : []);\n        let d = (inDescription ? resolved_descriptions[i] : []);\n\n        let combined = new Uint32Array(n.length + d.length);\n        combined.set(n);\n        combined.set(d, n.length);\n        gathered.push(combined);\n    }\n\n    return utils.intersect(gathered);\n}\n","import * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\nimport * as fac from \"./factorize.js\";\n\n/**\n * Create a blocking factor for a set of contiguous blocks, usually to accompany the output of {@linkcode cbind} on matrices representing different batches.\n * This can be used as the blocking factor in functions such as {@linkcode modelGeneVar} or {@linkcode scoreMarkers}.\n * Note that no protection is provided against empty blocks; if this is a possibility, use {@linkcode dropUnusedBlock} on the output of this function.\n *\n * @param {(Array|TypedArray)} ncells - Array of integers specifying the number of cells in each block.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {?Int32WasmArray} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to the sum of `ncells`.\n *\n * @return {Int32WasmArray} Array containing the blocking factor.\n * Each value specifies the block of origin for each cell.\n *\n * If `buffer` was supplied, it is used as the return value. \n */\nexport function createBlock(ncells, { buffer = null } = {}) {\n    let total = 0;\n    ncells.forEach(x => { total += x; });\n\n    let local_buffer;\n    try {\n        if (buffer == null) {\n            local_buffer = utils.createInt32WasmArray(total);\n            buffer = local_buffer;\n        } else if (buffer.length !== total) {\n            throw new Error(\"'buffer' should have length equal to sum of 'ncells'\");\n        }\n\n        let barr = buffer.array();\n        let sofar = 0;\n        for (var i = 0; i < ncells.length; i++) {\n            let old = sofar;\n            sofar += ncells[i];\n            barr.fill(i, old, sofar);\n        }\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n    }\n\n    return buffer;\n}\n\n// Soft-deprecated in favor of the more general convertToFactor().\nexport function convertBlock(x, { buffer = null } = {}) {\n    let output = fac.convertToFactor(x, { buffer, action: \"warn\", placeholder: 0 });\n    output.levels = output.levels.map(String);\n    return output;\n}\n\n// Soft-deprecated in favor of the more general subsetFactor(), or wasmarrays.js's subsetWasmArray, take your choice.\nexport function subsetBlock(x, subset, { filter = null, buffer = null } = {}) {\n    return wa.subsetWasmArray(x, subset, { filter, buffer });\n}\n\n// Soft-deprecated, just use subsetFactor().\nexport function filterBlock(x, filter, { buffer = null } = {}) {\n    return subsetBlock(x, filter, { buffer: buffer, filter: true });\n}\n\n// Soft-deprecated in favor of dropUnusedLevels().\nexport function dropUnusedBlock(x) {\n    return fac.dropUnusedLevels(x);\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as ir from \"./IRanges.js\";\nimport * as vec from \"./Vector.js\";\nimport * as olap from \"./overlap-utils.js\";\n\n/**\n * A GRanges object is a collection of genomic ranges, inspired by the class of the same name from the Bioconductor ecosystem.\n * Each range consists of a sequence name, a start position on that sequence, and a width.\n * Each range may also be associated with arbitrary range-level metadata in a {@linkplain DataFrame}.\n * The GRanges defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @extends Vector\n */\nexport class GRanges extends vec.Vector {\n    static #convertToInt8Array(x) {\n        if (x instanceof Int8Array) {\n            return x;\n        } else {\n            return new Int8Array(x);\n        }\n    }\n\n    static #checkStrandedness(strand) {\n        for (const y of strand) {\n            if (y < -1 || y > 1) {\n                throw new Error(\"'strand' must be -1, 0 or 1\");\n            }\n        }\n    }\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @param {IRanges} ranges - Position and width of the range on its specified sequence.\n     * This should have the same length as `seqnames`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.strand=null] - Array containing the strandedness of each genomic range.\n     * This should be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     * If `null`, this is assumed to be 0 for all genomic ranges.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each genomic range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(seqnames, ranges, { strand = null, names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(seqnames.length, { names, elementMetadata, metadata });\n\n        utils.checkStringArray(seqnames, \"seqnames\");\n        this._seqnames = seqnames;\n\n        let n = seqnames.length;\n        if (n !== generics.LENGTH(ranges)) {\n            throw utils.formatLengthError(\"'ranges'\", \"'seqnames'\");\n        }\n        this._ranges = ranges;\n\n        if (strand !== null) {\n            if (n !== strand.length) {\n                throw utils.formatLengthError(\"'strand'\", \"'seqnames'\");\n            }\n            strand = GRanges.#convertToInt8Array(strand);\n            GRanges.#checkStrandedness(strand);\n        } else {\n            strand = new Int8Array(n);\n            strand.fill(0);\n        }\n        this._strand = strand;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Int32Array} Array of integers containing the start position for each genomic range.\n     */\n    start() {\n        return this._ranges.start();\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the end position (specifically, one-past-the-end) for each genomic range.\n     */\n    end() {\n        return this._ranges.end();\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the width of each genomic range.\n     */\n    width() {\n        return this._ranges.width();\n    }\n\n    /**\n     * @return {Array} Array of strings containing the sequence name for each genomic range.\n     */\n    seqnames() {\n        return this._seqnames;\n    }\n\n    /**\n     * @return {IRanges} Start positions and widths for all ranges on their specified sequence names.\n     */\n    ranges() {\n        return this._ranges;\n    }\n\n    /**\n     * @return {Int8Array} Array containing the strandedness for each genomic range - 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     */\n    strand() {\n        return this._strand;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the sequence names to `seqnames`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setSeqnames(seqnames, { inPlace = false } = {}) {\n        utils.checkNamesArray(seqnames, \"replacement 'seqnames'\", generics.LENGTH(this), \"'LENGTH(<GRanges>)'\");\n        let target = cutils.setterTarget(this, inPlace); \n        target._seqnames = seqnames;\n        return target;\n    }\n\n    /**\n     * @param {Array} seqnames - Array of strings containing the sequence names for each genomic range.\n     * @return {GRanges} A reference to this GRanges object after setting the sequence names to `seqnames`.\n     */\n    $setSeqnames(seqnames) {\n        return this.setSeqnames(seqnames, { inPlace: true });\n    }\n\n    /**\n     * @param {IRanges} ranges - Start positions and widths for each genomic range.\n     * This should have length equal to the number of ranges. \n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the ranges to `ranges`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRanges(ranges, { inPlace = false } = {}) {\n        if (!(ranges instanceof ir.IRanges)) {\n            throw new Error(\"'ranges' should be an IRanges object\");\n        }\n\n        if (generics.LENGTH(ranges) !== generics.LENGTH(this._ranges)) {\n            throw utils.formatLengthError(\"replacement 'ranges'\", \"'LENGTH(<GRanges>)'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace); \n        target._ranges = ranges;\n        return target;\n    }\n\n    /**\n     * @param {IRanges} ranges - Start positions and widths for each genomic range.\n     * This should have length equal to the number of ranges. \n     * @return {GRanges} A reference to this GRanges object after setting the ranges to `ranges`.\n     */\n    $setRanges(ranges) {\n        return this.setRanges(ranges, { inPlace: true });\n    }\n\n    /**\n     * @param {Array|TypedArray} strand - Array of strands for each genomic range.\n     * This should have length equal to the number of ranges. \n     * Entries may be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GRanges} The GRanges object after setting the strands to `strand`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setStrand(strand, { inPlace = false } = {}) {\n        if (this._strand.length !== strand.length) {\n            throw utils.formatLengthError(\"'strand'\", \"'seqnames'\");\n        }\n        strand = GRanges.#convertToInt8Array(strand);\n        GRanges.#checkStrandedness(strand);\n\n        let target = cutils.setterTarget(this, inPlace); \n        target._strand = strand;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} strand - Array of strands for each genomic range.\n     * This should have length equal to the number of ranges. \n     * Entries may be 0 (any strand), 1 (forward strand) or -1 (reverse strand).\n     *\n     * @return {GRanges} A reference to this GRanges object after setting the strands to `strand`.\n     */\n    $setStrand(strand) {\n        return this.setStrand(strand, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|Set)} [options.restrictToSeqnames=null] - Array or Set containing the sequence names to use in the index.\n     * If `null`, all available sequence names are used.\n     * @param {?(Array|Set)} [options.restrictToStrand=null] - Array or Set containing the strands to use in the index.\n     * If `null`, all available strands are used.\n     *\n     * @return {GRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain GRanges} instances.\n     */\n    buildOverlapIndex({ restrictToSeqnames = null, restrictToStrand = null } = {}) {\n        let indices = utils.createSequence(generics.LENGTH(this));\n        let by_seqname = generics.SPLIT(indices, this._seqnames);\n        let starts = this.start();\n        let ends = this.end();\n\n        if (restrictToSeqnames !== null && restrictToSeqnames instanceof Array) {\n            restrictToSeqnames = new Set(restrictToSeqnames);\n        }\n        if (restrictToStrand !== null && restrictToStrand instanceof Array) {\n            restrictToStrand = new Set(restrictToStrand);\n        }\n\n        for (const name of Object.keys(by_seqname)) {\n            if (restrictToSeqnames !== null && !restrictToSeqnames.has(name)) {\n                delete by_seqname[name];\n                continue;\n            }\n            let seqname_indices = by_seqname[name];\n            let seqname_strand = generics.SLICE(this._strand, seqname_indices);\n            let by_strand = generics.SPLIT(seqname_indices, seqname_strand);\n\n            for (const str of Object.keys(by_strand)) {\n                if (restrictToStrand !== null && !restrictToStrand.has(Number(str))) {\n                    delete by_strand[str];\n                    continue;\n                }\n                let str_indices = by_strand[str];\n                by_strand[str] = olap.buildIntervalTree(starts, ends, { slice: str_indices });\n            }\n            by_seqname[name] = by_strand;\n        }\n\n        return new GRangesOverlapIndex(by_seqname);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._seqnames.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        output._seqnames = generics.SLICE(this._seqnames, i, { allowView });\n        output._ranges = generics.SLICE(this._ranges, i, { allowView });\n        output._strand = generics.SLICE(this._strand, i, { allowView });\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        let all_sn = [];\n        let all_rr = [];\n        let all_st = [];\n        for (const x of objects) {\n            all_sn.push(x._seqnames);\n            all_rr.push(x._ranges);\n            all_st.push(x._strand);\n        }\n\n        output._seqnames = generics.COMBINE(all_sn);\n        output._ranges = generics.COMBINE(all_rr);\n        output._strand = generics.COMBINE(all_st);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._seqnames = cutils.cloneField(this._seqnames, deepCopy);\n        output._ranges = cutils.cloneField(this._ranges, deepCopy);\n        output._strand = cutils.cloneField(this._strand, deepCopy);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} A zero-length GRanges object.\n     */\n    static empty() {\n        return new GRanges([], ir.IRanges.empty());\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain GRanges} objects.\n * This is typically constructed using the {@linkcode GRanges#buildOverlapIndex GRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query GRanges to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class GRangesOverlapIndex {\n    constructor(index) {\n        this._index = index;\n    }\n\n    /**\n     * @param {GRanges} query - The query object, containing ranges to be overlapped with those in the reference GRanges (that was used to construct this GRangesOverlapIndex object).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.ignoreStrand=true] - Whether to ignore differences in strandedness between the ranges in `query` and the reference object.\n     *\n     * @return {Array} An array of length equal to the number of ranges in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain GRanges} object.\n     */\n    overlap(query, { ignoreStrand = true } = {}) {\n        let n = generics.LENGTH(query);\n        let results = new Array(n);\n        let starts = query.start();\n        let ends = query.end();\n\n        for (var i = 0; i < n; i++) {\n            results[i] = [];\n            let my_results = results[i];\n\n            let name = query._seqnames[i];\n            if (!(name in this._index)) {\n                continue;\n            }\n            let seq_index = this._index[name];\n\n            let strand = query._strand[i];\n            let allowed_strands;\n            if (ignoreStrand || strand == 0) {\n                allowed_strands = Object.keys(seq_index);\n            } else {\n                let sstr = String(strand);\n                if (!(sstr in seq_index)) {\n                    continue;\n                }\n                allowed_strands = [ sstr ];\n            }\n\n            let start = starts[i];\n            let end = ends[i];\n            for (const str of allowed_strands) {\n                let str_results = olap.queryIntervalTree(start, end, seq_index[str]);\n                str_results.forEach(x => my_results.push(x));\n            }\n        }\n\n        return results;\n    }\n}\n","import * as scran from \"scran.js\";\n\nexport const summaries2int = { \"min\": 0, \"mean\": 1, \"min_rank\": 4 };\n\nexport function unserializeGroupStats(handle, permuter, { no_summaries = false, compute_auc = true } = {}) {\n    let output = {};\n    for (const x of [ \"means\", \"detected\" ]) {\n        output[x] = permuter(handle.open(x, { load: true }).values);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        if (i == \"auc\" && !compute_auc) {\n            continue;\n        }\n\n        if (no_summaries) {\n            output[i] = handle.open(i, { load: true }).values;\n        } else {\n            let rhandle = handle.open(i);\n            let current = {};\n            for (const j of Object.keys(rhandle.children)) {\n                current[j] = permuter(rhandle.open(j, { load: true }).values);\n            }\n            output[i] = current;\n        }\n    }\n\n    return output;\n}\n\nexport function fillGroupStats(object, i, vals) {\n    object.means(i, { copy: false }).set(vals.means);\n    object.detected(i, { copy: false }).set(vals.detected);\n\n    for (const [s, v] of Object.entries(vals.cohen)) {\n        object.cohen(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    for (const [s, v] of Object.entries(vals.lfc)) {\n        object.lfc(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    for (const [s, v] of Object.entries(vals.delta_detected)) {\n        object.deltaDetected(i, { summary: summaries2int[s], copy: false }).set(v);\n    }\n\n    if (\"auc\" in vals) {\n        for (const [s, v] of Object.entries(vals.auc)) {\n            object.auc(i, { summary: summaries2int[s], copy: false }).set(v);\n        }\n    }\n}\n\n/**\n * Report marker results for a given group or cluster, ordered so that the strongest candidate markers appear first.\n *\n * @param {ScoreMarkersResults} results - The marker results object generated by the `scoreMarkers` function in **scran.js**.\n * @param {number} group - Integer specifying the group or cluster of interest.\n * Any number can be used if it was part of the `groups` passed to `scoreMarkers`.\n * @param {string} rankEffect - Summarized effect size to use for ranking markers.\n * This should follow the format of `<effect>-<summary>` where `<effect>` may be `lfc`, `cohen`, `auc` or `delta_detected`,\n * and `<summary>` may be `min`, `mean` or `min-rank`.\n *\n * @return An object containing the marker statistics for the selection, sorted by the specified effect and summary size from `rankEffect`.\n * This contains:\n *   - `means`: a Float64Array of length equal to the number of genes, containing the mean expression within the selection.\n *   - `detected`: a Float64Array of length equal to the number of genes, containing the proportion of cells with detected expression inside the selection.\n *   - `lfc`: a Float64Array of length equal to the number of genes, containing the log-fold changes for the comparison between cells inside and outside the selection.\n *   - `delta_detected`: a Float64Array of length equal to the number of genes, containing the difference in the detected proportions between cells inside and outside the selection.\n */\nexport function formatMarkerResults(results, group, rankEffect) {\n    if (!rankEffect || rankEffect === undefined) {\n        rankEffect = \"cohen-min-rank\";\n    }\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        let index = 1;\n        if (rankEffect.match(/-min$/)) {\n            index = 0;\n        } else if (rankEffect.match(/-min-rank$/)) {\n            increasing = true;\n            index = 4;\n        }\n\n        if (rankEffect.match(/^cohen-/)) {\n            ranking = results.cohen(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^auc-/)) {\n            ranking = results.auc(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^lfc-/)) {\n            ranking = results.lfc(group, { summary: index, copy: false });\n        } else if (rankEffect.match(/^delta-d-/)) {\n            ranking = results.deltaDetected(group, { summary: index, copy: false });\n        } else {\n            throw \"unknown rank type '\" + rankEffect + \"'\";\n        }\n  \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected = reorder(results.detected(group, { copy: false }));\n    var stat_mean = reorder(results.means(group, { copy: false }));\n    var stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n    var stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n\n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n\nexport function locateVersusCache(left, right, cache) {\n    let left_small = left < right;\n\n    let bigg = (left_small ? right : left);\n    if (!(bigg in cache)) {\n        cache[bigg] = {};\n    }\n    let biggversus = cache[bigg];\n\n    let smal = (left_small ? left : right); \n    let rerun = !(smal in biggversus);\n    if (rerun) {\n        biggversus[smal] = {};\n    }\n\n    return { \n        cached: biggversus[smal],\n        run: rerun,\n        left_small: left_small\n    };\n}\n\nexport function freeVersusResults(cache) {\n    if (cache) {\n        for (const v of Object.values(cache)) {\n            for (const v2 of Object.values(v)) {\n                for (const m of Object.values(v2)) {\n                    scran.free(m);\n                }\n            }\n        }\n        for (const k of Object.keys(cache)) {\n            delete cache[k];\n        }\n    }\n}\n\nexport function computeVersusResults(matrices, clusters, block, keep, cache, lfc_threshold, compute_auc) {\n    let new_block = null;\n    if (block !== null) {\n        new_block = scran.subsetBlock(block, keep);\n        scran.dropUnusedBlock(new_block);\n    }\n\n    for (const modality of matrices.available()) {\n        let modmat = matrices.get(modality);\n        let sub;\n        try {\n            sub = scran.subsetColumns(modmat, keep);\n            cache[modality] = scran.scoreMarkers(sub, clusters, { block: new_block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n        } finally {\n            scran.free(sub);\n        }\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { FindNearestNeighborsResults, findNearestNeighbors } from \"./findNearestNeighbors.js\";\n\n/**\n * Wrapper around the SNN graph object on the Wasm heap, produced by {@linkcode buildSNNGraph}.\n * @hideconstructor\n */\nexport class BuildSNNGraphResults {\n    #id;\n    #graph;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#graph = raw;\n        return;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#graph !== null) {\n            gc.release(this.#id);\n            this.#graph = null;\n        }\n        return;\n    }\n\n    // Not documented, internal use only.\n    get graph() {\n        return this.#graph;\n    }\n}\n\n/**\n * Build a shared nearest graph.\n *\n * @param {(BuildNeighborSearchIndexResults|FindNearestNeighborsResults)} x \n * Either a pre-built neighbor search index for the dataset (see {@linkcode buildNeighborSearchIndex}),\n * or a pre-computed set of neighbor search results for all cells (see {@linkcode findNearestNeighbors}).\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.scheme=\"rank\"] - Weighting scheme for the edges between cells.\n * This can be based on the top ranks of the shared neighbors (`\"rank\"`),\n * the number of shared neighbors (`\"number\"`) \n * or the Jaccard index of the neighbor sets between cells (`\"jaccard\"`).\n * @param {number} [options.neighbors=10] - Number of nearest neighbors to use to construct the graph.\n * Ignored if `x` is a {@linkplain FindNearestNeighborsResults} object.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {BuildSNNGraphResults} Object containing the graph.\n */\nexport function buildSNNGraph(x, { scheme = \"rank\", neighbors = 10, numberOfThreads = null } = {}) {\n    var output;\n    var my_neighbors;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    utils.matchOptions(\"scheme\", scheme, [ \"rank\", \"number\", \"jaccard\" ]);\n\n    try {\n        let ref;\n        if (x instanceof FindNearestNeighborsResults) {\n            ref = x;\n        } else {\n            my_neighbors = findNearestNeighbors(x, neighbors, { numberOfThreads: nthreads }); \n            ref = my_neighbors ; // separate assignment is necessary for only 'my_neighbors' but not 'x' to be freed.\n        }\n\n        output = gc.call(\n            module => module.build_snn_graph(ref.results, scheme, nthreads),\n            BuildSNNGraphResults\n        );\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(my_neighbors);\n    }\n\n    return output;\n}\n\n/**\n * Wrapper around the SNN multi-level clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphMultiLevelResults {\n    #id;\n    #results;\n\n    #filledBest;\n    #filledModularity;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledBest = filled;\n        this.#filledModularity = utils.spawnArray(this.numberOfLevels(), filled);\n        this.#filledMembership = utils.spawnArray(this.numberOfLevels(), filled);\n\n        return;\n    }\n\n    /**\n     * @return {?number} The clustering level with the highest modularity.\n     * Alternatively `null`, if this has not been previously set via {@linkcode ClusterSNNGraphMultiLevelResults#setBest setBest}.\n     */\n    best() {\n        if (!this.#filledBest) {\n            return null;\n        } else {\n            return this.#results.best();\n        }\n    }\n\n    #chooseLevel(level) {\n        if (level === null) {\n            level = this.best();\n            if (level == null) {\n                throw new Error(\"'best' has not yet been set via 'setBest'\");\n            }\n        }\n        return level;\n    }\n\n    /**\n     * @param {number} best - Clustering level with the highest modularity.\n     * @return `best` is set as the best clustering level.\n     * This is typically only used after {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setBest(best) {\n        if (!this.#filledBest) {\n            this.#filledBest = true;\n        }\n        this.#results.set_best(best);\n        return;\n    }\n\n    /**\n     * @return {number} Number of levels in the results.\n     */\n    numberOfLevels() {\n        return this.#results.number();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.level=null] - The clustering level for which to obtain the modularity.\n     * Defaults to the best clustering level from {@linkcode ClusterSNNGraphMultiLevelResults#best best}.\n     *\n     * @return {?number} The modularity at the specified level.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphMultiLevelResults#setModularity setModularity}.\n     */\n    modularity({ level = null } = {}) {\n        level = this.#chooseLevel(level);\n        if (!this.#filledModularity[level]) {\n            return null;\n        } else {\n            return this.#results.modularity(level);\n        }\n    }\n\n    /**\n     * @param {number} level - The clustering level at which to set the modularity.\n     * @param {number} modularity - Modularity value.\n     *\n     * @return `modularity` is set as the modularity at the specified level.\n     * This is typically only used after {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(level, modularity) {\n        if (!this.#filledModularity[level]) {\n            this.#filledModularity[level] = true;\n        }\n        this.#results.set_modularity(level, modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.level=null] - The clustering level for which to obtain the cluster membership.\n     * Defaults to the best clustering level from {@linkcode ClusterSNNGraphMultiLevelResults#best best}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ level = null, copy = true, fillable = false } = {}) {\n        level = this.#chooseLevel(level);\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership[level], \n            () => { this.#filledMembership[level] = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(level), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Wrapper around the SNN walktrap clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphWalktrapResults {\n    #id;\n    #results;\n\n    #filledModularity;\n    #filledModularityDetails;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledModularity = filled;\n        this.#filledMembership = filled;\n        if (!filled) {\n            let n = this.numberOfMergeSteps() + 1;\n            this.#filledModularityDetails = { which: utils.spawnArray(n, false), remaining: n };\n        }\n\n        return;\n    }\n\n    /**\n     * @return {number} Number of merge steps used by the Walktrap algorithm.\n     */\n    numberOfMergeSteps() {\n        return this.#results.num_merge_steps();\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.at=null] - Index at which to extract the modularity.\n     * This can be any value from 0 to {@linkcode ClusterSNNGraphWalktrapResults#numberOfMergeSteps numberOfMergeSteps} plus 1.\n     * Set to `null` to obtain the largest modularity across all merge steps.\n     *\n     * @return {?number} The modularity at the specified merge step, or the maximum modularity across all merge steps.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphWalktrapResults#setModularity setModularity}.\n     */\n    modularity({ at = null } = {}) {\n        let fail = false;\n        if (at === null) {\n            if (!this.#filledModularity) {\n                return null;\n            }\n            at = -1;\n        } else if (!this.#filledModularity && !this.#filledModularityDetails[at]) {\n            return null;\n        }\n\n        return this.#results.modularity(at);\n    }\n\n    /**\n     * @param {number} at - Index at which to set the modularity.\n     * This can be any value from 0 to {@linkcode ClusterSNNGraphWalktrapResults#numberOfMergeSteps numberOfMergeSteps} plus 1.\n     * @param {number} modularity - Modularity value.\n     *\n     * @return Modularity value is set in this object.\n     * This is typically used after calling {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(at, modularity) {\n        if (!this.#filledModularity) {\n            this.#filledModularityDetails.which[at] = true;\n            this.#filledModularityDetails.remaining--;\n            if (this.#filledModularityDetails.remaining == 0) {\n                this.#filledModularity = true;\n            }\n        }\n        this.#results.set_modularity(at, modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership, \n            () => { this.#filledMembership = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Wrapper around the SNN Leiden clustering results on the Wasm heap, produced by {@linkcode clusterSNNGraph}.\n * @hideconstructor\n */\nexport class ClusterSNNGraphLeidenResults {\n    #id;\n    #results;\n\n    #filledModularity;\n    #filledMembership;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledModularity = filled;\n        this.#filledMembership = filled;\n        return;\n    }\n\n    /**\n     * @return {?number} The quality of the Leiden clustering.\n     * Alternatively `null`, if this has not been set by {@linkcode ClusterSNNGraphLeidenResults#setModularity setModularity}.\n     *\n     * Note that Leiden's quality score is technically a different measure from modularity.\n     * Nonetheless, we use `modularity` for consistency with the other SNN clustering result classes.\n     */\n    modularity() {\n        if (!this.#filledModularity) {\n            return null;\n        } else {\n            return this.#results.modularity();\n        }\n    }\n\n    /**\n     * @param {number} modularity - Modularity value.\n     * @return Modularity value is set in this object.\n     * This is typically used after calling {@linkcode emptyClusterSNNGraphResults}.\n     */\n    setModularity(modularity) {\n        if (!this.#filledModularity) {\n            this.#filledModularity = true;\n        }\n        this.#results.set_modularity(modularity);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster membership for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    membership({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledMembership, \n            () => { this.#filledMembership = true; }, \n            COPY => utils.possibleCopy(this.#results.membership(), COPY)\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Cluster cells using community detection on the SNN graph.\n *\n * @param {BuildSNNGraphResults} x - The shared nearest neighbor graph constructed by {@linkcode buildSNNGraph}.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.method=\"multilevel\"] - Community detection method to use.\n * This should be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n * @param {number} [options.multiLevelResolution=1] - The resolution of the multi-level clustering, when `method = \"multilevel\"`.\n * Larger values result in more fine-grained clusters.\n * @param {number} [options.leidenResolution=1] - The resolution of the Leiden clustering, when `method = \"leiden\"`.\n * Larger values result in more fine-grained clusters.\n * @param {boolean} [options.leidenModularityObjective=false] - Whether to use the modularity as the objective function when `method = \"leiden\"`.\n * By default, the Constant-Potts Model is used instead.\n * Set to `true` to get an interpretation of the resolution on par with that of `method = \"multilevel\"`.\n * @param {number} [options.walktrapSteps=4] - Number of steps for the Walktrap algorithm, when `method = \"walktrap\"`.\n *\n * @return {ClusterSNNGraphMultiLevelResults|ClusterSNNGraphWalktrapResults|ClusterSNNGraphLeidenResults} Object containing the clustering results.\n * The class of this object depends on the choice of `method`.\n */\nexport function clusterSNNGraph(x, { \n    method = \"multilevel\", \n    multiLevelResolution = 1, \n    leidenResolution = 1, \n    leidenModularityObjective = false,\n    walktrapSteps = 4\n} = {}) {\n    var output;\n\n    try {\n        if (method == \"multilevel\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_multilevel(x.graph, multiLevelResolution),\n                ClusterSNNGraphMultiLevelResults\n            );\n        } else if (method == \"walktrap\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_walktrap(x.graph, walktrapSteps),\n                ClusterSNNGraphWalktrapResults\n            );\n        } else if (method == \"leiden\") {\n            output = gc.call(\n                module => module.cluster_snn_graph_leiden(x.graph, leidenResolution, leidenModularityObjective),\n                ClusterSNNGraphLeidenResults\n            );\n        } else {\n            throw new Error(\"unknown method '\" + method + \"'\")\n        }\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ClusterSNNGraphMultiLevelResults} object (or one of its counterparts), to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.method=\"multilevel\"] - Community detection method to use.\n * This should be one of `\"multilevel\"`, `\"walktrap\"` or `\"leiden\"`.\n * @param {number} [options.numberOfLevels=1] - Number of levels for which to allocate space when `method=\"multilevel\"`.\n * @param {number} [options.numberOfMergeSteps=1] - Number of merge steps for which to allocate space when `method=\"walktrap\"`.\n *\n * @return {ClusterSNNGraphMultiLevelResults|ClusterSNNGraphWalktrapResults|ClusterSNNGraphLeidenResults} \n * Object with space allocated to store the clustering results.\n */\nexport function emptyClusterSNNGraphResults(numberOfCells, { method = \"multilevel\", numberOfLevels = 1, numberOfMergeSteps = 1 } = {}) {\n    if (method == \"multilevel\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphMultiLevel_Result(numberOfCells, numberOfLevels),\n            ClusterSNNGraphMultiLevelResults,\n            /* filled = */ false\n        );\n    } else if (method == \"walktrap\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphWalktrap_Result(numberOfCells, numberOfMergeSteps),\n            ClusterSNNGraphWalktrapResults,\n            /* filled = */ false\n        );\n    } else if (method == \"leiden\") {\n        return gc.call(\n            module => new module.ClusterSNNGraphLeiden_Result(numberOfCells),\n            ClusterSNNGraphLeidenResults,\n            /* filled = */ false\n        );\n    } else {\n        throw new Error(\"unknown method '\" + method + \"'\")\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/** \n * Wrapper for the PCA results on the Wasm heap, typically created by {@linkcode runPCA}.\n * @hideconstructor\n */\nexport class RunPCAResults {\n    #id;\n    #results;\n\n    #filledComponents;\n    #filledVariances;\n    #filledTotalVariance;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledComponents = filled;\n        this.#filledVariances = filled;\n        this.#filledTotalVariance = filled;\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     * \n     * @return {?(Float64Array|Float64Wasmarray)} Array containing the principal components for all cells.\n     * This should be treated as a column-major array where the rows are the PCs and columns are the cells.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    principalComponents({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledComponents, \n            () => { this.#filledComponents = true }, \n            COPY => utils.possibleCopy(this.#results.pcs(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} total - Total variance in the dataset,\n     * equal to the sum of the variances across all PCs (including those that were not explicitly computed).\n     *\n     * @return Total varaiance in this object is set to `total`.\n     * This is primarily intended for use with {@linkcode emptyRunPCAResults}.\n     */\n    setTotalVariance(total) {\n        if (!this.#filledTotalVariance) {\n            this.#filledTotalVariance = true;\n        }\n        this.#results.set_total_variance(total);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     * \n     * @return {?(Float64Array|Float64WasmArray)} Array containing the variance explained for each requested PC.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    varianceExplained({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledVariances, \n            () => { this.#filledVariances = true }, \n            COPY => utils.possibleCopy(this.#results.variance_explained(), COPY)\n        );\n    }\n\n    /**\n     * @return {?number} The total variance in the dataset,\n     * typically used with {@linkcode PCAResults#varianceExplained varianceExplained} to compute the proportion of variance explained.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setTotalVariance setTotalVariance}.\n     */\n    totalVariance() {\n        if (!this.#filledTotalVariance) {\n            return null;\n        } else {\n            return this.#results.total_variance();\n        }\n    }\n\n    /**\n     * @return {number} Number of PCs available in these results.\n     */\n    numberOfPCs() {\n        return this.#results.num_pcs();\n    }\n\n    /**\n     * @return {number} Number of cells used to compute these results.\n     */\n    numberOfCells() {\n        // TODO: switch to this.#results.num_cells();\n        return this.principalComponents({ copy: false }).length / this.numberOfPCs();\n\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Run a principal components analysis on the log-expression matrix.\n * This is usually done on a subset of features, and possibly with some kind of blocking on a per-cell batch factor.\n *\n * @param {ScranMatrix} x - The log-normalized expression matrix.\n * @param {object} [options={}] - Optional parameters. \n * @param {?(Uint8WasmArray|Array|TypedArray)} [options.features=null] - Array specifying which features should be retained (e.g., HVGs).\n * This should be of length equal to the number of rows in `x`; elements should be `true` to retain each row.\n * If `null`, all features are retained.\n * @param {number} [options.numberOfPCs=25] - Number of top principal components to compute.\n * @param {boolean} [options.scale=false] - Whether to scale each feature to unit variance.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {string} [options.blockMethod=\"regress\"] - How to modify the PCA for the blocking factor.\n *\n * - `\"regress\"` will regress out the factor, effectively performing a PCA on the residuals.\n * - `\"weight\"` will weight the contribution of each blocking level equally so that larger blocks do not dominate the PCA.\n * - `\"none\"` will ignore any blocking factor, i.e., as if `block = null`.\n *\n * This option is only used if `block` is not `null`.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {RunPCAResults} Object containing the computed PCs.\n */\nexport function runPCA(x, { features = null, numberOfPCs = 25, scale = false, block = null, blockMethod = \"regress\", numberOfThreads = null } = {}) {\n    var feat_data;\n    var block_data;\n    var output;\n\n    utils.matchOptions(\"blockMethod\", blockMethod, [\"none\", \"regress\", \"weight\" ]);\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        var use_feat = false;\n        var fptr = 0;\n\n        if (features !== null) {\n            feat_data = utils.wasmifyArray(features, \"Uint8WasmArray\");\n            if (feat_data.length != x.numberOfRows()) {\n                throw new Error(\"length of 'features' should be equal to number of rows in 'x'\");\n            }\n            use_feat = true;\n            fptr = feat_data.offset;\n        }\n\n        // Avoid asking for more PCs than is possible.\n        // Remember that centering removes one df, so we subtract 1 from the dimensions.\n        numberOfPCs = Math.min(numberOfPCs, x.numberOfRows() - 1, x.numberOfColumns() - 1);\n\n        if (block === null || blockMethod == 'none') {\n            output = gc.call(\n                module => module.run_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, nthreads),\n                RunPCAResults\n            );\n\n        } else {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"length of 'block' should be equal to the number of columns in 'x'\");\n            }\n            if (blockMethod == \"regress\") {\n                output = gc.call(\n                    module => module.run_blocked_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, block_data.offset, nthreads),\n                    RunPCAResults\n                );\n            } else if (blockMethod == \"weight\") {\n                output = gc.call(\n                    module => module.run_multibatch_pca(x.matrix, numberOfPCs, use_feat, fptr, scale, block_data.offset, nthreads),\n                    RunPCAResults\n                );\n            } else {\n                throw new Error(\"unknown value '\" + blockMethod + \"' for 'blockMethod='\");\n            }\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(feat_data);\n        utils.free(block_data);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain RunPCAResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode clusterKmeans} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset, usually after QC filtering.\n * @param {number} numberOfPCs - Number of PCs to be computed.\n *\n * @return {RunPCAResults} Object with allocated memory to store the PCs, but no actual values.\n */\nexport function emptyRunPCAResults(numberOfCells, numberOfPCs) {\n    return gc.call(\n        module => new module.RunPCA_Results(numberOfCells, numberOfPCs),\n        RunPCAResults,\n        /* filled = */ false\n    );\n}\n","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  // check if a range is taken\n  var colorRanges = [];\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n      // Value false at index i means the range i is not taken yet.\n      for (var i = 0; i < options.count; i++) {\n        colorRanges.push(false)\n        }\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        var color = randomColor(options);\n\n        if (seed !== null) {\n          options.seed = seed;\n        }\n\n        colors.push(color);\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue(options) {\n    if (colorRanges.length > 0) {\n      var hueRange = getRealHueRange(options.hue)\n\n      var hue = randomWithin(hueRange)\n\n      //Each of colorRanges.length ranges has a length equal approximatelly one step\n      var step = (hueRange[1] - hueRange[0]) / colorRanges.length\n\n      var j = parseInt((hue - hueRange[0]) / step)\n\n      //Check if the range j is taken\n      if (colorRanges[j] === true) {\n        j = (j + 2) % colorRanges.length\n      }\n      else {\n        colorRanges[j] = true\n           }\n\n      var min = (hueRange[0] + j * step) % 359,\n          max = (hueRange[0] + (j + 1) * step) % 359;\n\n      hueRange = [min, max]\n\n      hue = randomWithin(hueRange)\n\n      if (hue < 0) {hue = 360 + hue;}\n      return hue\n    }\n    else {\n      var hueRange = getHueRange(options.hue)\n\n      hue = randomWithin(hueRange);\n      // Instead of storing red as two seperate ranges,\n      // we group them, using negative numbers\n      if (hue < 0) {\n        hue = 360 + hue;\n      }\n\n      return hue;\n    }\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n      var golden_ratio = 0.618033988749895\n      var r=Math.random()\n      r += golden_ratio\n      r %= 1\n      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n}\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [18,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [46,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [62,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [178, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [257, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [282, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  // get The range of given hue when options.count!=0\n  function getRealHueRange(colorHue)\n  { if (!isNaN(colorHue)) {\n    var number = parseInt(colorHue);\n\n    if (number < 360 && number > 0) {\n      return getColorInfo(colorHue).hueRange\n    }\n  }\n    else if (typeof colorHue === 'string') {\n\n      if (colorDictionary[colorHue]) {\n        var color = colorDictionary[colorHue];\n\n        if (color.hueRange) {\n          return color.hueRange\n       }\n    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorHue)[0]\n        return getColorInfo(hue).hueRange\n    }\n  }\n\n    return [0,360]\n}\n  return randomColor;\n}));\n","import { gene_download, decompressLines } from \"./utils.js\";\n\nvar _genes = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {?Array} [options.types=null] - Array of strings specifying the identifier types to be retrieved.\n * The exact choice of strings depends on how the references were constructed.\n * If `null`, it defaults to an array containing `\"symbol\"`, `\"entrez\"` and `\"ensembl\"`.\n *\n * @return {Map} Object where each key is named after an identifier type in `types`.\n * Each value is an array where each element corresponds to a gene and is itself an array of strings containing all identifiers of the current type for that gene.\n *\n * The arrays for different identifier types are all of the same length, and corresponding elements across these arrays describe the same gene.\n * **gesel**'s identifier for each gene (i.e., the \"gene ID\") is defined as the index of that gene in any of these arrays.\n *\n * @async\n */\nexport async function fetchAllGenes(species, { types = null } = {}) {\n    if (types == null) {\n        types = [ \"symbol\", \"entrez\", \"ensembl\" ];\n    }\n\n    let target = _genes.get(species);\n    if (typeof target == \"undefined\") {\n        target = new Map;\n        _genes.set(species, target);\n    }\n\n    let output = new Map;\n    let promises = [];\n    let processing = [];\n\n    for (const t of types) {\n        let found = target.get(t);\n        if (typeof found == \"undefined\") {\n            promises.push(gene_download(species + \"_\" + t + \".tsv.gz\"));\n            processing.push(t);\n        } else {\n            output.set(t, found);\n        }\n    }\n\n    if (promises.length > 0) {\n        let resolved = await Promise.all(promises);\n        for (var i = 0; i < resolved.length; i++) {\n            let res = resolved[i];\n            if (!res.ok) {\n                throw \"failed to fetch symbol information for genes\";\n            }\n            var buffer = await res.arrayBuffer();\n\n            let gene_data = decompressLines(buffer);\n            let processed = [];\n            for (const x of gene_data) {\n                if (x == \"\") {\n                    processed.push([]);\n                } else {\n                    processed.push(x.split(\"\\t\"));\n                }\n            }\n\n            let t = processing[i];\n            target.set(t, processed);\n            output.set(t, processed);\n        }\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as rna_qc_module from \"./rna_quality_control.js\";\nimport * as adt_qc_module from \"./adt_quality_control.js\";\nimport * as crispr_qc_module from \"./crispr_quality_control.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"cell_filtering\";\n\nfunction find_usable_upstream_states(qc_states, in_use) {\n    let tmp = utils.findValidUpstreamStates(qc_states);\n    let to_use = [];\n    for (const k of tmp) {\n        if (in_use[k]) {\n            to_use.push(qc_states[k]);\n        }\n    }\n    return to_use;\n}\n\n/**\n * This step filters the count matrices to remove low-quality cells,\n * based on metrics and thresholds computed in {@linkplain RnaQualityControlState} and friends.\n * It wraps the [`filterCells`](https://kanaverse.github.io/scran.js/global.html#filterCells) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * For multi-modal datasets, this can combine quality calls from all valid modalities; \n * a cell is removed if it is considered low-quality in any individual modality.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CellFilteringState {\n    #inputs;\n    #qc_states;\n    #cache;\n    #parameters;\n\n    constructor(inputs, qc_states, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be an InputsState object\");\n        }\n        this.#inputs = inputs;\n\n        if (!(qc_states.RNA instanceof rna_qc_module.RnaQualityControlState)) {\n            throw new Error(\"'qc_states.RNA' should be a RnaQualityControlState object\");\n        }\n        if (!(qc_states.ADT instanceof adt_qc_module.AdtQualityControlState)) {\n            throw new Error(\"'qc_states.ADT' should be a AdtQualityControlState object\");\n        }\n        if (!(qc_states.CRISPR instanceof crispr_qc_module.CrisprQualityControlState)) {\n            throw new Error(\"'qc_states.CRISPR' should be a CrisprQualityControlState object\");\n        }\n        this.#qc_states = qc_states;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.block_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n        utils.freeCache(this.#cache.matrix);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {external:MultiMatrix} A {@linkplain external:MultiMatrix MultiMatrix} object containing the filtered and normalized matrices for all modalities,\n     * available after running {@linkcode CellFilteringState#compute compute}.\n     */\n    fetchFilteredMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute_matrix();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Int32WasmArray} Array of length equal to the number of cells after filtering, \n     * containing the block assignment for each cell.\n     * This is available after running {@linkcode CellFilteringState#compute compute}.\n     * Alternatively `null` if no blocks are present in the dataset.\n     */\n    fetchFilteredBlock() {\n        if (!(\"block_buffer\" in this.#cache)) {\n            this.#raw_compute_block();\n        }\n        return this.#cache.block_buffer;\n    }\n\n    /**\n     * @return {?Uint8WasmArray} Combined discard vector, i.e., an array of length equal to the number of cells in the dataset,\n     * indicating whether each cell should be removed.\n     * This is available after running {@linkcode CellFilteringState#compute compute}.\n     * Alternatively `null`, if no upstream filtering steps were performed.\n     */\n    fetchDiscards() {\n        if (\"discard_buffer\" in this.#cache) {\n            return this.#cache.discard_buffer;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute_matrix() {\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = new scran.MultiMatrix;\n\n        let inputs = this.#inputs.fetchCountMatrix();\n        for (const a of inputs.available()) {\n            let src = inputs.get(a);\n\n            let sub;\n            if (\"discard_buffer\" in this.#cache) {\n                sub = scran.filterCells(src, this.#cache.discard_buffer);\n            } else {\n                sub = src.clone();\n            }\n\n            this.#cache.matrix.add(a, sub);\n        }\n    }\n\n    #raw_compute_block() {\n        utils.freeCache(this.#cache.block_buffer);\n\n        let block = this.#inputs.fetchBlock();\n        if (block !== null) {\n            if (\"discard_buffer\" in this.#cache) {\n                // Filtering on the block. Might as well force a load of the\n                // matrix, it'll be needed once we have the blocks anyway.\n                let filtered_ncols = this.fetchFilteredMatrix().numberOfColumns();\n                let bcache = utils.allocateCachedArray(filtered_ncols, \"Int32Array\", this.#cache, \"block_buffer\");\n                scran.filterBlock(block, this.#cache.discard_buffer, { buffer: bcache });\n            } else {\n                this.#cache.block_buffer = block.view();\n            }\n        } else {\n            this.#cache.block_buffer = null;\n        }\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `cell_filtering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.use_rna - Whether to use the RNA-derived QC metrics for filtering.\n     * @param {boolean} parameters.use_adt - Whether to use the ADT-derived QC metrics for filtering.\n     * @param {boolean} parameters.use_crispr - Whether to use the CRISPR-derived QC metrics for filtering.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { use_rna, use_adt, use_crispr } = parameters;\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            this.changed = true;\n        }\n\n        if (this.#parameters.use_rna !== use_rna || this.#parameters.use_adt !== use_adt || this.#parameters.use_crispr !== use_crispr) {\n            this.#parameters.use_rna = use_rna;\n            this.#parameters.use_adt = use_adt;\n            this.#parameters.use_crispr = use_crispr;\n            this.changed = true;\n        }\n\n        let to_use = find_usable_upstream_states(this.#qc_states, { RNA: use_rna, ADT: use_adt, CRISPR: use_crispr });\n        if (!this.changed) {\n            for (const u of to_use) {\n                if (u.changed) {\n                    this.changed = true;\n                    break;\n                }\n            }\n        }\n\n        if (this.changed) {\n            if (to_use.length > 0) {\n                let first = to_use[0].fetchDiscards();\n\n                if (to_use.length > 1) {\n                    // A discard signal in any modality causes the cell to be removed. \n                    let disc_buffer = utils.allocateCachedArray(first.length, \"Uint8Array\", this.#cache, \"discard_buffer\");\n                    disc_buffer.fill(0);\n\n                    let disc_arr = disc_buffer.array();\n                    for (const u of to_use) {\n                        u.fetchDiscards().forEach((y, i) => { disc_arr[i] |= y; });\n                    }\n                } else {\n                    // If there's only one valid modality, we just create a view on it\n                    // to avoid unnecessary duplication.\n                    utils.freeCache(this.#cache.discard_buffer);\n                    this.#cache.discard_buffer = first.view();\n                }\n\n            } else {\n                // Deleting this so that serialization will behave correctly.\n                utils.freeCache(this.#cache.discard_buffer);\n                delete this.#cache.discard_buffer;\n            }\n\n            this.#raw_compute_matrix();\n            this.#raw_compute_block();\n        }\n    }\n\n    static defaults() {\n        return {\n            use_rna: true,\n            use_adt: true,\n            use_crispr: true\n        };\n    }\n\n    /**\n     * Apply the same filter to an array of data for each cell in the unfiltered dataset.\n     * This is typically used to filter the columns of {@linkcode InputsState#fetchCellAnnotations InputsState.fetchCellAnnotations} for downstream use.\n     * (See the {@linkcode CellFilteringState#undoFilter undoFilter} method for the reverse operation.)\n     * Any calls to this method should be done after running {@linkcode CellFilteringState#compute compute}.\n     *\n     * @param {Array|TypedArray} Any array-like object of length equal to the number of cells in the unfiltered dataset.\n     * \n     * @return {Array|TypedArray} An array-like object of the same type as `x`,\n     * where all elements corresponding to low-quality cells have been discarded.\n     * This will have number of columns equal to that of {@linkcode CellFilteringState#fetchFilteredMatrix fetchFilteredMatrix}.\n     */\n    applyFilter(x) {\n        let expect_len = this.#inputs.fetchCountMatrix().numberOfColumns();\n        if (expect_len != x.length) {\n            throw new Error(\"length of 'x' should be equal to the number of cells in the unfiltered dataset\");\n        }\n\n        if (!(\"discard_buffer\" in this.#cache)) {\n            return x.slice(); // making a copy.\n        } else {\n            let discard = this.#cache.discard_buffer.array();\n            return x.filter((y, i) => !discard[i]);\n        }\n    }\n\n    /**\n     * Undo the effect of filtering on an array of column indices on the filtered matrix, so that they now refer to column indices on the unfiltered matrix.\n     * This is primarily useful for adjusting indices from downstream steps like {@linkcode CustomSelectionsState#fetchSelectionIndices CustomSelectionsState.fetchSelectionIndices}.\n     * The output of this function can be combined with {@linkcode InputsState#undoSubset InputsState.undoSubset} to obtain column indices on the original matrix,\n     * which can be used in other contexts, e.g., like {@linkcode subsetInputs}.\n     *\n     * @param {Array|TypedArray} indices - Array of column indices to the filtered matrix.\n     * Note that this will be modified in-place.\n     *\n     * @return Entries of `indices` are replaced with indices to the unfiltered matrix.\n     */\n    undoFilter(indices) {\n        let max_index = this.fetchFilteredMatrix().numberOfColumns();\n        for (const x of indices) {\n            if (x < 0 || x >= max_index) {\n                throw new Error(\"entries of 'indices' should be less than the number of cells in the filtered dataset\");\n            }\n        }\n\n        if (!('discard_buffer' in this.#cache)) {\n            return;\n        }\n\n        let keep = [];\n        this.#cache.discard_buffer.forEach((x, i) => {\n            if (x == 0) {\n                keep.push(i);\n            }\n        });\n\n        indices.forEach((x, i) => {\n            indices[i] = keep[x];\n        });\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs, qc_states) {\n    let parameters = CellFilteringState.defaults();\n    let cache = {};\n    let output;\n\n    try {\n        if (step_name in handle.children) {\n            let ghandle = handle.open(step_name);\n\n            if (\"parameters\" in ghandle.children) {\n                let phandle = ghandle.open(\"parameters\");\n                if (\"use_rna\" in phandle.children) {\n                    parameters.use_rna = phandle.open(\"use_rna\", { load: true }).values[0] > 0;\n                    parameters.use_adt = phandle.open(\"use_adt\", { load: true }).values[0] > 0;\n                    parameters.use_crispr = phandle.open(\"use_crispr\", { load: true }).values[0] > 0;\n                }\n            }\n\n            let rhandle = ghandle.open(\"results\");\n            if (\"discards\" in rhandle.children) {\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n            }\n        } \n\n        if (!(\"discard_buffer\" in cache)) {\n            let to_use = find_usable_upstream_states(qc_states, { RNA: parameters.use_rna, ADT: parameters.use_adt, CRISPR: parameters.use_crispr });\n\n            if (to_use.length == 1) {\n                // We figure out which upstream QC state contains the discard vector\n                // and create a view on it so that our discard_buffer checks work properly.\n                // (v1 and earlier also implicitly falls in this category.)\n                cache.discard_buffer = to_use[0].fetchDiscards().view();\n            } else if (to_use.length == 0) {\n                // No-op; we don't need to define discard_buffer.\n                ;\n            } else {\n                throw new Error(\"no more than one upstream QC state should be valid if 'discards' is not available\");\n            }\n        }\n\n        output = new CellFilteringState(inputs, qc_states, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.discard_buffer);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import { reference_download, decompressLines } from \"./utils.js\";\nimport { fetchAllCollections } from \"./fetchAllCollections.js\";\n\nvar _sets = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the set details if they are not already available.\n * If `false`, `null` is returned if the set details have not already been loaded into memory.\n *\n * @return {Array} Array of objects where each entry corresponds to a set and contains the details about that set.\n * Each object can be expected to contain:\n * \n * - `name`, the name of the set.\n * - `description`, the description of the set.\n * - `size`, the number of genes in the set.\n * - `collection`, the index of the collection containing the set.\n * - `number`, the number of the set within the collection.\n *\n * In a **gesel** context, the identifier for a set (i.e., the \"set ID\") is defined as the index of the set in this array.\n *\n * If the set details have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchAllSets(species, { download = true } = {}) {\n    let found = _sets.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    found = [];\n    _sets.set(species, found);\n\n    var [ sres, _collections ] = await Promise.all([reference_download(species + \"_sets.tsv.gz\"), fetchAllCollections(species)]);\n    if (!sres.ok) {\n        throw new Error(\"failed to fetch set information for species '\" + species + \"'\");\n    }\n    var set_data = decompressLines(await sres.arrayBuffer());\n\n    for (var i = 0; i < set_data.length; i++) {\n        let x = set_data[i];\n        var details = x.split(\"\\t\");\n        found.push({\n            \"name\": details[0],\n            \"description\": details[1],\n            \"size\": Number(details[2])\n        });\n    }\n\n    let start = 0;\n    for (var i = 0; i < _collections.length; i++) {\n        let len = _collections[i].size;\n\n        // For easier access going the other way.\n        for (var j = 0; j < len; j++) {\n            found[j + start].collection = i;\n            found[j + start].number = j;\n        }\n\n        start += len;\n    }\n\n    return found;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as rna_pca_module from \"./rna_pca.js\";\nimport * as adt_pca_module from \"./adt_pca.js\";\nimport * as crispr_pca_module from \"./crispr_pca.js\";\n\nexport const step_name = \"combine_embeddings\";\n\nfunction find_nonzero_upstream_states(pca_states, weights) {\n    let tmp = utils.findValidUpstreamStates(pca_states);\n    let to_use = [];\n    for (const k of tmp) {\n        if (weights[k] > 0) {\n            to_use.push(k);\n        }\n    }\n    return to_use;\n}\n\n/**\n * This step combines multiple embeddings from different modalities into a single matrix for downstream analysis.\n * It wraps the [`scaleByNeighbors`](https://kanaverse.github.io/scran.js/global.html#scaleByNeighbors) function\n * from [**scran.js**](https://kanaverse.github.io/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CombineEmbeddingsState {\n    #pca_states;\n    #parameters;\n    #cache;\n\n    constructor(pca_states, parameters = null, cache = null) {\n        if (!(pca_states.RNA instanceof rna_pca_module.RnaPcaState)) {\n            throw new Error(\"'pca_states.RNA' should be an RnaPcaState object\");\n        }\n        if (!(pca_states.ADT instanceof adt_pca_module.AdtPcaState)) {\n            throw new Error(\"'pca_states.ADT' should be an AdtPcaState object\");\n        }\n        if (!(pca_states.CRISPR instanceof crispr_pca_module.CrisprPcaState)) {\n            throw new Error(\"'pca_states.CRISPR' should be an CrisprPcaState object\");\n        }\n        this.#pca_states = pca_states;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.combined_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Float64WasmArray} Buffer containing the combined embeddings as a column-major dense matrix,\n     * where the rows are the dimensions and the columns are the cells.\n     * This is available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchCombined() {\n        return this.#cache.combined_buffer;\n    }\n\n    /**\n     * @return {number} Number of cells in {@linkcode CombineEmbeddingsState#fetchCombined fetchCombined},\n     * available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchNumberOfCells() {\n        return this.#cache.num_cells;\n    }\n\n    /**\n     * @return {number} Number of dimensions in {@linkcode CombineEmbeddingsState#fetchCombined fetchCombined},\n     * available after running {@linkcode CombineEmbeddingsState#compute compute}.\n     */\n    fetchNumberOfDimensions() {\n        return this.#cache.total_dims;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Avoid any pass-by-reference activity.\n        return { ...this.#parameters };\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return { \n            rna_weight: 1,\n            adt_weight: 1,\n            crispr_weight: 0,\n            approximate: true\n        };\n    }\n\n    static createPcsView(cache, upstream) {\n        utils.freeCache(cache.combined_buffer);\n        cache.combined_buffer = upstream.principalComponents({ copy: \"view\" }).view();\n        cache.num_cells = upstream.numberOfCells();\n        cache.total_dims = upstream.numberOfPCs();\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.rna_weight - Relative weight of the RNA embeddings.\n     * @param {number} parameters.adt_weight - Relative weight of the ADT embeddings.\n     * @param {number} parameters.crispr_weight - Relative weight of the CRISPR embeddings.\n     * @param {boolean} parameters.approximate - Whether an approximate nearest neighbor search should be used by `scaleByNeighbors`.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        let { rna_weight, adt_weight, crispr_weight, approximate } = parameters;\n        this.changed = false;\n\n        for (const v of Object.values(this.#pca_states)) {\n            if (v.changed) {\n                this.changed = true;\n                break;\n            }\n        }\n\n        if (approximate !== this.#parameters.approximate) {\n            this.#parameters.approximate = approximate;\n            this.changed = true;\n        }\n\n        if (rna_weight !== this.#parameters.rna_weight || adt_weight !== this.#parameters.adt_weight || crispr_weight !== this.#parameters.crispr_weight) {\n            this.#parameters.rna_weight = rna_weight;\n            this.#parameters.adt_weight = adt_weight;\n            this.#parameters.crispr_weight = crispr_weight;\n            this.changed = true;\n        }\n\n        if (this.changed) { \n            const weights = { RNA: rna_weight, ADT: adt_weight, CRISPR: crispr_weight };\n            let to_use = find_nonzero_upstream_states(this.#pca_states, weights);\n\n            if (to_use.length > 1) {\n                let weight_arr = to_use.map(x => weights[x]);\n                let collected = [];\n                let total = 0;\n                let ncells = null;\n\n                for (const k of to_use) {\n                    let curpcs = this.#pca_states[k].fetchPCs();\n                    collected.push(curpcs.principalComponents({ copy: \"view\" }));\n                    if (ncells == null) {\n                        ncells = curpcs.numberOfCells();\n                    } else if (ncells !== curpcs.numberOfCells()) {\n                        throw new Error(\"number of cells should be consistent across all embeddings\");\n                    }\n                    total += curpcs.numberOfPCs();\n                }\n\n                let buffer = utils.allocateCachedArray(ncells * total, \"Float64Array\", this.#cache, \"combined_buffer\");\n                scran.scaleByNeighbors(collected, ncells, { buffer: buffer, weights: weight_arr, approximate: approximate });\n                this.#cache.num_cells = ncells;\n                this.#cache.total_dims = total;\n\n            } else {\n                // If there's only one embedding, we shouldn't respond to changes\n                // in parameters, because they won't have any effect.\n                let pcs = this.#pca_states[to_use[0]].fetchPCs();\n                this.constructor.createPcsView(this.#cache, pcs);\n            }\n        }\n\n        // Updating all parameters anyway. This requires us to take ownership\n        // of 'weights' to avoid pass-by-reference shenanigans.\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca_states) {\n    let cache = {};\n    let parameters = CombineEmbeddingsState.defaults();\n    let output;\n\n    try {\n        if (step_name in handle.children) {\n            let ghandle = handle.open(step_name);\n\n            {\n                let phandle = ghandle.open(\"parameters\");\n                parameters.approximate = phandle.open(\"approximate\", { load: true }).values[0] > 0;\n\n                if ('weights' in phandle.children) { // v2.0\n                    let whandle = phandle.open(\"weights\");\n                    if (\"RNA\" in whandle.children) {\n                        parameters.rna_weight = whandle.open(\"RNA\", { load: true }).values[0];\n                    }\n                    if (\"ADT\" in whandle.children) {\n                        parameters.adt_weight = whandle.open(\"ADT\", { load: true }).values[0];\n                    }\n                    if (\"CRISPR\" in whandle.children) {\n                        parameters.crispr_weight = whandle.open(\"CRISPR\", { load: true }).values[0];\n                    }\n                } else {\n                    parameters.rna_weight = phandle.open(\"rna_weight\", { load: true }).values[0];\n                    parameters.adt_weight = phandle.open(\"adt_weight\", { load: true }).values[0];\n                    parameters.crispr_weight = phandle.open(\"crispr_weight\", { load: true }).values[0];\n                }\n            }\n\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"combined\" in rhandle.children) {\n                let phandle = rhandle.open(\"combined\", { load: true });\n                cache.num_cells = phandle.shape[0];\n                cache.total_dims = phandle.shape[1];\n\n                let vals = phandle.values;\n                cache.combined_buffer = scran.createFloat64WasmArray(vals.length);\n                cache.combined_buffer.set(vals);\n            }\n        }\n\n        if (!(\"combined_buffer\" in cache)) {\n            // This only happens if there was only one upstream PCA state; in which case, \n            // we figure out which upstream PCA state contains the PC vector\n            // and create a view on it so that our fetchPCs() works properly.\n            // (v1 and earlier also implicitly falls in this category.)\n            const weights = { RNA: parameters.rna_weight, ADT: parameters.adt_weight, CRISPR: parameters.crispr_weight };\n            let to_use = find_nonzero_upstream_states(pca_states, weights);\n\n            if (to_use.length != 1) {\n                throw new Error(\"only one upstream PCA state should be valid with non-zero weight if 'combined' is not available\");\n            }\n\n            let pcs = pca_states[to_use[0]].fetchPCs();\n            CombineEmbeddingsState.createPcsView(cache, pcs);\n        }\n\n        output = new CombineEmbeddingsState(pca_states, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.combined_buffer);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","/**\n * Webpack (or something in kana's build system) specifically recognizes the\n * hard-coded path in this 'new Worker(new URL(...))' pattern. This is why we\n * have hard-coded creators for the workers rather than allowing callers to\n * pass in the URL as a variable, as that doesn't pack the worker's JS.\n */\n\nexport function createTsneWorker() {\n    return new Worker(new URL(\"../tsne.worker.js\", import.meta.url), { type: \"module\" });\n}\n\nexport function createUmapWorker() {\n    return new Worker(new URL(\"../umap.worker.js\", import.meta.url), { type: \"module\" });\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\n\nfunction create_solo_default_object(value, modality) {\n    let output = {};\n    output[modality] = value;\n    return output;\n}\n\nexport function reportFeatures(rawFeatures, typeField) {\n    if (rawFeatures.hasColumn(typeField)) {\n        let by_type = bioc.presplitFactor(rawFeatures.column(typeField));\n        let copy = rawFeatures.removeColumn(typeField);\n        return bioc.SPLIT(copy, by_type);\n    } else {\n        return create_solo_default_object(rawFeatures, \"\");\n    }\n}\n\nfunction is_subset_noop(indices, full_length) {\n    if (indices.length != full_length) {\n        return false;\n    }\n    for (var i = 0; i < full_length; i++) {\n        if (i !== indices[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction renameByModality(input, featureTypeMapping) {\n    let output = {};\n    for (const [k, v] of Object.entries(featureTypeMapping)) {\n        if (v !== null && v in input) {\n            output[k] = input[v];\n        }\n    }\n    return output;\n}\n\nfunction splitByModality(features, typeField, featureTypeMapping) {\n    let by_type = bioc.presplitFactor(features.column(typeField));\n    if (featureTypeMapping === null) {\n        return by_type;\n    }\n    return renameByModality(by_type, featureTypeMapping);\n}\n\nfunction findUnnamedDefault(featureTypeMapping, featureTypeDefault) {\n    let found = null;\n    let multiple = false;\n    for (const [k, v] of Object.entries(featureTypeMapping)) {\n        if (v !== null) {\n            if (found !== null) {\n                multiple = true;\n            }\n            found = k;\n        }\n    }\n\n    if (found === null || multiple) {\n        return featureTypeDefault;\n    } else {\n        return found;\n    }\n}\n\nexport function extractSplitPrimaryIds(features, typeField, featureTypeMapping, featureTypeDefault, primary) {\n    if (typeField !== null && features.hasColumn(typeField)) {\n        let by_type = splitByModality(features, typeField, featureTypeMapping);\n        for (const [k, v] of Object.entries(by_type)) {\n            let col = extractPrimaryIdColumn(k, features, primary);\n            by_type[k] = bioc.SLICE(col, v);\n        }\n        return by_type;\n    }\n\n    // Seeing if any featureTypeMapping is set to the unnamed string.\n    let new_default = findUnnamedDefault(featureTypeMapping, featureTypeDefault);\n    let output = {};\n    output[new_default] = extractPrimaryIdColumn(new_default, features, primary);\n    return output;\n}\n\nexport function splitScranMatrixAndFeatures(loaded, rawFeatures, typeField, featureTypeMapping, featureTypeDefault) {\n    let output = { matrix: new scran.MultiMatrix };\n\n    try {\n        let out_mat = loaded.matrix;\n        output.matrix.add(\"\", out_mat);\n\n        let current_features;\n        if (loaded.row_ids !== null) {\n            current_features = bioc.SLICE(rawFeatures, loaded.row_ids);\n        } else {\n            current_features = bioc.CLONE(rawFeatures, { deepCopy: false }); // because we're deleting a column.\n        }\n\n        if (typeField !== null && current_features.hasColumn(typeField)) {\n            let by_type = splitByModality(current_features, typeField, featureTypeMapping);\n            let type_keys = Object.keys(by_type);\n            let skip_subset = is_subset_noop(type_keys[0], out_mat.numberOfRows());\n\n            if (type_keys.length > 1 || !skip_subset) {\n                let replacement = new scran.MultiMatrix({ store: scran.splitRows(out_mat, by_type) });\n                scran.free(output.matrix);\n                output.matrix = replacement;\n            } else {\n                output.matrix.rename(\"\", type_keys[0]);\n            }\n\n            delete current_features[typeField];\n            output.features = bioc.SPLIT(current_features, by_type);\n\n        } else {\n            output.matrix.rename(\"\", featureTypeDefault);\n            output.features = create_solo_default_object(current_features, featureTypeDefault);\n        }\n    } catch (e) {\n        scran.free(output.matrix);\n        throw e;\n    }\n\n    return output;\n}\n\nfunction extractPrimaryIdColumn(modality, modality_features, primary) {\n    if (!(modality in primary)) {\n        throw new Error(\"modality '\" + modality + \"' has no primary key identifier\");  \n    }\n    let id = primary[modality];\n\n    if ((typeof id == \"string\" && modality_features.hasColumn(id)) || (typeof id == \"number\" && id < modality_features.numberOfColumns())) {\n        return modality_features.column(id);\n    } \n\n    return modality_features.rowNames();\n}\n\nexport function extractPrimaryIds(features, primary) {\n    let output = {};\n    for (const [k, v] of Object.entries(features)) {\n        output[k] = extractPrimaryIdColumn(k, v, primary);\n    }\n    return output;\n}\n\nexport function extractRemappedPrimaryIds(features, featureTypeMapping, primary) {\n    let renamed = renameByModality(features, featureTypeMapping);\n    return extractPrimaryIds(renamed, primary);\n}\n","import * as cutils from \"./clone-utils.js\";\n\n/**\n * Dense matrix of numbers.\n * Not really a Bioconductor-exclusive data structure, but we need this at a minimum for the {@linkplain SummarizedExperiment} to be useful.\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n */\nexport class DenseMatrix {\n    /**\n     * @param {number} numberOfRows - Number of rows, duh.\n     * @param {number} numberOfColumns - Number of columns.\n     * @param {TypedArray} values - 1-dimensional array of the matrix contents.\n     * This should have length equal to the product of `numberOfRows` and `numberOfColumns`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.columnMajor=true] - Whether `values` represents a column-major layout.\n     */\n    constructor(numberOfRows, numberOfColumns, values, { columnMajor = true } = {}) {\n        if (arguments.length == 0) {\n            return;\n        }\n\n        this._numberOfRows = numberOfRows;\n        this._numberOfColumns = numberOfColumns;\n        this._values = values;\n        this._columnMajor = columnMajor;\n        if (numberOfRows * numberOfColumns != values.length) {\n            throw new Error(\"length of 'values' should be equal to the product of 'dimensions'\");\n        }\n    }\n\n    static name = \"DenseMatrix\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {number} Number of rows.\n     */\n    numberOfRows() {\n        return this._numberOfRows;\n    }\n\n    /**\n     * @return {number} Number of columns.\n     */\n    numberOfColumns() {\n        return this._numberOfColumns;\n    }\n\n    /**\n     * @return {boolean} Whether the matrix is column-major.\n     */\n    isColumnMajor() {\n        return this._columnMajor;\n    }\n\n    /**\n     * @return {TypedArray} Matrix contents as a 1-dimensional array.\n     */\n    values() {\n        return this._values;\n    }\n\n    #extractor(i, nprimary, nsecondary, allowView, primaryMajor) {\n        if (!primaryMajor) {\n            let output = new this._values.constructor(nsecondary);\n            let offset = i;\n            for (var s = 0; s < nsecondary; s++) {\n                output[s] = this._values[offset];\n                offset += nprimary;\n            }\n            return output;\n\n        } else {\n            let start = i * nsecondary;\n            let end = start + nsecondary;\n            if (allowView) {\n                return this._values.subarray(start, end);\n            } else {\n                return this._values.slice(start, end);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the contents of a particular row.\n     *\n     * @param {number} i - Index of the row of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether to allow a view to be returned, if possible.\n     *\n     * @return {TypedArray} Contents of the row `i`.\n     * This may be a view on the array returned by {@linkcode DenseMatrix#values values}, if permitted by the layout.\n     */\n    row(i, { allowView = false } = {}) {\n        return this.#extractor(i, this._numberOfRows, this._numberOfColumns, allowView, !this._columnMajor);\n    }\n\n    /**\n     * Retrieve the contents of a particular column.\n     *\n     * @param {number} i - Index of the column of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether to allow a view to be returned, if possible.\n     *\n     * @return {TypedArray} Contents of the column `i`.\n     * This may be a view on the array returned by {@linkcode DenseMatrix#values values}, if permitted by the layout.\n     */\n    column(i, { allowView = false } = {}) {\n        return this.#extractor(i, this._numberOfColumns, this._numberOfRows, allowView, this._columnMajor);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {TypedArray} values - 1-dimensional array of matrix contents,\n     * of the same length as the array returned by {@linkcode DenseMatrix#values values}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setValues(values, { inPlace = false } = {}) {\n        if (values.length !== this._values.length) {\n            throw new Error(\"replacement 'values' should have length equal to 'values()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._values = values;\n        return target;\n    }\n\n    /**\n     * @param {TypedArray} values - 1-dimensional array of matrix contents,\n     * of the same length as the array returned by {@linkcode DenseMatrix#values values}.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setValues(values) {\n        return this.setValues(values, { inPlace: true });\n    }\n\n    #inserter(i, nprimary, nsecondary, primaryMajor, replacement) {\n        if (!primaryMajor) {\n            let output = new this._values.constructor(nsecondary);\n            let offset = i;\n            for (var s = 0; s < nsecondary; s++) {\n                this._values[offset] = replacement[s];\n                offset += nprimary;\n            }\n        } else {\n            let start = i * nsecondary;\n            this._values.set(replacement, start);\n        }\n    }\n\n    /**\n     * @param {number} i - Row index to set.\n     * @param {TypedArray} values - Row contents, of length equal to the number of columns in this DenseMatrix.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRow(i, values, { inPlace = false } = {}) {\n        if (values.length !== this._numberOfColumns) {\n            throw new Error(\"replacement row should have length equal to 'numberOfColumns()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        target.#inserter(i, target._numberOfRows, target._numberOfColumns, !target._columnMajor, values);\n        return target;\n    }\n\n    /**\n     * @param {number} i - Row index to set.\n     * @param {TypedArray} values - Row contents, of length equal to the number of columns in this DenseMatrix.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setRow(i, value) {\n        return this.setRow(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {number} i - Column index to set.\n     * @param {TypedArray} values - Column contents, of length equal to the number of rows in this DenseMatrix.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this DenseMatrix instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {DenseMatrix} The DenseMatrix after modifying the matrix contents.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumn(i, values, { inPlace = false } = {}) {\n        if (values.length !== this._numberOfRows) {\n            throw new Error(\"replacement column should have length equal to 'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        target.#inserter(i, target._numberOfColumns, target._numberOfRows, target._columnMajor, values);\n        return target;\n    }\n\n    /**\n     * @param {number} i - Column index to set.\n     * @param {TypedArray} values - Column contents, of length equal to the number of columns in this DenseMatrix.\n     * @return {DenseMatrix} A reference to this DenseMatrix after modifying the matrix contents.\n     */\n    $setColumn(i, value) {\n        return this.setColumn(i, value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.numberOfColumns();\n    }\n\n    _bioconductor_SLICE_2D(output, rows, columns, {}) {\n        let full_rows = (rows === null);\n        let is_row_range = (!full_rows && rows.constructor == Object);\n        let new_rows = full_rows ? this._numberOfRows : (is_row_range ? rows.end - rows.start : rows.length);\n        output._numberOfRows = new_rows;\n\n        let full_columns = (columns === null);\n        let is_column_range = (!full_columns && columns.constructor == Object);\n        let new_columns = full_columns ? this._numberOfColumns : (is_column_range ? columns.end - columns.start : columns.length);\n        output._numberOfColumns = new_columns;\n\n        let new_values = new this._values.constructor(new_rows * new_columns);\n        output._values = new_values;\n\n        if (this._columnMajor) {\n            this.#primarySlicer(columns, full_columns, is_column_range, this._numberOfColumns, rows, full_rows, is_row_range, this._numberOfRows, new_rows, new_values);\n        } else {\n            this.#primarySlicer(rows, full_rows, is_row_range, this._numberOfRows, columns, full_columns, is_column_range, this._numberOfColumns, new_columns, new_values);\n        }\n        output._columnMajor = this._columnMajor;\n        return;\n    }\n\n    #primarySlicer(primarySlice, fullPrimary, isPrimaryRange, primaryDim, secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues) {\n        if (fullPrimary) {\n            for (var p = 0; p < primaryDim; p++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, p, p);\n            }\n        } else if (isPrimaryRange) {\n            for (var p = primarySlice.start; p < primarySlice.end; p++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, p, p - primarySlice.start);\n            }\n        } else {\n            for (var pi = 0; pi < primarySlice.length; pi++) {\n                this.#secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, primarySlice[pi], pi);\n            }\n        }\n    }\n\n    #secondarySlicer(secondarySlice, fullSecondary, isSecondaryRange, inSecondaryDim, outSecondaryDim, outputValues, inPrimary, outPrimary) {\n        let in_offset = inPrimary * inSecondaryDim;\n        let out_offset = outPrimary * outSecondaryDim;\n\n        if (fullSecondary) {\n            let view = this._values.subarray(in_offset, in_offset + inSecondaryDim);\n            outputValues.set(view, out_offset);\n        } else if (isSecondaryRange) {\n            for (var s = secondarySlice.start; s < secondarySlice.end; s++) {\n                outputValues[out_offset + s - secondarySlice.start] = this._values[in_offset + s];\n            }\n        } else {\n            for (var si = 0; si < secondarySlice.length; si++) {\n                outputValues[out_offset + si] = this._values[in_offset + secondarySlice[si]];\n            }\n        }\n    }\n\n    _combiner(objects, primaryFun, secondaryFun, isPrimaryMajor, secondaryName) {\n        let num_primary = primaryFun(objects[0]);\n        let num_secondary = secondaryFun(objects[0]);\n        for (var i = 1; i < objects.length; i++) {\n            if (secondaryFun(objects[i]) !== num_secondary) {\n                throw new Error(\"all objects must have the same number of \" + secondaryName);\n            }\n            num_primary += primaryFun(objects[i]);\n        }\n\n        let primary_major = isPrimaryMajor(objects[0]);\n        let values = new objects[0]._values.constructor(num_primary * num_secondary);\n\n        if (primary_major) {\n            let used_primary = 0;\n            for (var i = 0; i < objects.length; i++) {\n                let current = objects[i];\n                let cur_primary = primaryFun(current);\n                let out_offset = used_primary * num_secondary;\n\n                if (isPrimaryMajor(current)) {\n                    values.set(current._values, out_offset);\n                } else {\n                    for (var s = 0; s < num_secondary; s++) {\n                        let in_offset = s * cur_primary;\n                        let out_offset2 = out_offset + s;\n                        for (var p = 0; p < cur_primary; p++) {\n                            values[out_offset2 + p * num_secondary] = current._values[in_offset + p];\n                        }\n                    }\n                }\n\n                used_primary += cur_primary;\n            }\n        } else {\n            let used_primary = 0;\n            for (var i = 0; i < objects.length; i++) {\n                let current = objects[i];\n                let cur_primary = primaryFun(current);\n\n                if (!isPrimaryMajor(current)) {\n                    for (var s = 0; s < num_secondary; s++) {\n                        let view_offset = s * cur_primary;\n                        let view = current._values.subarray(view_offset, view_offset + cur_primary);\n                        values.set(view, used_primary + s * num_primary);\n                    }\n                } else {\n                    for (var p = 0; p < cur_primary; p++) {\n                        let in_offset = p * num_secondary;\n                        let out_offset = used_primary + p;\n                        for (var s = 0; s < num_secondary; s++) {\n                            values[out_offset + s * num_primary] = current._values[in_offset + s];\n                        }\n                    }\n                }\n\n                used_primary += cur_primary;\n            }\n        }\n\n        return { num_primary, num_secondary, values, primary_major };\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        let combined = this._combiner(objects,\n            x => x._numberOfRows,\n            x => x._numberOfColumns,\n            x => !(x._columnMajor),\n            \"columns\"\n        );\n\n        output._numberOfRows = combined.num_primary;\n        output._numberOfColumns = combined.num_secondary;\n        output._values = combined.values;\n        output._columnMajor = !(combined.primary_major);\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        let combined = this._combiner(objects,\n            x => x._numberOfColumns,\n            x => x._numberOfRows,\n            x => x._columnMajor,\n            \"rows\"\n        );\n\n        output._numberOfColumns = combined.num_primary;\n        output._numberOfRows = combined.num_secondary;\n        output._values = combined.values;\n        output._columnMajor = combined.primary_major;\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true } = {}) {\n        output._values = (deepCopy ? this._values.slice() : this._values);\n        output._numberOfRows = this._numberOfRows;\n        output._numberOfColumns = this._numberOfColumns;\n        output._columnMajor = this._columnMajor;\n        return;\n    }\n}\n","import * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Compute group-based size factors, where composition biases are removed between groups and library size normalization is performed within groups.\n * This allows us to generate per-cell size factors in spite of the sparsity.\n *\n * @param {ScranMatrix} x The count matrix, usually after filtering.\n * @param {(Int32WasmArray|Array|TypedArray)} groups - Array containing the group assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.center=true] - Whether to return centered size factors.\n * If `false`, the size factors can be interpreted as the scaling to match `reference`.\n * @param {?Float64WasmArray} [options.buffer=null] - Output buffer for the size factors.\n * This should have length equal to the number of columns in `x`.\n * @param {number} [options.priorCount=10] - Prior count to use for shrinking size factors towards the relative library size.\n * Larger values result in stronger shrinkage when the coverage is low.\n * @param {?number} [options.reference=null] - Group to use as a reference.\n * This should be an entry in `groups`. \n * If `null`, it is automatically determined.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array of length equal to the number of columns in `x`, containing the size factors for all cells.\n *\n * If `buffer` was supplied, it is used as the return value.\n */\nexport function groupedSizeFactors(x, groups, { center = true, buffer = null, priorCount = 10, reference = null, numberOfThreads = null } = {}) {\n    var local_buffer;\n    var group_arr;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        if (!(buffer instanceof wa.Float64WasmArray)) {\n            local_buffer = utils.createFloat64WasmArray(x.numberOfColumns());\n            buffer = local_buffer;\n        } else if (buffer.length !== x.numberOfColumns()) {\n            throw new Error(\"length of 'buffer' must be equal to the number of columns in 'x'\");\n        }\n\n        group_arr = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (reference == null) {\n            reference = -1;\n        }\n\n        wasm.call(module => module.grouped_size_factors(x.matrix, group_arr.offset, center, priorCount, reference, buffer.offset, nthreads));\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n\n    } finally {\n        utils.free(group_arr);\n    }\n    \n    return buffer;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"crispr_quality_control\";\n\n/**\n * Results of computing per-cell CRISPR-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellCrisprQcMetricsResults.html) for details.\n *\n * @external PerCellCrisprQcMetricsResults\n */\n\n/**\n * Suggested filters for the CRISPR-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestCrisprQcFiltersResults.html) for details.\n *\n * @external SuggestCrisprQcFiltersResults\n */\n\n/**\n * This step applies quality control on the CRISPR guide count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellCrisprQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellCrisprQcMetrics)\n * and [`suggestCrisprQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestCrisprQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"CRISPR\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @return {external:SuggestCrisprQcFiltersResults} Result of filtering on the CRISPR-derived QC metrics.\n     * This is available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     * This is available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:PerCellCrisprQcMetricsResults} CRISPR-derived QC metrics,\n     * available after running {@linkcode CrisprQualityControlState#compute compute}.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return {\n            nmads: 3\n        };\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold on the maximum count. \n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { nmads } = parameters;\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                var mat = this.#inputs.fetchCountMatrix().get(\"CRISPR\");\n                this.#cache.metrics = scran.perCellCrisprQcMetrics(mat);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        if (this.changed || nmads !== this.#parameters.nmads) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestCrisprQcFilters(this.#cache.metrics, { numberOfMADs: nmads, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let cache = {};\n    let parameters = CrisprQualityControlState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"metrics\" in rhandle.children) { // if skip=true or valid() is false, QC metrics may not be reported.\n                let mhandle = rhandle.open(\"metrics\");\n\n                let detected = mhandle.open(\"detected\", { load: true }).values;\n                cache.metrics = scran.emptyPerCellCrisprQcMetricsResults(detected.length);\n                cache.metrics.detected({ fillable: true }).set(detected);\n\n                let sums = mhandle.open(\"sums\", { load: true }).values;\n                cache.metrics.sums({ fillable: true }).set(sums);\n\n                let max_prop = mhandle.open(\"max_proportion\", { load: true }).values;\n                cache.metrics.maxProportions({ fillable: true }).set(max_prop);\n\n                let max_index = mhandle.open(\"max_index\", { load: true }).values;\n                cache.metrics.maxIndex({ fillable: true }).set(max_index);\n            }\n\n            if (\"thresholds\" in rhandle.children) { // if skip=true or valid() is false, QC thresholds may not be reported.\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n\n                let thandle = rhandle.open(\"thresholds\");\n                let thresholds_max_count = thandle.open(\"max_count\", { load: true }).values;\n\n                cache.filters = scran.emptySuggestCrisprQcFiltersResults(thresholds_max_count.length);\n                cache.filters.thresholdsMaxCount({ fillable: true }).set(thresholds_max_count);\n            }\n\n            output = new CrisprQualityControlState(inputs, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.metrics);\n            utils.freeCache(cache.filters)\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback if the results aren't available. \n        output = new CrisprQualityControlState(inputs, parameters, cache);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { MultiMatrix } from \"./MultiMatrix.js\";\n\n/**\n * Slice a {@linkplain ScranMatrix} by its rows.\n * \n * @param {ScranMatrix} x - The matrix of interest.\n * @param {Array} indices - Row indices to extract.\n * All indices must be non-negative integers less than `mat.numberOfRows()`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inPlace=false] - Whether to modify `x` in place.\n * If `false`, a new ScranMatrix is returned.\n *\n * @return {ScranMatrix}\n * A ScranMatrix containing the subset of rows from `mat` specified by `indices`.\n * If `inPlace = true`, this is a reference to `x`, otherwise it is a new ScranMatrix.\n */\nexport function subsetRows(x, indices, { inPlace = false } = {}) {\n    let xcopy;\n    let target;\n    let wasm_indices;\n\n    try {\n        if (inPlace) {\n            target = x;\n        } else {\n            xcopy = x.clone();\n            target = xcopy;\n        }\n\n        wasm_indices = utils.wasmifyArray(indices, \"Int32WasmArray\");\n        wasm.call(module => module.row_subset(target.matrix, wasm_indices.offset, wasm_indices.length));\n\n    } catch (e) {\n        utils.free(xcopy);\n        throw e;\n\n    } finally {\n        utils.free(wasm_indices);\n    }\n\n    return target;\n}\n\n/**\n * Slice a ScranMatrix by its columns.\n * \n * @param {ScranMatrix} x - The matrix of interest.\n * @param {Array} indices - Column indices to extract.\n * Al indices must be a non-negative integer less than `mat.numberOfColumns()`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.inPlace=false] - Whether to modify `x` in place.\n * If `false`, a new ScranMatrix is returned.\n *\n * @return {ScranMatrix}\n * A new ScranMatrix containing the subset of columns from `mat` specified by `indices`.\n * If `inPlace = true`, this is a reference to `x`, otherwise it is a new ScranMatrix.\n */\nexport function subsetColumns(x, indices, { inPlace = false } = {}) {\n    let xcopy;\n    let target;\n    let wasm_indices;\n\n    try {\n        if (inPlace) {\n            target = x;\n        } else {\n            xcopy = x.clone();\n            target = xcopy;\n        }\n\n        wasm_indices = utils.wasmifyArray(indices, \"Int32WasmArray\");\n        wasm.call(module => module.column_subset(target.matrix, wasm_indices.offset, wasm_indices.length));\n\n    } catch (e) {\n        utils.free(xcopy);\n        throw e;\n\n    } finally {\n        utils.free(wasm_indices);\n    }\n\n    return target;\n}\n\n/**\n * Split a {@linkplain ScranMatrix} by row.\n *\n * @param {ScranMatrix} matrix - A ScranMatrix object.\n * @param {object} split - Object specifying how rows should be split.\n * Each value should be an Array/TypedArray of 0-based row indices.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.singleNull=false] - Whether `null` should be returned if `split` only contains one level and all rows are represented exactly once.\n * This can be used to avoid the creation of a redundant {@linkplain ScranMatrix} object.\n * @param {boolean} [options.createMultiMatrix=false] - Whether the output should be returned as a {@linkplain MultiMatrix}.\n *\n * @return {object|MultiMatrix} Object with the same keys as `split` where each value is a ScranMatrix for the corresponding subset of rows.\n * Alternatively, this is wrapped in a MultiMatrix if `createMultiMatrix = true`.\n */\nexport function splitRows(matrix, split, { singleNull = false, createMultiMatrix = false } = {}) { \n    let output = {};\n    let tkeys = Object.keys(split);\n\n    if (tkeys.length == 1) {\n        let chosen = split[tkeys[0]];\n        let consec = (chosen.length == matrix.numberOfRows());\n        if (consec) {\n            for (var i = 0; i < chosen.length; i++) {\n                if (i != chosen[i]) {\n                    consec = false;\n                    break;\n                }\n            }\n        }\n\n        if (consec) {\n            if (singleNull) {\n                return null;\n            } else {\n                output[tkeys[0]] = matrix.clone();\n                return output;\n            }\n        }\n    }\n\n    let stuff;\n    try {\n        for (const k of tkeys) {\n            output[k] = subsetRows(matrix, split[k]);\n        }\n\n        // Sticking this inside the trycatch, so that\n        // memory is released if the constructor fails. \n        if (createMultiMatrix) {\n            stuff = new MultiMatrix({ store: output });\n        }\n    } catch (e) {\n        for (const v of Object.values(output)) {\n            v.free();\n        }\n        throw e;\n    }\n\n    if (createMultiMatrix) {\n        return stuff;\n    } else {\n        return output;\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\"; \nimport { ScranMatrix } from \"./ScranMatrix.js\";\n\n/**\n * Initialize a sparse matrix from a dense array.\n *\n * @param {number} numberOfRows Number of rows in the matrix.\n * @param {number} numberOfColumns Number of columns in the matrix.\n * @param {WasmArray|Array|TypedArray} values Values of all elements in the matrix, stored in column-major order.\n * This is generally expected to contain non-negative integers; otherwise, users should set `forceInteger = false`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if `values` contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that `values` contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`.\n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromDenseArray(numberOfRows, numberOfColumns, values, { forceInteger = true, layered = true } = {}) {\n    var val_data; \n    var output;\n    var ids = null; \n\n    try {\n        val_data = utils.wasmifyArray(values, null);\n        if (val_data.length !== numberOfRows * numberOfColumns) {\n            throw new Error(\"length of 'values' is not consistent with supplied dimensions\");\n        }\n\n        output = gc.call(\n            module => module.initialize_sparse_matrix_from_dense_vector(\n                numberOfRows, \n                numberOfColumns, \n                val_data.offset, \n                val_data.constructor.className.replace(\"Wasm\", \"\"),\n                forceInteger,\n                layered\n            ),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(val_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/**\n * Initialize a sparse matrix from its compressed components.\n *\n * @param {number} numberOfRows Number of rows in the matrix.\n * @param {number} numberOfColumns Number of columns in the matrix.\n * @param {WasmArray} values Values of the non-zero elements.\n * This is generally expected to contain non-negative integers; otherwise, users should set `forceInteger = false`.\n * @param {WasmArray} indices Row indices of the non-zero elements.\n * This should be of the same length as `values`.\n * @param {WasmArray} pointers Pointers specifying the start of each column in `indices`.\n * This should have length equal to `numberOfColumns + 1`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.byColumn=true] - Whether the input arrays are supplied in the compressed sparse column format.\n * If `true`, `indices` should contain column indices and `pointers` should specify the start of each row in `indices`.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if `values` contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that `values` contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n * \n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */ \nexport function initializeSparseMatrixFromCompressedVectors(numberOfRows, numberOfColumns, values, indices, pointers, { byColumn = true, forceInteger = true, layered = true } = {}) {\n    var val_data;\n    var ind_data;\n    var indp_data;\n    var output;\n    var ids = null;\n\n    try {\n        val_data = utils.wasmifyArray(values, null);\n        ind_data = utils.wasmifyArray(indices, null);\n        indp_data = utils.wasmifyArray(pointers, null);\n        if (val_data.length != ind_data.length) {\n            throw new Error(\"'values' and 'indices' should have the same length\");\n        }\n        if (indp_data.length != (byColumn ? numberOfColumns : numberOfRows) + 1) {\n            throw new Error(\"'pointers' does not have an appropriate length\");\n        }\n\n        output = gc.call(\n            module => module.initialize_sparse_matrix(\n                numberOfRows, \n                numberOfColumns, \n                val_data.length, \n                val_data.offset, \n                val_data.constructor.className.replace(\"Wasm\", \"\"), \n                ind_data.offset, \n                ind_data.constructor.className.replace(\"Wasm\", \"\"), \n                indp_data.offset, \n                indp_data.constructor.className.replace(\"Wasm\", \"\"), \n                byColumn,\n                forceInteger,\n                layered\n            ),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(val_data);\n        utils.free(ind_data);\n        utils.free(indp_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/** \n * Initialize a sparse matrix from a buffer containing a MatrixMarket file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of a Matrix Market file with non-negative counts.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n * On browsers, this should be a path in the virtual filesystem, typically created with {@linkcode writeFile}. \n * @param {object} [options={}] - Optional parameters.\n * @param {?boolean} [options.compressed=null] - Whether the buffer is Gzip-compressed.\n * If `null`, we detect this automatically from the magic number in the header.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If `layered = true`, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If `layered = false`, this is `null`.\n */\nexport function initializeSparseMatrixFromMatrixMarket(x, { compressed = null, layered = true } = {}) {\n    var buf_data;\n    var output;\n    var ids = null;\n\n    try {\n        compressed = convert_compressed(compressed);\n        if (typeof x !== \"string\") {\n            buf_data = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            output = gc.call(\n                module => module.read_matrix_market_from_buffer(buf_data.offset, buf_data.length, compressed, layered),\n                ScranMatrix\n            );\n        } else {\n            output = gc.call(\n                module => module.read_matrix_market_from_file(x, compressed, layered),\n                ScranMatrix\n            );\n        }\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buf_data);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\nfunction convert_compressed(compressed) {\n    if (compressed === null) {\n        return -1;\n    } else if (compressed) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/** \n * Extract dimensions and other details from a MatrixMarket file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of a Matrix Market file with non-negative counts.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n * On browsers, this should be a path in the virtual filesystem, typically created with {@linkcode writeFile}. \n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.compressed=null] - Whether the buffer is Gzip-compressed.\n * If `null`, we detect this automatically from the magic number in the header.\n *\n * @return {object} An object containing the number of `rows`, `columns` and `lines` in the matrix.\n */\nexport function extractMatrixMarketDimensions(x, { compressed = null } = {}) {\n    var buf_data;\n    var stats = utils.createFloat64WasmArray(3);\n    let output = {};\n\n    try {\n        compressed = convert_compressed(compressed);\n        if (typeof x !== \"string\") {\n            buf_data = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            wasm.call(module => module.read_matrix_market_header_from_buffer(buf_data.offset, buf_data.length, compressed, stats.offset));\n        } else {\n            wasm.call(module => module.read_matrix_market_header_from_file(x, compressed, stats.offset));\n        }\n\n        let sarr = stats.array();\n        output.rows = sarr[0];\n        output.columns = sarr[1];\n        output.lines = sarr[2];\n\n    } finally {\n        utils.free(buf_data);\n        utils.free(stats);\n    }\n\n    return output;\n}\n\n/**\n * Initialize a layered sparse matrix from a HDF5 file.\n *\n * @param {string} file Path to the HDF5 file.\n * For browsers, the file should have been saved to the virtual filesystem.\n * @param {string} name Name of the dataset inside the file.\n * This can be a HDF5 Dataset for dense matrices or a HDF5 Group for sparse matrices.\n * For the latter, both H5AD and 10X-style sparse formats are supported.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce all elements to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if the relevant HDF5 dataset contains an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that the matrix contains only non-negative integers.\n * @param {?(Array|TypedArray|Int32WasmArray)} [options.subsetRow=null] - Row indices to extract.\n * All indices must be non-negative integers less than the number of rows in the sparse matrix.\n * @param {?(Array|TypedArray|Int32WasmArray)} [options.subsetColumn=null] - Column indices to extract.\n * All indices must be non-negative integers less than the number of columns in the sparse matrix.\n * @param {number} [options.cacheSize=100000000] - Size of the cache for loading chunks from HDF5 files. \n * Only really relevant when reading dense matrices, where a larger cache size may be necessary for handling large chunk dimensions efficiently.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *   If `subsetRow` was provided, `row_ids` contains indices into `subsetRow`, i.e., the i-th row in `matrix` is the `subsetRow[row_ids[i]]` row in the original matrix.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromHDF5(file, name, { forceInteger = true, layered = true, subsetRow = null, subsetColumn = null, cacheSize = 100000000 } = {}) {\n    var ids = null;\n    var output;\n    let wasm_row, wasm_col;\n\n    try {\n        let use_row_subset = (subsetRow !== null);\n        let row_offset = 0, row_length = 0;\n        if (use_row_subset) {\n            wasm_row = utils.wasmifyArray(subsetRow, \"Int32WasmArray\");\n            row_offset = wasm_row.offset;\n            row_length = wasm_row.length;\n        }\n\n        let use_col_subset = (subsetColumn !== null);\n        let col_offset = 0, col_length = 0;\n        if (use_col_subset) {\n            wasm_col = utils.wasmifyArray(subsetColumn, \"Int32WasmArray\");\n            col_offset = wasm_col.offset;\n            col_length = wasm_col.length;\n        }\n\n        output = gc.call(\n            module => module.read_hdf5_matrix(file, name, forceInteger, layered, use_row_subset, row_offset, row_length, use_col_subset, col_offset, col_length, cacheSize),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(wasm_row);\n        utils.free(wasm_col);\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n\n/**\n * Extract the format and dimensions of a HDF5 matrix.\n *\n * @param {string} file Path to the HDF5 file.\n * For browsers, the file should have been saved to the virtual filesystem.\n * @param {string} name Name of the dataset inside the file.\n * This can be a HDF5 Dataset for dense matrices or a HDF5 Group for sparse matrices.\n * For the latter, both H5AD and 10X-style sparse formats are supported.\n *\n * @return {object} An object containing:\n * - `rows`, the number of rows in the matrix.\n * - `columns`, the number of columns.\n * - `format`, whether the matrix is dense, CSR or CSC.\n * - `integer`, whether the matrix data is stored as integers or doubles.\n */\nexport function extractHDF5MatrixDetails(file, name) { \n    let output = {};\n    let arr = utils.createInt32WasmArray(5);\n    try {\n        wasm.call(module => module.extract_hdf5_matrix_details(file, name, arr.offset));\n\n        let vals = arr.array();\n        if (vals[0] > 0) {\n            output.format = \"dense\";\n        } else if (vals[1] > 0) {\n            output.format = \"csc\";\n        } else {\n            output.format = \"csr\";\n        }\n\n        output.rows = vals[2];\n        output.columns = vals[3];\n        output.integer = vals[4] > 0;\n    } finally {\n        arr.free();\n    }\n    return output;\n}\n\n/**\n * Initialize a dense matrix from a column-major array.\n *\n * @param {number} numberOfRows - Number of rows.\n * @param {number} numberOfColumns - Number of columns.\n * @param {(WasmArray|TypedArray|Array)} values - Array of length equal to the product of `numberOfRows` and `numberOfColumns`,\n * containing the values to store in the array.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce `values` to integers via truncation.\n *\n * @return {ScranMatrix} A dense matrix, filled by column with the contents of `values`.\n */\nexport function initializeDenseMatrixFromDenseArray(numberOfRows, numberOfColumns, values, { forceInteger = false } = {}) {\n    var tmp;\n    var output;\n\n    try {\n        tmp = utils.wasmifyArray(values, null);\n        output = gc.call(\n            module => module.initialize_dense_matrix(\n                numberOfRows, \n                numberOfColumns, \n                tmp.offset, \n                tmp.constructor.className.replace(\"Wasm\", \"\"),\n                forceInteger\n            ),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(tmp);\n    }\n\n    return output;\n}\n\n/**\n * Initialize a layered sparse matrix from an RDS file.\n *\n * @param {RdsObject} x - Handle to an object inside an RDS file.\n * This should be an integer/numeric matrix, `dgCMatrix` or `dgTMatrix` object.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.consume=false] - Whether to consume the values in `x` when creating the output sparse matrix.\n * Setting this to `true` improves memory efficiency at the cost of preventing any further use of `x`.\n * @param {boolean} [options.forceInteger=true] - Whether to coerce all elements to integers via truncation.\n * @param {boolean} [options.layered=true] - Whether to create a layered sparse matrix, which reorders the rows of the loaded matrix for better memory efficiency.\n * Only used if the R matrix is of an integer type and/or `forceInteger = true`.\n * Setting to `true` assumes that the matrix contains only non-negative integers.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the sparse matrix data.\n *   If layering is enabled, rows are shuffled to enable use of smaller integer types for low-abundance features.\n * - `row_ids`, an Int32Array specifying the identity of each row in `matrix`. \n *   This can be interpreted as the row slicing that was applied to the original matrix to obtain `matrix`.\n *   If layering is not enabled, this is `null`.\n *\n * Layering is enabled if the matrix contains integer data (either directly or via `forceInteger = true`) and `layered = true`.\n */\nexport function initializeSparseMatrixFromRds(x, { consume = false, forceInteger = true, layered = true } = {}) {\n    var ids = null;\n    var output;\n\n    try {\n        output = gc.call(\n            module => module.initialize_sparse_matrix_from_rds(x.object.$$.ptr, forceInteger, layered, consume),\n            ScranMatrix\n        );\n\n        if (output.isReorganized()) {\n            ids = output.identities();\n            output.wipeIdentities();\n        }\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n    }\n\n    return { \"matrix\": output, \"row_ids\": ids };\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\n\n/**\n * Results of per-gene variance modelling,\n * see [here](https://kanaverse.github.io/scran.js/ModelGeneVarResults.html) for details.\n *\n * @external ModelGeneVarResults\n */\n\n/**\n * Feature selection is performed by modelling the per-gene variance and finding highly variable genes.\n * This wraps the [`modelGeneVar`](https://kanaverse.github.io/scran.js/global.html#modelGeneVar) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class FeatureSelectionState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm' should be an RnaNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:ModelGeneVarResults} Variance modelling results,\n     * available after running {@linkcode FeatureSelectionState#compute compute}.\n     */\n    fetchResults() {\n        return this.#cache.results;\n    }\n\n    /**\n     * @return {Float64Array} Array of length equal to the number of genes,\n     * containing the sorted residuals after fitting a mean-dependent trend to the variances.\n     * Available after running {@linkcode FeatureSelectionState#compute compute}.\n     */\n    fetchSortedResiduals() {\n        return this.#cache.sorted_residuals;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference activity.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n \n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `feature_selection` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.span - Value between 0 and 1 specifying the span for the LOWESS smoother.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { span } = parameters;\n        this.changed = false;\n        \n        if (this.#norm.changed || span != this.#parameters.span) {\n            utils.freeCache(this.#cache.results);\n\n            if (this.valid()) {\n                let mat = this.#norm.fetchNormalizedMatrix();\n                let block = this.#filter.fetchFilteredBlock();\n                this.#cache.results = scran.modelGeneVar(mat, { span: span, block: block });\n\n                this.#cache.sorted_residuals = this.#cache.results.residuals().slice(); // a separate copy.\n                this.#cache.sorted_residuals.sort();\n\n                this.changed = true;\n            }\n\n            this.#parameters.span = span;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, permuter, filter, norm) {\n    let ghandle = handle.open(\"feature_selection\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            span: phandle.open(\"span\", { load: true }).values[0]\n        };\n    }\n\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n\n        if (\"means\" in rhandle.children) {\n            // Possibly permuting it to match the new permutation order;\n            // see 'unserialize' in 'inputs.js'.\n            let reloaded = {};\n            for (const key of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n                let value = rhandle.open(key, { load: true }).values;\n                reloaded[key] = permuter(value);\n            }\n\n            cache.results = scran.emptyModelGeneVarResults(reloaded.means.length, 1);\n            cache.results.means({ fillable: true }).set(reloaded.means);\n            cache.results.variances({ fillable: true }).set(reloaded.vars);\n            cache.results.fitted({ fillable: true }).set(reloaded.fitted);\n            cache.results.residuals({ fillable: true }).set(reloaded.resids);\n\n            cache.sorted_residuals = cache.results.residuals({ copy: true });\n            cache.sorted_residuals.sort();\n        }\n    }\n\n    return new FeatureSelectionState(filter, norm, parameters, cache);\n}\n\n","import * as methods from \"../file.js\";\n\nexport function temp(prefix, extension) {\n    let tmppath;\n    do {\n        tmppath = prefix + String(Number(new Date())) + \"_\" + String(Math.round(Math.random() * 10000)) + extension;\n    } while (methods.existsFile(tmppath));\n    return tmppath;\n}\n\nexport function handleString(file) {\n    throw new Error(\"cannot access the file system in a browser context\");\n}\n","import * as utils from \"./utils.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\nimport * as wasm from \"./wasm.js\";\n\n/**\n * Perform mutual nearest neighbor (MNN) correction on a low-dimensional representation.\n * This is primarily used to remove batch effects.\n *\n * @param {(RunPCAResults|TypedArray|Array|Float64WasmArray)} x - A matrix of low-dimensional results where rows are dimensions and columns are cells.\n * If this is a {@linkplain RunPCAResults} object, the PCs are automatically extracted.\n * Otherwise, the matrix should be provided as an array in column-major form, with specification of `numberOfDims` and `numberOfCells`.\n * @param {(Int32WasmArray|Array|TypedArray)} block - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to perform normalization within each block.\n * @param {object} [options={}] - Further optional parameters.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer of length equal to the product of the number of cells and dimensions,\n * to be used to store the corrected coordinates for each cell.\n * If `null`, this is allocated and returned by the function.\n * @param {?number} [options.numberOfDims=null] - Number of dimensions in `x`.\n * This should be specified if an array-like object is provided, otherwise it is ignored.\n * @param {?number} [options.numberOfCells=null] - Number of cells in `x`.\n * This should be specified if an array-like object is provided, otherwise it is ignored.\n * @param {number} [options.k=15] - Number of neighbors to use in the MNN search. \n * @param {number} [options.numberOfMADs=3] - Number of MADs to use to define the threshold on the distances to the neighbors,\n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {number} [options.robustIterations=2] - Number of robustness iterations to use for computing the center of mass,\n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {number} [options.robustTrim=0.25] - Proportion of furthest observations to remove during robustness iterations, \n * see comments [here](https://ltla.github.io/CppMnnCorrect).\n * @param {string} [options.referencePolicy=\"max-rss\"] - What policy to use to choose the first reference batch.\n * This can be the largest batch (`\"max-size\"`), the most variable batch (`\"max-variance\"`), the batch with the highest RSS (`\"max-rss\"`) or batch 0 in `block` (`\"input\"`).\n * @param {boolean} [options.approximate=true] - Whether to perform an approximate nearest neighbor search.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {Float64WasmArray} Array of length equal to `x`, containing the batch-corrected low-dimensional coordinates for all cells.\n * Values are organized using the column-major layout.\n * This is equal to `buffer` if provided.\n */\nexport function mnnCorrect(x, block, { \n    buffer = null, \n    numberOfDims = null,\n    numberOfCells = null,\n    k = 15,\n    numberOfMADs = 3, \n    robustIterations = 2, \n    robustTrim = 0.25,\n    referencePolicy = \"max-rss\",\n    approximate = true,\n    numberOfThreads = null\n} = {}) {\n\n    let local_buffer;\n    let x_data;\n    let block_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            x = x.principalComponents({ copy: \"view\" });\n        } else {\n            if (numberOfDims === null || numberOfCells === null || numberOfDims * numberOfCells !== x.length) {\n                throw new Error(\"length of 'x' must be equal to the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n            x_data = utils.wasmifyArray(x, \"Float64WasmArray\");\n            x = x_data;\n        }\n\n        if (buffer == null) {\n            local_buffer = utils.createFloat64WasmArray(numberOfCells * numberOfDims);\n            buffer = local_buffer;\n        } else if (buffer.length !== x.length) {\n            throw new Error(\"length of 'buffer' must be equal to the product of the number of dimensions and cells\");\n        }\n\n        block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n        if (block_data.length != numberOfCells) {\n            throw new Error(\"'block' must be of length equal to the number of cells in 'x'\");\n        }\n\n        wasm.call(module => module.mnn_correct(\n            numberOfDims, \n            numberOfCells,\n            x.offset,\n            block_data.offset,\n            buffer.offset,\n            k,\n            numberOfMADs,\n            robustIterations,\n            robustTrim,\n            referencePolicy,\n            approximate,\n            nthreads\n        ));\n\n    } catch (e) {\n        utils.free(local_buffer);\n        throw e;\n        \n    } finally {\n        utils.free(x_data);\n    }\n\n    return buffer; \n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as vec from \"./Vector.js\";\nimport * as olap from \"./overlap-utils.js\";\n\n/**\n * An IRanges object is a collection of integer ranges, inspired by the class of the same name from the Bioconductor ecosystem.\n * Each range consists of a start position and a width, and may be associated with arbitrary range-level metadata in a {@linkplain DataFrame}.\n * The IRanges defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * @extends Vector\n */\nexport class IRanges extends vec.Vector {\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array|TypedArray} start - Array of start positions for each range.\n     * This should be coercible into an Int32Array.\n     * @param {Array|TypedArray} width - Array of widths for each range.\n     * This should be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(start, width, { names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(start.length, { names, elementMetadata, metadata });\n\n        this._start = utils.convertToInt32Array(start);\n        utils.checkNonNegative(this._start, \"start\");\n\n        this._width = utils.convertToInt32Array(width);\n        utils.checkNonNegative(this._width, \"width\");\n\n        let n = this._start.length;\n        if (n !== this._width.length) {\n            throw new Error(\"'start' and 'width' should have the same length\");\n        }\n    }\n\n    static className = \"IRanges\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Int32Array} Array of integers containing the start position for each range.\n     */\n    start() {\n        return this._start;\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the end position (specifically, one-past-the-end) for each range.\n     */\n    end() {\n        return this._start.map((x, i) => x + this._width[i]);\n    }\n\n    /**\n     * @return {Int32Array} Array of integers containing the width of each range.\n     */\n    width() {\n        return this._width;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Array|TypedArray} value - Array of start positions for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this IRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {IRanges} The IRanges object after setting the start positions to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setStart(value, { inPlace = false } = {}) {\n        let candidate = utils.convertToInt32Array(value);\n        if (candidate.length !== generics.LENGTH(this)) {\n            throw new Error(\"'start' should be replaced by array of the same length\");\n        }\n        utils.checkNonNegative(candidate, \"start\");\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._start = candidate;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of start positions for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @return {IRanges} A reference to this IRanges object after setting the start positions to `value`.\n     */\n    $setStart(value) {\n        return this.setStart(value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of widths for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this IRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {IRanges} The IRanges object after setting the widths to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setWidth(value, { inPlace = false } = {}) {\n        let candidate = utils.convertToInt32Array(value);\n        if (candidate.length !== generics.LENGTH(this)) {\n            throw new Error(\"'width' should be replaced by array of the same length\");\n        }\n        utils.checkNonNegative(candidate, \"width\");\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._width = candidate;\n        return target;\n    }\n\n    /**\n     * @param {Array|TypedArray} value - Array of widths for each range.\n     * This should have length equal to the number of ranges and be coercible into an Int32Array.\n     * @return {IRanges} A reference to this IRanges object after setting the widths to `value`.\n     */\n    $setWidth(value) {\n        return this.setWidth(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {IRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain IRanges} instances.\n     */\n    buildOverlapIndex() {\n        let tree = olap.buildIntervalTree(this._start, this.end());\n        return new IRangesOverlapIndex(tree);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._start.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        output._start = generics.SLICE(this._start, i, { allowView });\n        output._width = generics.SLICE(this._width, i, { allowView });\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        let all_s = [];\n        let all_w = [];\n        for (const x of objects) {\n            all_s.push(x._start);\n            all_w.push(x._width);\n        }\n\n        output._start = generics.COMBINE(all_s);\n        output._width = generics.COMBINE(all_w);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._start = cutils.cloneField(this._start, deepCopy);\n        output._width = cutils.cloneField(this._width, deepCopy);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {IRanges} A zero-length IRanges object.\n     */\n    static empty() {\n        return new IRanges(new Int32Array, new Int32Array);\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain IRanges} objects.\n * This is typically constructed using the {@linkcode IRanges#buildOverlapIndex IRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query IRanges to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class IRangesOverlapIndex {\n    constructor(tree) {\n        this._tree = tree;\n    }\n\n    /**\n     * @param {IRanges} query - The query object, containing ranges to be overlapped with those in the reference IRanges (that was used to construct this IRangesOverlapIndex object).\n     * @return {Array} An array of length equal to the number of ranges in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain IRanges} object.\n     */\n    overlap(query) {\n        let n = generics.LENGTH(query);\n        let output = new Array(n);\n        for (var i = 0; i < n; i++) {\n            output[i] = olap.queryIntervalTree(query._start[i], query._start[i] + query._width[i], this._tree);\n        }\n        return output;\n    }\n}\n","import * as wasm from \"../wasm.js\";\nimport * as utils from \"../utils.js\"; \nimport * as wa from \"wasmarrays.js\";\n\nexport function computePerCellQcMetrics(x, subsets, run) {\n    var output;\n    var tmp_subsets = [];\n    var subset_offsets;\n\n    try {\n        let nsubsets = 0;\n        let offset_offset = 0;\n\n        if (subsets != null) {\n            nsubsets = subsets.length;\n            subset_offsets = utils.createBigUint64WasmArray(nsubsets);\n            offset_offset = subset_offsets.offset;\n            let offset_arr = subset_offsets.array();\n\n            for (var i = 0; i < nsubsets; i++) {\n                // This will either create a cheap view, or it'll clone\n                // 'subsets' into the appropriate memory space.\n                let current = utils.wasmifyArray(subsets[i], \"Uint8WasmArray\");\n                if (current.length != x.numberOfRows()) {\n                    throw new Error(\"length of each array in 'subsets' should be equal to the matrix rows\");\n                }\n                tmp_subsets.push(current);\n                offset_arr[i] = BigInt(current.offset);\n            }\n        }\n\n        output = run(x.matrix, nsubsets, offset_offset);\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(subset_offsets);\n        for (const y of tmp_subsets) {\n            utils.free(y);\n        }\n    }\n\n    return output;\n}\n","/* @license\nPapa Parse\nv5.5.3\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n((e,t)=>{\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof module&&\"undefined\"!=typeof exports?module.exports=t():e.Papa=t()})(this,function r(){var n=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==n?n:{};var d,s=!n.document&&!!n.postMessage,a=n.IS_PAPA_WORKER||!1,o={},h=0,v={};function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=b(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(t,e){var i=parseInt(this._config.skipFirstNLines)||0;if(this.isFirstChunk&&0<i){let e=this._config.newline;e||(r=this._config.quoteChar||'\"',e=this._handle.guessLineEndings(t,r)),t=[...t.split(e).slice(i)].join(e)}this.isFirstChunk&&U(this._config.beforeFirstChunk)&&void 0!==(r=this._config.beforeFirstChunk(t))&&(t=r),this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+t,r=(this._partialLine=\"\",this._handle.parse(i,this._baseIndex,!this._finished));if(!this._handle.paused()&&!this._handle.aborted()){t=r.meta.cursor,i=(this._finished||(this._partialLine=i.substring(t-this._baseIndex),this._baseIndex=t),r&&r.data&&(this._rowCount+=r.data.length),this._finished||this._config.preview&&this._rowCount>=this._config.preview);if(a)n.postMessage({results:r,workerId:v.WORKER_ID,finished:i});else if(U(this._config.chunk)&&!e){if(this._config.chunk(r,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);this._completeResults=r=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(r.data),this._completeResults.errors=this._completeResults.errors.concat(r.errors),this._completeResults.meta=r.meta),this._completed||!i||!U(this._config.complete)||r&&r.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),i||r&&r.meta.paused||this._nextChunk(),r}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):a&&this._config.error&&n.postMessage({workerId:v.WORKER_ID,error:e,finished:!1})}}function f(e){var r;(e=e||{}).chunkSize||(e.chunkSize=v.RemoteChunkSize),u.call(this,e),this._nextChunk=s?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),s||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!s),this._config.downloadRequestHeaders){var e,t=this._config.downloadRequestHeaders;for(e in t)r.setRequestHeader(e,t[e])}var i;this._config.chunkSize&&(i=this._start+this._config.chunkSize-1,r.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+i));try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}s&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize||r.responseText.length,this._finished=!this._config.chunkSize||this._start>=(e=>null!==(e=e.getResponseHeader(\"Content-Range\"))?parseInt(e.substring(e.lastIndexOf(\"/\")+1)):-1)(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){e=r.statusText||e;this._sendError(new Error(e))}}function l(e){(e=e||{}).chunkSize||(e.chunkSize=v.LocalChunkSize),u.call(this,e);var i,r,n=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,r=e.slice||e.webkitSlice||e.mozSlice,n?((i=new FileReader).onload=y(this._chunkLoaded,this),i.onerror=y(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input,t=(this._config.chunkSize&&(t=Math.min(this._start+this._config.chunkSize,this._input.size),e=r.call(e,this._start,t)),i.readAsText(e,this._config.encoding));n||this._chunkLoaded({target:{result:t}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function c(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){var e,t;if(!this._finished)return e=this._config.chunkSize,i=e?(t=i.substring(0,e),i.substring(e)):(t=i,\"\"),this._finished=!i,this.parseChunk(t)}}function p(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData(\"\")},this),this._streamCleanUp=y(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function i(m){var n,s,a,t,o=Math.pow(2,53),h=-o,u=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/,d=/^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/,i=this,r=0,f=0,l=!1,e=!1,c=[],p={data:[],errors:[],meta:{}};function y(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){if(p&&a&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+v.DefaultDelimiter+\"'\"),a=!1),m.skipEmptyLines&&(p.data=p.data.filter(function(e){return!y(e)})),_()){if(p)if(Array.isArray(p.data[0])){for(var e=0;_()&&e<p.data.length;e++)p.data[e].forEach(t);p.data.splice(0,1)}else p.data.forEach(t);function t(e,t){U(m.transformHeader)&&(e=m.transformHeader(e,t)),c.push(e)}}function i(e,t){for(var i=m.header?{}:[],r=0;r<e.length;r++){var n=r,s=e[r],s=((e,t)=>(e=>(m.dynamicTypingFunction&&void 0===m.dynamicTyping[e]&&(m.dynamicTyping[e]=m.dynamicTypingFunction(e)),!0===(m.dynamicTyping[e]||m.dynamicTyping)))(e)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&((e=>{if(u.test(e)){e=parseFloat(e);if(h<e&&e<o)return 1}})(t)?parseFloat(t):d.test(t)?new Date(t):\"\"===t?null:t):t)(n=m.header?r>=c.length?\"__parsed_extra\":c[r]:n,s=m.transform?m.transform(s,n):s);\"__parsed_extra\"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>c.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+c.length+\" fields but parsed \"+r,f+t):r<c.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+c.length+\" fields but parsed \"+r,f+t)),i}var r;p&&(m.header||m.dynamicTyping||m.transform)&&(r=1,!p.data.length||Array.isArray(p.data[0])?(p.data=p.data.map(i),r=p.data.length):p.data=i(p.data,0),m.header&&p.meta&&(p.meta.fields=c),f+=r)}function _(){return m.header&&0===c.length}function k(e,t,i,r){e={type:e,code:t,message:i};void 0!==r&&(e.row=r),p.errors.push(e)}U(m.step)&&(t=m.step,m.step=function(e){p=e,_()?g():(g(),0!==p.data.length&&(r+=e.data.length,m.preview&&r>m.preview?s.abort():(p.data=p.data[0],t(p,i))))}),this.parse=function(e,t,i){var r=m.quoteChar||'\"',r=(m.newline||(m.newline=this.guessLineEndings(e,r)),a=!1,m.delimiter?U(m.delimiter)&&(m.delimiter=m.delimiter(e),p.meta.delimiter=m.delimiter):((r=((e,t,i,r,n)=>{var s,a,o,h;n=n||[\",\",\"\\t\",\"|\",\";\",v.RECORD_SEP,v.UNIT_SEP];for(var u=0;u<n.length;u++){for(var d,f=n[u],l=0,c=0,p=0,g=(o=void 0,new E({comments:r,delimiter:f,newline:t,preview:10}).parse(e)),_=0;_<g.data.length;_++)i&&y(g.data[_])?p++:(d=g.data[_].length,c+=d,void 0===o?o=d:0<d&&(l+=Math.abs(d-o),o=d));0<g.data.length&&(c/=g.data.length-p),(void 0===a||l<=a)&&(void 0===h||h<c)&&1.99<c&&(a=l,s=f,h=c)}return{successful:!!(m.delimiter=s),bestDelimiter:s}})(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess)).successful?m.delimiter=r.bestDelimiter:(a=!0,m.delimiter=v.DefaultDelimiter),p.meta.delimiter=m.delimiter),b(m));return m.preview&&m.header&&r.preview++,n=e,s=new E(r),p=s.parse(n,t,i),g(),l?{meta:{paused:!0}}:p||{meta:{paused:!1}}},this.paused=function(){return l},this.pause=function(){l=!0,s.abort(),n=U(m.chunk)?\"\":n.substring(s.getCharIndex())},this.resume=function(){i.streamer._halted?(l=!1,i.streamer.parseChunk(n,!0)):setTimeout(i.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,s.abort(),p.meta.aborted=!0,U(m.complete)&&m.complete(p),n=\"\"},this.guessLineEndings=function(e,t){e=e.substring(0,1048576);var t=new RegExp(P(t)+\"([^]*?)\"+P(t),\"gm\"),i=(e=e.replace(t,\"\")).split(\"\\r\"),t=e.split(\"\\n\"),e=1<t.length&&t[0].length<i[0].length;if(1===i.length||e)return\"\\n\";for(var r=0,n=0;n<i.length;n++)\"\\n\"===i[n][0]&&r++;return r>=i.length/2?\"\\r\\n\":\"\\r\"}}function P(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function E(C){var S=(C=C||{}).delimiter,O=C.newline,x=C.comments,I=C.step,A=C.preview,T=C.fastMode,D=null,L=!1,F=null==C.quoteChar?'\"':C.quoteChar,j=F;if(void 0!==C.escapeChar&&(j=C.escapeChar),(\"string\"!=typeof S||-1<v.BAD_DELIMITERS.indexOf(S))&&(S=\",\"),x===S)throw new Error(\"Comment character same as delimiter\");!0===x?x=\"#\":(\"string\"!=typeof x||-1<v.BAD_DELIMITERS.indexOf(x))&&(x=!1),\"\\n\"!==O&&\"\\r\"!==O&&\"\\r\\n\"!==O&&(O=\"\\n\");var z=0,M=!1;this.parse=function(i,t,r){if(\"string\"!=typeof i)throw new Error(\"Input must be a string\");var n=i.length,e=S.length,s=O.length,a=x.length,o=U(I),h=[],u=[],d=[],f=z=0;if(!i)return w();if(T||!1!==T&&-1===i.indexOf(F)){for(var l=i.split(O),c=0;c<l.length;c++){if(d=l[c],z+=d.length,c!==l.length-1)z+=O.length;else if(r)return w();if(!x||d.substring(0,a)!==x){if(o){if(h=[],k(d.split(S)),R(),M)return w()}else k(d.split(S));if(A&&A<=c)return h=h.slice(0,A),w(!0)}}return w()}for(var p=i.indexOf(S,z),g=i.indexOf(O,z),_=new RegExp(P(j)+P(F),\"g\"),m=i.indexOf(F,z);;)if(i[z]===F)for(m=z,z++;;){if(-1===(m=i.indexOf(F,m+1)))return r||u.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:h.length,index:z}),E();if(m===n-1)return E(i.substring(z,m).replace(_,F));if(F===j&&i[m+1]===j)m++;else if(F===j||0===m||i[m-1]!==j){-1!==p&&p<m+1&&(p=i.indexOf(S,m+1));var y=v(-1===(g=-1!==g&&g<m+1?i.indexOf(O,m+1):g)?p:Math.min(p,g));if(i.substr(m+1+y,e)===S){d.push(i.substring(z,m).replace(_,F)),i[z=m+1+y+e]!==F&&(m=i.indexOf(F,z)),p=i.indexOf(S,z),g=i.indexOf(O,z);break}y=v(g);if(i.substring(m+1+y,m+1+y+s)===O){if(d.push(i.substring(z,m).replace(_,F)),b(m+1+y+s),p=i.indexOf(S,z),m=i.indexOf(F,z),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0);break}u.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:h.length,index:z}),m++}}else if(x&&0===d.length&&i.substring(z,z+a)===x){if(-1===g)return w();z=g+s,g=i.indexOf(O,z),p=i.indexOf(S,z)}else if(-1!==p&&(p<g||-1===g))d.push(i.substring(z,p)),z=p+e,p=i.indexOf(S,z);else{if(-1===g)break;if(d.push(i.substring(z,g)),b(g+s),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0)}return E();function k(e){h.push(e),f=z}function v(e){var t=0;return t=-1!==e&&(e=i.substring(m+1,e))&&\"\"===e.trim()?e.length:t}function E(e){return r||(void 0===e&&(e=i.substring(z)),d.push(e),z=n,k(d),o&&R()),w()}function b(e){z=e,k(d),d=[],g=i.indexOf(O,z)}function w(e){if(C.header&&!t&&h.length&&!L){var s=h[0],a=Object.create(null),o=new Set(s);let n=!1;for(let r=0;r<s.length;r++){let i=s[r];if(a[i=U(C.transformHeader)?C.transformHeader(i,r):i]){let e,t=a[i];for(;e=i+\"_\"+t,t++,o.has(e););o.add(e),s[r]=e,a[i]++,n=!0,(D=null===D?{}:D)[e]=i}else a[i]=1,s[r]=i;o.add(i)}n&&console.warn(\"Duplicate headers found and renamed.\"),L=!0}return{data:h,errors:u,meta:{delimiter:S,linebreak:O,aborted:M,truncated:!!e,cursor:f+(t||0),renamedHeaders:D}}}function R(){I(w()),h=[],u=[]}},this.abort=function(){M=!0},this.getCharIndex=function(){return z}}function g(e){var t=e.data,i=o[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,_(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:m,resume:m};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&_(t.workerId,t.results)}function _(e,t){var i=o[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete o[e]}function m(){throw new Error(\"Not implemented.\")}function b(e){if(\"object\"!=typeof e||null===e)return e;var t,i=Array.isArray(e)?[]:{};for(t in e)i[t]=b(e[t]);return i}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return\"function\"==typeof e}return v.parse=function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,!t.worker||!v.WORKERS_SUPPORTED)return i=null,v.NODE_STREAM_INPUT,\"string\"==typeof e?(e=(e=>65279!==e.charCodeAt(0)?e:e.slice(1))(e),i=new(t.download?f:c)(t)):!0===e.readable&&U(e.read)&&U(e.on)?i=new p(t):(n.File&&e instanceof File||e instanceof Object)&&(i=new l(t)),i.stream(e);(i=(()=>{var e;return!!v.WORKERS_SUPPORTED&&(e=(()=>{var e=n.URL||n.webkitURL||null,t=r.toString();return v.BLOB_URL||(v.BLOB_URL=e.createObjectURL(new Blob([\"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\"(\",t,\")();\"],{type:\"text/javascript\"})))})(),(e=new n.Worker(e)).onmessage=g,e.id=h++,o[e.id]=e)})()).userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,i.postMessage({input:e,config:t,workerId:i.id})},v.unparse=function(e,t){var n=!1,_=!0,m=\",\",y=\"\\r\\n\",s='\"',a=s+s,i=!1,r=null,o=!1,h=((()=>{if(\"object\"==typeof t){if(\"string\"!=typeof t.delimiter||v.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter),\"boolean\"!=typeof t.quotes&&\"function\"!=typeof t.quotes&&!Array.isArray(t.quotes)||(n=t.quotes),\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines),\"string\"==typeof t.newline&&(y=t.newline),\"string\"==typeof t.quoteChar&&(s=t.quoteChar),\"boolean\"==typeof t.header&&(_=t.header),Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s),t.escapeFormulae instanceof RegExp?o=t.escapeFormulae:\"boolean\"==typeof t.escapeFormulae&&t.escapeFormulae&&(o=/^[=+\\-@\\t\\r].*$/)}})(),new RegExp(P(s),\"g\"));\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if(\"object\"==typeof e[0])return u(r||Object.keys(e[0]),e,i)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||r),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:\"object\"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error(\"Unable to serialize unrecognized input\");function u(e,t,i){var r=\"\",n=(\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t)),Array.isArray(e)&&0<e.length),s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=k(e[a],a);0<t.length&&(r+=y)}for(var o=0;o<t.length;o++){var h=(n?e:t[o]).length,u=!1,d=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u=\"greedy\"===i?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===i&&n){for(var f=[],l=0;l<h;l++){var c=s?e[l]:l;f.push(t[o][c])}u=\"\"===f.join(\"\").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!d&&(r+=m);var g=n&&s?e[p]:p;r+=k(t[o][g],p)}o<t.length-1&&(!i||0<h&&!d)&&(r+=y)}}return r}function k(e,t){var i,r;return null==e?\"\":e.constructor===Date?JSON.stringify(e).slice(1,25):(r=!1,o&&\"string\"==typeof e&&o.test(e)&&(e=\"'\"+e,r=!0),i=e.toString().replace(h,a),(r=r||!0===n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||((e,t)=>{for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1})(i,v.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1))?s+i+s:i)}},v.RECORD_SEP=String.fromCharCode(30),v.UNIT_SEP=String.fromCharCode(31),v.BYTE_ORDER_MARK=\"\\ufeff\",v.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',v.BYTE_ORDER_MARK],v.WORKERS_SUPPORTED=!s&&!!n.Worker,v.NODE_STREAM_INPUT=1,v.LocalChunkSize=10485760,v.RemoteChunkSize=5242880,v.DefaultDelimiter=\",\",v.Parser=E,v.ParserHandle=i,v.NetworkStreamer=f,v.FileStreamer=l,v.StringStreamer=c,v.ReadableStreamStreamer=p,n.jQuery&&((d=n.jQuery).fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&n.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0===h.length)U(o.complete)&&o.complete();else{var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if(\"skip\"===s.action)return void u();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},v.parse(n.file,n.instanceConfig)}}function u(){h.splice(0,1),e()}}),a&&(n.onmessage=function(e){e=e.data;void 0===v.WORKER_ID&&e&&(v.WORKER_ID=e.workerId);\"string\"==typeof e.input?n.postMessage({workerId:v.WORKER_ID,results:v.parse(e.input,e.config),finished:!0}):(n.File&&e.input instanceof File||e.input instanceof Object)&&(e=v.parse(e.input,e.config))&&n.postMessage({workerId:v.WORKER_ID,results:e,finished:!0})}),(f.prototype=Object.create(u.prototype)).constructor=f,(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(c.prototype)).constructor=c,(p.prototype=Object.create(u.prototype)).constructor=p,v});","import * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\nimport * as gc from \"./gc.js\";\n\nfunction harvest_matrices(x) {\n    let output = utils.createBigUint64WasmArray(x.length);\n    let arr = output.array();\n    for (var i = 0; i < x.length; i++) {\n        arr[i] = BigInt(x[i].matrix.$$.ptr);\n    }\n    return output;\n}\n\n/**\n * Combine matrices by column, where all matrices contain data for the same features, in the same order.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * All of these should have the same number and order of features.\n *\n * @return {ScranMatrix} A {@linkplain ScranMatrix} containing the matrices after combining them by column.\n */\nexport function cbind(inputs) {\n    let mat_ptrs;\n    let output;\n\n    try {\n        mat_ptrs = harvest_matrices(inputs);\n        output = gc.call(\n            module => module.cbind(mat_ptrs.length, mat_ptrs.offset),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(mat_ptrs);\n    }\n\n    return output;\n}\n\n/**\n * Combine matrices by row, where all matrices contain data for the same cells, in the same order.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * All of these should have the same number and order of cells.\n *\n * @return {ScranMatrix} A {@linkplain ScranMatrix} containing the matrices after combining them by row.\n */\nexport function rbind(inputs) {\n    let mat_ptrs;\n    let output;\n\n    try {\n        mat_ptrs = harvest_matrices(inputs);\n        output = gc.call(\n            module => module.rbind(mat_ptrs.length, mat_ptrs.offset),\n            ScranMatrix\n        );\n    } catch (e) {\n        utils.free(output);\n        throw e;\n    } finally {\n        utils.free(mat_ptrs);\n    }\n\n    return output;\n}\n\n/**\n * Combine matrices by column, after subsetting each matrix to the intersection of common features.\n *\n * @param {Array} inputs - Array of one or more {@linkplain ScranMatrix} objects.\n * @param {Array} names - Array of length equal to `inputs`.\n * Each entry should be an Array containing the row names of the corresponding entry of `inputs`.\n * Names should correspond to the rows of that entry of `inputs`.\n *\n * @return {object} An object containing:\n * - `matrix`, a {@linkplain ScranMatrix} containing the combined matrices.\n * - `indices`, an Int32WasmArray of length equal to the number of rows in `matrix`.\n *    This contains the index of the row in the first entry of `inputs` corresponding to each row of `matrix`,\n *    i.e., the gene at the `i`-th row of `matrix` is the same as the gene at the `indices[i]`-th row of `inputs[0]`.\n * - `names`, an array of names identifying the rows of `matrix`.\n *    This is constructed by indexing the first entry of `names` with `indices`.\n */\nexport function cbindWithNames(x, names) {\n    let mat_ptrs;\n    let renamed = [];\n    let name_ptrs;\n    let indices;\n    let output = {};\n\n    try {\n        // Building a common set of rownames.\n        if (names.length !== x.length) {\n            throw new Error(\"length of 'names' should be equal to length of 'x'\");\n        }\n\n        let common = {};\n        let universe = [];\n        for (var i = 0; i < names.length; i++) {\n            if (x[i].numberOfRows() !== names[i].length) {\n                throw new Error(\"length of each 'names' must equal number of rows of its corresponding 'x'\");\n            }\n            names[i].forEach(x => {\n                if (!(x in common)) {\n                    common[x] = universe.length;\n                    universe.push(x);\n                }\n            });\n        }\n\n        name_ptrs = utils.createBigUint64WasmArray(x.length);\n        {\n            let names_arr = name_ptrs.array();\n            for (var i = 0; i < names.length; i++) {\n                let current = names[i];\n                let replacement = utils.createInt32WasmArray(current.length);\n                let replacement_arr = replacement.array();\n                current.forEach((x, i) => {\n                    replacement_arr[i] = common[x];\n                });\n                renamed.push(replacement);\n                names_arr[i] = BigInt(replacement.offset);\n            }\n        }\n\n        mat_ptrs = harvest_matrices(x);\n        indices = utils.createInt32WasmArray(x[0].numberOfRows());\n        output.matrix = gc.call(\n            module => module.cbind_with_rownames(x.length, mat_ptrs.offset, name_ptrs.offset, indices.offset),\n            ScranMatrix\n        );\n\n        output.indices = indices.slice(0, output.matrix.numberOfRows());\n        let internames = [];\n        for (const i of output.indices) {\n            internames.push(names[0][i]);\n        }\n        output.names = internames;\n\n    } catch (e) {\n        utils.free(output.matrix);\n        throw e;\n\n    } finally {\n        utils.free(mat_ptrs);\n        utils.free(name_ptrs);\n        utils.free(indices);\n        for (const x of renamed) {\n            utils.free(x);\n        }\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as inputs_module from \"./inputs.js\";\n\nexport const step_name = \"adt_quality_control\";\n\n/**\n * Results of computing per-cell ADT-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/PerCellAdtQcMetricsResults.html) for details.\n *\n * @external PerCellAdtQcMetricsResults\n */\n\n/**\n * Suggested filters for the ADT-derived QC metrics,\n * see [here](https://kanaverse.github.io/scran.js/SuggestAdtQcFiltersResults.html) for details.\n *\n * @external SuggestAdtQcFiltersResults\n */\n\n/**\n * This step applies quality control on the ADT count matrix.\n * Specifically, it computes the QC metrics and filtering thresholds, \n * wrapping the [`perCellAdtQcMetrics`](https://kanaverse.github.io/scran.js/global.html#perCellAdtQcMetrics)\n * and [`suggestAdtQcFilters`](https://kanaverse.github.io/scran.js/global.html#suggestAdtQcFilters) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * Note that the actual filtering is done by {@linkplain CellFilteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtQualityControlState {\n    #inputs;\n    #cache;\n    #parameters;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.metrics);\n        utils.freeCache(this.#cache.filters);\n        utils.freeCache(this.#cache.metrics_buffer);\n        utils.freeCache(this.#cache.discard_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let input = this.#inputs.fetchCountMatrix();\n        return input.has(\"ADT\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @return {external:SuggestAdtQcFiltersResults} Result of filtering on the ADT-derived QC metrics.\n     * This is available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchFilters() {\n        return this.#cache.filters;\n    }\n\n    /**\n     * @return {Uint8WasmArray} Buffer containing the discard vector of length equal to the number of cells,\n     * where each element is truthy if the corresponding cell is to be discarded.\n     * This is available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchDiscards() {\n        return this.#cache.discard_buffer;\n    }\n\n    /**\n     * @return {external:PerCellAdtQcMetricsResults} ADT-derived QC metrics,\n     * available after running {@linkcode AdtQualityControlState#compute compute}.\n     */\n    fetchMetrics() {\n        return this.#cache.metrics;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    static defaults() {\n        return {\n            automatic: true,\n            tag_id_column: null,\n            igg_prefix: \"IgG\",\n            nmads: 3,\n            min_detected_drop: 0.1\n        };\n    }\n\n    static configureFeatureParameters(lower_igg, annotations) {\n        let counter = val => {\n            let n = 0;\n            val.forEach(x => {\n                if (x.toLowerCase().startsWith(lower_igg)) {\n                    n++;\n                }\n            });\n            return n;\n        };\n\n        let best_key = null;\n        let best = 0;\n\n        let rn = annotations.rowNames();\n        if (rn !== null) {\n            best = counter(rn);\n        }\n\n        for (const key of annotations.columnNames()) {\n            let latest = counter(annotations.column(key));\n            if (latest > best) {\n                best_key = key;\n                best = latest;\n            }\n        }\n\n        return best_key;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     * \n     * @param {object} parameters - Parameter object, equivalent to the `adt_quality_control` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.automatic - Automatically choose feature-based parameters based on the feature annotations. \n     * Specifically, `tag_id_column` is set to the column with the most matches to `igg_prefix`.\n     * @param {?(string|number)} parameters.tag_id_column - Name or index of the column of the feature annotations that contains the tag identifiers.\n     * If `null`, the row names are used.\n     * Ignored if `automatic = true`.\n     * @param {?string} parameters.igg_prefix - Prefix of the identifiers for isotype controls.\n     * If `null`, no prefix-based identification is performed.\n     * @param {number} parameters.nmads - Number of MADs to use for automatically selecting the filter threshold for each metric.\n     * @param {number} parameters.min_detected_drop - Minimum proportional drop in the number of detected features before a cell is to be considered low-quality.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { igg_prefix, nmads, min_detected_drop } = parameters;\n        this.changed = false;\n\n        let automatic;\n        let tag_id_column; \n        if (\"automatic\" in parameters) {\n            automatic = parameters.automatic;\n            tag_id_column = parameters.tag_id_column;\n        } else {\n            automatic = true;\n            tag_id_column = null;\n        }\n\n        if (\n            this.#inputs.changed || \n            automatic !== this.#parameters.automatic ||\n            igg_prefix !== this.#parameters.igg_prefix ||\n            (!automatic && tag_id_column !== this.#parameters.tag_id_column)\n        ) {\n            utils.freeCache(this.#cache.metrics);\n\n            if (this.valid()) {\n                var tag_info = this.#inputs.fetchFeatureAnnotations()[\"ADT\"];\n                var subsets = utils.allocateCachedArray(tag_info.numberOfRows(), \"Uint8Array\", this.#cache, \"metrics_buffer\");\n                subsets.fill(0);\n\n                if (igg_prefix !== null) {\n                    var lower_igg = igg_prefix.toLowerCase();\n                    let key = tag_id_column;\n                    if (automatic) {\n                        key = AdtQualityControlState.configureFeatureParameters(lower_igg, tag_info);\n                    }\n\n                    let val = (key == null ? tag_info.rowNames() : tag_info.column(key));\n                    if (val !== null) {\n                        var sub_arr = subsets.array();\n                        val.forEach((x, i) => { \n                            if (x.toLowerCase().startsWith(lower_igg)) {\n                                sub_arr[i] = 1;                        \n                            }\n                        });\n                    }\n                }\n\n                var mat = this.#inputs.fetchCountMatrix().get(\"ADT\");\n                this.#cache.metrics = scran.perCellAdtQcMetrics(mat, [subsets]);\n                this.changed = true;\n            } else {\n                delete this.#cache.metrics;\n            }\n        }\n\n        this.#parameters.automatic = automatic;\n        this.#parameters.tag_id_column = tag_id_column;\n        this.#parameters.igg_prefix = igg_prefix;\n\n        if (this.changed || nmads !== this.#parameters.nmads || min_detected_drop !== this.#parameters.min_detected_drop) {\n            utils.freeCache(this.#cache.filters);\n\n            if (this.valid()) {\n                let block = this.#inputs.fetchBlock();\n                this.#cache.filters = scran.suggestAdtQcFilters(this.#cache.metrics, { numberOfMADs: nmads, minDetectedDrop: min_detected_drop, block: block });\n                var discard = utils.allocateCachedArray(this.#cache.metrics.numberOfCells(), \"Uint8Array\", this.#cache, \"discard_buffer\");\n                this.#cache.filters.filter(this.#cache.metrics, { block: block, buffer: discard });\n                this.changed = true;\n            } else {\n                delete this.#cache.filters;\n            }\n\n            this.#parameters.nmads = nmads;\n            this.#parameters.min_detected_drop = min_detected_drop;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, inputs) {\n    let cache = {};\n    let parameters = AdtQualityControlState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.igg_prefix = phandle.open(\"igg_prefix\", { load: true }).values[0];\n        parameters.nmads = phandle.open(\"nmads\", { load: true }).values[0];\n        parameters.min_detected_drop = phandle.open(\"min_detected_drop\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"metrics\" in rhandle.children) { // if skip=true or valid() is false, QC metrics may not be reported.\n                let mhandle = rhandle.open(\"metrics\");\n\n                let detected = mhandle.open(\"detected\", { load: true }).values;\n                cache.metrics = scran.emptyPerCellAdtQcMetricsResults(detected.length, 1);\n                cache.metrics.detected({ fillable: true }).set(detected);\n\n                let sums = mhandle.open(\"sums\", { load: true }).values;\n                cache.metrics.sums({ fillable: true }).set(sums);\n                let igg_total = mhandle.open(\"igg_total\", { load: true }).values;\n                cache.metrics.subsetTotals(0, { fillable: true }).set(igg_total);\n            }\n\n            if (\"thresholds\" in rhandle.children) { // if skip=true or valid() is false, QC thresholds may not be reported.\n                let discards = rhandle.open(\"discards\", { load: true }).values; \n                cache.discard_buffer = scran.createUint8WasmArray(discards.length);\n                cache.discard_buffer.set(discards);\n\n                let thandle = rhandle.open(\"thresholds\");\n                let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n                let thresholds_igg_total = thandle.open(\"igg_total\", { load: true }).values;\n\n                cache.filters = scran.emptySuggestAdtQcFiltersResults(1, thresholds_detected.length);\n                cache.filters.thresholdsDetected({ fillable: true }).set(thresholds_detected);\n                cache.filters.thresholdsSubsetTotals(0, { fillable: true }).set(thresholds_igg_total);\n            }\n\n            output = new AdtQualityControlState(inputs, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.metrics);\n            utils.freeCache(cache.filters)\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        output = new AdtQualityControlState(inputs, parameters, cache);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as correct_module from \"./batch_correction.js\";\n\nexport const step_name = \"neighbor_index\";\n\n/**\n * This step assembles the neighbor search indices from the PCs (see {@linkplain PcaState}) in preparation for nearest neighbor searches in downstream steps.\n * It wraps the [`buildNeighborSearchIndex`](https://kanaverse.github.io/scran.js/global.html#buildNeighborSearchIndex) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class NeighborIndexState {\n    #correct;\n    #parameters;\n    #cache;\n\n    constructor(correct, parameters = null, cache = null) {\n        if (!(correct instanceof correct_module.BatchCorrectionState)) {\n            throw new Error(\"'correct' should be a BatchCorrectionState object\");\n        }\n        this.#correct = correct;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.raw);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {BuildNeighborSearchIndexResults} Index for a nearest-neighbor search,\n     * available after running {@linkcode NeighborIndexState#compute compute}.\n     */\n    fetchIndex() {\n        if (!(\"raw\" in this.#cache)) {\n            this.#raw_compute(this.#parameters.approximate);\n        }\n        return this.#cache.raw;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    static defaults() {\n        return {\n            approximate: true\n        };\n    }\n\n    #raw_compute(approximate) {\n        this.#cache.raw = scran.buildNeighborSearchIndex(this.#correct.fetchCorrected(), { \n            approximate: approximate, \n            numberOfDims: this.#correct.fetchNumberOfDimensions(),\n            numberOfCells: this.#correct.fetchNumberOfCells()\n        });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `neighbor_index` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.approximate - Whether to create an approximate search index.\n     * If `false`, an exact index is used.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { approximate } = parameters;\n        this.changed = false;\n\n        if (this.#correct.changed || approximate != this.#parameters.approximate) {\n            utils.freeCache(this.#cache.raw);\n            this.#raw_compute(approximate);\n            this.#parameters.approximate = approximate;\n            this.changed = true;\n        }\n\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, pca) {\n    let ghandle = handle.open(\"neighbor_index\");\n\n    let parameters = {};\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            approximate: phandle.open(\"approximate\", { load: true }).values[0] > 0\n        };\n    }\n\n    let cache = {};\n    return new NeighborIndexState(pca, parameters, cache);\n}\n","import * as wa from \"wasmarrays.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Convert an arbitrary array into a R-style factor, with integer indices into an array of levels.\n * This is useful for formatting grouping or blocking vectors for {@linkcode scoreMarkers}, {@linkcode modelGeneVar}, etc.\n *\n * @param {Array|TypedArray} x - Array of values to be converted into a factor.\n * \n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.asWasmArray=true] - Whether to return an Int32WasmArray instance for the indices.\n * If `false`, an Int32Array is returned instead.\n * Only used if `buffer` is not supplied.\n * @param {?(Int32WasmArray|Int32Array)} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to that of `x`.\n * @param {?Array} [options.levels=null] - An existing array of known levels to be matched against `x`.\n * Values in `x` that are not in `levels` are considered to be invalid.\n * If `null`, the levels are automatically inferred from `x`; these will be sorted if all-numeric or all-string.\n * @param {string} [options.action=\"error\"] - Action to take when invalid values (i.e., null, NaNs) are detected in `x`.\n *\n * - `\"none\"`: the index is silently set to `placeholder`.\n * - `\"warn\"`: a warning is raised on the first occurrence of an invalid value, and the index is set to `placeholder`.\n * - `\"error\"`: an error is raised.\n * \n * @param {number} [options.placeholder=-1] - Placeholder index to use upon detecting invalid values in `x`.\n *\n * @return {object} Object containing:\n *\n * - `ids`: an Int32WasmArray or Int32Array of length equal to `x`, containing the index into `levels` for each cell.\n * - `levels`: an array of unique levels, such that `Array.from(ids).map(i => levels[i])` returns the same contents as `x` (aside from invalid values).\n *   If an input `levels` is supplied, this is returned directly.\n *\n * If `buffer` was supplied, it is used as the value of the `ids` property.\n */\nexport function convertToFactor(x, { asWasmArray = true, buffer = null, levels = null, action = \"error\", placeholder = -1 } = {}) {\n    let local_buffer;\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing invalid values with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected invalid value (e.g., null, NaN) in 'x'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling invalid entries\");\n    }\n\n    try {\n        if (buffer == null) {\n            local_buffer = (asWasmArray ? utils.createInt32WasmArray(x.length) : new Int32Array(x.length));\n            buffer = local_buffer;\n        } else {\n            if (buffer.length !== x.length) {\n                throw new Error(\"'buffer' should have length equal to that of 'x'\");\n            }\n            asWasmArray = buffer instanceof wa.Int32WasmArray;\n        }\n\n        let barr = (asWasmArray ? buffer.array() : buffer); // no allocations from this point onwards!\n        let mapping = new Map;\n\n        if (levels == null) {\n            levels = [];\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                if (y == null || (typeof y == \"number\" && !Number.isFinite(y))) {\n                    failure();\n                    barr[i] = placeholder;\n                    continue;\n                }\n\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    let n = levels.length;\n                    mapping.set(y, n);\n                    levels.push(y);\n                    barr[i] = n;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n\n            // Sorting them by default, to make life nicer.\n            if (levels.every(x => typeof x == \"string\")) {\n                let oldlevels = levels.slice();\n                levels.sort();\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            } else if (levels.every(x => typeof x == \"number\")) {\n                let oldlevels = levels.slice();\n                levels.sort((a, b) => a - b);\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            }\n\n        } else {\n            for (var l = 0; l < levels.length; l++) {\n                mapping.set(levels[l], l);\n            }\n\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    failure();\n                    barr[i] = placeholder;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n        }\n\n    } catch (e) {\n        if (local_buffer instanceof wa.WasmArray) {\n            utils.free(local_buffer);\n        }\n        throw e;\n    }\n\n    return {\n        ids: buffer,\n        levels: levels\n    };\n}\n\n// Back-compatible renaming.\nexport function factorize(x, options = {}) {\n    return convertToFactor(x, options);\n}\n\n/**\n * Reindex the factor indices to remove unused levels.\n * This is done by adjusting the indices such that every index from `[0, N)` is represented at least once, where `N` is the number of (used) levels.\n *\n * @param {Int32WasmArray|TypedArray|Array} x - Array of factor indices such as that produced by {@linkcode convertToFactor}. \n *\n * @return {Array} `x` is modified in place to remove unused levels.\n *\n * An array (denoted here as `y`) is returned that represents the mapping between the original and modified IDs,\n * i.e., running `x.map(i => y[i])` will recover the input `x`.\n * This is most commonly used to create a new array of levels, i.e., `y.map(i => old_levels[i])` will drop the unused levels. \n */\nexport function dropUnusedLevels(x) {\n    if (x instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        x = x.array();\n    }\n\n    let uniq = new Set(x);\n    let uniq_arr = Array.from(uniq).sort();\n    let mapping = {};\n    uniq_arr.forEach((y, i) => { mapping[y] = i; });\n\n    x.forEach((y, i) => {\n        x[i] = mapping[y];\n    });\n\n    return uniq_arr;\n}\n\n/**\n * Change the levels of a factor, updating the indices appropriately.\n *\n * @param {object} x - Factor object produced by {@linkcode convertToFactor}.\n * @param {Array} newLevels - Array of new levels.\n * This should be a superset of `x.levels`.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.action=\"error\"] - Action to take when `newLevels` is not a superset of `x.levels`.\n * This can be `\"error\"`, `\"warn\"` or `\"none\"`.\n * @param {number} [options.placeholder=-1] - Placeholder index corresponding to invalid values of `x.ids`.\n * Any placeholders in `x.ids` will be preserved on function return.\n * Additionally, if entries of `x.ids` refer to entries of `x.levels` that are missing in `newLevels`, they will be set to the placeholder value on function return;\n * this is only relevant if `action = \"warn\"` or `\"none\"`.\n *\n * @return `x` is modified by reference such that `x.levels` is set to `newLevels`.\n * `x.ids` is updated so that the indices now refer to the appropriate value in `newLevels`.\n */\nexport function resetLevels(x, newLevels, { action = \"error\", placeholder = -1 } = {}) {\n    let mapping = new Map;\n    for (var i = 0; i < newLevels.length; i++) {\n        mapping.set(newLevels[i], i);\n    }\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing missing levels with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected level in 'x.levels' that is missing from 'newLevels'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling missing levels\");\n    }\n\n    let oldLevels = x.levels;\n    let conversion = new Array(oldLevels.length);\n    let warned = false;\n    for (var i = 0; i < oldLevels.length; i++) {\n        let found = mapping.get(oldLevels[i]);\n        if (typeof found == \"undefined\") {\n            failure();\n            conversion[i] = placeholder;\n        } else {\n            conversion[i] = found;\n        }\n    }\n    x.levels = newLevels;\n\n    let target = x.ids;\n    if (target instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        target = target.array();\n    }\n    target.forEach((y, i) => {\n        if (y !== placeholder) {\n            target[i] = conversion[y];\n        }\n    });\n}\n\n/**\n * Subset a factor, possibly also dropping its unused levels.\n * This is typically based on the same filtering vector as {@linkcode filterCells}.\n *\n * @param {object} x - An object representing a factor, containing the following properties:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices.\n * - `levels`: An array of levels that can be indexed by entries of `ids`.\n *\n * This is typically produced by {@linkcode convertToFactor}. \n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n *\n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.drop=true] - Whether to drop unused levels in the output, see {@linkcode dropUnusedLevels}.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?(Int32Array|Int32WasmArray)} [options.buffer=null] - Array in which the output is to be stored, of the same type as `x.ids`.\n * If provided, this should be of length equal to `subset`, if `filter = null`;\n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {object} An object like `x`, containing:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices, subsetted from those in `x.ids`.\n * - `levels`: Array of levels that can be indexed by entries of the output `ids`.\n *   If `drop = true`, this may be a subset of `x.levels` where every entry is represented at least once in the output `ids`.\n *\n * If `buffer` is supplied, the returned `ids` will be set to `buffer`.\n */\nexport function subsetFactor(x, subset, { drop = true, filter = null, buffer = null } = {}) {\n    let output = { ids: null, levels: x.levels };\n\n    if (x.ids instanceof wa.WasmArray) {\n        output.ids = wa.subsetWasmArray(x.ids, subset, { filter, buffer });\n    } else {\n        let n = wa.checkSubsetLength(subset, filter, x.length, \"x\");\n        if (buffer == null) {\n            buffer = new x.ids.constructor(n);\n        }\n        wa.fillSubset(subset, filter, x.ids, buffer);\n        output.ids = buffer;\n    }\n\n    if (drop) {\n        let remapping = dropUnusedLevels(output.ids);\n        output.levels = remapping.map(i => x.levels[i]);\n    }\n    return output;\n}\n","export class SimpleFile {\n    #mode;\n    #buffer;\n    #file;\n    #name;\n\n    constructor(x, { name = null } = {}) {\n        if (x instanceof File) {\n            this.#mode = \"file\";\n            this.#file = x;\n            if (name === null) {\n                name = x.name;\n            }\n            this.#name = name;\n        } else if (x instanceof Uint8Array) {\n            this.#mode = \"buffer\";\n            this.#buffer = x; \n            if (name === null) {\n                throw new Error(\"'name' must be provided for Uint8Array inputs in SimpleFile constructor\");\n            }\n            this.#name = name;\n        } else {\n            throw new Error(\"unknown type '\" + typeof(x) + \"' for SimpleFile constructor\");\n        }\n    }\n\n    buffer({ copy = false } = {}) {\n        if (this.#mode == \"file\") {\n            let reader = new FileReaderSync();\n            let b = reader.readAsArrayBuffer(this.#file);\n            return new Uint8Array(b);\n        } else {\n            if (copy) {\n                return this.#buffer.slice();\n            } else {\n                return this.#buffer;\n            }\n        }\n    }\n\n    size() {\n        if (this.#mode == \"file\") {\n            return this.#file.size;\n        } else {\n            return this.#buffer.length;\n        }\n    }\n\n    name() {\n        return this.#name;\n    }\n\n    content({ copy = false } = {}) {\n        return this.buffer({ copy: copy });\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport * as internal from \"./internal/computePerCellQcFilters.js\";\nimport { PerCellRnaQcMetricsResults } from \"./perCellRnaQcMetrics.js\";\n\n/**\n * Wrapper class for the filtering results, produced by {@linkcode computeSuggestRnaQcFilters}.\n * @hideconstructor\n */\nexport class SuggestRnaQcFiltersResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetProportions;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetProportions = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the sums for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the number of detected genes for each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsDetected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the filtering threshold on the proportions for subset `i` in each batch.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    thresholdsSubsetProportions(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetProportions[i], \n            () => { this.#filledSubsetProportions[i] = true }, \n            COPY => utils.possibleCopy(this.#results.thresholds_proportions(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of blocks in this object.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @param {PerCellRnaQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellRnaQcMetrics}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell in `metrics`.\n     * This should have length equal to the number of cells and contain all values in `[0, n)` where `n` is the return value of {@linkcode SuggestRnaQcFilters#numberOfBlocks numberOfBlocks}.\n     *\n     * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n     * This will raise an error if multiple blocks were used to compute the thresholds.\n     * @param {?Uint8WasmArray} [options.buffer=null] - Array of length equal to the number of cells in `metrics`, to be used to store the low-quality calls.\n     *\n     * @return {Uint8Array} Array of length equal to the number of cells in `metrics`.\n     * Each entry is truthy if the corresponding cell is deemed to be of low-quality based on its values in `metrics`.\n     * If `buffer` is supplied, the returned array is a view on `buffer`.\n     */\n    filter(metrics, { block = null, buffer = null } = {}) {\n        if (!(metrics instanceof PerCellRnaQcMetricsResults)) {\n            throw new Error(\"'metrics' should be a PerCellRnaQcMetricsResults object\");\n        }\n        return internal.applyFilter(this.#results, metrics, block, buffer); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Define filters based on the per-cell QC metrics computed from an RNA count matrix.\n *\n * @param {PerCellRnaQcMetricsResults} metrics - Per-cell QC metrics, usually computed by {@linkcode perCellRnaQcMetrics}.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfMADs=3] - Number of median absolute deviations to use to define low-quality outliers.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to compute filters within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n *\n * @return {SuggestRnaQcFiltersResults} Object containing the filtering results.\n */\nexport function suggestRnaQcFilters(metrics, { numberOfMADs = 3, block = null } = {}) {\n    if (!(metrics instanceof PerCellRnaQcMetricsResults)) {\n        throw new Error(\"'metrics' should be a PerCellRnaQcMetricsResults object\");\n    }\n    return internal.computePerCellQcFilters(\n        metrics,\n        block,\n        (x, use_blocks, bptr) => gc.call(\n            module => module.suggest_rna_qc_filters(x.results.$$.ptr, use_blocks, bptr, numberOfMADs),\n            SuggestRnaQcFiltersResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain SuggestRnaQcFiltersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfSubsets Number of feature subsets.\n * @param {number} numberOfBlocks Number of blocks in the dataset.\n *\n * @return {SuggestRnaQcFiltersResults} Object with allocated memory to store QC filters, but no actual values.\n */\nexport function emptySuggestRnaQcFiltersResults(numberOfSubsets, numberOfBlocks) {\n    return gc.call(\n        module => new module.SuggestRnaQcFilters_Results(numberOfSubsets, numberOfBlocks),\n        SuggestRnaQcFiltersResults,\n        /* filled = */ false \n    );\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \nimport * as internal from \"./internal/computePerCellQcMetrics.js\";\n\n/**\n * Wrapper for the RNA-based metrics allocated on the Wasm heap, produced by {@linkcode perCellRnaQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellRnaQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetProportions;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetProportions = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count across genes for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected genes for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the proportion of counts in the subset `i` for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    subsetProportions(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetProportions[i], \n            () => { this.#filledSubsetProportions[i] = true }, \n            COPY => utils.possibleCopy(this.#results.subset_proportions(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute per-cell QC metrics from the RNA count matrix.\n *\n * @param {ScranMatrix} x - The RNA count matrix for genes.\n * @param {?Array} subsets - Array of arrays of boolean values specifying the feature subsets.\n * Each internal array corresponds to a subset and should be of length equal to the number of rows.\n * Each entry of each internal array specifies whether the corresponding row of `x` belongs to that subset; \n * any value interpretable as a boolean can be used here.\n * \n * Alternatively, each internal array may be any TypedArray or TypedWasmArray.\n * Each array should be of length equal to the number of rows and values are interpreted as booleans.\n *\n * Alternatively `null`, which is taken to mean that there are no subsets.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellRnaQcMetricsResults} Object containing the QC metrics.\n */\nexport function perCellRnaQcMetrics(x, subsets, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n     return internal.computePerCellQcMetrics(\n        x, \n        subsets, \n        (matrix, nsubsets, subset_offset) => gc.call(\n            module => module.per_cell_rna_qc_metrics(matrix, nsubsets, subset_offset, nthreads),\n            PerCellRnaQcMetricsResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellRnaQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode suggestRnaQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfSubsets - Number of feature subsets.\n *\n * @return {PerCellRnaQcMetricsResults} Object with allocated memory to store QC metrics, but no actual values.\n */\nexport function emptyPerCellRnaQcMetricsResults(numberOfCells, numberOfSubsets) {\n    return gc.call(\n        module => new module.PerCellRnaQcMetrics_Results(numberOfCells, numberOfSubsets),\n        PerCellRnaQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./rna_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"rna_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered matrix from the {@linkplain QualityControlState}.\n * It wraps the [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaNormalizationState {\n    #qc\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.RnaQualityControlState)) {\n            throw new Error(\"'qc' should be a RnaQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.sum_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"RNA\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing normalized expression values,\n     * available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the RNA-derived size factor for each cell.\n     * This is available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sum_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sum_buffer.length, \"Float64Array\", this.#cache, \"centered_buffer\");\n            scran.centerSizeFactors(this.#cache.sum_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"RNA\");\n        let buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"sum_buffer\");\n\n        var block = this.#filter.fetchFilteredBlock();\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        this.changed = false;\n        if (this.#qc.changed || this.#filter.changed) {\n            if (this.valid()) {\n                this.changed = true;\n            }\n        } \n\n        if (this.changed) {\n            this.#raw_compute();\n        }\n        return;\n    }\n\n    static defaults() {\n        return {};\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    return new RnaNormalizationState(qc, filter);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as snn_module from \"./snn_graph_cluster.js\";\nimport * as kmeans_module from \"./kmeans_cluster.js\";\n\n/**\n * This step chooses between the k-means and SNN graph clusterings from {@linkplain KmeansClusterState} and {@linkplain SnnGraphClusterState}, respectively.\n * We added this step to preserve the cache for each clustering step - \n * specifically, each clustering does not need to be recomputed when a user changes their choice.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class ChooseClusteringState {\n    #snn_cluster;\n    #kmeans_cluster;\n    #parameters;\n    #cache;\n\n    constructor(snn, kmeans, parameters = null, cache = null) {\n        if (!(snn instanceof snn_module.SnnGraphClusterState)) {\n            throw new Error(\"'snn' should be a State object from './snn_graph_cluster.js'\");\n        }\n        this.#snn_cluster = snn;\n\n        if (!(kmeans instanceof kmeans_module.KmeansClusterState)) {\n            throw new Error(\"'kmeans' should be a State object from './kmeans_cluster.js'\");\n        }\n        this.#kmeans_cluster = kmeans;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {}\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Int32WasmArray} Array of cluster assignments for each cell in the (filtered) dataset,\n     * available after running {@linkcode ChooseClusteringState#compute compute}.\n     */\n    fetchClusters() {\n        if (this.#parameters.method == \"snn_graph\") {\n            return this.#snn_cluster.fetchClusters();\n        } else if (this.#parameters.method == \"kmeans\") {\n            return this.#kmeans_cluster.fetchClusters();\n        }\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters };\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `choose_clustering` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {string} parameters.method - Clustering method to use, either `\"kmeans\"` or `\"snn_graph\"`.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { method } = parameters;\n        this.changed = true;\n        \n        if (method == this.#parameters.method) {\n            if (method == \"snn_graph\") {\n                if (!this.#snn_cluster.changed) {\n                    this.changed = false;\n                }\n            } else if (method == \"kmeans\") {\n                if (!this.#kmeans_cluster.changed) {\n                    this.changed = false;\n                }\n            }\n        }\n\n        this.#parameters.method = method;\n        return;\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, snn, kmeans) {\n    let ghandle = handle.open(\"choose_clustering\");\n\n    let parameters;\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            method: phandle.open(\"method\", { load: true }).values[0]\n        };\n    }\n\n    let cache = {};\n    return new ChooseClusteringState(snn, kmeans, parameters, cache);\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Filter out low-quality cells.\n *\n * @param {ScranMatrix} x The count matrix.\n * @param {(Uint8WasmArray|Array|TypedArray)} filters \n * An array of length equal to the number of columns in `x`, where truthy elements specify the cells to be discarded.\n *\n * @return {ScranMatrix} A matrix of the same type as `x`, filtered by column to remove all cells specified in `filters`. \n */\nexport function filterCells(x, filters) {\n    var filter_data;\n    var output;\n\n    try {\n        filter_data = utils.wasmifyArray(filters, \"Uint8WasmArray\");\n        if (filter_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'filters' must be equal to number of columns in 'x'\");\n        }\n        var ptr = filter_data.offset;\n\n        output = gc.call(\n            module => module.filter_cells(x.matrix, ptr, false),\n            x.constructor\n        );\n\n    } catch(e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(filter_data);\n    }\n\n    return output;\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as gr from \"./GRanges.js\";\nimport * as ggr from \"./GroupedGRanges.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\n\n/**\n * A RangedSummarizedExperiment is a {@linkplain SummarizedExperiment} subclass where each row represents a genomic interval.\n * As such, it stores an additional {@linkplain GRanges} or {@linkplain GroupedGRanges} of length equal to the number of rows,\n * where each element represents the genomic range(s) for the corresponding row of the SummarizedExperiment.\n *\n * The RangedSummarizedExperiment supports the same set of generics as the {@linkplain SummarizedExperiment}.\n * Each method will call the base method, with the following extensions:\n *\n * - {@linkcode SLICE_2D} will additionally slice the supplied genomic ranges by the desired `rows`.\n * - {@linkcode COMBINE_ROWS} will combine genomic ranges across objects.\n *   If some objects contain a GroupedGRanges and other objects contain GRanges, the latter will be coerced to a GroupedGRanges (where each group contains one range) before combining.\n *   If any object is a base SummarizedExperiment, a GroupedGRanges containing zero-length groups will be automatically constructed to attempt combining.\n * - {@linkcode COMBINE_COLUMNS} will use the genomic ranges from the first object.\n *\n * @extends SummarizedExperiment\n */\nexport class RangedSummarizedExperiment extends se.SummarizedExperiment {\n    #check_rowRanges(x) {\n        if (!(x instanceof gr.GRanges) && !(x instanceof ggr.GroupedGRanges)) {\n            throw new Error(\"'rowRanges' should be a 'GRanges' or 'GroupedGRanges' instance\");\n        }\n        if (generics.LENGTH(x) !== this._rowData.numberOfRows()) {\n            throw utils.formatLengthError(\"'rowRanges'\", \"the number of rows\");\n        }\n    }\n\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * All arrays should have the same number of rows and columns.\n     * @param {?(GRanges|GroupedGRanges)} rowRanges - Genomic ranges corresponding to each row.\n     *\n     * Alternatively, each row may correspond to a group of genomic ranges.\n     *\n     * If `null`, a {@linkplain GroupedGRanges} is constructed where each row corresponds to one group of ranges of zero length.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain SummarizedExperiment} constructor.\n     */\n    constructor(assays, rowRanges, options = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(assays, options);\n\n        if (rowRanges === null) {\n            rowRanges = ggr.GroupedGRanges.empty(this.numberOfRows());\n        } else {\n            this.#check_rowRanges(rowRanges);\n        }\n        this._rowRanges = rowRanges;\n\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} Genomic ranges corresponding to each row.\n     */\n    rowRanges() {\n        return this._rowRanges;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {GRanges} value - Genomic ranges corresponding to each row.\n     * This should have length equal to the number of rows in this RangedSummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Annotated instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {RangedSummarizedExperiment} The RangedSummarizedExperiment after modifying its `rowRanges`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowRanges(value, { inPlace = false } = {}) {\n        this.#check_rowRanges(value);\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowRanges = value;\n        return target;\n    }\n\n    /**\n     * @param {GRanges} value - Genomic ranges corresponding to each row.\n     * This should have length equal to the number of rows in this RangedSummarizedExperiment.\n     * @return {RangedSummarizedExperiment} A reference to this RangedSummarizedExperiment after modifying its `rowRanges`.\n     */\n    $setRowRanges(value) {\n        return this.setRowRanges(value, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        super._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n        if (rows !== null) {\n            output._rowRanges = generics.SLICE(this._rowRanges, rows);\n        } else {\n            output._rowRanges = this._rowRanges;\n        }\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        super._bioconductor_COMBINE_ROWS(output, objects);\n\n        let collected = [];\n        let has_empty = false;\n        let has_ggr = false;\n\n        for (var i = 0; i < objects.length; i++) {\n            let x = objects[i];\n            if (x instanceof RangedSummarizedExperiment) {\n                let y = x._rowRanges;\n                if (y instanceof ggr.GroupedGRanges) {\n                    has_ggr = true;\n                }\n                collected.push(y);\n            } else if (x instanceof se.SummarizedExperiment) {\n                has_empty = true;\n                collected.push(null);\n            } else {\n                throw new Error(\"objects to be combined must be SummarizedExperiments (failing for object \" + String(i) + \")\");\n            }\n        }\n\n        // Promoting nulls and GRanges to GroupedGRanges, if necessary.\n        if (has_empty || has_ggr) {\n            for (var i = 0; i < collected.length; i++) {\n                let current = collected[i];\n\n                if (current instanceof gr.GRanges) {\n                    let widths = new Int32Array(generics.LENGTH(current));\n                    widths.fill(1);\n\n                    let options = { \n                        rangeLengths: widths,\n                        names: current.names(),\n                        elementMetadata: current.elementMetadata(),\n                        metadata: current.metadata()\n                    };\n\n                    if (options.names !== null) {\n                        current = current.setNames(null);\n                    } \n\n                    if (options.elementMetadata.metadata().size > 0 || options.elementMetadata.numberOfColumns() > 0) {\n                        current = current.setElementMetadata(null);\n                    }\n\n                    if (options.metadata.size > 0) {\n                        current = current.setMetadata(new Map);\n                    }\n\n                    collected[i] = new ggr.GroupedGRanges(current, options);\n\n                } else if (current === null){\n                    collected[i] = ggr.GroupedGRanges.empty(objects[i].numberOfRows());\n                }\n            }\n        }\n\n        output._rowRanges = generics.COMBINE(collected);\n\n        return;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        super._bioconductor_COMBINE_COLUMNS(output, objects);\n\n        output._rowRanges = objects[0]._rowRanges;\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._rowRanges = cutils.cloneField(this._rowRanges, deepCopy);\n\n        return;\n    }\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\"; \nimport * as internal from \"./internal/computePerCellQcMetrics.js\";\n\n/**\n * Wrapper for the ADT-based metrics allocated on the Wasm heap, typically produced by {@linkcode computePerCellAdtQcMetrics}.\n * @hideconstructor\n */\nexport class PerCellAdtQcMetricsResults {\n    #id;\n    #results;\n\n    #filledSums;\n    #filledDetected;\n    #filledSubsetTotals;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        this.#filledSums = filled;\n        this.#filledDetected = filled;\n        this.#filledSubsetTotals = utils.spawnArray(this.numberOfSubsets(), filled);\n\n        return;\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total ADT count for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    sums({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSums, \n            () => { this.#filledSums = true }, \n            COPY => utils.possibleCopy(this.#results.sums(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the total number of detected ADT features for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledDetected, \n            () => { this.#filledDetected = true }, \n            COPY => utils.possibleCopy(this.#results.detected(), COPY)\n        );\n    }\n\n    /**\n     * @param {number} i - Index of the feature subset of interest.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {?boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the total count in the ADT subset `i` for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    subsetTotals(i, { copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSubsetTotals[i], \n            () => { this.#filledSubsetTotals[i] = true }, \n            COPY => utils.possibleCopy(this.#results.subset_totals(i), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of feature subsets in this object.\n     */\n    numberOfSubsets() {\n        return this.#results.num_subsets();\n    }\n\n    /**\n     * @return {number} Number of cells in this object.\n     */\n    numberOfCells() {\n        return this.#results.num_cells();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Compute the per-cell QC metrics from an ADT count matrix.\n *\n * @param {ScranMatrix} x - The ADT count matrix.\n * @param {?Array} subsets - Array of arrays of boolean values specifying the feature subsets.\n * Each internal array corresponds to a subset and should be of length equal to the number of rows.\n * Each entry of each internal array specifies whether the corresponding row of `x` belongs to that subset; \n * any value interpretable as a boolean can be used here.\n * \n * Alternatively, each internal array may be any TypedArray or TypedWasmArray.\n * Each array should be of length equal to the number of rows and values are interpreted as booleans.\n *\n * Alternatively `null`, which is taken to mean that there are no subsets.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {PerCellAdtQcMetricsResults} Object containing the ADT-based QC metrics.\n */\nexport function perCellAdtQcMetrics(x, subsets, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return internal.computePerCellQcMetrics(\n        x, \n        subsets, \n        (matrix, nsubsets, subset_offset) => gc.call(\n            module => module.per_cell_adt_qc_metrics(matrix, nsubsets, subset_offset, nthreads),\n            PerCellAdtQcMetricsResults\n        )\n    );\n}\n\n/**\n * Create an empty {@linkplain PerCellAdtQcMetricsResults} object, to be filled with custom results.\n * This is typically used to generate a convenient input into later {@linkcode computePerCellAdtQcFilters} calls.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfSubsets - Number of feature subsets.\n *\n * @return {PerCellAdtQcMetricsResults} Object with allocated memory but no actual values.\n */\nexport function emptyPerCellAdtQcMetricsResults(numberOfCells, numberOfSubsets) {\n    return gc.call(\n        module => new module.PerCellAdtQcMetrics_Results(numberOfCells, numberOfSubsets),\n        PerCellAdtQcMetricsResults,\n        /* filled = */ false \n    );\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as combine_module from \"./combine_embeddings.js\";\n\nexport const step_name = \"batch_correction\";\n\n/**\n * Correct for batch effects in PC space based on mutual nearest neighbors.\n * This wraps the [`mnnCorrect`](https://kanaverse.github.io/scran.js/global.html#mnnCorrect) function\n * from [**scran.js**](https://kanaverse.github.io/scran.js).\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class BatchCorrectionState {\n    #filter;\n    #combined;\n    #parameters;\n    #cache;\n\n    constructor(filter, combined, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(combined instanceof combine_module.CombineEmbeddingsState)) {\n            throw new Error(\"'pca' should be a CombineEmbeddingsState object\");\n        }\n        this.#combined = combined;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.corrected);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {Float64WasmArray} Buffer containing the batch-corrected embeddings as a column-major dense matrix,\n     * where the rows are the dimensions and the columns are the cells.\n     * This is available after running {@linkcode BatchCorrectionState#compute compute}.\n     */\n    fetchCorrected() {\n        return this.#cache.corrected;\n    }\n\n    /**\n     * @return {number} Number of cells in {@linkcode BatchCorrectionState#fetchCorrected fetchCorrected}.\n     */\n    fetchNumberOfCells() {\n        return this.#combined.fetchNumberOfCells();\n    }\n\n    /**\n     * @return {number} Number of dimensions in {@linkcode BatchCorrectionState#fetchCorrected fetchCorrected}.\n     */\n    fetchNumberOfDimensions() {\n        return this.#combined.fetchNumberOfDimensions();\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `batch_correction` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {string} parameters.method - The correction method to use.\n     * Currently this can be either `\"mnn\"` or `\"none\"`.\n     * If `\"mnn\"`, it is recommended that upstream PCA steps (i.e., {@linkplain RnaPcaState} and {@linkplain AdtPcaState}) use `block_method = \"weight\"`.\n     * @param {number} parameters.num_neighbors - Number of neighbors to use during MNN correction.\n     * @param {boolean} parameters.approximate - Whether to use an approximate method to identify MNNs.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        let { method, num_neighbors, approximate} = parameters;\n        this.changed = false;\n\n        if (this.#filter.changed || this.#combined.changed) {\n            this.changed = true;\n        }\n        let block = this.#filter.fetchFilteredBlock();\n        let needs_correction = (method == \"mnn\" && block !== null);\n\n        if (this.changed || method !== this.#parameters.method || num_neighbors !== this.#parameters.num_neighbors || approximate !== this.#parameters.approximate) { \n            if (needs_correction) {\n                let pcs = this.#combined.fetchCombined();\n                let corrected = utils.allocateCachedArray(pcs.length, \"Float64Array\", this.#cache, \"corrected\");\n                scran.mnnCorrect(pcs, block, { \n                    k: num_neighbors, \n                    buffer: corrected, \n                    numberOfCells: this.#combined.fetchNumberOfCells(), \n                    numberOfDims: this.#combined.fetchNumberOfDimensions(), \n                    approximate: approximate \n                });\n                this.changed = true;\n            }\n        }\n\n        if (this.changed) {\n            // If no correction is actually required, we shouldn't respond to\n            // changes in parameters, because they won't have any effect.\n            if (!needs_correction) {\n                utils.freeCache(this.#cache.corrected);\n                this.#cache.corrected = this.#combined.fetchCombined().view();\n            }\n        }\n\n        // Updating all parameters, even if they weren't used.\n        this.#parameters.method = method;\n        this.#parameters.num_neighbors = num_neighbors;\n        this.#parameters.approximate = approximate;\n        return;\n    }\n\n    static defaults() {\n        return {\n            method: \"mnn\",\n            num_neighbors: 15,\n            approximate: true\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, combined) {\n    let cache = {};\n    let parameters = BatchCorrectionState.defaults();\n    let output;\n    \n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.method = phandle.open(\"method\", { load: true }).values[0];\n        parameters.num_neighbors = phandle.open(\"num_neighbors\", { load: true }).values[0];\n        parameters.approximate = phandle.open(\"approximate\", { load: true }).values[0] > 0;\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"corrected\" in rhandle.children) {\n                let corrected = rhandle.open(\"corrected\", { load: true }).values;\n                cache.corrected = scran.createFloat64WasmArray(corrected.length);\n                cache.corrected.set(corrected);\n            } else {\n                // Creating a view from the upstream combined state.\n                let pcs = combined.fetchCombined();\n                cache.corrected = pcs.view();\n            }\n\n            output = new BatchCorrectionState(filter, combined, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.corrected);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        // Fallback for v1.\n        let ghandle = handle.open(\"pca\");\n\n        let rhandle = ghandle.open(\"results\");\n        if (\"corrected\" in rhandle.children) {\n            let corrected = rhandle.open(\"corrected\", { load: true }).values;\n            let corbuffer = utils.allocateCachedArray(corrected.length, \"Float64Array\", cache, \"corrected\");\n            corbuffer.set(corrected);\n        } else {\n            cache.corrected = combined.fetchCombined().view();\n        }\n\n        output = new BatchCorrectionState(filter, combined, parameters, cache);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as misc from \"./miscellaneous.js\";\n\n/**\n * Compute the length of a vector-like object.\n *\n * For Array and TypedArrays, this just returns the `length` property directly.\n *\n * Custom classes should provide a `_bioconductor_LENGTH` method to describe their length.\n * This method should accept no arguments. \n *\n * @param {*} x - Some vector-like object.\n * @return {number} Length of the object.\n */\nexport function LENGTH(x) {\n    if (\"_bioconductor_LENGTH\" in x) {\n        return x._bioconductor_LENGTH();\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'LENGTH' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    return x.length;\n}\n\n/**\n * Slice a vector-like object.\n *\n * For Array and TypedArrays, this just uses `slice()` or `subarray()`.\n *\n * Custom classes should provide a `_bioconductor_SLICE` method to create a slice.\n * This method should accept the same arguments as `SLICE` except for `x`.\n *\n * @param {*} x - Some vector-like object.\n * @param {Object|Array|TypedArray} i - An Array or TypedArray of integer indices specifying the slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.allowView=false] - Whether a view can be created to mimic the slice operation.\n * Whether this is actually done depends on the method, but may improve efficiency by avoiding unnecessary copies.\n *\n * @return {*} A vector-like object, typically of the same class as `x`, containing data for the specified slice.\n *\n * If `allowInPlace = true`, `x` _may_ be modified in place, and the return value _may_ be a reference to `x`. \n */\nexport function SLICE(x, i, { allowView = false } = {}) {\n    if (\"_bioconductor_SLICE\" in x) {\n        let output = new x.constructor;\n        x._bioconductor_SLICE(output, i, { allowView });\n        return output;\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'SLICE' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    if (i.constructor == Object) {\n        if (allowView && ArrayBuffer.isView(x)) {\n            return x.subarray(i.start, i.end);\n        } else {\n            return x.slice(i.start, i.end);\n        }\n    } else {\n        let output = new x.constructor(i.length);\n        i.forEach((y, j) => {\n            output[j] = x[y];\n        });\n        return output;\n    }\n}\n\n/**\n * Combine multiple vector-like objects.\n *\n * For Array and TypedArrays, the combined array is of a class that avoids information loss.\n *\n * Custom classes should provide a `_bioconductor_COMBINE` method to define the combining operation.\n * This method should accept the same arguments as `COMBINE`.\n *\n * @param {Array} objects - Array of vector-like objects to be combined.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE` method of the first element of `objects`.\n *\n * @return {*} A vector-like object containing the concatenated data from the input objects.\n * - If the first entry of `objects` is an instance of a custom class, the return value should be of the same class.\n * - If all `objects` are TypedArrays of the same class, the return value will be a TypedArray of that class.\n * - If any of the `objects` are Arrays, the return value will be an Array.\n * - If any of the `objects` are 64-bit TypedArrays of different classes, the return value will be an Array.\n * - Otherwise, for any other classes of TypedArrays in `objects`, the return value will be a Float64Array.\n */\nexport function COMBINE(objects) {\n    let x = objects[0];\n    if (\"_bioconductor_COMBINE\" in x) {\n        let output = new x.constructor;\n        x._bioconductor_COMBINE(output, objects);\n        return output;\n    }\n\n    if (!utils.isArrayLike(x)) {\n        throw new Error(\"no method for 'COMBINE' in '\" + x.constructor.name + \"' instance\");\n    }\n\n    // It is assumed that every 'y' is of some compatible Array-like type as well.\n    let total_LENGTH = 0;\n    let constructor = x.constructor;\n\n    for (const obj of objects) {\n        total_LENGTH += obj.length;\n        constructor = utils.chooseArrayConstructors(constructor, obj.constructor);\n    }\n\n    let output = new constructor(total_LENGTH);\n    let position = 0;\n    for (const obj of objects) {\n        if (\"set\" in output) {\n            output.set(obj, position);\n            position += obj.length;\n        } else {\n            obj.forEach(x => {\n                output[position] = x;\n                position++;\n            });\n        }\n    }\n\n    return output;\n}\n\n/**\n * Clone a vector-like object.\n * \n * For TypedArrays, this just uses `slice()`.\n * For Arrays, this creates a copy and runs `CLONE` on each element in the copy.\n *\n * Custom classes should provide a `_bioconductor_CLONE` method to define the cloning operation.\n * This method should accept the same arguments as `COMBINE` except for `x`.\n *\n * @param {*} x - Some vector-like object.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.deepCopy=true] - Whether to create a deep copy.\n * The exact interpretation of `deepCopy=false` is left to each method, but generally speaking, \n * any setter (`$`-marked) functions operating on the copy should not alter `x`.\n *\n * @return {*} A clone of `x`, i.e., the return value and `x` should not compare equal.\n * If `deepCopy=true`, all internal components are also cloned.\n */\nexport function CLONE(x, { deepCopy = true } = {}) {\n    if (x instanceof Object) {\n        let options = { deepCopy };\n        if (\"_bioconductor_CLONE\" in x) {\n            let output = new x.constructor;\n            x._bioconductor_CLONE(output, options);\n            return output;\n        }\n\n        if (utils.isArrayLike(x)) {\n            if (x.constructor == Array) {\n                return x.map(y => CLONE(y, options));\n            } else if (deepCopy) {\n                return x.slice();\n            } else {\n                return x.subarray();\n            }\n        }\n\n        if (x.constructor == Object) {\n            if (deepCopy) {\n                let output = {};\n                for (const [k, v] of Object.entries(x)) {\n                    output[k] = CLONE(v);\n                }\n                return output;\n            } else {\n                return { ...x };\n            }\n        }\n\n        if (x.constructor == Map) {\n            let output = new Map;\n            for (const [k, v] of x) {\n                output.set(k, deepCopy ? CLONE(v) : v);\n            }\n            return output;\n        }\n\n        if (x.constructor == Set) {\n            let output = new Set;\n            for (const k of x) {\n                output.add(deepCopy ? CLONE(k) : k);\n            }\n            return output;\n        }\n\n\n        throw new Error(\"unknown CLONE operation for instance of class '\" + x.constructor.name + \"'\");\n    }\n\n    // Immutable atomics should be all that's left.\n    return x;\n}\n\n/**\n * Split a vector-like object along its length according to the levels of a factor of the same length.\n * This works automatically for all classes for which there is a {@linkcode SLICE} method,\n * but custom classes may also choose to define their own `_bioconductor_SPLIT` method. \n *\n * @param {*} x - Some vector-like object.\n * @param {Array|TypedArray} factor - Array containing the factor to use for splitting.\n * This should have the same length as `x`.\n *\n * Alternatively, the output of {@linkcode presplitFactor} can be supplied.\n *\n * @return {Object} An object containing one key per level of `factor`,\n * where the value is the slice of `x` corresponding to the indices of that level in `factor`.\n */\nexport function SPLIT(x, factor) {\n    if (factor.constructor != Object) {\n        factor = misc.presplitFactor(factor);\n    }\n\n    if (\"_bioconductor_SPLIT\" in x) {\n        return x._bioconductor_SPLIT(factor);\n    }\n\n    let output = {};\n    for (const [k, v] of Object.entries(factor)) {\n        output[k] = SLICE(x, v);\n    }\n\n    return output;\n}\n\n/**\n * Return the number of rows for a two-dimensional object.\n * Custom classes should provide a `_bioconductor_NUMBER_OF_ROWS` method, accepting no arguments.\n *\n * @param {*} x - Some two-dimensional object.\n * @return {number} Number of rows.\n */\nexport function NUMBER_OF_ROWS(x) {\n    if (!(\"_bioconductor_NUMBER_OF_ROWS\" in x)) {\n        throw new Error(\"no 'NUMBER_OF_ROWS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    return x._bioconductor_NUMBER_OF_ROWS();\n}\n\n/**\n * Return the number of columns for a two-dimensional object.\n * Custom classes should provide a `_bioconductor_NUMBER_OF_COLUMNS` method, accepting no arguments.\n *\n * @param {*} x - Some two-dimensional object.\n * @return {number} Number of columns.\n */\nexport function NUMBER_OF_COLUMNS(x) {\n    if (!(\"_bioconductor_NUMBER_OF_COLUMNS\" in x)) {\n        throw new Error(\"no 'NUMBER_OF_COLUMNS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    return x._bioconductor_NUMBER_OF_COLUMNS();\n}\n\n/**\n * Slice a two-dimensional object by its rows and/or columns.\n *\n * Custom classes should provide a `_bioconductor_SLICE_2D` method, accepting the same arguments as this generic but with `x` replaced by an \"empty\" instance of the same class.\n * Each method should then fill the empty instance with the sliced contents of `x`.\n *\n * @param {*} x - Some two-dimensional object.\n * @param {?(Object|Array|TypedArray)} rows - An Array or TypedArray of integer indices specifying the row-wise slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n * \n * Alternatively `null`, to indicate that no slicing is to be performed on the rows.\n * @param {?(Object|Array|TypedArray)} columns - An Array or TypedArray of integer indices specifying the column-wise slice of `x` to retain.\n *\n * Alternatively, an object containing `start` and `end`, where the slice is defined as the sequence of consecutive integers in `[start, end)`.\n *\n * Alternatively `null`, to indicate that no slicing is to be performed on the columns.\n * @param {Object} [options={}] - Optional parameters.\n * @param {boolean} [options.allowView=false] - Whether a view can be created to mimic the slice operation.\n * Whether this is actually done depends on the method, but may improve efficiency by avoiding unnecessary copies.\n *\n * @return {*} A two-dimensional object, typically of the same class as `x`, containing data for the specified slice.\n */\nexport function SLICE_2D(x, rows, columns, { allowView = false } = {}) {\n    if (!(\"_bioconductor_SLICE_2D\" in x)) {\n        throw new Error(\"no 'SLICE_2D' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_SLICE_2D(output, rows, columns, { allowView });\n    return output;\n}\n\n/**\n * Combine multiple two-dimensional objects by row.\n * Custom classes should provide a `_bioconductor_COMBINE_ROWS` method to define the combining operation.\n * This method should accept:\n * - an \"empty\" instance of the class of the first object, to be populated with data.\n * - an array of objects to be combined, like `objects`.\n *\n * @param {Array} objects - Array of two-dimensional objects to be combined by row.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE_ROWS` method of the first element of `objects`.\n *\n * @return {*} A two-dimensional object containing the row-wise concatenated data from the input objects, typically of the same class as the first entry of `objects`.\n */\nexport function COMBINE_ROWS(objects) {\n    let x = objects[0];\n    if (!(\"_bioconductor_COMBINE_ROWS\" in x)) {\n        throw new Error(\"no 'COMBINE_ROWS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_COMBINE_ROWS(output, objects);\n    return output;\n}\n\n/**\n * Combine multiple two-dimensional objects by column.\n * Custom classes should provide a `_bioconductor_COMBINE_COLUMNS` method to define the combining operation.\n * This method should accept:\n * - an \"empty\" instance of the class of the first object, to be populated with data.\n * - an array of objects to be combined, like `objects`.\n *\n * @param {Array} objects - Array of two-dimensional objects to be combined by column.\n * It is assumed that the objects are of the same class, or at least compatible with each other -\n * for custom classes, the definition of \"compatibility\" depends on the `_bioconductor_COMBINE_COLUMNS` method of the first element of `objects`.\n *\n * @return {*} A two-dimensional object containing the column-wise concatenated data from the input objects, typically of the same class as the first entry of `objects`.\n */\nexport function COMBINE_COLUMNS(objects) {\n    let x = objects[0];\n    if (!(\"_bioconductor_COMBINE_COLUMNS\" in x)) {\n        throw new Error(\"no 'COMBINE_COLUMNS' method available for '\" + x.constructor.name + \"' instance\");\n    }\n    let output = new x.constructor;\n    x._bioconductor_COMBINE_COLUMNS(output, objects);\n    return output;\n}\n","import * as pako from \"pako\";\nimport ppp from \"papaparse\";\nimport * as astream from \"./abstract/stream.js\";\nimport * as afile from \"../abstract/file.js\";\n\nexport function extractHDF5Strings(handle, name) {\n    if (!(name in handle.children)) {\n        return null;\n    }\n\n    if (handle.children[name] !== \"DataSet\") {\n        return null;\n    }\n\n    let content = handle.open(name);\n    if (content.type !== \"String\") {\n        return null;\n    }\n\n    return content.load();\n}\n\n/**\n * Summarize an array, typically corresponding to a single column of per-cell annotation.\n * This can be used as part of a preflight response in a Reader.\n *\n * @param {Array|TypedArray} array - Per-cell annotation array of length equal to the number of cells for a given matrix.\n * An Array is treated as categorical data and should contain strings, while TypedArrays are treated as continuous data.\n * @param {object} [options] - Optional parameters.\n * @param {number} [options.limit=50] - Maximum number of unique values to report for categorical `x`.\n *\n * @return {object} Object containing `type`, a string indicating whether `array` was categorical or continuous.\n *\n * If `\"categorical\"`, the object will contain `values`, an array of unique values up to the length specified by `limit`.\n * It will also contain `truncated`, a boolean indicating whether the actual number of unique values exceeds `limit`.\n *\n * If `\"continuous\"`, the object will contain the numbers `min` and `max` specifying the minimum and maximum value in `x`, respectively.\n * `min` or `max` may be negative or positive infinity, respectively, if there is no bound on one or both ends.\n * If `min > max`, all values in `array` are `NaN`s such that no bound can be found.\n */\nexport function summarizeArray(array, { limit = 50 } = {}) {\n    if (array instanceof Array) {\n        let chosen = Array.from(new Set(array));\n        chosen.sort();\n        let truncated = false;\n        if (chosen.length > limit) {\n            chosen = chosen.slice(0, limit);\n            truncated = true;\n        }\n        return {\n            \"type\": \"categorical\",\n            \"values\": chosen,\n            \"truncated\": truncated\n        };\n    } else {\n        let min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;\n        array.forEach(x => {\n            if (x < min) {\n                min = x;\n            }\n            if (x > max) {\n                max = x;\n            }\n        });\n\n        return { \n            \"type\": \"continuous\",\n            \"min\": min, \n            \"max\": max \n        };\n    }\n}\n\nfunction guess_compression(x, compression) {\n    if (compression !== null) {\n        return compression;\n    }\n\n    let buffer;\n    if (x instanceof Uint8Array) {\n        buffer = x;\n    } else {\n        buffer = astream.peek(x, 3);\n    }\n\n    // Compare against magic words for auto-detection.\n    if (buffer.length >= 3 && buffer[0] == 0x1F && buffer[1] == 0x8B && buffer[2] == 0x08) {\n        return 'gz';\n    }\n\n    return 'none';\n}\n\nexport function unpackText(buffer, { compression = null } = {}) {\n    compression = guess_compression(buffer, compression);\n    let txt = (compression === \"gz\" ? pako.ungzip(buffer) : buffer);\n    const dec = new TextDecoder();\n    return dec.decode(txt);\n}\n\n// Soft-deprecated as of 1.1.0.\nexport function readLines(buffer, { compression = null } = {}) {\n    let decoded = unpackText(buffer, { compression: compression });\n    let lines = decoded.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] == \"\") { // ignoring the trailing newline.\n        lines.pop();\n    }\n    return lines;    \n}\n\nfunction merge_bytes(leftovers, decoder) {\n    let total = 0;\n    for (const x of leftovers) {\n        total += x.length;\n    }\n\n    let combined = new Uint8Array(total);\n    total = 0;\n    for (const x of leftovers) {\n        combined.set(x, total);\n        total += x.length;\n    }\n\n    return decoder.decode(combined);\n}\n\nasync function stream_callback(x, compression, chunkSize, callback) {\n    // Force the input to be either a Uint8Array or a file path string.\n    if (typeof x == \"string\") {\n        ;\n    } else if (x instanceof Uint8Array) {\n        ;\n    } else if (x instanceof afile.SimpleFile) {\n        x = x.content();\n    } else {\n        x = (new afile.SimpleFile(x, { name: \"dummy\" })).content();\n    }\n\n    if (guess_compression(x, compression) == \"gz\") {\n        await (new Promise((resolve, reject) => {\n            let gz = new pako.Inflate({ chunkSize: chunkSize });\n            gz.onData = callback;\n            gz.onEnd = status => {\n                if (status) {\n                    reject(\"gzip decompression failed; \" + gz.msg);\n                } else {\n                    resolve(null);\n                }\n            };\n\n            if (typeof x == \"string\") {\n                astream.stream(x, chunkSize, chunk => gz.push(chunk), null, reject);\n            } else {\n                gz.push(x);\n            }\n        }));\n        return;\n    }\n\n    // Remaining possibilities are uncompressed.\n    if (typeof x == \"string\") {\n        await (new Promise((resolve, reject) => astream.stream(x, chunkSize, callback, resolve, reject)));\n        return;\n    }\n\n    callback(x);\n    return;\n}\n\n/**\n * Read lines of text from a file, possibly with decompression.\n *\n * @param {string|Uint8Array|SimpleFile|File} x - Contents of the file to be read.\n * On Node.js, this may be a string containing a path to a file;\n * on browsers, this may be a File object.\n * @param {object} [options={}] - Optional parameters.\n * @param {?string} [options.compression=null] - Compression of `buffer`, either `\"gz\"` or `\"none\"`.\n * If `null`, it is determined automatically from the `buffer` header.\n * @param {number} [options.chunkSize=65536] - Chunk size in bytes to use for file reading (if `x` is a file path) and decompression (if `compression=\"gz\"`).\n * Larger values improve speed at the cost of memory.\n *\n * @return {Array} Array of strings where each entry contains a line in `buffer`.\n * The newline itself is not included in each string.\n * @async \n */\nexport async function readLines2(x, { compression = null, chunkSize = 65536 } = {}) {\n    const dec = new TextDecoder;\n    let leftovers = [];\n    let lines = [];\n\n    let callback = (chunk) => {\n        let last = 0;\n        for (var i = 0; i < chunk.length; i++) {\n            if (chunk[i] == 10) { // i.e., ASCII newline.\n                let current = chunk.subarray(last, i);\n                if (leftovers.length) {\n                    leftovers.push(current);\n                    lines.push(merge_bytes(leftovers, dec));\n                    leftovers = [];\n                } else {\n                    lines.push(dec.decode(current));\n                }\n                last = i + 1; // skip past the newline.\n            }\n        }\n\n        if (last != chunk.length) {\n            leftovers.push(chunk.slice(last)); // copy to avoid problems with ownership as chunk gets deref'd.\n        }\n    };\n\n    await stream_callback(x, compression, chunkSize, callback);\n\n    if (leftovers.length) {\n        lines.push(merge_bytes(leftovers, dec));\n    }\n\n    return lines;    \n}\n\n// Soft-deprecated as of 1.1.0.\nexport function readTable(buffer, { compression = null, delim = \"\\t\", firstOnly = false } = {}) {\n    let decoded = unpackText(buffer, { compression: compression });\n    let res = ppp.parse(decoded, { delimiter: delim, preview: (firstOnly ? 1 : 0) });\n\n    // Handle terminating newlines.\n    let last = res.data[res.data.length - 1];\n    if (last.length === 1 && last[0] === \"\") {\n        res.data.pop();\n    }\n\n    return res.data;\n}\n\n/**\n * Read a delimiter-separated table from a buffer, possibly with decompression.\n * This assumes that newlines represent the end of each row of the table, i.e., there cannot be newlines inside quoted strings.\n *\n * @param {string|Uint8Array|SimpleFile|File} x - Contents of the file to be read.\n * On Node.js, this may be a string containing a path to a file;\n * on browsers, this may be a File object.\n * @param {object} [options={}] - Optional parameters.\n * @param {?string} [options.compression=null] - Compression of `buffer`, either `\"gz\"` or `\"none\"`.\n * If `null`, it is determined automatically from the `buffer` header.\n * @param {string} [options.delim=\"\\t\"] - Delimiter between fields.\n * @param {number} [options.chunkSize=1048576] - Chunk size in bytes to use for file reading (if `x` is a path), parsing of rows, and decompression (if `compression=\"gz\"`).\n * Larger values improve speed at the cost of memory.\n *\n * @return {Array} Array of length equal to the number of lines in `buffer`.\n * Each entry is an array of strings, containing the `delim`-separated fields for its corresponding line.\n *\n * @async\n */\nexport async function readTable2(x, { compression = null, delim = \"\\t\", chunkSize = 1048576 } = {}) {\n    const dec = new TextDecoder;\n\n    let rows = [];\n    let parse = (str) => {\n        let out = ppp.parse(str, { delimiter: delim });\n        if (out.meta.aborted) {\n            let msg = \"failed to parse delimited file\";\n            for (const e of out.errors) {\n                msg += \"; \" + e.message;\n            }\n            throw new Error(msg);\n        }\n        for (const x of out.data) {\n            rows.push(x);\n        }\n    };\n\n    let leftovers = [];\n    let size_left = 0;\n    let callback = (chunk) => {\n        let last = 0;\n        for (var i = 0; i < chunk.length; i++) {\n            // We assume that all newlines are end-of-rows, i.e., there are no\n            // newlines inside quoted strings. Under this assumption, we can\n            // safely chunk the input stream based on newlines, parse each\n            // chunk, and then combine the parsing results together. To avoid\n            // too many parsing calls, we accumulate buffers until we hit \n            // the chunkSize and then we decode + parse them altogether.\n            if (chunk[i] == 10 && (i - last) + size_left >= chunkSize) {\n                let current = chunk.subarray(last, i);\n                if (leftovers.length) {\n                    leftovers.push(current);\n                    parse(merge_bytes(leftovers, dec));\n                    leftovers = [];\n                } else {\n                    parse(dec.decode(current));\n                }\n                last = i + 1; // skip past the newline.\n                size_left = 0;\n            }\n        }\n\n        if (last != chunk.length) {\n            leftovers.push(chunk.slice(last)); // copy to avoid problems with ownership as chunk gets deref'd.\n            size_left += chunk.length - last;\n        }\n    };\n\n    await stream_callback(x, compression, chunkSize, callback);\n\n    if (leftovers.length) {\n        let combined = merge_bytes(leftovers, dec);\n        parse(combined);\n        if (combined[combined.length - 1] == \"\\n\") { // guaranteed to have non-zero length, by virtue of how 'leftovers' is filled.\n            rows.pop();            \n        }\n    }\n\n    return rows;    \n}\n\n/**\n * Detect if an array contains only stringified numbers and, if so, convert it into a TypedArray.\n * Conversion will still be performed for non-number strings corresponding to missing values or explicit not-a-number entries.\n *\n * @param {Array} x Array of strings, usually corresponding to a column in a table read by {@linkcode readDSVFromBuffer}.\n *\n * @return {?Float64Array} A Float64Array is returned if `x` contains stringified numbers.\n * Otherwise, `null` is returned if the conversion could not be performed.\n */\nexport function promoteToNumber(x) {\n    let as_num = new Float64Array(x.length);\n\n    for (const [i, v] of Object.entries(x)) {\n        // See discussion at https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number.\n        let opt1 = Number(v);\n        let opt2 = parseFloat(v);\n        if (!isNaN(opt1) && !isNaN(opt2)) {\n            as_num[i] = opt1;\n        } else if (v === \"\" || v === \"NA\" || v == \"na\" || v == \"NaN\" || v == \"nan\") {\n            as_num[i] = NaN;\n        } else if (v == \"Inf\" || v == \"inf\") {\n            as_num[i] = Number.POSITIVE_INFINITY;\n        } else if (v == \"-Inf\" || v == \"-inf\") {\n            as_num[i] = Number.NEGATIVE_INFINITY;\n        } else {\n            return null;\n        }\n    }\n\n    return as_num;\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/**\n * Wrapper around the k-means clustering results on the Wasm heap, produced by {@linkcode clusterKmeans}.\n * @hideconstructor\n */\nexport class ClusterKmeansResults {\n    #id;\n    #results;\n\n    #filledClusters;\n    #filledSizes;\n    #filledCenters;\n    #filledWcss;\n    #filledIterations;\n    #filledStatus;\n\n    constructor(id, raw, filled = true) {\n        this.#results = raw;\n        this.#id = id;\n\n        this.#filledClusters = filled;\n        this.#filledSizes = filled;\n        this.#filledCenters = filled;\n        this.#filledWcss = filled;\n        this.#filledIterations = filled;\n        this.#filledStatus = filled;\n\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the results.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    /**\n     * @return {number} Number of clusters in the results.\n     */\n    numberOfClusters() {\n        return this.#results.num_clusters();\n    }\n\n    /**\n     * @param {number} iterations - Number of iterations.\n     * @return The specified number of iterations is set in this object.\n     * Typically only used after {@linkcode emptyClusterKmeansResults}.\n     */\n    setIterations(iterations) {\n        if (!this.#filledIterations) {\n            this.#filledIterations = true;\n        }\n        this.#results.set_iterations(iterations);\n        return;\n    }\n\n    /**\n     * @param {number} status - Status of the k-means clustering.\n     * @return The status is set in this object.\n     * Typically only used after {@linkcode emptyClusterKmeansResults}.\n     */\n    setStatus(status) {\n        if (!this.#filledStatus) {\n            this.#filledStatus = true;\n        }\n        this.#results.set_status(status);\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the cluster assignment for each cell.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusters({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledClusters, \n            () => { this.#filledClusters = true }, \n            COPY => utils.possibleCopy(this.#results.clusters(), COPY),\n            \"clusters\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Int32Array|Int32WasmArray)} Array containing the number of cells in each cluster.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusterSizes({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledSizes, \n            () => { this.#filledSizes = true }, \n            COPY => utils.possibleCopy(this.#results.cluster_sizes(), COPY),\n            \"clusterSizes\"\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the within-cluster sum of squares in each cluster.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    withinClusterSumSquares({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledWcss, \n            () => { this.#filledWcss = true }, \n            COPY => utils.possibleCopy(this.#results.wcss(), COPY)\n        );\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array containing the cluster centers in column-major format,\n     * where rows are dimensions and columns are the clusters.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    clusterCenters({ copy = true, fillable = false } = {}) {\n        return utils.checkFillness(\n            fillable, \n            copy, \n            this.#filledCenters, \n            () => { this.#filledCenters = true }, \n            COPY => utils.possibleCopy(this.#results.centers(), COPY)\n        );\n    }\n\n    /**\n     * @return {?number} Number of refinement iterations performed by the algorithm.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setIterations setIterations}.\n     */\n    iterations() {\n        if (!this.#filledIterations) {\n            return null;\n        } else {\n            return this.#results.iterations();\n        }\n    }\n\n    /**\n     * @return {?number} Status of the algorithm - anything other than zero usually indicates a problem with convergence.\n     * Alternatively `null`, if this value has not been filled by {@linkcode ClusterKmeansResults#setStatus setStatus}.\n     */\n    status() {\n        if (!this.#filledStatus) {\n            return null;\n        } else {\n            return this.#results.status();\n        }\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Cluster cells using k-means.\n *\n* @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {number} clusters Number of clusters to create.\n * This should not be greater than the number of cells.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {string} [options.initMethod=\"pca-part\"] - Initialization method.\n * Setting `\"random\"` will randomly select `clusters` cells as centers.\n * Setting `\"kmeans++\"` will use the weighted sampling approach of Arthur and Vassilvitskii (2007).\n * Setting `\"pca-part\"` will use PCA partitioning.\n * @param {number} [options.initSeed=5768] - Seed to use for random number generation during initialization.\n * @param {number} [options.initPCASizeAdjust=1] - Adjustment factor for the cluster sizes, used when `initMethod = \"pca-part\"`.\n * Larger values (up to 1) will prioritize partitioning of clusters with more cells.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {ClusterKmeansResults} Object containing the clustering results.\n */\nexport function clusterKmeans(x, clusters, { numberOfDims = null, numberOfCells = null, initMethod = \"pca-part\", initSeed = 5768, initPCASizeAdjust = 1, numberOfThreads = null } = {}) {\n    var buffer;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.cluster_kmeans(pptr, numberOfDims, numberOfCells, clusters, initMethod, initSeed, initPCASizeAdjust, nthreads),\n            ClusterKmeansResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ClusterKmeansResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfCells - Number of cells in the dataset.\n * @param {number} numberOfClusters - Number of clusters in the dataset.\n * @param {number} numberOfDimensions - Number of dimensions of the embedding used for clustering.\n *\n * @return {ClusterKmeansResults} Object with allocated memory to store variance modelling statistics, but no actual values.\n */\nexport function emptyClusterKmeansResults(numberOfCells, numberOfClusters, numberOfDimensions) {\n    return gc.call(\n        module => new module.ClusterKmeans_Result(numberOfCells, numberOfClusters, numberOfDimensions),\n        ClusterKmeansResults,\n        /* filled = */ false\n    );\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as gc from \"./gc.js\";\nimport * as packer from \"./internal/pack_strings.js\";\n\n/**\n * Base class for RDS objects.\n * @hideconstructor\n */\nexport class RdsObject {\n    constructor(id, raw, par) {\n        this.id = id;\n        this.object = raw;\n        this.parent = par;\n    }\n\n    /**\n     * @return {string} Type of the object.\n     */\n    type() {\n        return this.object.type();\n    }\n\n    /**\n     * Free the memory on the Wasm heap for this object.\n     */\n    free() {\n        if (this.object !== null) {\n            gc.release(this.id);\n            this.object = null;\n        }\n    }\n}\n\n/**\n * Vector-like R object.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsVector extends RdsObject {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @return{number} Length of the vector.\n     */\n    length() {\n        return this.object.size();\n    }\n\n    /**\n     * @return {Array} Names of all attributes.\n     */\n    attributeNames() {\n        return wasm.call(mod => {\n            this.object.fill_attribute_names();\n            let anames_buf = this.object.attribute_names_buffer();\n            let anames_len = this.object.attribute_names_length();\n            return packer.unpack_strings(anames_buf, anames_len);\n        });\n    }\n\n    /**\n     * @param {string} name - Name of the attribute of interest.\n     * @return {number} Index of `name` in the array of attributes from {@linkcode RdsVector#attributeNames attributeNames}.\n     * If `name` is not present, -1 is returned.\n     */\n    findAttribute(name) {\n        return wasm.call(mod => this.object.find_attribute(name));\n    }\n\n    /**\n     * @param {number|string} i - Index or name of the attribute of interest.\n     * @return {RdsObject} Value of the attribute.\n     */\n    attribute(i) {\n        if (typeof i == \"number\") {\n            return dispatch(mod => this.object.load_attribute_by_index(i), this.parent);\n        } else {\n            return dispatch(mod => this.object.load_attribute_by_name(i), this.parent);\n        }\n    }\n}\n\n/**\n * Integer vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsIntegerVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Int32Array|Int32WasmArray} Values of the integer vector.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * Boolean (i.e., boolean) vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsBooleanVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Int32Array|Int32WasmArray} Values of the logical vector.\n     * Zero values are falsey and values of 1 are truthy.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * Double-precision vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsDoubleVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean|string} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     *\n     * @return {Float64Array|Float64WasmArray} Values of the double vector.\n     */\n    values({ copy = true } = {}) {\n        return utils.possibleCopy(this.object.numeric_vector(), copy);\n    }\n}\n\n/**\n * String vector from R.\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsStringVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @return {Array} Values of the string vector.\n     */\n    values() {\n        return wasm.call(mod => {\n            this.object.fill_string_vector();\n            let buf = this.object.string_vector_buffer();\n            let len = this.object.string_vector_length();\n            return packer.unpack_strings(buf, len);\n        });\n    }\n}\n\n/**\n * Generic vector from R, typically known as a \"list\".\n *\n * @augments RdsVector \n * @hideconstructor\n */\nexport class RdsGenericVector extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * @param {number} index - Index of the list element of interest.\n     * @return {RdsObject} Value of the list element.\n     */\n    load(index) {\n        return dispatch(mod => this.object.load_list_element(index), this.parent);\n    }\n}\n\n/**\n * S4 object from R, containing slot data in its attributes.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsS4Object extends RdsObject {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n\n    /**\n     * Name of the R class.\n     */\n    className() {\n        return wasm.call(mod => this.object.class_name());\n    }\n\n    /**\n     * Name of the package that defines the class.\n     */\n    packageName() {\n        return wasm.call(mod => this.object.package_name());\n    }\n\n    /**\n     * @return {Array} Names of all attributes.\n     */\n    attributeNames() {\n        return wasm.call(mod => {\n            this.object.fill_attribute_names();\n            let anames_buf = this.object.attribute_names_buffer();\n            let anames_len = this.object.attribute_names_length();\n            return packer.unpack_strings(anames_buf, anames_len);\n        });\n    }\n\n    /**\n     * @param {string} name - Name of the attribute of interest.\n     * @return {number} Index of `name` in the array of attributes from {@linkcode RdsVector#attributeNames attributeNames}.\n     * If `name` is not present, -1 is returned.\n     */\n    findAttribute(name) {\n        return wasm.call(mod => this.object.find_attribute(name));\n    }\n\n    /**\n     * @param {number|string} i - Index or name of the attribute of interest.\n     * @return {RdsObject} Value of the attribute.\n     */\n    attribute(i) {\n        if (typeof i == \"number\") {\n            return dispatch(mod => this.object.load_attribute_by_index(i), this.parent);\n        } else {\n            return dispatch(mod => this.object.load_attribute_by_name(i), this.parent);\n        }\n    }\n}\n\n/**\n * NULL type in R.\n *\n * @augments RdsObject\n * @hideconstructor\n */\nexport class RdsNull extends RdsVector {\n    constructor(id, raw, par) {\n        super(id, raw, par);\n    }\n};\n\nfunction dispatch(fun, par) {\n    let obj = wasm.call(fun);\n\n    let tt = null;\n    try {\n        tt = obj.type();\n    } catch (e) {\n        obj.delete();\n        throw e;\n    }\n\n    // Remaining steps until gc.call() should be no-throw!\n    let cons;\n    if (tt == \"integer\") {\n        cons = RdsIntegerVector;\n    } else if (tt == \"double\") {\n        cons = RdsDoubleVector;\n    } else if (tt == \"boolean\") {\n        cons = RdsBooleanVector;\n    } else if (tt == \"string\") {\n        cons = RdsStringVector;\n    } else if (tt == \"vector\") {\n        cons = RdsGenericVector;\n    } else if (tt == \"S4\") {\n        cons = RdsS4Object;\n    } else if (tt == \"null\") {\n        cons = RdsNull;\n    } else {\n        cons = RdsObject;\n    }\n\n    return gc.call(mod => obj, cons, par);\n}\n\n/**\n * Details of the RDS file.\n * @hideconstructor\n */\nexport class RdsDetails {\n    #id;\n    #obj;\n\n    constructor(id, obj) {\n        this.#id = id;\n        this.#obj = obj;\n    }\n\n    /**\n     * @return {number} Version of the RDS format. This should be 3.\n     */\n    formatVersion() {\n        return this.#obj.format_version();\n    }\n\n    /**\n     * @return {string} The R version used to create the file.\n     */\n    writerVersion() {\n        let info = this.#obj.writer_version();\n        return String(info[0]) + \".\" + String(info[1]) + \".\" + String(info[2]);\n    }\n\n    /**\n     * @return {string} The minimum R version that can read the file.\n     */\n    readerVersion() {\n        let info = this.#obj.reader_version();\n        return String(info[0]) + \".\" + String(info[1]) + \".\" + String(info[2]);\n    }\n\n    /**\n     * @return {RdsObject} Interface into the underlying R object.\n     */\n    value() {\n        return dispatch(mod => this.#obj.load(), this); \n    }\n\n    /**\n     * Free the memory on the Wasm heap for this object.\n     * Doing so will invalidate all {@linkplain RdsObject} instances derived from this object, \n     * directly via {@linkcode RdsDetails#load} or indirectly \n     * (e.g., from further {@linkcode RdsVector#attribute RdsVector.attribute} or {@linkcode RdsGenericVector#load RdsGenericVector.load} calls).\n     */\n    free() {\n        if (this.#obj !== null) {\n            gc.release(this.#id);\n            this.#obj = null;\n        }\n    }\n}\n\n/**\n * Read the contents of an RDS file.\n *\n * @param {Uint8WasmArray|Array|TypedArray|string} buffer Byte array containing the contents of an RDS file.\n * This can be raw text or Gzip-compressed.\n * \n * Alternatively, this can be a string containing a file path to a MatrixMarket file.\n *\n * @return {RdsDetails} Details of the file.\n */\nexport function readRds(x) {\n    let tmp;\n    let output;\n\n    try {\n        if (typeof x == \"string\") {\n            output = gc.call(module => module.parse_rds_from_file(x), RdsDetails)\n        } else {\n            tmp = utils.wasmifyArray(x, \"Uint8WasmArray\");\n            output = gc.call(module => module.parse_rds_from_buffer(tmp.offset, tmp.length), RdsDetails);\n        }\n    } finally {\n        utils.free(tmp);\n    }\n\n    return output;\n}\n\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as markers from \"./utils/markers.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as choice_module from \"./choose_clustering.js\";\nimport * as rna_norm_module from \"./rna_normalization.js\";\nimport * as adt_norm_module from \"./adt_normalization.js\";\nimport * as crispr_norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"marker_detection\";\n\n/**\n * Results of marker detection,\n * see [here](https://www.kanaverse.github.io/scran.js/ScoreMarkersResults.html) for details.\n *\n * @external ScoreMarkersResults\n */\n\n/*********************\n ***** Internals *****\n *********************/\n\nfunction _free_results(cache) {\n    for (const v of Object.values(cache.raw)) {\n        utils.freeCache(v);\n    }\n    cache.raw = {};\n    markers.freeVersusResults(cache.versus);\n    delete cache.versus;\n}\n\nfunction _computeVersus(left, right, matrices, clusters, { cache = {}, block = null, lfc_threshold = 0, compute_auc = true } = {}) {\n    let cache_info = markers.locateVersusCache(left, right, cache);\n    let left_index = (cache_info.left_small ? 0 : 1);\n    let right_index = (cache_info.left_small ? 1 : 0);\n\n    if (cache_info.run) {\n        let new_clusters = [];\n        let keep = [];\n        let leftfound = false, rightfound = false;\n        clusters.forEach((x, i) => {\n            if (x == left) {\n                new_clusters.push(left_index);\n                keep.push(i);\n                leftfound = true;\n            } else if (x == right) {\n                new_clusters.push(right_index);\n                keep.push(i);\n                rightfound = true;\n            }\n        });\n\n        if (!leftfound || !rightfound) {\n            throw new Error(\"non-zero entries should be present for both requested clusters in versus mode\");\n        }\n\n        markers.computeVersusResults(matrices, new_clusters, block, keep, cache_info.cached, lfc_threshold, compute_auc);\n    }\n\n    return { \n        results: cache_info.cached,\n        left: left_index,\n        right: right_index\n    };\n}\n\n/*****************\n ***** State *****\n *****************/\n\n/**\n * This step performs marker detection for each cluster of cells by performing pairwise comparisons to each other cluster.\n * This wraps the [`scoreMarkers`](https://kanaverse.github.io/scran.js/global.html#scoreMarkers) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n * The clustering is obtained from the upstream {@linkplain ChooseClusteringState}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class MarkerDetectionState {\n    #filter;\n    #norm_states;\n    #choice;\n    #parameters;\n    #cache;\n\n    constructor(filter, norm_states, choice, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a State object from './cell_filtering.js'\");\n        }\n        this.#filter = filter;\n\n        if (!(norm_states.RNA instanceof rna_norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm_states.RNA' should be an RnaNormalizationState object\");\n        }\n        if (!(norm_states.ADT instanceof adt_norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm_states.ADT' should be an AdtNormalizationState object\");\n        }\n        if (!(norm_states.CRISPR instanceof crispr_norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm_states.CRISPR' should be an CrisprNormalizationState object\");\n        }\n        this.#norm_states = norm_states;\n\n        if (!(choice instanceof choice_module.ChooseClusteringState)) {\n            throw new Error(\"'choice' should be a State object from './choose_clustering.js'\");\n        }\n        this.#choice = choice;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? { \"raw\": {} } : cache);\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        _free_results(this.#cache);\n    }\n\n    /**\n     * Obtain the marker detection results for all modalities.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @return {object} Object where each key is a modality name and each value is an {@linkplain external:ScoreMarkersResults ScoreMarkerResults} object,\n     * containing marker detection statistics for all clusters.\n     */\n    fetchResults() {\n        return this.#cache.raw;\n    }\n\n    /**\n     * Parameters used to compute the results.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `marker_detection` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.lfc_threshold - Log-fold change threshold to use when computing the Cohen's d and AUC for each pairwise comparison.\n     * @param {boolean} parameters.compute_auc - Whether to compute the AUCs.\n     * Setting this to `false` will skip AUC calculations and improve speed and memory efficiency.\n     *\n     * @return The state is updated with new results.\n     */\n    compute(parameters) {\n        let { lfc_threshold, compute_auc } = parameters;\n        this.changed = false;\n        let changed_params = (lfc_threshold !== this.#parameters.lfc_threshold || compute_auc !== this.#parameters.compute_auc);\n        \n        for (const [k, v] of Object.entries(this.#norm_states)) {\n            if (!v.valid()) {\n                continue;\n            }\n\n            if (this.#choice.changed || v.changed || changed_params) {\n                var mat = v.fetchNormalizedMatrix();\n                var clusters = this.#choice.fetchClusters();\n                var block = this.#filter.fetchFilteredBlock();\n                \n                utils.freeCache(this.#cache.raw[k]);\n                this.#cache.raw[k] = scran.scoreMarkers(mat, clusters, { block: block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n\n                this.changed = true;\n            }\n        }\n\n        this.#parameters.lfc_threshold = lfc_threshold;\n        this.#parameters.compute_auc = compute_auc;\n        if (this.changed) {\n            markers.freeVersusResults(this.#cache.versus);\n        }\n\n        return;\n    }\n\n    /**\n     * @return {object} Default parameters that may be modified and fed into {@linkcode MarkerDetectionCore#compute compute}.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    // Soft-deprecated.\n    static computeVersusCustom(left, right, matrices, clusters, { cache = {}, block = null, lfc_threshold = 0, compute_auc = true } = {}) {\n        return computeVersus(left, right, matrices, clusters, { cache, block, lfc_threshold, compute_auc });\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two clusters for more detailed examination of the differences between them.\n     * It is assumed that {@linkcode runAnalysis} was already run on this MarkerDetectionState instance before calling this method.\n     *\n     * @param {number} left - Index of one cluster in which to find upregulated markers.\n     * @param {number} right - Index of another cluster to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` cluster in each ScoreMarkersResults object,\n     *    e.g., Cohen's d for the RNA markers of the `left` cluster are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` cluster in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` cluster are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        var clusters = this.#choice.fetchClusters();\n        var block = this.#filter.fetchFilteredBlock();\n\n        // No need to free this afterwards; we don't own the normalized matrices anyway.\n        let matrices = new scran.MultiMatrix;\n        for (const [modality, state] of Object.entries(this.#norm_states)) {\n            if (!state.valid()) {\n                continue;\n            }\n            matrices.add(modality, state.fetchNormalizedMatrix());\n        }\n\n        if (!(\"versus\" in this.#cache)) {\n            this.#cache[\"versus\"] = {};\n        }\n\n        return _computeVersus(left, right, matrices, clusters, { \n            cache: this.#cache.versus, \n            block: block,\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        });\n    }\n}\n\n/**********************\n ***** Standalone *****\n **********************/\n\n/**\n * Standalone version of {@linkplain MarkerDetectionState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own normalized matrices, groups and blocking factor to compute the various marker statistics for each group.\n * Users are also responsible for ensuring that the lifetime of the supplied objects exceeds that of the constructed MarkerDetectionStandalone instance,\n * i.e., the Wasm-related `free()` methods are not called while the MarkerDetectionStandalone instance is still in operation.\n */\nexport class MarkerDetectionStandalone {\n    #matrices;\n\n    #groups;\n    #group_levels;\n    #block;\n    #block_levels;\n\n    #cache;\n    #parameters;\n\n    /**\n     * @param {external:MultiMatrix} normalized - A {@linkplain external:MultiMatrix MultiMatrix} of log-normalized values for multiple modalities.\n     * @param {Array|TypedArray} groups - Array of length equal to the number of columns in any value of `normalized`, containing the group assignments for each column. \n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in any value of `normalized`, containing the block assignments for each column.\n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(normalized, groups, { block = null } = {}) {\n        // Checking dimensions.\n        let N = groups.length;\n\n        for (const k of normalized.available()) {\n            let v = normalized.get(k);\n            if (v.numberOfColumns() != N) {\n                throw new Error(\"all matrices in 'normalized' should have the same number of columns as the length of 'groups'\");\n            }\n        }\n\n        if (block !== null) {\n            if (block.length != N) {\n                throw new Error(\"'block' should have the same length as 'groups' if not null\");\n            }\n        }\n\n        let arrays = [ groups ];\n        if (block !== null) {\n            arrays.push(block);\n        }\n        let dump = utils.subsetInvalidFactors(arrays);\n\n        // Maybe taking a subset to eliminate invalid entries.\n        let new_matrices;\n        if (dump.retain !== null) {\n            new_matrices = new scran.MultiMatrix;\n            let temp = scran.createInt32WasmArray(dump.retain.length);\n            try {\n                temp.set(dump.retain);\n                for (const k of normalized.available()) {\n                    new_matrices.add(k, scran.subsetColumns(normalized.get(k), temp))\n                }\n            } catch (e) {\n                new_matrices.free();\n                throw e;\n            } finally {\n                scran.free(temp);\n            }\n        } else {\n            new_matrices = normalized.clone();\n        }\n\n        this.#matrices = new_matrices;\n        this.#groups = dump.arrays[0].ids;\n        this.#group_levels = dump.arrays[0].levels;\n\n        if (block !== null) {\n            this.#block = dump.arrays[1].ids;\n            this.#block_levels = dump.arrays[1].levels;\n        } else {\n            this.#block = null;\n            this.#block_levels = null;\n        }\n\n        this.#cache = { raw: {}, init: true };\n        this.#parameters = MarkerDetectionState.defaults();\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#groups);\n        scran.free(this.#block);\n        scran.free(this.#matrices);\n        _free_results(this.#cache);\n    }\n\n    /**\n     * @return {object} Marker detection results for the all modalities.\n     * Each key is a modality name and each value is an {@linkplain external:ScoreMarkersResults ScoreMarkerResults} object,\n     * containing marker detection statistics for all groups.\n     * This is available after running {@linkcode MarkerDetectionState#compute compute}.\n     */\n    fetchResults() {\n        return this.#cache.raw;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the grouping factor.\n     * Group indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchGroupLevels({ copy = true } = {}) {\n        let ret = this.#group_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the blocking factor.\n     * Block indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchBlockLevels({ copy = true } = {}) {\n        let ret = this.#block_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#matrices;\n    }\n\n    _peekGroups() {\n        return this.#groups;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode MarkerDetectionState#defaults MarkerDetectionState.defaults}.\n     *\n     * @param {object} parameters - Parameter object, see the argument of the same name in {@linkcode MarkerDetectionState#compute MarkerDetectionState.compute} for more details.\n     *\n     * @return The state is updated with new parameters.\n     */\n    setParameters(parameters) {\n        if (this.#parameters.lfc_threshold !== parameters.lfc_threshold || this.#parameters.compute_auc !== parameters.compute_auc) {\n            // Removing existing results, as they are now invalid.\n            _free_results(this.#cache);\n        }\n        this.#parameters = { ...parameters };\n        return;\n    }\n\n    /**\n     * Compute markers for all groups.\n     *\n     * @return The state is updated with new results.\n     */\n    computeAll() {\n        let { lfc_threshold, compute_auc } = this.#parameters;\n        for (const k of this.#matrices.available()) {\n            var mat = this.#matrices.get(k);\n            utils.freeCache(this.#cache.raw[k]);\n            this.#cache.raw[k] = scran.scoreMarkers(mat, this.#groups, { block: this.#block, lfcThreshold: lfc_threshold, computeAuc: compute_auc });\n        }\n        return;\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two groups, \n     * for more detailed examination of the differences between them.\n     *\n     * @param {number} left - Index of one group in which to find upregulated markers.\n     * @param {number} right - Index of another group to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two groups.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` group in each ScoreMarkersResults object,\n     *    e.g., Cohen's d for the RNA markers of the `left` group are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` group in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` group are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        if (!(\"versus\" in this.#cache)) {\n            this.#cache[\"versus\"] = {};\n        }\n        return _computeVersus(left, right, this.#matrices, this.#groups, { \n            cache: this.#cache.versus, \n            block: this.#block,\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        });\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nfunction fill_results(stats, num_blocks) {\n    let keys = Object.keys(stats);\n    let first = stats[keys[0]];\n    let ngenes = first.means.length;\n    let object = scran.emptyScoreMarkersResults(ngenes, keys.length, num_blocks, { computeAuc: (\"auc\" in first) });\n\n    for (const k of keys) {\n        let i = Number(k);\n        let vals = stats[k];\n        object.means(i, { fillable: true }).set(vals.means);\n        object.detected(i, { fillable: true }).set(vals.detected);\n\n        for (const [s, v] of Object.entries(vals.cohen)) {\n            object.cohen(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        for (const [s, v] of Object.entries(vals.lfc)) {\n            object.lfc(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        for (const [s, v] of Object.entries(vals.delta_detected)) {\n            object.deltaDetected(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n        }\n\n        if (\"auc\" in vals) {\n            for (const [s, v] of Object.entries(vals.auc)) {\n                object.auc(i, { summary: markers.summaries2int[s], fillable: true }).set(v);\n            }\n        }\n    }\n\n    return object;\n}\n\nexport function unserialize(handle, permuters, filter, norm_states, choice) {\n    let ghandle = handle.open(\"marker_detection\");\n\n    let parameters = MarkerDetectionState.defaults();\n    {\n        let phandle = ghandle.open(\"parameters\");\n        if (\"lfc_threshold\" in phandle.children) {\n            parameters.lfc_threshold = phandle.open(\"lfc_threshold\", { load: true }).values[0];\n        }\n        if (\"compute_auc\" in phandle.children) {\n            parameters.compute_auc = phandle.open(\"compute_auc\", { load: true }).values[0] > 0;\n        }\n    }\n\n    // Figure out the number of blocks.\n    let num_blocks = 1;\n    {\n        let filtered = filter.fetchFilteredBlock();\n        if (filtered != null) {\n            filtered.forEach(x => {\n                if (x + 1 > num_blocks) {\n                    num_blocks = x + 1;\n                }\n            });\n        }\n    }\n\n    // Set up the marker detection statistics.\n    let cache = {};\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.raw = {};\n\n        if (\"clusters\" in rhandle.children) { \n            // below v2.0\n            let chandle = rhandle.open(\"clusters\");\n            let clusters = {};\n            for (const cl of Object.keys(chandle.children)) {\n                clusters[Number(cl)] = markers.unserializeGroupStats(chandle.open(cl), permuters[\"RNA\"], { compute_auc: parameters.compute_auc });\n            }\n            cache.raw.RNA = fill_results(clusters, num_blocks);\n        } else {\n            // after v2.0.\n            let chandle = rhandle.open(\"per_cluster\");\n            for (const a of Object.keys(chandle.children)) {\n                let clusters = {};\n                let ahandle = chandle.open(a);\n                for (const cl of Object.keys(ahandle.children)) {\n                    clusters[Number(cl)] = markers.unserializeGroupStats(ahandle.open(cl), permuters[a], { compute_auc: parameters.compute_auc });\n                }\n                cache.raw[a] = fill_results(clusters, num_blocks);\n            }\n        }\n \n    }\n\n    return new MarkerDetectionState(filter, norm_states, choice, parameters, cache);\n}\n\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as gc from \"./gc.js\";\nimport { BuildNeighborSearchIndexResults, findNearestNeighbors } from \"./findNearestNeighbors.js\";\n\n/**\n * Wrapper around the t-SNE status object on the Wasm heap, typically created by {@linkcode initializeTSNE}.\n * @hideconstructor\n */\nexport class InitializeTSNEResults {\n    #id;\n    #status;\n    #coordinates;\n\n    constructor(id, raw_status, raw_coordinates) {\n        this.#id = id;\n        this.#status = raw_status;\n        this.#coordinates = raw_coordinates;\n        return;\n    }\n\n    // Internal use only, not documented.\n    get status() {\n        return this.#status;\n    }\n\n    // Internal use only, not documented.\n    get coordinates() {\n        return this.#coordinates;\n    }\n\n    /**\n     * @return {InitializeTSNEResults} A deep copy of this object.\n     */\n    clone() {\n        return gc.call(\n            module => this.#status.deepcopy(), \n            InitializeTSNEResults, \n            this.#coordinates.clone()\n        );\n    }\n\n    /**\n     * @return {number} Number of cells in the dataset.\n     */\n    numberOfCells () {\n        return this.#status.num_obs();\n    }\n\n    /**\n     * @return {number} Number of iterations processed so far.\n     * This will change with repeated invocations of {@linkcode runTSNE} on this object.\n     */\n    iterations () {\n        return this.#status.iterations();\n    }\n\n    /**\n     * @return {object} Object with `x` and `y` keys.\n     * The corresponding values are Float64Array objects of length equal to the number of cells,\n     * containing the x- and  y- coordinates for each cell at the current state of the algorithm.\n     */\n    extractCoordinates() {\n        return utils.extractXY(this.numberOfCells(), this.#coordinates.array()); \n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */   \n    free() {\n        if (this.#status !== null) {\n            gc.release(this.#id);\n            this.#status = null;\n        }\n        if (this.#coordinates !== null) {\n            this.#coordinates.free();\n            this.#coordinates = null;\n        }\n        return;\n    }\n}\n\n/**\n * @param {number} perplexity - Perplexity to use in the t-SNE algorithm.\n * @return {number} Appropriate number of neighbors to use in the nearest neighbor search.\n */\nexport function perplexityToNeighbors(perplexity) {\n    return wasm.call(module => module.perplexity_to_k(perplexity));\n}\n\n/**\n * @param {(BuildNeighborSearchIndexResults|FindNearestNeighborsResults)} x \n * Either a pre-built neighbor search index for the dataset (see {@linkcode buildNeighborSearchIndex}),\n * or a pre-computed set of neighbor search results for all cells (see {@linkcode findNearestNeighbors}).\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.perplexity=30] - Perplexity to use when computing neighbor probabilities in the t-SNE.\n * @param {boolean} [options.checkMismatch=true] - Whether to check for a mismatch between the perplexity and the number of searched neighbors.\n * Only relevant if `x` is a {@linkplain FindNearestNeighborsResults} object.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {InitializeTSNEResults} Object containing the initial status of the t-SNE algorithm.\n */\nexport function initializeTSNE(x, { perplexity = 30, checkMismatch = true, numberOfThreads = null } = {}) {\n    var my_neighbors;\n    var raw_coords;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        let neighbors;\n\n        if (x instanceof BuildNeighborSearchIndexResults) {\n            let k = perplexityToNeighbors(perplexity);\n            my_neighbors = findNearestNeighbors(x, k, { numberOfThreads: nthreads });\n            neighbors = my_neighbors;\n\n        } else {\n            if (checkMismatch) {\n                let k = perplexityToNeighbors(perplexity);\n                if (k * x.numberOfCells() != x.size()) {\n                    throw new Error(\"number of neighbors in 'x' does not match '3 * perplexity'\");\n                }\n            }\n            neighbors = x;\n        }\n\n        raw_coords = utils.createFloat64WasmArray(2 * neighbors.numberOfCells());\n        wasm.call(module => module.randomize_tsne_start(neighbors.numberOfCells(), raw_coords.offset, 42));\n        output = gc.call(\n            module => module.initialize_tsne(neighbors.results, perplexity, nthreads),\n            InitializeTSNEResults,\n            raw_coords\n        );\n\n    } catch(e) {\n        utils.free(output);\n        utils.free(raw_coords);\n        throw e;\n\n    } finally {\n        utils.free(my_neighbors);\n    }\n\n    return output;\n}\n\n/**\n * Run the t-SNE algorithm on an initialized {@linkplain InitializeTSNEResults}.\n *\n * @param {InitializeTSNEResults} x A previously initialized status object from {@linkcode initializeTSNE}.\n * This may be passed through {@linkcode runTSNE} any number of times.\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.maxIterations=1000] - Maximum number of iterations to perform.\n * This number includes all existing iterations that were already performed in `x` from previous calls to {@linkcode runTSNE}.\n * @param {?number} [options.runTime=null] - Number of milliseconds for which the algorithm is allowed to run before returning.\n * If `null`, no limit is imposed on the runtime.\n *\n * @return The algorithm status in `x` is advanced up to the requested number of iterations,\n * or until the requested run time is exceeded, whichever comes first.\n */\nexport function runTSNE(x, { maxIterations = 1000, runTime = null } = {}) {\n    if (runTime === null) {\n        runTime = -1;\n    }\n    wasm.call(module => module.run_tsne(x.status, runTime, maxIterations, x.coordinates.offset));\n    return;\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\n\n/** \n * Perform a hypergeometric test, typically for over-enrichment of markers across feature sets.\n * This can be computed for multiple feature sets by providing arrays as some or all of the arguments.\n * If multiple arrays are supplied, they must be of the same length.\n *\n * @param {number|Array|TypedArray|WasmArray} markersInSet - Number of detected markers that are also in the feature set.\n * @param {number|Array|TypedArray|WasmArray} numberOfMarkers - Total number of detected markers.\n * @param {number|Array|TypedArray|WasmArray} featureSetSize - Size of the feature set.\n * @param {number|Array|TypedArray|WasmArray} numberOfFeatures - Total number of features.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * @param {boolean} [options.assumeSorted=false] - Whether the input arrays are already sorted such that `markersInSet` is the slowest-changing value.\n * Setting this to `true` can avoid an extra sorting step for greater efficiency.\n *\n * @return {Float64Array} An array of length equal to that of the supplied arrays (or 1, if no arrays are supplied).\n * The i-th entry contains the p-value for enrichment computed using the i-th entry of each supplied array. \n */\nexport function hypergeometricTest(markersInSet, numberOfMarkers, featureSetSize, numberOfFeatures, { numberOfThreads = null, assumeSorted = false } = {}) {\n    let markersInSet_data;\n    let numberOfMarkers_data;\n    let featureSetSize_data;\n    let numberOfFeatures_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    let ntests = null;\n    let check_length = (candidate, name, sofar) => {\n        if (sofar !== null && candidate.length !== sofar) {\n            throw new Error(\"array inputs must have the same length (failing for '\" + name + \"')\");\n        }\n        return candidate.length;\n    }\n\n    if (typeof markersInSet == \"number\") {\n        markersInSet = [markersInSet];\n    } else { \n        ntests = check_length(markersInSet, \"markersInSet\", ntests);\n    }\n\n    if (typeof numberOfMarkers == \"number\") {\n        numberOfMarkers = [numberOfMarkers];\n    } else {\n        ntests = check_length(numberOfMarkers, \"numberOfMarkers\", ntests);\n    }\n\n    if (typeof featureSetSize == \"number\") {\n        featureSetSize = [featureSetSize];\n    } else {\n        ntests = check_length(featureSetSize, \"featureSetSize\", ntests);\n    }\n\n    if (typeof numberOfFeatures == \"number\") {\n        numberOfFeatures = [numberOfFeatures];\n    } else {\n        ntests = check_length(numberOfFeatures, \"numberOfFeatures\", ntests);\n    }\n\n    if (ntests == null) {\n        ntests = 1;\n    }\n\n    let output;\n    let output_data;\n\n    try {\n        markersInSet_data = utils.wasmifyArray(markersInSet, \"Int32WasmArray\");\n        numberOfMarkers_data = utils.wasmifyArray(numberOfMarkers, \"Int32WasmArray\");\n        featureSetSize_data = utils.wasmifyArray(featureSetSize, \"Int32WasmArray\");\n        numberOfFeatures_data = utils.wasmifyArray(numberOfFeatures, \"Int32WasmArray\");\n        output_data = utils.createFloat64WasmArray(ntests);\n\n        wasm.call(module => module.hypergeometric_test(\n            ntests, \n            markersInSet_data.length != 1,\n            markersInSet_data.offset,\n            featureSetSize_data.length != 1,\n            featureSetSize_data.offset,\n            numberOfMarkers_data.length != 1,\n            numberOfMarkers_data.offset,\n            numberOfFeatures_data.length != 1,\n            numberOfFeatures_data.offset,\n            assumeSorted,\n            output_data.offset,\n            nthreads\n        ));\n\n        output = output_data.slice();\n\n    } finally {\n        utils.free(markersInSet_data);\n        utils.free(numberOfMarkers_data);\n        utils.free(featureSetSize_data);\n        utils.free(numberOfFeatures_data);\n        utils.free(output_data);\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\n\n/**\n * Helper class for handling matrix data from multiple modalities.\n * In particular, it simplifies memory management of the assorted {@linkplain ScranMatrix} instances containing data for different features in the same set of cells.\n */\nexport class MultiMatrix {\n    #store;\n    #ncols;\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {object} [options.store={}] - Existing store of {@linkplain ScranMatrix} objects.\n     * Each matrix should correspond to a different modality, named according to its key.\n     * All matrices should have data for the same set of cells, i.e., same number of columns.\n     */\n    constructor({ store = {} } = {}) {\n        this.#store = store;\n        this.#ncols = null;\n\n        let keys = Object.keys(store);\n        if (keys.length) {\n            // We ignore numberOfColumns here, as everyone should have the same number of cells.\n            for (var k = 0; k < keys.length; k++) {\n                let current = store[keys[k]];\n                if (k == 0) {\n                    this.#ncols = current.numberOfColumns();\n                } else if (current.numberOfColumns() != this.#ncols) {\n                    throw new Error(\"all matrices should have the same number of columns\");\n                }\n            }\n        }\n    }\n\n    /**\n     * @return {?number} Number of columns in the matrices.\n     * If no matrices are available, `null` is returned.\n     */\n    numberOfColumns() {\n        return this.#ncols;\n    }\n\n    /**\n     * @return {Array} Names of the available modalities.\n     */\n    available() {\n        return Object.keys(this.#store);\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {boolean} Whether modality `i` is available.\n     */\n    has(i) {\n        return (i in this.#store);\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {ScranMatrix} The matrix data for modality `i`.\n     */\n    get(i) {\n        return this.#store[i];\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @param {ScranMatrix} matrix - The matrix data for modality `i`.\n     *\n     * @return `matrix` is added to the MultiMatrix with name `i`.\n     */\n    add(i, matrix) {\n        if (this.#ncols === null) {\n            this.#ncols = matrix.numberOfColumns();\n        } else if (matrix.numberOfColumns() != this.#ncols) {\n            throw new Error(\"all matrices should have the same number of columns\");\n        }\n\n        if (i in this.#store) {\n            let old = this.#store[i];\n            utils.free(old);\n        }\n\n        this.#store[i] = matrix;\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return Modality `i` is removed from the MultiMatrix.\n     */\n    remove(i) {\n        utils.free(this.#store[i]);\n        delete this.#store[i];\n        if (Object.keys(this.#store).length == 0) {\n            this.#ncols = null;\n        }\n    }\n\n    /**\n     * @param {string} i - Name of a modality.\n     * @return {MultiMatrix} A deep copy of the current object. \n     */\n    clone() {\n        let new_matrix = new MultiMatrix;\n        try {\n            for (const [k, v] of Object.entries(this.#store)) {\n                new_matrix.add(k, v.clone());\n            }\n        } catch (e) {\n            new_matrix.free();\n            throw e;\n        }\n        return new_matrix;\n    }\n\n    /**\n     * @param {string} from - Old name of the modality.\n     * @param {string} to - New name for the modality.\n     *\n     * @return The modality `from` is renamed to `to`, possibly replacing any existing modality at `to`.\n     */\n    rename(from, to) {\n        if (from !== to) {\n            if (to in this.#store) {\n                utils.free(this.#store[to]);\n            }\n            this.#store[to] = this.#store[from];\n            delete this.#store[from];\n        }\n    }\n\n    /**\n     * @return Frees memory for all modalities in this MultiMatrix.\n     */\n    free() {\n        for (const [x, v] of Object.entries(this.#store)) {\n            utils.free(v);\n        }\n        return;\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as ann from \"./Annotated.js\";\n\nfunction verifyElementMetadata(elementMetadata, numExpected, className) {\n    if (elementMetadata !== null) {\n        if (!(elementMetadata instanceof df.DataFrame)) {\n            throw new Error(\"'elementMetadata' should be a DataFrame\");\n        }\n        if (generics.LENGTH(elementMetadata) !== numExpected) {\n            throw new Error(\"'elementMetadata' should have the same number of rows as 'LENGTH(<\" + className + \">)'\");\n        }\n    } else {\n        elementMetadata = new df.DataFrame({}, { numberOfRows: numExpected });\n    }\n    return elementMetadata;\n}\n\n/**\n * The Vector class implements a store for arbitrary per-element metadata and per-element names.\n * It is intended as a base class for other structures that have a concept of \"vector-ness\".\n * It should not be constructed directly.\n *\n * @augments Annotated\n */\nexport class Vector extends ann.Annotated {\n    /**\n     * @param {number} length - Number of elements in this vector-like object.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-element annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(length, { names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n\n        this._elementMetadata = verifyElementMetadata(elementMetadata, length, this.constructor.className);\n\n        if (names !== null) {\n            utils.checkNamesArray(names, \"'names'\", length, \"'LENGTH(<\" + this.constructor.className + \">)'\");\n        }\n        this._names = names;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {DataFrame} A {@linkplain DataFrame} with one row corresponding to each vector element, containing arbitrary per-element metadata.\n     */\n    elementMetadata() {\n        return this._elementMetadata;\n    }\n\n    /**\n     * @return {?Array} Array of strings containing the name of each range, or `null` if no names are available.\n     */\n    names() {\n        return this._names;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {?DataFrame} elementMetadata - Arbitrary metadata for each vector element.\n     * This should have number of rows equal to the vector length.\n     * Alternatively `null`, in which case all existing per-element metadata is removed.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Vector instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Vector} The Vector object after setting the element metadata to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setElementMetadata(elementMetadata, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._elementMetadata = verifyElementMetadata(elementMetadata, generics.LENGTH(target), target.constructor.className);\n        return target;\n    }\n\n    /**\n     * @param {?DataFrame} elementMetadata - Arbitrary metadata for each vector element.\n     * This should have number of rows equal to the vector length.\n     * Alternatively `null`, in which case all existing per-element metadata is removed.\n     *\n     * @return {Vector} A reference to this Vector object after setting the element metadata to `value`.\n     */\n    $setElementMetadata(elementMetadata) {\n        return this.setElementMetadata(elementMetadata, { inPlace: true });\n    }\n\n    /**\n     * @param {?Array} names - Array of strings containing a name for each range.\n     * This should have length equal to the number of ranges.\n     * Alternatively `null`, if no names are present.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this Vector instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {Vector} The Vector object after setting the names to `value`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", generics.LENGTH(this), \"'LENGTH(<\" + this.constructor.className + \">)'\");\n        } \n        let target = cutils.setterTarget(this, inPlace);\n        target._names = names;\n        return target;\n    }\n\n    /**\n     * @param {?Array} names - Array of strings containing a name for each range.\n     * This should have length equal to the number of ranges.\n     * Alternatively `null`, if no names are present.\n     *\n     * @return {Vector} A reference to this Vector object after setting the element metadata to `value`.\n     */\n    $setNames(names) {\n        return this.setNames(names, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE(output, i, { allowView = false }) {\n        output._elementMetadata = generics.SLICE(this._elementMetadata, i, { allowView });\n        output._names = (this._names === null ? null : generics.SLICE(this._names, i, { allowView }));\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        let all_em = [];\n        let all_n = [];\n        let all_l = [];\n\n        for (const x of objects) {\n            all_em.push(x._elementMetadata);\n            all_n.push(x._names);\n            all_l.push(generics.LENGTH(x));\n        }\n\n        output._elementMetadata = generics.COMBINE(all_em);\n        output._names = utils.combineNames(all_n, all_l);\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n        output._elementMetadata = cutils.cloneField(this._elementMetadata, deepCopy);\n        output._names = cutils.cloneField(this._names, deepCopy);\n        return;\n    }\n}\n","import * as utils from \"./utils.js\";\n\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the gene-to-set mappings if they are not already available.\n * If `false`, `null` is returned if the gene-to-set mappings have not already been loaded into memory.\n *\n * @return {?Array} Array of length equal to the total number of genes for this `species`.\n * Each element corresponds to an entry in {@linkcode fetchAllGenes} and is an array of integers containing the IDs for all sets containing that gene.\n * Set IDs refer to indices in {@linkcode fetchAllSets}.\n *\n * If the gene-to-set mappings have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchSetsForAllGenes(species, { download = true } = {}) {\n    let found = _cache.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    let res = await utils.reference_download(species + \"_gene2set.tsv.gz\");\n    if (!res.ok) {\n        throw new Error(\"failed to fetch full gene-to-set information for species '\" + species + \"'\");\n    }\n\n    var gene_data = utils.decompressLines(await res.arrayBuffer());\n    let loaded = gene_data.map(utils.convertToUint32Array);\n    _cache.set(species, loaded);\n    return loaded;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\nimport * as feat_module from \"./feature_selection.js\";\n\nexport const step_name = \"rna_pca\";\n\n/**\n * Results of running PCA on some input matrix,\n * see [here](https://kanaverse.github.io/scran.js/RunPCAResults.html) for details.\n *\n * @external RunPCAResults\n */\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise the data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class RnaPcaState { \n    #filter;\n    #norm;\n    #feat;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, feat, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm' should be an RnaNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        if (!(feat instanceof feat_module.FeatureSelectionState)) {\n            throw new Error(\"'feat' should be a FeatureSelectionState object\");\n        }\n        this.#feat = feat;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.hvg_buffer);\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized gene expression values.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `rna_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {number} parameters.num_hvgs - Number of highly variable genes (see {@linkplain FeatureSelectionState}) to use in the PCA.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be one of:\n     *\n     * - `\"none\"`, in which case nothing is done using the sample information. \n     * - `\"regress\"`, where linear regression is applied to remove mean differences between samples.\n     * - `\"weight\"`, where samples are weighted so that they contribute equally regardless of the number of cells.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_hvgs, num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#feat.changed || num_hvgs !== this.#parameters.num_hvgs) {\n            if (this.valid()) {\n                choose_hvgs(num_hvgs, this.#feat, this.#cache);\n                this.changed = true;\n            }\n\n            this.#parameters.num_hvgs = num_hvgs;\n        }\n\n        if (this.changed || this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            utils.freeCache(this.#cache.pcs);\n\n            if (this.valid()) {\n                let sub = this.#cache.hvg_buffer;\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                this.#cache.pcs = scran.runPCA(mat, { features: sub, numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_hvgs: 2000,\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction choose_hvgs(num_hvgs, feat, cache) {\n    var sorted_resids = feat.fetchSortedResiduals();\n    var sub = utils.allocateCachedArray(sorted_resids.length, \"Uint8Array\", cache, \"hvg_buffer\");\n\n    if (num_hvgs < sorted_resids.length) {\n        var threshold_at = sorted_resids[sorted_resids.length - num_hvgs];\n        var unsorted_resids = feat.fetchResults().residuals({ copy: false });\n        sub.array().forEach((element, index, array) => {\n            array[index] = unsorted_resids[index] >= threshold_at;\n        });\n    } else {\n        sub.fill(1);\n    }\n\n    return sub;\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm, feat) {\n    let ghandle = handle.open(\"rna_pca\" in handle.children ? \"rna_pca\" : \"pca\");\n\n    let parameters = {};\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = { \n            num_hvgs: phandle.open(\"num_hvgs\", { load: true }).values[0],\n            num_pcs: phandle.open(\"num_pcs\", { load: true }).values[0]\n        };\n\n        // For back-compatibility.\n        if (\"block_method\" in phandle.children) {\n            parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n            if (parameters.block_method == \"mnn\") {\n                parameters.block_method = \"weight\";\n            }\n        } else {\n            parameters.block_method = \"none\";\n        }\n    }\n\n    let output;\n    let cache = {};\n    try {\n        if (feat.valid()) {\n            choose_hvgs(parameters.num_hvgs, feat, cache);\n\n            let rhandle = ghandle.open(\"results\");\n            if (\"pcs\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n        }\n\n        output = new RnaPcaState(filter, norm, feat, parameters, cache);\n    } catch (e) {\n        utils.freeCache(cache.hvg_buffer);\n        utils.freeCache(cache.pcs);\n        utils.freeCache(output);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**\n * Dataset in the 10X HDF5 feature-barcode matrix format, see [here](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices) for details.\n */\nexport class TenxHdf5Dataset { \n    #h5_file;\n    #h5_path;\n    #h5_flush;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"h5\", file: fun(this.#h5_file) }];\n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a HDF5 file in the 10X feature-barcode format.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = TenxHdf5Dataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode TenxHdf5Dataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: 0, \n            primaryAdtFeatureIdColumn: 0,\n            primaryCrisprFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode TenxHdf5Dataset#load load} (but not {@linkcode TenxHdf5Dataset#summary summary}).\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset, all features are considered to be genes by default.\n     * This behavior can also be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     * \n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     * @param {string|number} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #instantiate() {\n        if (this.#h5_path !== null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode TenxHdf5Dataset#load load} or {@linkcodeTenxHdf5Dataset#summary summary}. \n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"10X\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset,\n     * in a form that can be cheaply stringified.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#instantiate();\n        let handle = new scran.H5File(this.#h5_path);\n        if (!(\"matrix\" in handle.children) || handle.children[\"matrix\"] != \"Group\") {\n            throw new Error(\"expected a 'matrix' group at the top level of the file\");\n        }\n        let mhandle = handle.open(\"matrix\");\n\n        if (!(\"features\" in mhandle.children) || mhandle.children[\"features\"] != \"Group\") {\n            throw new Error(\"expected a 'matrix/features' group containing the feature annotation\");\n        }\n        let fhandle = mhandle.open(\"features\");\n\n        let ids = eutils.extractHDF5Strings(fhandle, \"id\");\n        if (ids == null) {\n            throw new Error(\"expected a 'matrix/features/id' string dataset containing the feature IDs\");\n        }\n        let feats = new bioc.DataFrame({ id: ids }); // build it piece-by-piece for a well-defined ordering.\n\n        let names = eutils.extractHDF5Strings(fhandle, \"name\");\n        if (names !== null) {\n            feats.$setColumn(\"name\", names);\n        }\n\n        let ftype = eutils.extractHDF5Strings(fhandle, \"feature_type\");\n        if (ftype !== null) {\n            feats.$setColumn(\"type\", ftype);\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#instantiate();\n        let details = scran.extractHDF5MatrixDetails(this.#h5_path, \"matrix\");\n        this.#raw_cells = new bioc.DataFrame({}, { numberOfRows: details.columns });\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode TenxMatrixMarketDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n\n        let output = {\n            \"modality_features\": futils.reportFeatures(this.#raw_features, \"type\"),\n            \"cells\": this.#raw_cells\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode TenxHdf5Dataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode TenxHdf5Dataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode TenxHdf5Dataset#defaults defaults} or with {@linkcode TenxHdf5Dataset#setOptions setOptions}.\n     *\n     * If the feature annotation lacks information about the feature types, it is assumed that all features are genes, i.e., only the RNA modality is present.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n\n        let loaded = scran.initializeSparseMatrixFromHDF5(this.#h5_path, \"matrix\"); // collection gets handled inside splitScranMatrixAndFeatures.\n\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, \"type\", this.#feature_type_mapping(), \"RNA\");\n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode TenxHdf5Dataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {TenxHdf5Dataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"h5\") {\n            throw new Error(\"expected exactly one file of type 'h5' for 10X HDF5 unserialization\");\n        }\n        let output = new TenxHdf5Dataset(files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n","import * as utils from \"./../utils.js\";\nimport * as wasm from \"../wasm.js\";\n\nexport function computePerCellQcFilters(metrics, block, run) {\n    var block_data;\n    var output;\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != metrics.numberOfCells()) {\n                throw new Error(\"'block' must be of length equal to the number of cells in 'metrics'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = run(metrics, use_blocks, bptr);\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n    }\n\n    return output;\n}\n\nexport function applyFilter(thresholds, metrics, block, buffer) {\n    var block_data;\n    var rebuffer;\n    var output;\n\n    try {\n        var bptr = 0;\n        var use_blocks = false;\n\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != metrics.numberOfCells()) {\n                throw new Error(\"'block' must be of length equal to the number of cells in 'metrics'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        let optr;\n        if (buffer == null) {\n            rebuffer = utils.createUint8WasmArray(metrics.numberOfCells());\n            optr = rebuffer.offset;\n        } else {\n            if (buffer.length != metrics.numberOfCells()) {\n                throw new Error(\"'buffer' must be of length equal to the number of cells in 'metrics'\");\n            }\n            optr = buffer.offset;\n        }\n\n        wasm.call(module => thresholds.filter(metrics.results.$$.ptr, use_blocks, bptr, optr));\n        if (buffer == null) {\n            output = rebuffer.slice();\n        } else {\n            output = buffer.array();\n        }\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n        utils.free(rebuffer);\n    }\n\n    return output;\n}\n\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int8WasmArray} Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int16WasmArray} Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int32WasmArray} Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigInt64WasmArray} Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as ann from \"./Annotated.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SummarizedExperiment contains zero or more assays, consisting of multi-dimensional arrays (usually matrices) of experimental data,\n * as well as {@linkplain DataFrame}s containing further annotations on the rows or columns of those arrays.\n * The SummarizedExperiment class defines methods for the following generics:\n * \n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n *\n * Assays are expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode NUMBER_OF_COLUMNS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode COMBINE_COLUMNS}\n * - {@linkcode CLONE}\n *\n * @extends Annotated\n */\nexport class SummarizedExperiment extends ann.Annotated {\n    /**\n     * @param {Object|Map} assays - Object or Map where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * All arrays should have the same number of rows and columns.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?Array} [options.assayOrder=null] - Array of strings specifying the ordering of the assays.\n     * If non-`null`, this should have the same values as the keys of `assays`.\n     * If `null`, an arbitrary ordering is obtained from `assays`.\n     * @param {?DataFrame} [options.rowData=null] - Data frame of row annotations.\n     * If non-`null`, this should have a number of rows equal to the number of rows in each entry of `assays`.\n     * If `null`, an empty {@linkplain DataFrame} is automatically created.\n     * @param {?DataFrame} [options.columnData=null] - Data frame of column annotations.\n     * If non-`null`, this should have a number of columns equal to the number of columns in each entry of `assays`.\n     * If `null`, an empty {@linkplain DataFrame} is automatically created.\n     * @param {?Array} [options.rowNames=null] - Array of strings of length equal to the number of rows in the `assays`, containing row names.\n     * Alternatively `null`, if no row names are present.\n     * @param {?Array} [options.columnNames=null] - Array of strings of length equal to the number of columns in the `assays`, containing column names.\n     * Alternatively `null`, if no column names are present.\n     * @param {Object|Map} [options.metadata={}] - Object or Map containing arbitrary metadata as key-value pairs.\n     */\n    constructor(assays, { assayOrder = null, rowData = null, columnData = null, rowNames = null, columnNames = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        super(metadata);\n\n        // Check the assays.\n        try {\n            this._assays = new il.InternalList(assays, assayOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize assay list for this SummarizedExperiment; \" + e.message, { cause: e });\n        }\n\n        let nrows = null;\n        let ncols = null;\n        for (const k of this._assays.names()) {\n            let current = this._assays.entry(k);\n            let nr = generics.NUMBER_OF_ROWS(current);\n            let nc = generics.NUMBER_OF_COLUMNS(current);\n            if (nrows == null) {\n                nrows = nr;\n                ncols = nc;\n            } else if (nrows !== nr || ncols !== nc) {\n                throw new Error(\"expected all assays in 'assays' to have the same number of rows and columns\");\n            }\n        }\n\n        // Check the rowData.\n        if (rowData === null) {\n            if (nrows == null){\n                throw new Error(\"'rowData' must be specified if 'assays' is empty\");\n            }\n            rowData = new df.DataFrame({}, { numberOfRows: nrows });\n        } else {\n            if (nrows !== null && nrows !== generics.LENGTH(rowData)) {\n                throw new Error(\"'rowData' should be equal to the number of rows in each 'assays'\");\n            }\n        }\n        this._rowData = rowData;\n\n        // Check the columnData.\n        if (columnData === null) {\n            if (ncols == null){\n                throw new Error(\"'columnData' must be specified if 'assays' is empty\");\n            }\n            columnData = new df.DataFrame({}, { numberOfRows: ncols });\n        } else {\n            if (ncols !== null && ncols !== generics.LENGTH(columnData)) {\n                throw new Error(\"'columnData' should be equal to the number of columns in each 'assays'\");\n            }\n        }\n        this._columnData = columnData;\n\n        // Checking the names.\n        if (rowNames != null) {\n            utils.checkNamesArray(rowNames, \"'rowNames'\", this._rowData.numberOfRows(), \"the number of rows in each 'assays'\");\n        }\n        this._rowNames = rowNames;\n\n        if (columnNames != null) {\n            utils.checkNamesArray(columnNames, \"'columnNames'\", this._columnData.numberOfRows(), \"the number of columns in each 'assays'\");\n        }\n        this._columnNames = columnNames;\n    }\n\n    static className = \"SummarizedExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of assay names.\n     */\n    assayNames() {\n        return this._assays.names();\n    }\n\n    /**\n     * @return {number} Number of assays.\n     */\n    numberOfAssays() {\n        return this._assays.numberOfEntries();\n    }\n\n    /**\n     * @param {string|number} i - Assay to retrieve, either by name or index.\n     * @return {*} The contents of assay `i` as an multi-dimensional array-like object.\n     */\n    assay(i) {\n        let output;\n        try {\n            output = this._assays.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified assay from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {DataFrame} Data frame of row data, with one row per row in this SummarizedExperiment.\n     */\n    rowData() {\n        return this._rowData;\n    }\n\n    /**\n     * @return {number} Number of rows in this SummarizedExperiment.\n     */\n    numberOfRows() {\n        return this._rowData.numberOfRows();\n    }\n\n    /**\n     * @return {?Array} Array of strings containing row names, or `null` if no row names are available.\n     */\n    rowNames() {\n        return this._rowNames;\n    }\n\n    /**\n     * @return {DataFrame} Data frame of column data, with one row per column in this SummarizedExperiment.\n     */\n    columnData() {\n        return this._columnData;\n    }\n\n    /**\n     * @return {number} Number of columns in this SummarizedExperiment.\n     */\n    numberOfColumns() {\n        return this._columnData.numberOfRows();\n    }\n\n    /**\n     * @return {?Array} Array of strings containing column names, or `null` if no column names are available.\n     */\n    columnNames() {\n        return this._columnNames;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAssay(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = target._assays.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove assay \" + (typeof i == \"string\" ? \"'\" + i + \"'\" : String(i)) + \" from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment after removing the specified assay.\n     */\n    $removeAssay(i) {\n        return this.removeAssay(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * - If `i` is a number, the assay at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of assays.\n     * - If `i` is a string, any assay with the same name is replaced.\n     *   If no such assay exists, a new assay is appended to the list of assays.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the assay.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} A SummarizedExperiment with modified assays.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAssay(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) !== this.numberOfRows() || generics.NUMBER_OF_COLUMNS(value) !== this.numberOfColumns()) {\n            throw new Error(\"expected 'value' to have the same dimensions as this 'SummarizedExperiment'\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._assays = target._assays.set(i, value, { inPlace });\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the assay to add, either by name or index.\n     * - If `i` is a number, the assay at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of assays.\n     * - If `i` is a string, any assay with the same name is replaced.\n     *   If no such assay exists, a new assay is appended to the list of assays.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the assay.\n     *\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified assays.\n     */\n    $setAssay(i, value) {\n        return this.setAssay(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the assay names.\n     * This should be of the same length as the number of assays and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified assay names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAssayNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = target._assays.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the assay names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the assay names.\n     * This should be of the same length as the number of assays and contain unique values.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified assay names.\n     */\n    $setAssayNames(names) {\n        return this.setAssayNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the assays to retain in the slice.\n     * This should refer to unique assay names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with sliced assays.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAssays(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._assays = this._assays.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the assays for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the assays to retain in the slice.\n     * This should refer to unique assay names.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with sliced assays.\n     */\n    $sliceAssays(i) {\n        return this.sliceAssays(i, { inPlace: true });\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the row annotations.\n     * This should have one row for each row of this SummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified row data.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowData(value, { inPlace = false } = {}) {\n        if (!(value instanceof df.DataFrame)) {\n            throw new Error(\"'value' should be a DataFrame\");\n        }\n\n        if (value.numberOfRows() !== this.numberOfRows()) {\n            throw new Error(\"expected 'value' to have the same number of rows as this 'SummarizedExperiment'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowData = value;\n        return target;\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the row annotations.\n     * This should have one row for each row of this SummarizedExperiment.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified row data.\n     */\n    $setRowData(value) {\n        return this.setRowData(value, { inPlace: true });\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the column annotations.\n     * This should have one row for each columns of this SummarizedExperiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column data.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnData(value, { inPlace = false } = {}) {\n        if (!(value instanceof df.DataFrame)) {\n            throw new Error(\"'value' should be a DataFrame\");\n        }\n\n        if (value.numberOfRows() !== this.numberOfColumns()) {\n            throw new Error(\"expected 'value' to have the same number of rows as the number of columns of this 'SummarizedExperiment'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columnData = value;\n        return target;\n    }\n\n    /**\n     * @param {DataFrame} value - Data frame containing the column annotations.\n     * This should have one row for each columns of this SummarizedExperiment.\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified column data.\n     */\n    $setColumnData(value) {\n        return this.setColumnData(value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of rows in this SummarizedExperiment, containing row names.\n     * Alternatively `null`, to remove all row names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified row names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRowNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this.numberOfRows(), \"'numberOfRows()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._rowNames = names;\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of rows in this SummarizedExperiment, containing row names.\n     * Alternatively `null`, to remove all row names.\n     *\n     * @return {SummarizedExperiment} A reference to this SummarizedExperiment with modified row names.\n     */\n    $setRowNames(names) {\n        return this.setRowNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of columns in this SummarizedExperiment, containing column names.\n     * Alternatively `null`, to remove all column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setColumnNames(names, { inPlace = false } = {}) {\n        if (names !== null) {\n            utils.checkNamesArray(names, \"replacement 'names'\", this.numberOfColumns(), \"'numberOfColumns()'\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._columnNames = names;\n        return target;\n    }\n\n    /**\n     * @param {Array} names - Array of strings of length equal to the number of columns in this SummarizedExperiment, containing column names.\n     * Alternatively `null`, to remove all column names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SummarizedExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SummarizedExperiment} The SummarizedExperiment with modified column names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    $setColumnNames(names) {\n        return this.setColumnNames(names, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.numberOfRows();\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.numberOfColumns();\n    }\n\n    _bioconductor_SLICE_2D(output, rows, columns, { allowView = false }) {\n        output._assays = this._assays.apply(v => generics.SLICE_2D(v, rows, columns, { allowView }));\n\n        if (rows !== null) {\n            output._rowData = generics.SLICE(this._rowData, rows, { allowView });\n            output._rowNames = (this._rowNames == null ? null : generics.SLICE(this._rowNames, rows, { allowView }));\n        } else {\n            output._rowData = this._rowData;\n            output._rowNames = this._rowNames;\n        }\n\n        if (columns !== null) {\n            output._columnData = generics.SLICE(this._columnData, columns, { allowView });\n            output._columnNames = (this._columnNames == null ? null : generics.SLICE(this._columnNames, columns, { allowView }));\n        } else {\n            output._columnData = this._columnData;\n            output._columnNames = this._columnNames;\n        }\n\n        output._metadata = this._metadata;\n        return;\n    }\n\n    _bioconductor_COMBINE_ROWS(output, objects) {\n        output._assays = il.InternalList.parallelCombine(objects.map(x => x._assays), generics.COMBINE_ROWS);\n\n        let all_dfs = objects.map(x => x._rowData);\n        output._rowData = generics.COMBINE(all_dfs);\n\n        let all_n = objects.map(x => x._rowNames);\n        let all_l = objects.map(x => x.numberOfRows());\n        output._rowNames = utils.combineNames(all_n, all_l);\n\n        output._columnData = this._columnData;\n        output._columnNames = this._columnNames;\n        output._metadata = this._metadata;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(output, objects) {\n        output._assays = il.InternalList.parallelCombine(objects.map(x => x._assays), generics.COMBINE_COLUMNS);\n\n        let all_dfs = objects.map(x => x._columnData);\n        output._columnData = generics.COMBINE(all_dfs);\n\n        let all_n = objects.map(x => x._columnNames);\n        let all_l = objects.map(x => x.numberOfColumns());\n        output._columnNames = utils.combineNames(all_n, all_l);\n\n        output._rowData = this._rowData;\n        output._rowNames = this._rowNames;\n        output._metadata = this._metadata;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output._assays = cutils.cloneField(this._assays, deepCopy);\n        output._rowData = cutils.cloneField(this._rowData, deepCopy);\n        output._rowNames = cutils.cloneField(this._rowNames, deepCopy);\n\n        output._columnData = cutils.cloneField(this._columnData, deepCopy);\n        output._columnNames = cutils.cloneField(this._columnNames, deepCopy);\n        return;\n    }\n}\n","import * as vec from \"./Vector.js\";\nimport * as gr from \"./GRanges.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\n/**\n * A GroupedGRanges object is a collection of groups of genomic ranges, inspired by the `GRangesList` class from the Bioconductor ecosystem.\n * Each group consists of a {@linkplain GRanges} object of arbitrary length, which is most often used to represent a multi-exon gene.\n * The GroupedGRanges can be considered a vector of groups, and defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * Our implementation re-uses Bioconductor's strategy of storing the groups in a single concatenated GRanges.\n * This improves efficiency for large numbers of small GRanges, especially in placeholder objects where all the GRanges are zero-length.\n * \n * @extends Vector\n */\nexport class GroupedGRanges extends vec.Vector {\n    static #computeStarts(lengths) {\n        let starts = new Int32Array(lengths.length);\n        let last = 0;\n        for (var i = 0; i < lengths.length; i++) {\n            starts[i] = last;\n            last += lengths[i];\n        }\n        return { starts: starts, total: last };\n    }\n\n    #staged_setGroup = null;\n\n    /**\n     * @param {Array|GRanges} ranges - An array of {@linkplain GRanges} objects, where each element represents a group of genomic ranges.\n     * All objects should have compatible columns in their {@linkplain Vector#elementMetadata elementMetadata}.\n     * \n     * Alternatively, a single GRanges containing a concatenation of ranges from all groups.\n     * In this case, `rangeLengths` must be supplied.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(TypedArray|Array)} [options.rangeLengths=null] - Length of the ranges within each group.\n     * This should be coercible to an Int32Array, contain non-negative values, and have a sum equal to the length of `ranges`.\n     * Only used if `ranges` is a single {@linkplain GRanges} object, where each group's ranges are assumed to form contiguous intervals along `ranges`.\n     * @param {?Array} [options.names=null] - Array of strings of length equal to `start`, containing names for each genomic range.\n     * Alternatively `null`, in which case the ranges are assumed to be unnamed.\n     * @param {?DataFrame} [options.elementMetadata=null] - A {@linkplain DataFrame} with number of rows equal to the length of `start`, containing arbitrary per-range annotations.\n     * Alternatively `null`, in which case a zero-column DataFrame is automatically constructed.\n     * @param {Object} [options.metadata={}] - Object containing arbitrary metadata as key-value pairs.\n     */\n    constructor(ranges, { rangeLengths = null, names = null, elementMetadata = null, metadata = {} } = {}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        if (ranges.constructor == Array) {\n            super(ranges.length, { names, elementMetadata, metadata });\n            rangeLengths = new Int32Array(ranges.length);\n            for (var i = 0; i < rangeLengths.length; i++) {\n                if (!(ranges[i] instanceof gr.GRanges)) {\n                    throw new Error(\"'ranges' must either be a 'GRanges' or an array of 'GRanges'\");\n                }\n                rangeLengths[i] = generics.LENGTH(ranges[i]);\n            }\n            ranges = generics.COMBINE(ranges);\n\n        } else {\n            if (!(ranges instanceof gr.GRanges)) {\n                throw new Error(\"'ranges' must either be a 'GRanges' or an array of 'GRanges'\");\n            }\n            if (rangeLengths == null) {\n                throw new Error(\"'rangeLengths' must be specified when 'ranges' is a 'GRanges'\");\n            }\n            super(rangeLengths.length, { names, elementMetadata, metadata });\n            rangeLengths = utils.convertToInt32Array(rangeLengths);\n            utils.checkNonNegative(rangeLengths);\n        }\n\n        this._ranges = ranges;\n        this._rangeLengths = rangeLengths;\n\n        let accumulated = GroupedGRanges.#computeStarts(rangeLengths);\n        this._rangeStarts = accumulated.starts;\n\n        if (accumulated.total !== generics.LENGTH(ranges)) {\n            throw new Error(\"sum of 'rangeLengths' must be equal to the length of 'ranges'\");\n        }\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {GRanges} The concatenated set of ranges across all groups. \n     */\n    ranges() {\n        this.#flush_staged_setGroup();\n        return this._ranges;\n    }\n\n    /**\n     * @return {Int32Array} The start indices for each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     */\n    rangeStarts() {\n        this.#flush_staged_setGroup();\n        return this._rangeStarts;\n    }\n\n    /**\n     * @return {Int32Array} The length of each group's ranges along the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     */\n    rangeLengths() {\n        this.#flush_staged_setGroup();\n        return this._rangeLengths;\n    }\n\n    /**\n     * @param {number} i - Index of the group of interest.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.allowView=false] - Whether a view can be created in any internal slicing operations.\n     *\n     * @return {GRanges} The genomic ranges for group `i`.\n     */\n    group(i, { allowView = false } = {}) {\n        this.#flush_staged_setGroup();\n        let s = this._rangeStarts[i];\n        return generics.SLICE(this._ranges, { start: s, end: s + this._rangeLengths[i] }, { allowView });\n    }\n\n    /**\n     * @return {number} Number of groups in this object.\n     */\n    numberOfGroups() {\n        return this._rangeStarts.length;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {GRanges} ranges - Genomic ranges of length equal to the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GroupedGRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GroupedGRanges} The GroupedGRanges object after modifying the internal ranges.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setRanges(ranges, { inPlace = false } = {}) {\n        if (!(ranges instanceof gr.GRanges)) {\n            throw new Error(\"'ranges' must be a 'GRanges'\");\n        }\n\n        this.#flush_staged_setGroup();\n        if (generics.LENGTH(ranges) !== generics.LENGTH(this._ranges)) {\n            throw utils.formatLengthError(\"'ranges'\", \"number of ranges\");\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._ranges = ranges;\n        return target;\n    }\n\n    /**\n     * @param {GRanges} ranges - Genomic ranges of length equal to the concatenated set of ranges returned by {@linkcode GroupedGRanges#ranges ranges}.\n     * @return {GroupedGRanges} A reference to this GroupedGRanges object after modifying the internal ranges.\n     */\n    $setRanges(ranges) {\n        return this.setRanges(ranges, { inPlace: true });\n    }\n\n    #flush_staged_setGroup() {\n        let staged = this.#staged_setGroup;\n        if (staged === null) {\n            return;\n        }\n\n        staged.sort((a, b) => {\n            let diff = a[0] - b[0];\n            return (diff === 0 ? a[1] - b[1] : diff);\n        });\n\n        let counter = 0;\n        let accumulated = 0;\n        let last_start = 0;\n        let more_ranges = [];\n\n        let ngroups = this.numberOfGroups();\n        for (var g = 0; g < ngroups; g++) {\n            if (counter < staged.length && g == staged[counter][0]) { \n                let current_start = this._rangeStarts[g];\n                if (last_start < current_start) {\n                    more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: current_start }));\n                }\n                last_start = current_start + this._rangeLengths[g];\n\n                let replacement;\n                do {\n                    replacement = staged[counter][2];\n                    counter++;\n                } while (counter < staged.length && g == staged[counter][0]);\n\n                more_ranges.push(replacement);\n                this._rangeLengths[g] = generics.LENGTH(replacement);\n            }\n\n            this._rangeStarts[g] = accumulated;\n            accumulated += this._rangeLengths[g];\n        }\n\n        let nranges = generics.LENGTH(this._ranges);\n        if (last_start < nranges) {\n            more_ranges.push(generics.SLICE(this._ranges, { start: last_start, end: nranges }));\n        }\n\n        try {\n            this._ranges = generics.COMBINE(more_ranges);\n        } catch (e) {\n            throw new Error(\"failed to combine staged '$setGroup' operations; \" + e.message);\n        }\n\n        this.#staged_setGroup = null;\n        return;\n    }\n\n    /**\n     * Multiple consecutive calls to `$setGroup` are not executed immediately.\n     * Rather, the operations are staged and executed in batch once the modified GroupedGRanges is used in other methods.\n     * This enables efficient setting of individual groups inside a single concatenated {@linkplain GRanges}. \n     *\n     * @param {number} i - Index of the group of interest.\n     * @param {GRanges} ranges - Genomic ranges for group `i`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this GroupedGRanges instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {GroupedGRanges} The GroupedGRanges object after setting group `i`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setGroup(i, ranges, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (target.#staged_setGroup === null) {\n            target.#staged_setGroup = [];\n        } else if (!inPlace) {\n            target.#staged_setGroup = target.#staged_setGroup.slice();\n        }\n\n        if (!inPlace) {\n            target._rangeStarts = target._rangeStarts.slice();\n            target._rangeLengths = target._rangeLengths.slice();\n        }\n\n        let nops = target.#staged_setGroup.length;\n        target.#staged_setGroup.push([i, nops, ranges]);\n        return target;\n    }\n\n    /**\n     * See comments for {@linkcode GroupedGRanges#$setGroup $setGroup}.\n     *\n     * @param {number} i - Index of the group of interest.\n     * @param {GRanges} ranges - Genomic ranges for group `i`.\n     *\n     * @return {GroupedGRanges} A reference to this GroupedGRanges object after setting group `i`.\n     */\n    $setGroup(i, ranges) {\n        return this.setGroup(i, ranges, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {?(Array|Set)} [options.restrictToSeqnames=null] - Array or Set containing the sequence names to use in the index.\n     * If `null`, all available sequence names are used.\n     * @param {?(Array|Set)} [options.restrictToStrand=null] - Array or Set containing the strands to use in the index.\n     * If `null`, all available strands are used.\n     *\n     * @return {GroupedGRangesOverlapIndex} A pre-built index for computing overlaps with other {@linkplain GRanges} instances.\n     */\n    buildOverlapIndex({ restrictToSeqnames = null, restrictToStrand = null } = {}) {\n        this.#flush_staged_setGroup();\n        return new GroupedGRangesOverlapIndex(\n            this._ranges.buildOverlapIndex({ restrictToSeqnames, restrictToStrand }),\n            generics.LENGTH(this._ranges),\n            this._rangeStarts,\n            this._rangeLengths\n        );\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_LENGTH() {\n        return this._rangeStarts.length;\n    }\n\n    _bioconductor_SLICE(output, i, { allowView = false } = {}) {\n        super._bioconductor_SLICE(output, i, { allowView });\n        this.#flush_staged_setGroup();\n\n        output._rangeLengths = generics.SLICE(this._rangeLengths, i, { allowView });\n        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);\n        output._rangeStarts = accumulated.starts;\n\n        if (i.constructor == Object) {\n            // Handle this specially for optimizing allowView = true.\n            let s = this._rangeStarts[i.start];\n            output._ranges = generics.SLICE(this._ranges, { start: s, end: s + accumulated.total }, { allowView });\n        } else {\n            let keep = new Int32Array(accumulated.total);\n\n            let counter = 0;\n            for (const j of i) {\n                let start = this._rangeStarts[j];\n                let end = start + this._rangeLengths[j];\n                for (var k = start; k < end; k++) {\n                    keep[counter] = k;\n                    counter++;\n                }\n            }\n\n            output._ranges = generics.SLICE(this._ranges, keep, { allowView });\n        }\n\n        return;\n    }\n\n    _bioconductor_COMBINE(output, objects) {\n        super._bioconductor_COMBINE(output, objects);\n\n        // We need to flush the staged operations in each object.\n        for (const o of objects) {\n            o.#flush_staged_setGroup();\n        }\n\n        output._rangeLengths = generics.COMBINE(objects.map(x => x.rangeLengths()));\n        let accumulated = GroupedGRanges.#computeStarts(output._rangeLengths);\n        output._rangeStarts = accumulated.starts;\n        output._ranges = generics.COMBINE(objects.map(x => x._ranges));\n\n        return;\n    }\n\n    _bioconductor_CLONE(output, { deepCopy = true }) {\n        super._bioconductor_CLONE(output, { deepCopy });\n\n        output.#staged_setGroup = cutils.cloneField(this.#staged_setGroup, deepCopy);\n        output._rangeLengths = cutils.cloneField(this._rangeLengths, deepCopy);\n        output._rangeStarts = cutils.cloneField(this._rangeStarts, deepCopy);\n        output._ranges = cutils.cloneField(this._ranges, deepCopy);\n\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {number} [numberOfGroups=0] - Numbe of empty groups to create.\n     * @return {GroupedGRanges} A GroupedGRanges object of length equal to `numberOfGroups`,\n     * where each group is of zero length.\n     */\n    static empty(numberOfGroups) {\n        let runs = new Int32Array(numberOfGroups);\n        runs.fill(0);\n        return new GroupedGRanges(gr.GRanges.empty(), { rangeLengths: runs });\n    }\n}\n\n/**\n * Pre-built index for overlapping {@linkplain GroupedGRanges} objects.\n * This is typically constructed using the {@linkcode GroupedGRanges#buildOverlapIndex GroupedGRanges.buildOverlapIndex} method for a \"reference\" object,\n * and can be applied to different query GroupedGRanges or {@linkplain GRanges} to identify overlaps with the reference.\n *\n * @hideconstructor\n */\nexport class GroupedGRangesOverlapIndex {\n    constructor(index, fullLength, rangeStarts, rangeLengths) {\n        this._index = index;\n        this._rangeStarts = rangeStarts;\n        this._rangeLengths = rangeLengths;\n\n        let rev_map = new Int32Array(fullLength);\n        for (var i = 0; i < rangeStarts.length; i++) {\n            let start = rangeStarts[i];\n            let end = start + rangeLengths[i];\n            for (var s = start; s < end; s++) {\n                rev_map[s] = i;\n            }\n        }\n        this._reverseMapping = rev_map;\n    }\n\n    /**\n     * @param {GroupedGRanges|GRanges} query - The query object, containing ranges to be overlapped with those in the reference GroupedGRanges (that was used to construct this GroupedGRangesOverlapIndex object).\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.ignoreStrand=true] - Whether to ignore differences in strandedness between the ranges in `query` and the reference object.\n     *\n     * @return {Array} An array of length equal to the number of ranges or groups in `query`,\n     * where each element is an array containing the indices of the overlapping ranges in the reference {@linkplain GRanges} object.\n     */\n    overlap(query, { ignoreStrand = true } = {}) {\n        let output = new Array(this._rangeStarts.length);\n        let rev_map = this._reverseMapping;\n\n        if (query instanceof GroupedGRanges) {\n            let overlaps = this._index.overlap(query._ranges);\n            for (var i = 0; i < query._rangeStarts.length; i++) {\n                let start = query._rangeStarts[i];\n                let end = start + query._rangeLengths[i];\n\n                let results = new Set;\n                for (var s = start; s < end; s++) {\n                    overlaps[s].forEach(x => results.add(rev_map[x]));\n                }\n                output[i] = Array.from(results);\n            }\n\n        } else {\n            let overlaps = this._index.overlap(query);\n            for (var i = 0; i < overlaps.length; i++) {\n                let results = new Set;\n                overlaps[i].forEach(x => results.add(rev_map[x]));\n                output[i] = Array.from(results);\n            }\n        }\n\n        return output;\n    }\n\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./utils/general.js\";\nimport * as nutils from \"./utils/normalization.js\";\nimport * as qc_module from \"./crispr_quality_control.js\";\nimport * as filter_module from \"./cell_filtering.js\";\n\nexport const step_name = \"crispr_normalization\";\n\n/**\n * This step performs normalization and log-transformation on the QC-filtered CRISPR count matrix from the {@linkplain CellFilteringState}.\n * It wraps the [`logNormCounts`](https://kanaverse.github.io/scran.js/global.html#logNormCounts) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CrisprNormalizationState {\n    #qc;\n    #filter;\n    #parameters;\n    #cache;\n\n    constructor(qc, filter, parameters = null, cache = null) {\n        if (!(qc instanceof qc_module.CrisprQualityControlState)) {\n            throw new Error(\"'qc' should be a CrisprQualityControlState object\");\n        }\n        this.#qc = qc;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.total_buffer);\n        utils.freeCache(this.#cache.centered_buffer);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let filtered = this.#filter.fetchFilteredMatrix();\n        return filtered.has(\"CRISPR\");\n    }\n\n    /**\n     * @return {external:ScranMatrix} A {@linkplain external:ScranMatrix ScranMatrix} object containing the normalized CRISPR abundances,\n     * available after running {@linkcode CrisprNormalizationState#compute compute}.\n     */\n    fetchNormalizedMatrix() {\n        if (!(\"matrix\" in this.#cache)) {\n            this.#raw_compute();\n        }\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {Float64WasmArray} Array of length equal to the number of cells, \n     * containing the CRISPR-derived size factor for each cell.\n     * This is available after running {@linkcode RnaNormalizationState#compute compute}.\n     */\n    fetchSizeFactors() {\n        let buff;\n        if (this.#cache.sum_buffer) {\n            buff = utils.allocateCachedArray(this.#cache.sum_buffer.length, \"Float64Array\", this.#cache, \"centered_buffer\");\n            scran.centerSizeFactors(this.#cache.sum_buffer, { buffer: buff, block: this.#filter.fetchFilteredBlock() })\n        }\n        return buff;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #raw_compute() {\n        var mat = this.#filter.fetchFilteredMatrix().get(\"CRISPR\");\n        let buffer = nutils.subsetSums(this.#qc, this.#filter, mat, this.#cache, \"sum_buffer\");\n\n        var block = this.#filter.fetchFilteredBlock();\n        utils.freeCache(this.#cache.matrix);\n        this.#cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block, allowZeros: true });\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `crispr_normalization` property of the `parameters` of {@linkcode runAnalysis}.\n     *\n     * @return The object is updated with new results.\n     */\n    compute(parameters) {\n        this.changed = false;\n        if (this.#qc.changed || this.#filter.changed) {\n            if (this.valid()) {\n                this.#raw_compute();\n                this.changed = true;\n            }\n        } \n\n        return;\n    }\n\n    static defaults() {\n        return {};\n    }\n\n    /*************************\n     ******** Saving *********\n     *************************/\n\n    serialize(handle) {\n        let ghandle = handle.createGroup(step_name);\n        let phandle = ghandle.createGroup(\"parameters\"); \n        let rhandle = ghandle.createGroup(\"results\"); \n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, qc, filter) {\n    return new CrisprNormalizationState(qc, filter);\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Compute per-cell scores for the activity of a feature set.\n *\n * @param {ScranMatrix} x - Log-normalized expression matrix.\n * @param {Uint8Array|Uint8WasmArray|TypedArray|Array} features - An array of length equal to the number of rows in `x`, indicating which features belong to the set.\n * A non-zero value for any entry indicates that the corresponding row of `x` is part of the feature set.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {boolean} [options.scale=false] - Whether to scale the expression matrix to unit variance for each feature before computing the per-feature weights.\n * Setting to `true` improves robustness (or reduces sensitivity) to the behavior of highly variable features in the set.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {object} Object containing:\n *\n * - `weights`, a Float64Array containing per-gene weights for each feature in the set.\n * - `scores`, a Float64Array containing the per-cell scores for each column of `x`.\n */\nexport function scoreFeatureSet(x, features, { block = null, scale = false, numberOfThreads = null } = {}) {\n    let temp;\n    let output = {};\n    let feature_data, block_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        // Setting up the features.\n        if (features.length !== x.numberOfRows()) {\n            throw new Error(\"Uint8Array 'features' must be of length equal to the number of rows in 'x'\");\n        }\n        feature_data = utils.wasmifyArray(features, \"Uint8WasmArray\");\n\n        // Setting up the blocks.\n        var bptr = 0;\n        var use_blocks = false;\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        temp = wasm.call(module => module.score_feature_set(x.matrix, feature_data.offset, use_blocks, bptr, scale, nthreads));\n        output.weights = temp.weights().slice();\n        output.scores = temp.scores().slice();\n\n    } finally {\n        utils.free(block_data);\n        utils.free(feature_data);\n        if (temp) {\n            temp.delete();\n        }\n    }\n\n    return output;\n}\n","import * as utils from \"./utils.js\";\n\nconst _cache = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the embeddings if they are not already available.\n * If `false`, `null` is returned if the embeddings have not already been loaded into memory.\n *\n * @return {?Object} Object with the `x` and `y`-coordinates for the t-SNE embedding.\n * \n * Each value is a Float64Array of length equal to the total number of sets for this `species`.\n * Each entry of the Float64Array corresponds to a gene set in {@linkcode fetchAllSets} and that set's x/y-coordinates on the embedding.\n * \n * If the embedding mappings have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchEmbeddings(species, { download = true } = {}) {\n    let found = _cache.get(species);\n    if (typeof found !== \"undefined\") {\n        return found;\n    } else if (!download) {\n        return null;\n    }\n\n    let res = await utils.reference_download(species + \"_tsne.tsv.gz\");\n    if (!res.ok) {\n        throw new Error(\"failed to fetch embeddings for species '\" + species + \"'\");\n    }\n\n    let embed_data = utils.decompressLines(await res.arrayBuffer());\n    let loaded = convertToCoordinates(embed_data);\n\n    _cache.set(species, loaded);\n    return loaded;\n}\n\n// Provided for back-compatibility.\nexport function fetchEmbeddingsForSpecies(species, { download = true } = {}) {\n    return fetchEmbeddings(species, { download });\n}\n\nfunction convertToCoordinates(lines) {\n    var x = [], y = [];\n\n    for (let i = 0; i < lines.length; i++) {\n        let split = lines[i].split(\"\\t\");\n        x.push(Number(split[0]));\n        y.push(Number(split[1]));\n    }\n\n    return {\n        \"x\": new Float64Array(x), \n        \"y\": new Float64Array(y)\n    }\n};\n","import { reference_download, decompressLines } from \"./utils.js\";\n\nvar _collections = new Map;\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.download=true] - Whether to download the collection details if they are not already available.\n * If `false`, `null` is returned if the collection details have not already been loaded into memory.\n *\n * @return {?Array} Array of objects where each entry corresponds to a set collection and contains details about that collection.\n * Each object can be expected to contain:\n * \n * - `title`, the title for the collection.\n * - `description`, the description for the collection.\n * - `species`, the species for all gene identifiers in the collection.\n *   This should contain the full scientific name, e.g., `\"Homo sapiens\"`, `\"Mus musculus\"`.\n * - `maintainer`, the maintainer of this collection.\n * - `source`, the source of this set, usually a link to some external resource.\n * - `start`, the index for the first set in the collection in the output of {@linkcode sets}.\n *   All sets from the same collection are stored contiguously.\n * - `size`, the number of sets in the collection.\n *\n * In a **gesel** context, the identifier for a collection (i.e., the \"collection ID\") is defined as the index of the collection in this array.\n *\n * If the collection details have not already been loaded and `download = false`, `null` is returned.\n * @async\n */\nexport async function fetchAllCollections(species, { download = true } = {}) {\n    let target = _collections.get(species);\n    if (typeof target !== \"undefined\") {\n        return target;\n    } else if (!download) {\n        return null;\n    }\n\n    target = [];\n    _collections.set(species, target);\n\n    var cres = await reference_download(species + \"_collections.tsv.gz\");\n    if (!cres.ok) {\n        throw new Error(\"failed to fetch collection information for species '\" + species + \"'\");\n    }\n    var coll_data = decompressLines(await cres.arrayBuffer());\n\n    var start = 0;\n    for (var i = 0; i < coll_data.length; i++) {\n        let x = coll_data[i];\n        var details = x.split(\"\\t\");\n        var len = Number(details[5]);\n        target.push({\n            \"title\": details[0],\n            \"description\": details[1],\n            \"species\": details[2],\n            \"maintainer\": details[3],\n            \"source\": details[4],\n            \"start\": start,\n            \"size\": len\n        });\n        start += len;\n    }\n\n    return target;\n}\n","export function areArraysEqual(x, y) {\n    if (x.length !== y.length) {\n        return false;\n    }\n\n    for (var i = 0; i < x.length; i++) {\n        if (x[i] != y[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function isArrayLike(x) {\n    return x.constructor == Array || ArrayBuffer.isView(x);\n}\n\nexport function chooseArrayConstructors(con1, con2) {\n    if (con1 == con2) {\n        return con1;\n    }\n\n    if (con1 == Array || con2 == Array) {\n        return Array;\n    }\n\n    if (con1 == BigInt64Array || con2 == BigInt64Array || con1 == BigUint64Array || con2 == BigUint64Array) {\n        return Array;\n    }\n\n    return Float64Array;\n}\n\nexport function formatLengthError(left, right) {\n    return new Error(left + \" should have length equal to \" + right);\n}\n\nexport function checkStringArray(names, typeMessage) {\n    for (const x of names) {\n        if (typeof x !== \"string\") {\n            throw new Error(typeMessage + \" array should only contain strings\");\n        }\n    }\n}\n\nexport function checkNamesArray(names, typeMessage, numExpected, lengthMessage) {\n    checkStringArray(names, typeMessage);\n    if (names.length != numExpected) {\n        throw formatLengthError(typeMessage + \" array\", lengthMessage);\n    }\n}\n\nexport function sum(y) {\n    let total = 0;\n    y.forEach(x => { total += x; });\n    return total;\n}\n\nexport function combineNames(all_names, all_lengths, total_n = null) {\n    let all_null = true;\n    for (var i = 0; i < all_names.length; i++) {\n        if (all_names[i] !== null) {\n            all_null = false;\n        }\n    }\n\n    if (all_null) {\n        return null;\n    }\n\n    if (total_n === null) {\n        total_n = sum(all_lengths);\n    }\n\n    let output = new Array(total_n);\n    let counter = 0;\n    for (var i = 0; i < all_names.length; i++) {\n        let n = all_names[i];\n        if (n === null) {\n            output.fill(\"\", counter, counter + all_lengths[i]);\n            counter += all_lengths[i];\n        } else {\n            n.forEach(x => {\n                output[counter] = x;\n                counter++;\n            });\n        }\n    }\n\n    return output;\n}\n\nexport function createSequence(n) {\n    let output = new Int32Array(n);\n    for (var i = 0; i < n; i++) {\n        output[i] = i;\n    }\n    return output;\n}\n\nexport function isSorted(n, cmp) {\n    for (var i = 1; i < n; ++i) {\n        if (cmp(i-1, i) > 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function convertToInt32Array(x) {\n    if (x instanceof Int32Array) {\n        return x;\n    } else {\n        return new Int32Array(x);\n    }\n}\n\nexport function checkNonNegative(x, msg) {\n    for (const y of x) {\n        if (y < 0) {\n            throw new Error(\"detected a negative entry in '\" + msg + \"'\");\n        }\n    }\n}\n\nexport function object2map(x) {\n    if (x.constructor == Object) {\n        let replacement = new Map;\n        for (const [k, v] of Object.entries(x)) {\n            replacement.set(k, v);\n        }\n        return replacement;\n    } \n\n    if (!(x instanceof Map)) {\n        throw new Error(\"'x' should be either an object or Map\");\n    }\n    return x;\n}\n","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","import * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\nexport class InternalList {\n    constructor(entries, order) {\n        if (arguments.length == 0){\n            return;\n        }\n\n        entries = utils.object2map(entries);\n\n        let expected = Array.from(entries.keys());\n        if (order !== null) {\n            utils.checkNamesArray(order, \"'order'\", expected.length, \"the length of 'entries'\");\n            let observed = order.slice().sort();\n            expected.sort();\n\n            if (!utils.areArraysEqual(observed, expected)) {\n                throw new Error(\"values of 'order' should be the same as the keys of 'entries'\");\n            }\n        } else {\n            order = expected;\n        }\n\n        this._entries = entries;\n        this._order = order;\n    }\n\n    static className = \"InternalList\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    names() {\n        return this._order;\n    }\n\n    numberOfEntries() {\n        return this._order.length;\n    }\n\n    #check_entry_index(i) {\n        if (i < 0 || i >= this._order.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n    }\n\n    entry(i) {\n        if (typeof i == \"string\") {\n            if (!this._entries.has(i)) {\n                throw new Error(\"no entry '\" + i + \"' present in this \" + this.constructor.className);\n            }\n            return this._entries.get(i);\n        } else {\n            this.#check_entry_index(i);\n            return this._entries.get(this._order[i]);\n        }\n    }\n\n    has(name) {\n        return this._entries.has(name);\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n    \n    delete(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            // Shallow copies so that we can do our setting.\n            target._order = target._order.slice();\n            target._entries = new Map(target._entries); \n        }\n\n        if (typeof i == \"string\") {\n            let ii = target._order.indexOf(i);\n            if (ii < 0) {\n                throw new Error(\"no entry '\" + i + \"' present in this \" + this.constructor.className);\n            }\n            target._order.splice(ii, 1); \n            target._entries.delete(i);\n        } else {\n            this.#check_entry_index(i);\n            let n = target._order[i];\n            target._order.splice(i, 1);\n            target._entries.delete(n);\n        }\n\n        return target;\n    }\n\n    set(i, value, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            // Shallow copy so that we can do our setting.\n            target._entries = new Map(target._entries);\n        }\n\n        if (typeof i == \"string\") {\n            if (!target._entries.has(i)) {\n                if (!inPlace) {\n                    target._order = target._order.slice();\n                }\n                target._order.push(i);\n            }\n            target._entries.set(i, value);\n        } else {\n            this.#check_entry_index(i);\n            target._entries.set(target._order[i], value);\n        }\n\n        return target;\n    }\n\n    setNames(names, { inPlace = false } = {}) {\n        utils.checkNamesArray(names, \"replacement 'names'\", this._order.length, \"length of 'names()'\");\n\n        let new_entries = new Map;\n        for (var i = 0; i < names.length; i++) {\n            if (new_entries.has(names[i])) {\n                throw new Error(\"detected duplicate value '\" + names[i] + \"' in replacement 'names'\");\n            }\n            new_entries.set(names[i], this._entries.get(this._order[i]));\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._entries = new_entries;\n        target._order = names;\n        return target;\n    }\n\n    slice(indices, { inPlace = false } = {}) {\n        let new_entries = new Map;\n        let new_order = [];\n\n        for (var ii of indices) {\n            if (typeof ii != \"string\") {\n                this.#check_entry_index(ii);\n                ii = this._order[ii];\n            }\n            if (new_entries.has(ii)) {\n                throw new Error(\"duplicate entries detected in slice request\");\n            } else if (!this._entries.has(ii)) {\n                throw new Error(\"slice contains missing entry '\" + ii + \"' \");\n            }\n\n            new_entries.set(ii, this._entries.get(ii));\n            new_order.push(ii);\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._entries = new_entries;\n        target._order = new_order;\n        return target;\n    }\n\n    reorder(indices, { inPlace = false } = {}) {\n        // Reorder can be slightly more efficient than slice because we just\n        // need to change the ordering vector rather than creating a new Map.\n        if (indices.length !== this._order.length) {\n            throw utils.formatLengthError(\"reordered indices\", \"the number of existing entries\");\n        }\n\n        let new_order = [];\n        for (var ii of indices) {\n            if (typeof ii != \"string\") {\n                this.#check_entry_index(ii);\n                ii = this._order[ii];\n            }\n            if (!this._entries.has(ii)) {\n                throw new Error(\"missing entry '\" + ii + \"' among the reordered indices\");\n            }\n            new_order.push(ii);\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._order = new_order;\n        return target;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_CLONE(output, { deepCopy = true } = {}) {\n        output._entries = (deepCopy ? generics.CLONE(this._entries) : this._entries);\n        output._order = (deepCopy ? generics.CLONE(this._order) : this._order);\n        return;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    apply(FUN, { inPlace = false } = {}) {\n        let new_entries = (inPlace ? this._entries : new Map);\n        for (const [k, v] of this._entries) {\n            new_entries.set(k, FUN(v));\n        }\n        return (inPlace ? this : new InternalList(new_entries, this._order));\n    }\n\n    static parallelCombine(objects, combiner) {\n        let first_order = objects[0]._order;\n        for (var i = 1; i < objects.length; i++) {\n            if (!utils.areArraysEqual(first_order, objects[i]._order)) {\n                throw new Error(\"detected differences in names between first object and object \" + String(i) + \" to be combined\");\n            }\n        }\n\n        let new_entries = new Map;\n        for (const k of first_order) {\n            let found = objects.map(x => x._entries.get(k));\n            new_entries.set(k, combiner(found));\n        }\n\n        return new InternalList(new_entries, first_order);\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as utils from \"./utils.js\";\nimport { ScranMatrix } from \"./ScranMatrix.js\";\n\n/**\n * Wrapper for the cell aggregation results, produced by {@linkcode aggregateAcrossCells}.\n * @hideconstructor\n */\nexport class AggregateAcrossCellsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of groups.\n     */\n    numberOfGroups() {\n        return this.#results.num_groups();\n    }\n\n    /**\n     * @return {number} Number of genes.\n     */\n    numberOfGenes() {\n        return this.#results.num_genes();\n    }\n\n    /**\n     * @param {?number} group - Index of the group.\n     * If a number, it should be non-negative and less than {@linkcode AggregateAcrossCellsResults#numberOfGroups numberOfGroups}.\n     * This may also be `null` to obtain values for all groups.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {(string|boolean)} [options.copy=true] - Copying mode to use when `asMatrix = false`, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray}\n     * If `group` is a number, an array is returned where each entry corresponds to a gene and contains the summed value across all cells in the specified `group`.\n     * If {@linkcode aggregateAcrossCells} was run with `average = true`, the array contains the mean value instead of the sum.\n     *\n     * If `group = null`, an array is returned containing the concatenation of the arrays for all groups.\n     * If `copy = \"view\"`, the output can be used in {@linkcode ScranMatrix#createDenseMatrix ScranMatrix.createDenseMatrix} to create a {@linkcode ScranMatrix} for input into other functions.\n     */\n    sums(group, { copy = true } = {}) {\n        let vec = (group !== null ? this.#results.group_sums(group) : this.#results.all_sums());\n        return utils.possibleCopy(vec, copy);\n    }\n\n    /**\n     * @param {number} group - Index of the group.\n     * This should be non-negative and less than {@linkcode AggregateAcrossCellsResults#numberOfGroups numberOfGroups}.\n     * This may also be `null` to obtain values for all groups.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {(string|boolean)} [options.copy=true] - Copying mode to use when `asMatrix = false`, see {@linkcode possibleCopy} for details.\n     *\n     * @return {Float64Array|Float64WasmArray}\n     * If `group` is a number, an array is returned where each entry corresponds to a gene and contains the number of detected cells in the specified `group`.\n     * If {@linkcode aggregateAcrossCells} was run with `average = true`, each value is the proportion of cells with detected expression.\n     * \n     * If `group = null`, an array is returned containing the concatenation of the arrays for all groups.\n     * If `copy = \"view\"`, the output can be used in {@linkcode ScranMatrix#createDenseMatrix ScranMatrix.createDenseMatrix} to create a {@linkcode ScranMatrix} for input into other functions.\n     */\n    detected(group, { copy = true } = {}) {\n        let vec = (group !== null ? this.#results.group_detected(group) : this.#results.all_detected());\n        return utils.possibleCopy(vec, copy);\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Aggregate per-cell expression profiles for each group of cells.\n * This is typically used to summarize data into per-cluster expression profiles for easier inspection.\n *\n * @param {ScranMatrix} x - Some expression matrix, typically containing normalized log-expression values.\n * @param {Int32Array|Int32WasmArray} groups - Array containing group IDs for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.average=false] - Whether to compute the average expression instead of the sum for each group.\n * Similarly, the proportion of detected expression is reported, rather than the number of detected cells in each group.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {AggregateAcrossCellsResults} Object containing the aggregation results.\n */\nexport function aggregateAcrossCells(x, groups, { average = false, numberOfThreads = null } = {}) {\n    var group_data;\n    var output;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        group_data = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (group_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'groups' should be equal to number of columns in 'x'\");\n        }\n\n        output = gc.call(\n            module => module.aggregate_across_cells(x.matrix, group_data.offset, average, nthreads),\n            AggregateAcrossCellsResults \n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(group_data);\n    }\n\n    return output;\n}\n","import * as bioc from \"bioconductor\";\n\nexport function cloneCached(x, cached) {\n    return (cached ? bioc.CLONE(x) : x);\n}\n\n/**\n * A representation of a matrix of expression values, where the values are hosted on the Wasm heap for easier compute via [**scran.js**](https://github.com/jkanche/scran.js).\n * See [here](https://jkanche.github.io/scran.js/ScranMatrix.html) for more details.\n *\n * @external ScranMatrix\n */ \n\n/**\n * A representation of multiple {@linkplain external:ScranMatrix ScranMatrix} objects, where each object contains data for the same cells but across a different feature space, e.g., for different data modalities.\n * See [here](https://jkanche.github.io/scran.js/MultiMatrix.html) for more details.\n *\n * @external MultiMatrix\n */ \n\n\n/**\n * A DataFrame from the [**bioconductor**](https://github.com/LTLA/bioconductor.js) package, where each column is represented by some arbitrary vector-like object.\n * See [here](https://ltla.github.io/bioconductor.js/DataFrame.html) for more details.\n *\n * @external DataFrame\n */ \n\n/**\n * Representation of a file that is agnostic to the environment (Node.js or browser) or the nature of the contents (buffer or file path).\n * See [here](https://ltla.github.io/bakana/SimpleFile.html) for more details.\n *\n * @external SimpleFile\n */ \n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as bakana from \"bakana\";\nimport * as utils from \"./utils.js\";\n\nconst baseUrl = \"https://experimenthub.bioconductor.org/fetch\";\n\nconst registry = {\n    \"zeisel-brain\": { \"counts\": \"2596\", \"coldata\": \"2598\", \"rowdata\": \"2597\" }, // corresponding to EH2580, 2582 and 2581, for whatever reason.\n    \"segerstolpe-pancreas\": { \"counts\": \"2591\", \"coldata\": \"2593\", \"rowdata\": \"2592\" }, // corresponding to EH2575, 2577 and 2576.\n    \"nestorowa-hsc\": { \"counts\": \"2710\", \"ncol\": 1920 }, // corresponding to EH2694; the coldata doesn't contain much that's useful here.\n    \"aztekin-tail\": { \"counts\": \"3124\", \"coldata\": \"3125\" }, // corresponding to EH3108 and 3109.\n    \"wu-kidney\": { \"counts\": \"3594\", \"coldata\": \"3595\" }, // corresponding to EH3558 and 3559.\n    \"zilionis-mouse-lung\": { \"counts\": \"3478\", \"coldata\": \"3479\" } // corresponding to EH3462 and 3463.\n};\n\nfunction check_class(handle, accepted, base) {\n    if (!(handle instanceof scran.RdsS4Object)) {\n        throw new Error(\"expected an S4 object\");\n    }\n\n    for (const [k, v] of Object.entries(accepted)) {\n        if (handle.className() == k && handle.packageName() == v) {\n            return;\n        }\n    }\n    throw new Error(\"object is not a \" + base + \" or one of its recognized subclasses\");\n}\n\nfunction load_listData_names(lhandle) {\n    let ndx = lhandle.findAttribute(\"names\");\n    if (ndx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let names;\n    try {\n        nhandle = lhandle.attribute(ndx);\n        names = nhandle.values();\n    } catch(e) {\n        throw new Error(\"failed to load listData names; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    if (names.length != lhandle.length()) {\n        throw new Error(\"expected names to have same length as listData\");\n    }\n    return names;\n}\n\nfunction populate_list_columns(lhandle, output) {\n    let colnames = load_listData_names(lhandle);\n    if (colnames == null) {\n        throw new Error(\"expected the listData list to be named\");\n    }\n    let columns = {};\n\n    for (var i = 0; i < lhandle.length(); i++) {\n        let curhandle;\n        try {\n            curhandle = lhandle.load(i);\n            if (curhandle instanceof scran.RdsVector && !(curhandle instanceof scran.RdsGenericVector)) {\n                let curcol = curhandle.values();\n                columns[colnames[i]] = curcol;\n                output.nrow = curcol.length;\n            }\n        } finally {\n            scran.free(curhandle);\n        }\n    }\n\n    output.columns = columns;\n    return;\n}\n\nfunction load_data_frame(handle) {\n    let output = {};\n\n    if (handle.type() == \"S4\") {\n        check_class(handle, { \"DFrame\": \"S4Vectors\", \"DataFrame\": \"S4Vectors\" }, \"DFrame\");\n\n        // Loading the atomic columns.\n        let lhandle;\n        try {\n            lhandle = handle.attribute(\"listData\");\n            if (!(lhandle instanceof scran.RdsGenericVector)) {\n                throw new Error(\"listData slot should be a generic list\");\n            }\n            populate_list_columns(lhandle, output);\n        } catch(e) {\n            throw new Error(\"failed to retrieve data from DataFrame's listData; \" + e.message);\n        } finally {\n            scran.free(lhandle);\n        }\n    } else {\n        if (handle.type() != \"vector\") {\n            throw new Error(\"expected a data.frame or DataFrame instance\");\n        }\n        populate_list_columns(handle, output);\n    }\n\n    // Loading the row names.\n    let rnhandle;\n    try {\n        let rndx = handle.findAttribute(\"rownames\");\n        if (rndx >= 0) {\n            rnhandle = handle.attribute(rndx);\n            if (rnhandle instanceof scran.RdsStringVector) {\n                output.row_names = rnhandle.values();\n                output.nrow = output.row_names.length;\n            }\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve row names from DataFrame; \" + e.message);\n    } finally {\n        scran.free(rnhandle);\n    }\n\n    // Loading the number of rows.\n    if (!(\"nrow\" in output)) {\n        let nrhandle;\n        try {\n            nrhandle = handle.attribute(\"nrows\");\n            if (!(nrhandle instanceof scran.RdsIntegerVector)) {\n                throw new Error(\"expected an integer vector as the 'nrows' slot\");\n            }\n            let NR = nrhandle.values();\n            if (NR.length != 1) {\n                throw new Error(\"expected an integer vector of length 1 as the 'nrows' slot\");\n            }\n            output.nrow = NR[0];\n        } catch (e) {\n            throw new Error(\"failed to retrieve nrows from DataFrame; \" + e.message);\n        } finally {\n            scran.free(nrhandle);\n        }\n    }\n\n    return output;\n}\n\nfunction extract_matrix_rownames(handle) {\n    let idx;\n\n    if (handle.type() == \"S4\") {\n        check_class(handle, { \"dgCMatrix\": \"Matrix\", \"dgTMatrix\": \"Matrix\" }, \"Matrix\");\n        idx = handle.findAttribute(\"Dimnames\");\n    } else {\n        idx = handle.findAttribute(\"dimnames\");\n    }\n\n    if (idx < 0) {\n        throw new Error(\"count matrix does not have dimnames\");\n    }\n\n    let dimhandle;\n    let firsthandle;\n    let output;\n    \n    try {\n        dimhandle = handle.attribute(idx);\n        if (dimhandle.type() != \"vector\" && dimhandle.size() != 2) {\n            throw new Error(\"dimnames of the count matrix should be a list of length 2\");\n        }\n\n        firsthandle = dimhandle.load(0);\n        if (firsthandle.type() != \"string\") {\n            throw new Error(\"expected a character vector in the first dimnames\");\n        }\n\n        output = firsthandle.values();\n    } finally {\n        scran.free(dimhandle);\n        scran.free(firsthandle);\n    }\n\n    return output;\n}\n\n/**\n * Dataset derived from a SummarizedExperiment-like representation on Bioconductor's [ExperimentHub](https://bioconductor.org/packages/ExperimentHub).\n */\nexport class ExperimentHubDataset {\n    #id;\n\n    #rowdata;\n    #coldata;\n\n    #counts_handle;\n    #counts_loaded;\n\n    // We should _know_ which experiments correspond to which modality for each\n    // dataset in our registry, so there's no need to provide options for that.\n    // However, we might not know how to choose an appropriate primary\n    // identifier for combining datasets, hence these options.\n    #options;\n\n    /****************************************\n     ****************************************/\n\n    static #downloadFun = async url => {\n        let resp = await fetch(url);\n        if (!resp.ok) {\n            throw new Error(\"failed to fetch content at \" + url + \" (\" + resp.status + \")\");\n        }\n        return new Uint8Array(await resp.arrayBuffer());\n    }\n\n    /** \n     * @param {function} fun - Function that accepts a URL string and downloads the resource,\n     * returning a Uint8Array of its contents.\n     * Alternatively, on Node.js, the funciton may return a string containing the path to the downloaded resource.\n     * @return {function} Previous setting of the download function.\n     */\n    static setDownloadFun(fun) {\n        let previous = ExperimentHubDataset.#downloadFun;\n        ExperimentHubDataset.#downloadFun = fun;\n        return previous;\n    }\n\n    /****************************************\n     ****************************************/\n\n    /**\n     * @return {Array} Array of strings containing identifiers of available datasets.\n     * @static\n     */\n    static availableDatasets() {\n        return Object.keys(registry);\n    }\n\n    /**\n     * @param {string} id - Identifier of a dataset to load.\n     * This should be a string in {@linkcode ExperimentHubDataset.availableDatasets availableDatasets}.\n     */\n    constructor(id) {\n        this.#id = id;\n        if (!(this.#id in registry)) {\n            throw new Error(\"unrecognized identifier '\" + this.#id + \"' for ExperimentHub-based datasets\");\n        }\n\n        this.#options = ExperimentHubDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode ExperimentHubDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            primaryRnaFeatureIdColumn: 0\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode ExperimentHubDataset#load load} (but not {@linkcode ExperimentHubDataset#summary summary}).\n     * @param {string|number} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     * If `i` is invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is treated as undefined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"ExperimentHub\";\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode ExperimentHubDataset#load load} or {@linkcodeExperimentHubDataset#annotations annotations}. \n     */\n    clear() {\n        scran.free(this.#counts_handle);\n        scran.free(this.#counts_loaded);\n        this.#counts_handle = null;\n        this.#counts_loaded = null;\n        this.#rowdata = null;\n        this.#coldata = null;\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return { \"id\": this.#id, \"options\": this.options() };\n    }\n\n    async #counts() {\n        if (this.#counts_handle !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n        let counts_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.counts);\n        try {\n            this.#counts_loaded = scran.readRds(counts_deets);\n            this.#counts_handle = this.#counts_loaded.value();\n        } catch(e) {\n            scran.free(this.#counts_handle);\n            scran.free(this.#counts_loaded);\n            throw e;\n        }\n    }\n\n    async #features() {\n        if (this.#rowdata !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n\n        if (\"rowdata\" in details) {\n            let rowdata_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.rowdata);\n\n            let rowdata_load;\n            let rowdata_handle;\n            try {\n                rowdata_load = scran.readRds(rowdata_deets);\n                rowdata_handle = rowdata_load.value();\n                let rowdata = load_data_frame(rowdata_handle);\n                let names = rowdata.row_names;\n\n                let output = {};\n                if (names) {\n                    output.id = names;\n                }\n\n                for (const [k, v] of Object.entries(rowdata.columns)) {\n                    if (k.match(/^sym/)) {\n                        output[k] = v;\n                    }\n                }\n\n                if (Object.keys(output).length == 0) {\n                    throw new Error(\"no acceptable feature identifiers found in the rowData DataFrame\");\n                }\n                this.#rowdata = new bioc.DataFrame(output);\n            } finally {\n                scran.free(rowdata_handle);\n                scran.free(rowdata_load);\n            }\n            return;\n        }\n\n        // Otherwise we pull the details from the counts.\n        await this.#counts();\n        let ids = extract_matrix_rownames(this.#counts_handle);\n        this.#rowdata = new bioc.DataFrame({ id: ids });\n    }\n\n    async #cells() {\n        if (this.#coldata !== null) {\n            return;\n        }\n\n        let details = registry[this.#id];\n        if (\"coldata\" in details) {\n            let coldata_deets = await ExperimentHubDataset.#downloadFun(baseUrl + \"/\" + details.coldata);\n\n            let coldata_load;\n            let coldata_handle; \n            let cd_df;\n            try {\n                coldata_load = scran.readRds(coldata_deets);\n                coldata_handle = coldata_load.value();\n                cd_df = load_data_frame(coldata_handle);\n            } finally {\n                scran.free(coldata_handle);\n                scran.free(coldata_load);\n            }\n\n            this.#coldata = new bioc.DataFrame(cd_df.columns, { numberOfRows: cd_df.nrow });\n        } else {\n            this.#coldata = new bioc.DataFrame({}, { numberOfRows: details.ncol });\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     *   Unlike {@linkcode ExperimentHubDataset#load load}, modality names are arbitrary.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     */\n    async summary({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n\n        let output = { cells: utils.cloneCached(this.#coldata, cache) };\n        let my_rd = utils.cloneCached(this.#rowdata, cache);\n        output.modality_features = { \"RNA\": my_rd };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #fetchPrimaryId(curfeat) {\n        let id = this.#options.primaryRnaFeatureIdColumn;\n        if ((typeof id == \"string\" && curfeat.hasColumn(id)) || (typeof id == \"number\" && id < curfeat.numberOfColumns())) {\n            return { RNA: curfeat.column(id) };\n        } else {\n            return { RNA: curfeat.rowNames() };\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode ExperimentHubDataset#load load} but the order of values may be different.\n     *\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#features();\n        let preview = this.#fetchPrimaryId(this.#rowdata);\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode ExperimentHubDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an integer array containing the feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode ExperimentHubDataset#defaults defaults} or with {@linkcode ExperimentHubDataset#setOptions setOptions}.\n     */\n    async load({ cache = false } = {}) {\n        await this.#features();\n        await this.#cells();\n        await this.#counts();\n\n        let output = {\n            cells: utils.cloneCached(this.#coldata, cache)\n        };\n\n        // Hard-coding the fact that we're dealing with RNA here, as all\n        // registry entries are currently RNA-only anyway.\n        let details = registry[this.#id];\n        try {\n            output.matrix = new scran.MultiMatrix;\n            let counts = scran.initializeSparseMatrixFromRds(this.#counts_handle, { consume: !cache });\n\n            output.matrix.add(\"RNA\", counts.matrix);\n            output.row_ids = { \"RNA\": counts.row_ids };\n\n            let perm_features = bioc.SLICE(this.#rowdata, counts.row_ids);\n            output.features = { \"RNA\": perm_features };\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        output.primary_ids = this.#fetchPrimaryId(output.features.RNA);\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        const enc = new TextEncoder;\n        let buffer = enc.encode(this.#id);\n\n        // Storing it as a string in the buffer.\n        let output = {\n            type: \"id\",\n            file: new bakana.SimpleFile(buffer, { name: \"id\" })\n        };\n\n        return {\n            files: [ output ],\n            options: this.options()\n        }\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ExperimentHubDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ExperimentHubDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        let args = {};\n\n        // This should contain 'id'.\n        for (const x of files) {\n            const dec = new TextDecoder;\n            args[x.type] = dec.decode(x.file.buffer());\n        }\n\n        if (!(\"id\" in args)) {\n            throw new Error(\"expected a file of type 'id' when unserializing ExperimentHub dataset\"); \n        }\n        return new ExperimentHubDataset(args.id, options);\n    }\n}\n","/**\n * Representation of a HTTP response error.\n * The error message is captured in `message` as usual, but the HTTP status code may also be retrieved via the `statusCode` property.\n */\nexport class HttpError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.statusCode = code;\n    }\n}\n\nexport async function checkHttpResponse(res, msg) {\n    if (res.ok) {\n        return;\n    }\n\n    let info = await res.json();\n    if (info.status == \"error\") {\n        throw new HttpError(msg + \"; \" + info.reason, res.status);\n    } \n\n    throw new HttpError(msg, res.status);\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as bakana from \"bakana\";\nimport * as adb from \"artifactdb\";\nimport * as utils from \"./utils.js\";\n\nconst baseUrl = \"https://collaboratordb.aaron-lun.workers.dev\";\n\nvar getFun = null;\nvar downloadFun = null;\n\nclass CollaboratordbNavigator {\n    #project;\n    #version;\n\n    constructor(project, version) {\n        this.#project = project;\n        this.#version = version;\n    }\n\n    async file(path) {\n        let id = adb.packId(this.#project, path, this.#version);\n        return await adb.getFile(baseUrl, id, { getFun: getFun, downloadFun: downloadFun });\n    }\n\n    async metadata(path) {\n        let id = adb.packId(this.#project, path, this.#version);\n        return await adb.getFileMetadata(baseUrl, id, { getFun: getFun });\n    }\n};\n\n/**\n * Dataset derived from a SummarizedExperiment in [CollaboratorDB](https://github.com/CollaboratorDB).\n * This extends the [AbstractArtifactdbDataset](https://kanaverse.github.io/bakana/AbstractArtifactdbDataset.html) class.\n */\nexport class CollaboratordbDataset extends bakana.AbstractArtifactdbDataset {\n    /** \n     * @param {?function} fun - Function that accepts a URL string and downloads the resource,\n     * returning a Uint8Array of the file contents.\n     * Alternatively, on Node.js, the function may return a string containing a file path to the downloaded resource.\n     * \n     * Alternatively `null`, to reset the function to its default value.\n     * See [`getFile`](https://artifactdb.github.io/artifactdb.js/global.html#getFile) for details.\n     * @return {?function} Previous setting of the download function.\n     */\n    static setDownloadFun(fun) {\n        let previous = downloadFun;\n        downloadFun = fun;\n        return previous;\n    }\n\n    /** \n     * @param {?function} fun - Function that accepts a URL string and performs a GET to return a Response object,\n     * see [`getFileMetadata`](https://artifactdb.github.io/artifactdb.js/global.html#getFileMetadata) for details.\n     * \n     * Alternatively `null`, to reset the function to its default value.\n     * @return {?function} Previous setting of the GET function.\n     */\n    static setGetFun(fun) {\n        let previous = getFun;\n        getFun = fun;\n        return previous;\n    }\n\n    /****************************************\n     ****************************************/\n\n    #id;\n    #unpacked;\n\n    /**\n     * @param {string} id - Identifier of a SummarizedExperiment in CollaboratorDB.\n     */\n    constructor(id) {\n        let unpacked = adb.unpackId(id);\n        super(unpacked.path, new CollaboratordbNavigator(unpacked.project, unpacked.version));\n        this.#id = id;\n        this.#unpacked = unpacked;\n        return;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"CollaboratorDB\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return { \n            \"id\": this.#id, \n            \"options\": this.options()\n        };\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        const enc = new TextEncoder;\n        let buffer = enc.encode(this.#id);\n\n        // Storing it as a string in the buffer.\n        let output = {\n            type: \"id\",\n            file: new bakana.SimpleFile(buffer, { name: \"id\" })\n        };\n\n        return {\n            files: [ output ],\n            options: this.options()\n        }\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode CollaboratordbDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {CollaboratordbDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        let args = {};\n\n        // This should contain 'id'.\n        for (const x of files) {\n            const dec = new TextDecoder;\n            args[x.type] = dec.decode(x.file.buffer());\n        }\n\n        if (!(\"id\" in args)) {\n            throw new Error(\"expected a file of type 'id' when unserializing CollaboratorDB dataset\"); \n        }\n        return new CollaboratordbDataset(args.id, options);\n    }\n}\n","import * as gc from \"./gc.js\";\nimport * as wasm from \"./wasm.js\";\nimport * as utils from \"./utils.js\";\n\nfunction checkFillness2(group, summary, fillable, copy, fillcheck, getfun) {\n    return utils.checkFillness(\n        fillable, \n        copy, \n        fillcheck.filled || fillcheck.details[group][summary] || false, \n        () => { fillcheck.details[group][summary] = true }, \n        getfun  \n    );\n}\n\nfunction intifySummary(summary) {\n    if (typeof summary == \"number\") {\n        return summary; // for back-compatibility with numeric summaries.\n    }\n    let output;\n    switch (summary) {\n        case \"minimum\": \n            output = 0;\n            break;\n        case \"mean\": \n            output = 1;\n            break;\n        case \"median\":\n            output = 2;\n            break;\n        case \"maximum\": \n            output = 3;\n            break;\n        case \"min-rank\":\n            output = 4;\n            break;\n        default:\n            throw new Error(\"unknown summary type '\" + summary + \"'\");\n    }\n    return output;\n}\n\n/**\n * Wrapper around the marker scoring results on the Wasm heap, typically produced by {@linkcode scoreMarkers}.\n * @hideconstructor\n */\nexport class ScoreMarkersResults {\n    #id;\n    #results;\n\n    #filledMeans;\n    #filledDetected;\n    #filledCohen;\n    #filledLfc;\n    #filledAuc;\n    #filledDeltaDetected;\n\n    constructor(id, raw, filled = true) {\n        this.#id = id;\n        this.#results = raw;\n\n        let n = this.numberOfGroups();\n        let b = this.numberOfBlocks();\n\n        function createBlockedStatsFilled(filled) {\n            let output = { filled };\n            if (!filled) {\n                output.details = new Array(n);\n                for (var g = 0; g < n; g++) {\n                    output.details[g] = utils.spawnArray(b + 1, filled);\n                }\n            }\n            return output;\n        }\n\n        this.#filledMeans = createBlockedStatsFilled(filled);\n        this.#filledDetected = createBlockedStatsFilled(filled);\n\n        function createEffectsFilled(filled) {\n            let output = { filled };\n            if (!filled) {\n                output.details = new Array(n);\n                for (var g = 0; g < n; g++) {\n                    output.details[g] = {};\n                }\n            }\n            return output;\n        }\n\n        this.#filledCohen = createEffectsFilled(filled); \n        this.#filledLfc = createEffectsFilled(filled); \n        this.#filledAuc = createEffectsFilled(filled); \n        this.#filledDeltaDetected = createEffectsFilled(filled); \n\n        return;\n    }\n\n    #extractBlockedStat(group, block, copy, fillable, fillcheck, method) {\n        let index = block;\n        if (block == null) {\n            let nblocks = this.numberOfBlocks();\n            index = (nblocks > 1 ? nblocks : 0);\n            block = -1;\n        }\n\n        return utils.checkFillness(\n            fillable, \n            copy, \n            fillcheck.filled || fillcheck.details[group][index] || false, \n            () => { fillcheck.details[group][index] = true }, \n            COPY => utils.possibleCopy(this.#results[method](group, block), COPY)\n        );\n    }\n\n    /**\n     * @return {number} Number of blocks used to compute the results.\n     */\n    numberOfBlocks() {\n        return this.#results.num_blocks();\n    }\n\n    /**\n     * @return {number} Number of groups in the results.\n     */\n    numberOfGroups() {\n        return this.#results.num_groups();\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the mean expression for the requested group in the requested block.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    means(group, { block = null, copy = true, fillable = false } = {}) {\n        return this.#extractBlockedStat(group, block, copy, fillable, this.#filledMeans, \"means\");\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?number} [options.block=null] - Number of the block for which to extract statistics.\n     * If `null`, the average across all blocks is returned.\n     * Otherwise, should be less than the value returned by {@linkcode ModelGeneVarResults#numberOfBlocks numberOfBlocks}.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the proportion of cells with detectable expression for the requested group in the requested block.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    detected(group, { block = null, copy = true, fillable = false } = {}) {\n        return this.#extractBlockedStat(group, block, copy, fillable, this.#filledDetected, \"detected\");\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the Cohen's d values of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized Cohen's d for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    cohen(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledCohen,\n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.cohen(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * AUCs are only computed if `computeAuc = true` in {@linkcode scoreMarkers}.\n     * If `false`, this method will throw an error.\n     *\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the AUCs of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized AUC for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    auc(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledAuc, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.auc(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the log-fold changes of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {?(Float64Array|Float64WasmArray)} Array of length equal to the number of genes,\n     * containing the summarized log-fold change for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    lfc(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledLfc, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.lfc(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @param {number} group - Group of interest.\n     * Should be non-negative and less than {@linkcode ScoreMarkersResults#numberOfGroups numberOfGroups}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {string} [options.summary=\"mean\"] - Summary statistic to be computed from the delta-detected values of all pairwise comparisons involving `group`.\n     * This can be the `\"minimum\"` across comparisons, `\"mean\"` or `\"min-rank\"`.\n     * @param {boolean} [options.copy=true] - Whether to copy the results from the Wasm heap, see {@linkcode possibleCopy}.\n     * @param {boolean} [options.fillable=false] - Whether to return a fillable array, to write to this object.\n     * If `true`, this method automatically sets `copy = false` if `copy` was previously true.\n     * If `false` and the array was not previously filled, `null` is returned.\n     *\n     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of genes,\n     * containing the summarized delta-detected for the comparisons between `group` and all other groups.\n     * Alternatively `null`, if `fillable = false` and the array was not already filled.\n     */\n    deltaDetected(group, { summary = \"mean\", copy = true, fillable = false } = {}) {\n        summary = intifySummary(summary);\n        return checkFillness2(\n            group, \n            summary, \n            fillable, \n            copy, \n            this.#filledDeltaDetected, \n            COPY => utils.possibleCopy(\n                wasm.call(_ => this.#results.delta_detected(group, summary)),\n                COPY\n            )\n        );\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Score genes as potential markers for each group of cells.\n *\n * @param {ScranMatrix} x - Log-normalized expression matrix.\n * @param {(Int32WasmArray|Array|TypedArray)} groups - Array containing the group assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of groups.\n * @param {object} [options={}] - Optional parameters.\n * @param {?(Int32WasmArray|Array|TypedArray)} [options.block=null] - Array containing the block assignment for each cell.\n * This should have length equal to the number of cells and contain all values from 0 to `n - 1` at least once, where `n` is the number of blocks.\n * This is used to segregate cells in order to perform comparisons within each block.\n * Alternatively, this may be `null`, in which case all cells are assumed to be in the same block.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n * @param {number} [options.lfcThreshold=0] - Log-fold change threshold to use for computing Cohen's d and AUC.\n * Large positive values favor markers with large log-fold changes over those with low variance.\n * @param {boolean} [options.computeAuc=true] - Whether to compute the AUCs as an effect size.\n * This can be set to `false` for greater speed and memory efficiency.\n * @param {boolean} [options.computeMedian=false] - Whether to compute the median effect sizes across all pairwise comparisons for each group.\n * This can be used as a more robust/less sensitive alternative to the mean.\n * @param {boolean} [options.computeMaximum=false] - Whether to compute the maximum effect size across all pairwise comparisons for each group.\n * This could be used to find uniquely downregulated genes.\n *\n * @return {ScoreMarkersResults} Object containing the marker scoring results.\n */\nexport function scoreMarkers(x, groups, { block = null, numberOfThreads = null, lfcThreshold = 0, computeAuc = true, computeMedian = false, computeMaximum = false } = {}) {\n    var output;\n    var block_data;\n    var group_data;\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n\n    try {\n        group_data = utils.wasmifyArray(groups, \"Int32WasmArray\");\n        if (group_data.length != x.numberOfColumns()) {\n            throw new Error(\"length of 'groups' should be equal to number of columns in 'x'\");\n        }\n\n        var bptr = 0;\n        var use_blocks = false;\n        if (block !== null) {\n            block_data = utils.wasmifyArray(block, \"Int32WasmArray\");\n            if (block_data.length != x.numberOfColumns()) {\n                throw new Error(\"'block' must be of length equal to the number of columns in 'x'\");\n            }\n            use_blocks = true;\n            bptr = block_data.offset;\n        }\n\n        output = gc.call(\n            module => module.score_markers(x.matrix, group_data.offset, use_blocks, bptr, lfcThreshold, computeAuc, computeMedian, computeMaximum, nthreads),\n            ScoreMarkersResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(block_data);\n        utils.free(group_data);\n    }\n\n    return output;\n}\n\n/**\n * Create an empty {@linkplain ScoreMarkersResults} object, to be filled with custom results.\n * Note that filling requires use of `fillable: true` in the various getters to obtain a writeable memory view.\n *\n * @param {number} numberOfGenes - Number of genes in the dataset.\n * @param {number} numberOfGroups - Number of groups for which to store marker detection statistics.\n * @param {number} numberOfBlocks - Number of blocks in the dataset.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.computeAuc=true] - Whether to allocate memory for storing AUCs.\n * @param {boolean} [options.computeMedian=false] - Whether to allocate memory for storing median effect sizes.\n * @param {boolean} [options.computeMaximum=false] - Whether to allocate memory for storing maximum effect sizes.\n *\n * @return {ScoreMarkersResults} Object with memory allocated to store marker statistics, but not containing any actual values.\n */\nexport function emptyScoreMarkersResults(numberOfGenes, numberOfGroups, numberOfBlocks, { computeAuc = true, computeMedian = false, computeMaximum = false } = {}) {\n    return gc.call(\n        module => new module.ScoreMarkers_Results(numberOfGenes, numberOfGroups, numberOfBlocks, computeAuc, computeMedian, computeMaximum),\n        ScoreMarkersResults,\n        /* filled = */ false\n    );\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./adt_normalization.js\";\n\nexport const step_name = \"adt_pca\";\n\n/**\n * This step performs a principal components analysis (PCA) to compact and denoise ADT data.\n * The resulting PCs can be used as input to various per-cell analyses like clustering and dimensionality reduction.\n * It wraps the [`runPCA`](https://kanaverse.github.io/scran.js/global.html#runPCA) function\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class AdtPcaState {\n    #filter;\n    #norm;\n    #cache;\n    #parameters;\n\n    constructor(filter, norm, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm instanceof norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm' should be a AdtNormalizationState object\");\n        }\n        this.#norm = norm;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.pcs);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        return this.#norm.valid();\n    }\n\n    /**\n     * @return {external:RunPCAResults} Results of the PCA on the normalized ADT matrix,\n     * available after running {@linkcode AdtPcaState#compute compute}.\n     */\n    fetchPCs() {\n        return this.#cache.pcs;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return { ...this.#parameters }; // avoid pass-by-reference links.\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `adt_pca` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} parameters.num_pcs - Number of PCs to return.\n     * @param {string} parameters.block_method - Blocking method to use when dealing with multiple samples.\n     * This can be `\"none\"`, `\"regress\"` or `\"weight\"`, see comments in {@linkplain RnaPcaState}.\n     *\n     * @return The object is updated with the new results.\n     */\n    compute(parameters) {\n        let { num_pcs, block_method } = parameters;\n        this.changed = false;\n\n        if (this.#norm.changed || num_pcs !== this.#parameters.num_pcs || block_method !== this.#parameters.block_method) { \n            if (this.valid()) {\n                let block = this.#filter.fetchFilteredBlock();\n                var mat = this.#norm.fetchNormalizedMatrix();\n                utils.freeCache(this.#cache.pcs);\n                this.#cache.pcs = scran.runPCA(mat, { numberOfPCs: num_pcs, block: block, blockMethod: block_method });\n\n                this.changed = true;\n            }\n\n            this.#parameters.num_pcs = num_pcs;\n            this.#parameters.block_method = block_method;\n        }\n\n        return;\n    }\n\n    static defaults() {\n        return {\n            num_pcs: 20,\n            block_method: \"none\"\n        };\n    }\n}\n\n/**************************\n ******** Loading *********\n **************************/\n\nexport function unserialize(handle, filter, norm) {\n    let cache = {};\n    let parameters = AdtPcaState.defaults();\n    let output;\n\n    if (step_name in handle.children) {\n        let ghandle = handle.open(step_name);\n\n        let phandle = ghandle.open(\"parameters\"); \n        parameters.num_pcs = phandle.open(\"num_pcs\", { load: true }).values[0];\n        parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0];\n\n        try {\n            let rhandle = ghandle.open(\"results\");\n\n            if (\"var_exp\" in rhandle.children) {\n                let pcs_handle = rhandle.open(\"pcs\", { load: true });\n                let pcs = pcs_handle.values;\n                let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n\n                cache.pcs = scran.emptyRunPCAResults(pcs_handle.shape[0], pcs_handle.shape[1]);\n                cache.pcs.principalComponents({ fillable: true }).set(pcs);\n                cache.pcs.varianceExplained({ fillable: true }).set(var_exp);\n                cache.pcs.setTotalVariance(1); // because the file only stores proportions.\n            }\n\n            output = new AdtPcaState(filter, norm, parameters, cache);\n        } catch (e) {\n            utils.freeCache(cache.pcs);\n            utils.freeCache(output);\n            throw e;\n        }\n    } else {\n        output = new AdtPcaState(filter, norm, parameters, cache);\n    }\n\n    return output;\n}\n"],"names":["subsetWasmArray","x","subset","filter","buffer","arguments","length","undefined","len","targetLength","targetName","forEach","i","Error","sum","checkSubsetLength","createWasmArray","space","constructor","barr","array","input","output","s","j","y","fillSubset","guessFeatures","features","forceTaxonomy","ntotal","early_threshold","Math","ceil","format","payload","confidence","unique_features","Set","f","add","ensembl_human","ensembl_mouse","ensembl_6239","ensembl_10116","ensembl_9541","ensembl_7227","ensembl_7955","ensembl_9598","symbol_human","symbol_mouse","symbol_6239","symbol_7955","hsid","mmid","collected","any_ens","match","startsWith","push","species","type","highest","_id","WeakMap","_results","_filledMeans","_filledVariances","_filledFitted","_filledResiduals","_ModelGeneVarResults_brand","WeakSet","ModelGeneVarResults","id","raw","filled","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","this","utils","numberOfBlocks","means","block","copy","fillable","_assertClassBrand","_extract","call","_classPrivateFieldGet","variances","fitted","residuals","num_blocks","free","gc","fillcheck","method","fillindex","nblocks","COPY","modelGeneVar","span","numberOfThreads","block_data","nthreads","bptr","use_blocks","numberOfColumns","offset","module","model_gene_var","matrix","e","_filledDetected","_filledSubsetTotals","SuggestAdtQcFiltersResults","numberOfSubsets","thresholdsDetected","thresholds_detected","thresholdsSubsetTotals","thresholds_subset_totals","num_subsets","metrics","PerCellAdtQcMetricsResults","internal","suggestAdtQcFilters","numberOfMADs","minDetectedDrop","suggest_adt_qc_filters","results","$$","ptr","presplitFactor","factor","by","_index","_parameters","_reloaded","_worker_id","_ready","_run","_TsneState_brand","TsneState","index","parameters","reloaded","neighbor_module","changed","worker","aworkers","worker_id","ready","vizutils","fetchParameters","_objectSpread","fetchResults","slice","iterations","compute","perplexity","animate","same_neighbors","Promise","resolve","_core","then","contents","reneighbor","nn_out","k","scran","args","step_name","_cache","_SnnGraphClusterState_brand","SnnGraphClusterState","cache","neighbors","graph","clusters","fetchClusters","_valid","membership","defaults","scheme","algorithm","multilevel_resolution","leiden_resolution","walktrap_steps","run_me","_compute_neighbors","_compute_graph","_compute_clusters","fetchIndex","multiLevelResolution","leidenResolution","leidenModularityObjective","walktrapSteps","_filledMaxCount","SuggestCrisprQcFiltersResults","thresholdsMaxCount","thresholds_max_count","PerCellCrisprQcMetricsResults","suggestCrisprQcFilters","suggest_crispr_qc_filters","_correct","_KmeansClusterState_brand","KmeansClusterState","correct","correct_module","pcs","fetchCorrected","numberOfDims","fetchNumberOfDimensions","numberOfCells","fetchNumberOfCells","initMethod","subsetSums","qc","mat","name","discards","fetchDiscards","sums","fetchMetrics","set","oarr","computeTopThreshold","number","largest","Array","sort","a","b","Number","NaN","max","min","freeCache","object","changedParametersIllegal","xskip","yskip","ArrayBuffer","isView","changedParameters","xnull","ynull","xarr","yarr","xkeys","Object","keys","ykeys","allocateCachedArray","size","reallocate","candidate","className","owner","findValidUpstreamStates","states","msg","to_use","v","entries","valid","checkIndices","indices","async","defaultDownload","url","resp","fetch","ok","status","Uint8Array","arrayBuffer","guessFeatureTypes","genes","columns","rn","rowNames","row_names","key","columnNames","column","subsetInvalidFactors","arrays","N","retain","invalid","fill","transformed","action","placeholder","ids","num_invalid","Int32Array","counter","new_ids","new_levels","map","levels","logNormCounts","sizeFactors","center","allowZeros","sf_data","sfptr","use_sf","log_norm_counts","centerSizeFactors","local_buffer","wa","wasm","center_size_factors","setterTarget","inPlace","generics","deepCopy","cloneField","value","Map","_filter","_norm","CrisprPcaState","norm","filter_module","norm_module","fetchPCs","num_pcs","block_method","fetchFilteredBlock","fetchNormalizedMatrix","numberOfPCs","blockMethod","registerCallback","callback","onmessage","sendMessage","message","transfer","postMessage","terminateWorker","terminate","scaleByNeighbors","embeddings","embed_ptrs","index_ptrs","holding_ndims","holding_weights","approximate","weights","nembed","deletable","embed_arr","BigInt","weight_offset","use_weights","allocator","total_ndim","total_len","index_arr","scale_by_neighbors_indices","ndims_arr","n","floor","scale_by_neighbors_matrices","reindexSetsForAllGenes","geneMapping","setsForGenes","remapped","gesel_gene","Uint32Array","_inputs","_automatic","_RnaQualityControlState_brand","RnaQualityControlState","inputs","inputs_module","filters","metrics_buffer","discard_buffer","fetchCountMatrix","has","bioc","fetchFilters","automatic","gene_id_column","use_reference_mito","gene_id_type","mito_prefix","nmads","configureFeatureParameters","guesses","best_key","best","val","toUpperCase","flush","_mito_lists","_","setDownload","fun","previous","_downloadFun","use_mito_default","def","gene_id_column2","species2","gene_id_type2","guessRnaFeatureTypes","backcomp","gene_info","fetchFeatureAnnotations","subsets","numberOfRows","lists","_acquire_reference","sub_arr","lower_mito","toLowerCase","get","fetchBlock","discard","feature_type","mito_lists","target","baseUrl","lines","rutils","compression","_RnaQualityControlState","_defineProperty","Uint8WasmArray","WasmArray","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Int32WasmArray","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","Float64WasmArray","Float64Array","choices","stringToClass","Annotated","metadata","_metadata","setMetadata","cutils","$setMetadata","_bioconductor_CLONE","_ref","buildIntervalTree","start","end","rank2position","startRanks","endRanks","positions","fillIndex","at","next","order","new_starts","new_ends","last","pos","idx","convertPositionToRank","tree","create_node","recursive_build_tree","one_past_the_end","left_bound","right_bound","start_overlaps_sorted","overlaps","end_overlaps_sorted","left_node","right_node","node","current","queryIntervalTree","recursive_query_tree","overlap","DataFrame","ann","columnOrder","super","_numberOfRows","_rowNames","_columns","il","cause","names","entry","hasColumn","numberOfEntries","removeColumn","delete","$removeColumn","setColumn","$setColumn","setColumnNames","setNames","$setColumnNames","setRowNames","$setRowNames","sliceColumns","$sliceColumns","_bioconductor_LENGTH","_bioconductor_SLICE","new_numberOfRows","allowView","options","new_columns","apply","new_rowNames","_bioconductor_COMBINE","objects","parallelCombine","all_n","all_l","yi","_ref2","flexibleCombineRows","ckeys","corder","cnames","copies","dummy","reorder","quickAdtSizeFactors","clust","numberOfClusters","totals","runPCA","clusterKmeans","groupedSizeFactors","_matrix_file","_feature_file","_barcode_file","_dimensions","_raw_features","_raw_cells","_options","_TenxMatrixMarketDataset_brand","TenxMatrixMarketDataset","matrixFile","featureFile","barcodeFile","featureTypeRnaName","featureTypeAdtName","featureTypeCrisprName","primaryRnaFeatureIdColumn","primaryAdtFeatureIdColumn","primaryCrisprFeatureIdColumn","afile","clear","setOptions","abbreviate","_dump_summary","summary","_features","_cells","futils","previewPrimaryIds","preview","_feature_type_mapping","_primary_mapping","load","is_gz","endsWith","loaded","content","cells","primary_ids","serialize","unserialize","files","file","feat","barcode","annotations","mtx","_fetch_dimensions","headers","rows","NR","fname","parsed","eutils","shift","symb","types","bname","diff","conv","RNA","ADT","CRISPR","SingleCellExperiment","rse","assays","reducedDimensions","reducedDimensionOrder","alternativeExperiments","alternativeExperimentOrder","rowRanges","ncols","_reducedDimensions","_alternativeExperiments","se","reducedDimensionNames","reducedDimension","alternativeExperimentNames","alternativeExperiment","removeReducedDimension","$removeReducedDimension","setReducedDimension","$setReducedDimension","setReducedDimensionNames","$setReducedDimensionNames","sliceReducedDimensions","$sliceReducedDimensions","removeAlternativeExperiment","$removeAlternativeExperiment","setAlternativeExperiment","$setAlternativeExperiment","setAlternativeExperimentNames","$setAlternativeExperimentNames","sliceAlternativeExperiments","$sliceAlternativeExperiments","_bioconductor_SLICE_2D","_bioconductor_COMBINE_ROWS","_bioconductor_COMBINE_COLUMNS","_matrix","ScranMatrix","createDenseMatrix","columnMajor","NumericMatrix","clone","nrow","ncol","row","isSparse","sparse","isReorganized","reorganized","identities","wipeIdentities","wipe_identities","stream","chunkSize","reject","peek","_filledSums","_filledMaxProportions","_filledMaxIndex","detected","maxProportions","max_proportion","maxIndex","max_index","num_cells","perCellCrisprQcMetrics","per_cell_crispr_qc_metrics","load_data_frame","info","navigator","colnames","path","rownames","delim","data_frame","out","ghandle","open","hdf5_data_frame","group","values","chandle","String","children","dhandle","replacement","attributes","readAttribute","new_colnames","nest_meta","resource","console","warn","dimensions","extract_all_features","extract_features","se_meta","summarized_experiment","row_path","row_data","full_meta","alt","single_cell_experiment","alternative_experiments","alt_meta","extract_all_assay_names","extract_assay_names","ass","extract_assay","meta","assay","forceInteger","extract_assay_raw","asspath","assmeta","schema","is_dense","is_sparse","hdf5_sparse_matrix","hdf5_dense_array","dataset","stuff","hdf5_delayed_array","handle","abs","log","ghandle2","ghandle3","sf","ahandle","row_ids","extract_logcounts","extract_other_data","other_path","othermeta","ofile","unpacked","json_simple_list","extract_list_data_internal","JSON","parse","obj","_navigator","_metadata_cache","MetadataCacheWrapper","nav","_path","_navigator2","_AbstractArtifactdbDataset_brand","AbstractArtifactdbDataset","_reset_local_caches","rnaCountAssay","adtCountAssay","crisprCountAssay","rnaExperiment","adtExperiment","crisprExperiment","modality_features","modality_assay_names","fmapping","mapping","exp","altmap","alts","col_path","column_data","_path2","_navigator3","_raw_features2","_raw_cells2","_raw_other","_options2","_AbstractArtifactdbResult_brand","AbstractArtifactdbResult","_reset_local_caches2","primaryAssay","isPrimaryNormalized","_features2","_cells2","_other","reduced_dimension_names","other_metadata","reddim_meta","reduced_dimensions","_get_all_reddim_names","reddims","redmap","red","redmeta","dims","redcontents","realized","acquired","d","curassay","curnormalized","normed","other_data","rd_meta","store","_UmapState_brand","UmapState","num_epochs","num_neighbors","min_dist","_reference","LoadLabelledReferenceResults","reference","numberOfSamples","num_samples","numberOfFeatures","num_features","numberOfLabels","num_labels","loadLabelledReferenceFromBuffers","ranks","markers","labels","matbuf","markbuf","labbuf","load_singlepp_reference","_id2","_reference2","BuildLabelledReferenceResults","sharedFeatures","shared_features","register_features","id_array","registry_contents","convert_features","registry","used","found","z","buildLabelledReference","referenceFeatures","top","mat_id_buffer","ref_id_buffer","nfeat","build_singlepp_reference","expectedNumberOfFeatures","_id3","_cell_buffer","_label_buffer","LabelCellsResults","predictedLabels","get_best","scoresForCell","get_scores_for_sample","scoresForLabel","get_scores_for_label","fineTuningDelta","get_delta","label_cells","FUN","tempmat","init","labelCells","quantile","run_singlepp","_id4","_integrated","IntegrateLabelledReferencesResults","integrated","numberOfReferences","num_references","integrateLabelledReferences","built","id_arr","loaded_arr2","ref_arr2","built_arr2","nrefs","ref_arr","la2","ra2","ba2","integrate_singlepp_references","_results2","IntegrateCellLabelsResults","predictedReferences","scoresForReference","integrateCellLabels","assigned","aptrs","assigned_arrs","aptrs_arr","fail","integrate_singlepp","reindexGenesForAllSets","genesForSets","reverse_mapping","new_sets","gene","fetchGenesForAllSets","download","res","by_symbol","by_symbol_lower","mapGenesByIdentifier","lowerCase","host","sfound","tfound","_genes","fetchAllGenes","from","_qc","_AdtNormalizationState_brand","AdtNormalizationState","qc_module","total_buffer","sf_buffer","centered_sf_buffer","fetchFilteredMatrix","_raw_compute","fetchSizeFactors","buff","num_clusters","remove_bias","nutils","createBlock","ncells","total","sofar","old","subsetBlock","filterBlock","dropUnusedBlock","fac","GRanges","vec","seqnames","ranges","strand","elementMetadata","_seqnames","_ranges","_convertToInt8Array","_checkStrandedness","_strand","width","setSeqnames","$setSeqnames","setRanges","ir","$setRanges","setStrand","$setStrand","buildOverlapIndex","restrictToSeqnames","restrictToStrand","by_seqname","starts","ends","seqname_indices","seqname_strand","by_strand","str","str_indices","olap","GRangesOverlapIndex","all_sn","all_rr","all_st","empty","query","ignoreStrand","my_results","allowed_strands","seq_index","sstr","summaries2int","formatMarkerResults","rankEffect","ordering","ranking","increasing","cohen","auc","lfc","deltaDetected","stats","thing","stat_detected","stat_mean","stat_lfc","stat_delta_d","locateVersusCache","left","right","left_small","bigg","biggversus","smal","rerun","cached","run","freeVersusResults","v2","m","computeVersusResults","matrices","keep","lfc_threshold","compute_auc","new_block","modality","available","sub","modmat","lfcThreshold","computeAuc","_graph","BuildSNNGraphResults","buildSNNGraph","my_neighbors","ref","FindNearestNeighborsResults","findNearestNeighbors","build_snn_graph","_filledBest","_filledModularity","_filledMembership","_ClusterSNNGraphMultiLevelResults_brand","ClusterSNNGraphMultiLevelResults","numberOfLevels","setBest","set_best","modularity","level","_chooseLevel","setModularity","set_modularity","_filledModularity2","_filledModularityDetails","_filledMembership2","ClusterSNNGraphWalktrapResults","numberOfMergeSteps","which","remaining","num_merge_steps","_results3","_filledModularity3","_filledMembership3","ClusterSNNGraphLeidenResults","clusterSNNGraph","cluster_snn_graph_multilevel","cluster_snn_graph_walktrap","cluster_snn_graph_leiden","_filledComponents","_filledTotalVariance","RunPCAResults","principalComponents","setTotalVariance","set_total_variance","varianceExplained","variance_explained","totalVariance","total_variance","scale","feat_data","use_feat","fptr","run_pca","run_blocked_pca","run_multibatch_pca","randomColor","seed","colorDictionary","loadColorBounds","colorRanges","parseInt","stringToInteger","TypeError","H","S","count","totalColors","colors","color","setFormat","pickHue","pickSaturation","pickBrightness","hue","randomWithin","hueRange","getRealHueRange","step","getHueRange","luminosity","saturationRange","getSaturationRange","sMin","sMax","bMin","getMinimumBrightness","bMax","hsv","HSVtoHSL","hsl","hslColor","alpha","random","HSVtoRGB","join","rgbColor","HSVtoHex","lowerBounds","getColorInfo","s1","v1","s2","colorInput","HexToHSB","colorName","range","golden_ratio","r","rnd","rgb","componentToHex","c","hex","toString","defineColor","brightnessRange","h","h_i","p","q","t","g","replace","substr","green","blue","cMax","delta","saturation","round","string","MAX_SAFE_INTEGER","charCodeAt","colorHue","isNaN","factory","exports","promises","processing","gene_download","resolved","all","gene_data","decompressLines","processed","split","find_usable_upstream_states","qc_states","in_use","tmp","_qc_states","_CellFilteringState_brand","CellFilteringState","rna_qc_module","adt_qc_module","crispr_qc_module","block_buffer","_raw_compute_matrix","_raw_compute_block","use_rna","use_adt","use_crispr","u","first","disc_buffer","disc_arr","view","applyFilter","undoFilter","src","filtered_ncols","bcache","_sets","fetchAllSets","sres","_collections","reference_download","fetchAllCollections","set_data","details","collection","find_nonzero_upstream_states","pca_states","_pca_states","CombineEmbeddingsState","rna_pca_module","adt_pca_module","crispr_pca_module","combined_buffer","fetchCombined","total_dims","rna_weight","adt_weight","crispr_weight","createPcsView","upstream","weight_arr","curpcs","createTsneWorker","Worker","URL","createUmapWorker","BuildNeighborSearchIndexResults","num_obs","num_dim","buildNeighborSearchIndex","pptr","byteOffset","build_neighbor_index","runs","distances","run_data","ind_data","dist_data","NeighborResults","find_nearest_neighbors","create_solo_default_object","reportFeatures","rawFeatures","typeField","by_type","renameByModality","featureTypeMapping","splitByModality","extractSplitPrimaryIds","featureTypeDefault","primary","col","extractPrimaryIdColumn","new_default","multiple","findUnnamedDefault","splitScranMatrixAndFeatures","current_features","out_mat","type_keys","skip_subset","full_length","is_subset_noop","rename","extractPrimaryIds","extractRemappedPrimaryIds","_DenseMatrix_brand","_extractor","nprimary","nsecondary","primaryMajor","_values","subarray","_inserter","_primarySlicer","primarySlice","fullPrimary","isPrimaryRange","primaryDim","secondarySlice","fullSecondary","isSecondaryRange","inSecondaryDim","outSecondaryDim","outputValues","_secondarySlicer","pi","inPrimary","outPrimary","in_offset","out_offset","si","_numberOfColumns","_columnMajor","isColumnMajor","setValues","$setValues","setRow","$setRow","_bioconductor_NUMBER_OF_ROWS","_bioconductor_NUMBER_OF_COLUMNS","full_rows","is_row_range","new_rows","full_columns","is_column_range","new_values","_combiner","primaryFun","secondaryFun","isPrimaryMajor","secondaryName","num_primary","num_secondary","primary_major","used_primary","cur_primary","out_offset2","view_offset","combined","groups","priorCount","group_arr","grouped_size_factors","CrisprQualityControlState","subsetRows","xcopy","wasm_indices","row_subset","subsetColumns","column_subset","splitRows","singleNull","createMultiMatrix","tkeys","chosen","consec","MultiMatrix","initializeSparseMatrixFromMatrixMarket","compressed","layered","buf_data","convert_compressed","read_matrix_market_from_buffer","read_matrix_market_from_file","extractMatrixMarketDimensions","read_matrix_market_header_from_buffer","read_matrix_market_header_from_file","sarr","initializeSparseMatrixFromHDF5","subsetRow","subsetColumn","cacheSize","wasm_row","wasm_col","use_row_subset","row_offset","row_length","use_col_subset","col_offset","col_length","read_hdf5_matrix","extractHDF5MatrixDetails","arr","extract_hdf5_matrix_details","vals","integer","initializeDenseMatrixFromDenseArray","initialize_dense_matrix","initializeSparseMatrixFromRds","consume","initialize_sparse_matrix_from_rds","FeatureSelectionState","fetchSortedResiduals","sorted_residuals","temp","prefix","extension","tmppath","Date","methods","handleString","mnnCorrect","x_data","robustIterations","robustTrim","referencePolicy","mnn_correct","IRanges","_start","_width","setStart","$setStart","setWidth","$setWidth","IRangesOverlapIndex","all_s","all_w","_tree","computePerCellQcMetrics","subset_offsets","tmp_subsets","nsubsets","offset_offset","offset_arr","define","self","window","document","IS_PAPA_WORKER","o","_handle","_finished","_completed","_halted","_input","_baseIndex","_partialLine","_rowCount","_nextChunk","isFirstChunk","_completeResults","data","errors","chunk","streamer","_config","parseChunk","skipFirstNLines","newline","quoteChar","guessLineEndings","U","beforeFirstChunk","paused","aborted","cursor","substring","workerId","WORKER_ID","finished","concat","complete","_sendError","error","RemoteChunkSize","_readChunk","_chunkLoaded","XMLHttpRequest","withCredentials","onload","onerror","_chunkError","downloadRequestBody","downloadRequestHeaders","setRequestHeader","send","readyState","responseText","getResponseHeader","lastIndexOf","statusText","l","LocalChunkSize","FileReader","webkitSlice","mozSlice","FileReaderSync","readAsText","encoding","result","pause","prototype","resume","on","_streamData","_streamEnd","_streamError","_checkIsFinished","_streamCleanUp","removeListener","pow","skipEmptyLines","trim","DefaultDelimiter","isArray","splice","transformHeader","header","dynamicTypingFunction","dynamicTyping","test","parseFloat","transform","fields","code","abort","delimiter","RECORD_SEP","UNIT_SEP","E","comments","successful","bestDelimiter","delimitersToGuess","getCharIndex","setTimeout","RegExp","P","C","O","I","A","T","fastMode","D","L","F","escapeChar","BAD_DELIMITERS","indexOf","M","w","R","create","linebreak","truncated","renamedHeaders","userError","userStep","userChunk","userComplete","WORKERS_SUPPORTED","NODE_STREAM_INPUT","readable","read","File","webkitURL","BLOB_URL","createObjectURL","Blob","config","unparse","quotes","escapeFormulae","stringify","charAt","fromCharCode","BYTE_ORDER_MARK","Parser","ParserHandle","NetworkStreamer","FileStreamer","StringStreamer","ReadableStreamStreamer","jQuery","fn","each","prop","attr","inputElem","instanceConfig","extend","before","reason","harvest_matrices","cbindWithNames","mat_ptrs","name_ptrs","renamed","common","universe","names_arr","replacement_arr","cbind_with_rownames","internames","AdtQualityControlState","tag_id_column","igg_prefix","min_detected_drop","lower_igg","latest","tag_info","_NeighborIndexState_brand","NeighborIndexState","convertToFactor","failure","asWasmArray","warned","isFinite","existing","every","oldlevels","resetLevels","factorize","dropUnusedLevels","uniq","uniq_arr","newLevels","oldLevels","conversion","SimpleFile","_mode","_buffer","_file","_name","readAsArrayBuffer","_filledSubsetProportions","SuggestRnaQcFiltersResults","thresholdsSums","thresholds_sums","thresholdsSubsetProportions","thresholds_proportions","PerCellRnaQcMetricsResults","suggestRnaQcFilters","suggest_rna_qc_filters","subsetProportions","subset_proportions","perCellRnaQcMetrics","subset_offset","per_cell_rna_qc_metrics","_RnaNormalizationState_brand","RnaNormalizationState","sum_buffer","_snn_cluster","_kmeans_cluster","ChooseClusteringState","snn","kmeans","snn_module","kmeans_module","filterCells","filter_data","filter_cells","_RangedSummarizedExperiment_brand","RangedSummarizedExperiment","ggr","_check_rowRanges","_rowRanges","setRowRanges","$setRowRanges","has_empty","has_ggr","gr","widths","rangeLengths","setElementMetadata","_rowData","initialize","localFile","scran_custom_nthreads","locateFile","import","loadScran","register","maximumThreads","func","get_error_message","wasmMemory","wasmArraySpace","subsetTotals","subset_totals","perCellAdtQcMetrics","per_cell_adt_qc_metrics","_combined","BatchCorrectionState","combine_module","corrected","needs_correction","LENGTH","SLICE","COMBINE","total_LENGTH","position","CLONE","SPLIT","misc","_bioconductor_SPLIT","NUMBER_OF_ROWS","NUMBER_OF_COLUMNS","SLICE_2D","COMBINE_ROWS","COMBINE_COLUMNS","extractHDF5Strings","summarizeArray","limit","POSITIVE_INFINITY","NEGATIVE_INFINITY","guess_compression","astream","unpackText","txt","pako","TextDecoder","decode","merge_bytes","leftovers","decoder","stream_callback","gz","onData","onEnd","readLines2","dec","readTable2","ppp","size_left","pop","promoteToNumber","as_num","opt1","opt2","_filledClusters","_filledSizes","_filledCenters","_filledWcss","_filledIterations","_filledStatus","ClusterKmeansResults","setIterations","set_iterations","setStatus","set_status","clusterSizes","cluster_sizes","withinClusterSumSquares","wcss","clusterCenters","centers","initSeed","initPCASizeAdjust","cluster_kmeans","createUint8WasmArray","createInt32WasmArray","createBigUint64WasmArray","createFloat64WasmArray","wasmifyArray","expected","chooseNumberOfThreads","threads","possibleCopy","view_class","matchOptions","spawnArray","checkFillness","check","setFilledFun","getFun","RdsObject","par","parent","RdsVector","attributeNames","mod","fill_attribute_names","anames_buf","attribute_names_buffer","anames_len","attribute_names_length","packer","findAttribute","find_attribute","attribute","dispatch","load_attribute_by_index","load_attribute_by_name","RdsIntegerVector","numeric_vector","RdsBooleanVector","RdsDoubleVector","RdsStringVector","fill_string_vector","buf","string_vector_buffer","string_vector_length","RdsGenericVector","load_list_element","RdsS4Object","class_name","packageName","package_name","RdsNull","cons","tt","_obj","RdsDetails","formatVersion","format_version","writerVersion","writer_version","readerVersion","reader_version","readRds","parse_rds_from_file","parse_rds_from_buffer","_free_results","versus","_computeVersus","cache_info","left_index","right_index","new_clusters","leftfound","rightfound","_norm_states","_choice","MarkerDetectionState","norm_states","choice","rna_norm_module","adt_norm_module","crispr_norm_module","choice_module","changed_params","computeVersusCustom","computeVersus","state","_matrices","_groups","_group_levels","_block","_block_levels","_cache2","_parameters2","MarkerDetectionStandalone","normalized","new_matrices","dump","fetchGroupLevels","ret","fetchBlockLevels","_peekMatrices","_peekGroups","_peekBlock","setParameters","computeAll","perplexityToNeighbors","perplexity_to_k","hypergeometricTest","markersInSet","numberOfMarkers","featureSetSize","markersInSet_data","numberOfMarkers_data","featureSetSize_data","numberOfFeatures_data","output_data","assumeSorted","ntests","check_length","hypergeometric_test","_store","_ncols","remove","new_matrix","to","verifyElementMetadata","numExpected","df","Vector","_elementMetadata","_names","$setElementMetadata","$setNames","all_em","fetchSetsForAllGenes","_feat","RnaPcaState","feat_module","hvg_buffer","num_hvgs","choose_hvgs","sorted_resids","threshold_at","unsorted_resids","element","_h5_file","_h5_path","_h5_flush","_TenxHdf5Dataset_brand","TenxHdf5Dataset","h5File","_instantiate","mhandle","fhandle","feats","ftype","computePerCellQcFilters","thresholds","rebuffer","optr","arrayClass","allocate","SummarizedExperiment","assayOrder","rowData","columnData","_assays","nrows","nr","nc","_columnData","_columnNames","assayNames","numberOfAssays","removeAssay","$removeAssay","setAssay","$setAssay","setAssayNames","$setAssayNames","sliceAssays","$sliceAssays","setRowData","$setRowData","setColumnData","$setColumnData","all_dfs","_staged_setGroup","_GroupedGRanges_brand","GroupedGRanges","_rangeLengths","accumulated","_computeStarts","_rangeStarts","_flush_staged_setGroup","rangeStarts","numberOfGroups","setGroup","nops","$setGroup","GroupedGRangesOverlapIndex","lengths","staged","last_start","more_ranges","ngroups","current_start","nranges","fullLength","rev_map","_reverseMapping","_CrisprNormalizationState_brand","CrisprNormalizationState","centered_buffer","createGroup","scoreFeatureSet","feature_data","score_feature_set","scores","cres","coll_data","areArraysEqual","isArrayLike","chooseArrayConstructors","con1","con2","formatLengthError","checkStringArray","typeMessage","checkNamesArray","lengthMessage","combineNames","all_names","all_lengths","total_n","all_null","createSequence","convertToInt32Array","checkNonNegative","object2map","ownKeys","getOwnPropertySymbols","getOwnPropertyDescriptor","enumerable","_objectSpread2","getOwnPropertyDescriptors","defineProperties","defineProperty","_InternalList_brand","InternalList","observed","_entries","_order","_check_entry_index","ii","new_entries","new_order","combiner","first_order","AggregateAcrossCellsResults","num_groups","numberOfGenes","num_genes","group_sums","all_sums","group_detected","all_detected","aggregateAcrossCells","average","group_data","aggregate_across_cells","cloneCached","check_class","accepted","base","populate_list_columns","lhandle","nhandle","ndx","load_listData_names","curhandle","curcol","rnhandle","rndx","nrhandle","_rowdata","_coldata","_counts_handle","_counts_loaded","_ExperimentHubDataset_brand","ExperimentHubDataset","setDownloadFun","availableDatasets","my_rd","_fetchPrimaryId","_counts","counts","perm_features","TextEncoder","encode","bakana","counts_deets","rowdata_load","rowdata_handle","rowdata_deets","rowdata","dimhandle","firsthandle","extract_matrix_rownames","coldata_load","coldata_handle","cd_df","coldata_deets","coldata","curfeat","_ExperimentHubDataset","checkFillness2","getfun","intifySummary","_filledCohen","_filledLfc","_filledAuc","_filledDeltaDetected","_ScoreMarkersResults_brand","ScoreMarkersResults","createBlockedStatsFilled","createEffectsFilled","_extractBlockedStat","delta_detected","scoreMarkers","computeMedian","computeMaximum","score_markers","AdtPcaState"],"sourceRoot":""}