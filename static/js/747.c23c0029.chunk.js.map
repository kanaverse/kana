{"version":3,"file":"static/js/747.c23c0029.chunk.js","mappings":"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","sources":["workers/DownloadsDBHandler.js","workers/helpers.js","utils/utils.js","workers/explorer.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["var DownloadsDB;\nvar init = null;\n\nexport function initialize() {\n  if (init === null) {\n    init = new Promise((resolve, reject) => {\n      // initialize database on worker creation\n      DownloadsDB = indexedDB.open(\"DownloadsDB\", 3);\n\n      DownloadsDB.onupgradeneeded = (e) => {\n        var DownloadsDBClient = e.target.result;\n\n        // Currently purging all existing stores when the version is updated.\n        // At some point we may add a more sophisticated upgrade mechanism.\n        try {\n          DownloadsDBClient.deleteObjectStore(\"downloads\");\n        } catch (e) {}\n\n        DownloadsDBClient.createObjectStore(\"downloads\", { keyPath: \"url\" });\n      };\n\n      DownloadsDB.onsuccess = () => {\n        resolve(null);\n      };\n\n      DownloadsDB.onerror = () => {\n        reject(\"failed to initialize DownloadsDB\");\n      };\n    });\n  }\n\n  return init;\n}\n\nexport async function list() {\n  await init;\n  let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n  let download_store = trans.objectStore(\"downloads\");\n  return download_store.getAllKeys();\n}\n\nexport async function get(url, params = null, force = false) {\n  await init;\n\n  if (!force) {\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n    let download_store = trans.objectStore(\"downloads\");\n    var data_check = new Promise((resolve) => {\n      var already = download_store.get(url);\n      already.onsuccess = function (event) {\n        if (already.result !== undefined) {\n          resolve(already.result.payload);\n        } else {\n          resolve(null);\n        }\n      };\n      already.onerror = function (event) {\n        resolve(null);\n      };\n    });\n\n    var found = await data_check;\n    if (found !== null) {\n      return found;\n    }\n  }\n\n  var req;\n  if (params == null) {\n    req = fetch(url);\n  } else {\n    req = fetch(url, params);\n  }\n\n  var res = await req;\n  if (!res.ok) {\n    throw \"failed to download '\" + url + \"' (\" + res.status + \")\";\n  }\n  var buffer = await res.arrayBuffer();\n\n  // Technically, this isn't quite right, because we need to close the read\n  // transaction before opening the write transaction; multiple queries to\n  // the same URL from different workers could cause multiple downloads if\n  // they each miss each other's read check. But oh well; the auto-commit\n  // of IDB transactions means that it's hard to do any better. (Specifically,\n  // we can't do an async fetch while the transaction is still open, because\n  // it just closes before the fetch is done.)\n  let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n  let download_store = trans.objectStore(\"downloads\");\n  var data_saving = new Promise((resolve) => {\n    var putrequest = download_store.put({ url: url, payload: buffer });\n    putrequest.onsuccess = function (event) {\n      resolve(true);\n    };\n    putrequest.onerror = function (event) {\n      resolve(false);\n    };\n  });\n\n  let success = await data_saving;\n  if (!success) {\n    throw \"failed to download resources for '\" + url + \"'\";\n  }\n\n  return buffer;\n}\n\nexport async function remove(url) {\n  await init;\n  let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n  let download_store = trans.objectStore(\"downloads\");\n\n  var removal = new Promise((resolve) => {\n    let request = download_store.delete(url);\n    request.onsuccess = function (event) {\n      resolve(true);\n    };\n    request.onerror = function (event) {\n      resolve(false);\n    };\n  });\n\n  return await removal;\n}\n","import * as bakana from \"bakana\";\nimport * as gesel from \"gesel\";\nimport * as remotes from \"bakana-remotes\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\n\n// Evade CORS problems and enable caching.\nconst proxy = \"https://cors-proxy.aaron-lun.workers.dev\";\nasync function proxyAndCache(url) {\n  let buffer = await downloads.get(proxy + \"/\" + encodeURIComponent(url));\n  return new Uint8Array(buffer);\n}\n\nbakana.CellLabellingState.setDownload(proxyAndCache);\ngesel.setGeneDownload(proxyAndCache);\nbakana.RnaQualityControlState.setDownload(proxyAndCache);\n\ngesel.referenceDownload(async (file, start, end) => {\n  let url = gesel.referenceBaseUrl() + \"/\" + file;\n  let full = proxy + \"/\" + encodeURIComponent(url);\n  if (start == null && end == null) {\n    let buffer = await downloads.get(full);\n    return new Response(buffer);\n  } else {\n    return fetch(full + \"?start=\" + String(start) + \"&end=\" + String(end));\n  }\n});\n\ngesel.geneDownload(async (file) => {\n  let url = gesel.geneBaseUrl() + \"/\" + file;\n  let buffer = await downloads.get(proxy + \"/\" + encodeURIComponent(url));\n  return new Response(buffer);\n});\n\nremotes.ExperimentHubDataset.setDownloadFun(proxyAndCache);\nbakana.availableReaders[\"ExperimentHub\"] = remotes.ExperimentHubDataset;\n\nexport function extractBuffers(object, store) {\n  if (!object) {\n    return;\n  }\n\n  if (Array.isArray(object)) {\n    for (const element of object) {\n      extractBuffers(element, store);\n    }\n  } else if (object.constructor == Object) {\n    for (const [key, element] of Object.entries(object)) {\n      extractBuffers(element, store);\n    }\n  } else if (ArrayBuffer.isView(object)) {\n    if (!(object.buffer instanceof ArrayBuffer)) {\n      throw \"only ArrayBuffers should be in the message payload\";\n    }\n    store.push(object.buffer);\n  }\n}\n\nexport function postAttempt(step) {\n  postMessage({\n    type: `${step}_START`,\n  });\n}\n\nexport function postSuccess(step, info) {\n  if (typeof info == \"undefined\") {\n    postMessage({\n      type: `${step}_CACHE`,\n    });\n  } else {\n    var transferable = [];\n    extractBuffers(info, transferable);\n    postMessage(\n      {\n        type: `${step}_DATA`,\n        resp: info,\n      },\n      transferable\n    );\n  }\n}\n\nexport function postError(type, err, fatal) {\n  postMessage({\n    type: `${type}_ERROR`,\n    resp: {\n      reason: err.toString(),\n      fatal: fatal,\n    },\n  });\n}\n\nexport function splitMetricsByBlock(metrics, blockLevels, blockIds) {\n  var output = {};\n  var blocks = blockIds.slice();\n  for (var b = 0; b < blockLevels.length; b++) {\n    let current = {};\n    for (const [key, val] of Object.entries(metrics)) {\n      current[key] = val.slice().filter((x, i) => blocks[i] == b);\n    }\n    output[blockLevels[b]] = current;\n  }\n  return output;\n}\n\nexport function splitThresholdsByBlock(thresholds, blockLevels) {\n  var output = {};\n  for (const x of blockLevels) {\n    output[x] = {};\n  }\n\n  for (const [key, val] of Object.entries(thresholds)) {\n    for (var b = 0; b < blockLevels.length; b++) {\n      output[blockLevels[b]][key] = val[b];\n    }\n  }\n\n  return output;\n}\n\nexport async function fetchStepSummary(state, step) {\n  // do not send any response to UI if they have not changed\n  if (!state[step].changed) {\n    return undefined;\n  }\n\n  if (step === \"inputs\") {\n    let output = {};\n\n    let ngenes = {};\n    for (const a of state[step].fetchCountMatrix().available()) {\n      ngenes[a] = state[step].fetchCountMatrix().get(a).numberOfRows();\n    }\n\n    let gene_info = {};\n    for (const [k, v] of Object.entries(\n      state[step].fetchFeatureAnnotations()\n    )) {\n      let info = {};\n      for (const c of v.columnNames()) {\n        let col = v.column(c);\n        if (Array.isArray(col)) {\n          info[c] = col;\n        }\n      }\n\n      if (Array.isArray(v.rowNames())) {\n        info[\"rownames\"] = v.rowNames();\n      }\n\n      gene_info[k] = info;\n    }\n\n    let cell_info = {};\n    for (const c of state[step].fetchCellAnnotations().columnNames()) {\n      let col = state[step].fetchCellAnnotations().column(c);\n\n      if (Array.isArray(col) || ArrayBuffer.isView(col)) {\n        const ksumm = bakana.summarizeArray(col);\n        if (ksumm.type === \"continuous\") {\n          cell_info[c] = {\n            name: c,\n            truncated: new Set(col).size >= 50,\n            type: ksumm.type,\n          };\n        } else if (ksumm.type === \"categorical\") {\n          cell_info[c] = {\n            name: c,\n            truncated: ksumm.truncated === true,\n            type: ksumm.type,\n          };\n        }\n      }\n    }\n\n    var blocks = state[step].fetchBlockLevels();\n    if (blocks !== null) {\n      const col = state[step].fetchBlock().slice();\n      const ksumm = bakana.summarizeArray(col);\n      cell_info[\"__batch__\"] = {\n        name: \"__batch__\",\n        truncated: new Set(col).size >= 50,\n        type: \"continuous\",\n      };\n    }\n\n    output = {\n      num_cells: state[step].fetchCountMatrix().numberOfColumns(),\n      num_genes: ngenes,\n      genes: gene_info,\n      annotations: cell_info,\n    };\n\n    return output;\n  } else if (step === \"rna_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sums(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().subsetProportions(0),\n    };\n\n    let output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      sums: state[step].fetchFilters().thresholdsSums(),\n      detected: state[step].fetchFilters().thresholdsDetected(),\n      proportion: state[step].fetchFilters().thresholdsSubsetProportions(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    return output;\n  } else if (step === \"adt_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sums(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().subsetTotals(0),\n    };\n\n    var output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      detected: state[step].fetchFilters().thresholdsDetected(),\n      proportion: state[step].fetchFilters().thresholdsSubsetTotals(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    // We don't use sums for filtering but we do report it in the metrics,\n    // so we just add some NaNs to the thresholds for consistency.\n    for (const [k, v] of Object.entries(output.thresholds)) {\n      v.sums = NaN;\n    }\n\n    return output;\n  } else if (step === \"crispr_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sums(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().maxProportions(),\n    };\n\n    let output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      count: state[step].fetchFilters().thresholdsMaxCount(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    return output;\n  } else if (step === \"cell_filtering\") {\n    let remaining = 0,\n      discard_vec = null;\n    const discardBuff = state[step].fetchDiscards();\n    if (discardBuff) {\n      discardBuff.forEach((x) => {\n        remaining += x == 0;\n      });\n      discard_vec = discardBuff.slice();\n    } else {\n      remaining = state.inputs.fetchCountMatrix().numberOfColumns();\n    }\n    let output = { retained: remaining, discard: discard_vec };\n    return output;\n  } else if (step === \"rna_normalization\") {\n    return {};\n  } else if (step === \"adt_normalization\") {\n    return {};\n  } else if (step === \"crispr_normalization\") {\n    return {};\n  } else if (step === \"feature_selection\") {\n    let output = {\n      means: state[step].fetchResults().means(),\n      vars: state[step].fetchResults().variances(),\n      fitted: state[step].fetchResults().fitted(),\n      resids: state[step].fetchResults().residuals(),\n    };\n    return output;\n  } else if (\n    step === \"rna_pca\" ||\n    step === \"adt_pca\" ||\n    step === \"crispr_pca\"\n  ) {\n    let pcs = state[step].fetchPCs();\n    var var_exp = pcs.varianceExplained();\n    var total_var = pcs.totalVariance();\n    var_exp.forEach((x, i) => {\n      var_exp[i] = x / total_var;\n    });\n    return {\n      var_exp: var_exp,\n    };\n  } else if (step === \"combine_embeddings\") {\n    return {};\n  } else if (step === \"batch_correction\") {\n    return {};\n  } else if (step === \"neighbor_index\") {\n    return {};\n  } else if (step === \"tsne\" || step === \"umap\") {\n    return await state[step].fetchResults();\n  } else if (step === \"kmeans_cluster\") {\n    return {};\n  } else if (step === \"snn_graph_cluster\") {\n    return {};\n  } else if (step === \"choose_clustering\") {\n    var clusters = state[step].fetchClusters();\n    return { clusters: clusters.slice() };\n  } else if (step === \"marker_detection\") {\n    return {};\n  } else if (step === \"cell_labelling\") {\n    return await state[step].fetchResults();\n  } else if (step === \"custom_selections\") {\n    return {};\n  } else if (step === \"feature_set_enrichment\") {\n    let collections = state.feature_set_enrichment.fetchCollectionDetails();\n    let sets = state.feature_set_enrichment.fetchSetDetails();\n    return {\n      collections: collections,\n      sets: {\n        names: sets.names,\n        descriptions: sets.descriptions,\n        sizes: sets.sizes.slice(),\n        collections: sets.collections.slice(),\n      },\n    };\n  }\n}\n","import { randomColor } from \"randomcolor\";\n\nexport const getColors = (data) => {\n  const palette = {\n    1: [\"#1b9e77\"],\n    2: [\"#1b9e77\", \"#d95f02\"],\n    3: [\"#1b9e77\", \"#d95f02\", \"#7570b3\"],\n    4: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\"],\n    5: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\"],\n    6: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\"],\n    7: [\n      \"#1b9e77\",\n      \"#d95f02\",\n      \"#7570b3\",\n      \"#e7298a\",\n      \"#66a61e\",\n      \"#e6ab02\",\n      \"#a6761d\",\n    ],\n    8: [\n      \"#1b9e77\",\n      \"#d95f02\",\n      \"#7570b3\",\n      \"#e7298a\",\n      \"#66a61e\",\n      \"#e6ab02\",\n      \"#a6761d\",\n      \"#666666\",\n    ],\n    9: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n    ],\n    10: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n    ],\n    11: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n      \"#ffff99\",\n    ],\n    12: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n      \"#ffff99\",\n      \"#b15928\",\n    ],\n  };\n\n  let cluster_count = Math.max(...data) + 1;\n  let cluster_colors = null;\n  if (cluster_count > Object.keys(palette).length) {\n    cluster_colors = randomColor({\n      luminosity: \"dark\",\n      count: cluster_count + 1,\n    });\n  } else {\n    cluster_colors = palette[cluster_count.toString()];\n  }\n\n  return cluster_colors;\n};\n\nexport function isObject(object) {\n  return typeof object === \"object\" && Array.isArray(object) === false;\n}\n\nexport const code = \"K@ðœ‚a#$c3ll\";\n\n// this function is from https://developer.mozilla.org/en-US/docs/Glossary/Base64\nexport function utf8_to_b64(str) {\n  return window.btoa(unescape(encodeURIComponent(str)));\n}\n\nexport function generateUID(resource) {\n  let base = `${resource.format}`;\n  switch (resource.format) {\n    case \"SummarizedExperiment\":\n      base += `::${resource.rds.name}::${resource.rds.lastModified}::${resource.rds.size}`;\n      return utf8_to_b64(base);\n    case \"MatrixMarket\":\n      for (let key of [\"genes\", \"mtx\", \"annotations\"]) {\n        if (resource[key]) {\n          base += `::${resource[key].name}::${resource[key].lastModified}::${resource[key].size}`;\n        }\n      }\n      return utf8_to_b64(base);\n    case \"10X\":\n    case \"H5AD\":\n      base += `::${resource.h5.name}::${resource.h5.lastModified}::${resource.h5.size}`;\n      return utf8_to_b64(base);\n    case \"ExperimentHub\":\n      base += `::${resource.id}`;\n      return utf8_to_b64(base);\n    case \"ZippedArtifactdb\":\n      base += `::${resource.zipname}::${resource.zipfile}`;\n      return utf8_to_b64(base);\n    default:\n      throw Error(`format: ${resource.format} does not exist`);\n      break;\n  }\n}\n\nexport const MODALITIES = [\"RNA\", \"ADT\", \"CRISPR\"];\n\nexport const getMinMax = (arr) => {\n  var max = -Number.MAX_VALUE,\n    min = Number.MAX_VALUE;\n  arr.forEach(function (x) {\n    if (max < x) {\n      max = x;\n    }\n    if (min > x) {\n      min = x;\n    }\n  });\n  return [min, max];\n};\n\nexport const defaultColor = \"#5F6B7C\";\n","import * as bakana from \"bakana\";\nimport * as scran from \"scran.js\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\nimport {\n  extractBuffers,\n  postAttempt,\n  postSuccess,\n  postError,\n} from \"./helpers.js\";\nimport { code } from \"../utils/utils.js\";\n/***************************************/\n\nconst default_cluster = `${code}::CLUSTERS`;\nconst default_selection = `${code}::SELECTION`;\n\nlet superstate = null;\nlet preflights = {};\nlet preflights_summary = {};\nlet dataset = null;\nlet cache_anno_markers = {};\nlet custom_selection_state = null;\nlet feature_set_enrich_state = null;\n\nfunction createDataset(args, setOpts = false) {\n  if (args.format === \"H5AD\") {\n    return new bakana.H5adResult(args.h5, setOpts ? args.options : {});\n  } else if (args.format === \"SummarizedExperiment\") {\n    return new bakana.SummarizedExperimentResult(\n      args.rds,\n      setOpts ? args.options : {}\n    );\n  } else if (args.format === \"ZippedArtifactdb\") {\n    return new bakana.ZippedArtifactdbResult(\n      args.zipname,\n      new bakana.SimpleFile(args.zipfile),\n      setOpts ? args.options : {}\n    );\n  } else {\n    throw new Error(\"unknown format '\" + args.format + \"'\");\n  }\n}\n\nfunction summarizeResult(summary, args) {\n  let cells_summary = {};\n  for (const k of summary.cells.columnNames()) {\n    let kcol = summary.cells.column(k);\n    if (Array.isArray(kcol) || ArrayBuffer.isView(kcol))\n      cells_summary[k] = bakana.summarizeArray(kcol);\n  }\n  let tmp_meta = {\n    cells: {\n      columns: cells_summary,\n      numberOfCells: summary.cells.numberOfRows(),\n    },\n  };\n\n  if (\n    args.format === \"SummarizedExperiment\" ||\n    args.format === \"ZippedArtifactdb\"\n  ) {\n    tmp_meta[\"modality_features\"] = {};\n    if (\"modality_features\" in summary) {\n      for (const [k, v] of Object.entries(summary.modality_features)) {\n        let tmod_summary = {};\n        for (const k of v.columnNames()) {\n          // TODO: figure out a way to deal with these later\n          if (!Array.isArray(v.column(k))) {\n            continue;\n          }\n          tmod_summary[k] = bakana.summarizeArray(v.column(k));\n          tmod_summary[k][\"_all_\"] = v.column(k);\n        }\n        tmp_meta[\"modality_features\"][k] = {\n          columns: tmod_summary,\n          numberOfFeatures: v.numberOfRows(),\n          rownames: Array.isArray(v.rowNames()),\n        };\n      }\n    }\n  } else {\n    tmp_meta[\"all_features\"] = {};\n    let tmod_summary = {};\n    for (const k of summary[\"all_features\"].columnNames()) {\n      tmod_summary[k] = bakana.summarizeArray(\n        summary[\"all_features\"].column(k)\n      );\n      tmod_summary[k][\"_all_\"] = summary[\"all_features\"].column(k);\n    }\n    tmp_meta[\"all_features\"] = {\n      columns: tmod_summary,\n      numberOfFeatures: summary[\"all_features\"].numberOfRows(),\n      rownames: Array.isArray(summary[\"all_features\"].rowNames()),\n    };\n  }\n\n  if (args.format === \"H5AD\") {\n    tmp_meta[\"all_assay_names\"] = summary.all_assay_names;\n  } else if (\n    args.format === \"SummarizedExperiment\" ||\n    args.format === \"ZippedArtifactdb\"\n  ) {\n    tmp_meta[\"modality_assay_names\"] = summary.modality_assay_names;\n  }\n\n  tmp_meta.reduced_dimension_names = summary.reduced_dimension_names;\n  return tmp_meta;\n}\n\nfunction getMarkerStandAloneForAnnot(annotation, annotation_vec) {\n  let mds;\n  if (!(annotation in cache_anno_markers)) {\n    mds = new bakana.MarkerDetectionStandalone(\n      getMatrix(),\n      annotation_vec.ids.slice()\n    );\n\n    mds.computeAll();\n    cache_anno_markers[annotation] = mds;\n  }\n\n  return cache_anno_markers[annotation];\n}\n\nconst getAnnotation = (annotation) => {\n  if (annotation.indexOf(\":::\") !== -1) {\n    let splits = annotation.split(\":::\");\n    return dataset.cells.column(splits[0]).column(splits[1]);\n  }\n  return dataset.cells.column(annotation);\n};\n\nconst getMatrix = () => {\n  return dataset.matrix;\n};\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n  const { type, payload } = msg.data;\n\n  // console.log(\"EXPLORE WORKER::RCV::\", type, payload);\n\n  let fatal = false;\n  if (type === \"INIT\") {\n    fatal = true;\n    let nthreads = Math.round((navigator.hardwareConcurrency * 2) / 3);\n    let back_init = bakana.initialize({ numberOfThreads: nthreads });\n\n    let state_init = back_init.then(() => {\n      return bakana.createAnalysis();\n    });\n\n    state_init.then((x) => {\n      superstate = x;\n      postMessage({\n        type: type,\n        msg: \"Success: analysis state created\",\n      });\n    });\n\n    let down_init = downloads.initialize();\n    down_init\n      .then((output) => {\n        postMessage({\n          type: \"DownloadsDB_store\",\n          resp: output,\n          msg: \"Success: DownloadsDB initialized\",\n        });\n      })\n      .catch((error) => {\n        console.error(error);\n        postMessage({\n          type: \"DownloadsDB_ERROR\",\n          msg: \"Error: Cannot initialize DownloadsDB\",\n        });\n      });\n\n    loaded = Promise.all([back_init, state_init, down_init]);\n\n    loaded\n      .then(() => {\n        postMessage({\n          type: type,\n          msg: \"Success: bakana initialized\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n    /**************** EXPLORE AN ANALYSIS *******************/\n  } else if (type === \"EXPLORE\") {\n    fatal = true;\n    loaded\n      .then(async (x) => {\n        let inputs = payload.inputs;\n        let files = inputs.files;\n\n        if (files !== null) {\n          // Extracting existing datasets from the preflights.\n          let current = {};\n          for (const [k, v] of Object.entries(files)) {\n            if (\"uid\" in v && v.uid in preflights) {\n              preflights[v.uid].clear();\n              delete preflights[k];\n            }\n            current[k] = createDataset(v, true);\n            current[k].setOptions(v.options);\n          }\n\n          for (const [k, v] of Object.entries(current)) {\n            dataset = await v.load();\n\n            let finput = files[k];\n\n            if (!finput.options.normalized) {\n              for (const k of dataset.matrix.available()) {\n                let mat = dataset.matrix.get(k);\n                let lnorm = scran.logNormCounts(mat, { allowZeros: true });\n                dataset.matrix.add(k, lnorm);\n              }\n            }\n\n            let step_inputs = \"inputs\";\n            postAttempt(step_inputs);\n\n            // extract cell annotations\n            let annotation_keys = {};\n            for (const k of dataset.cells.columnNames()) {\n              let kcol = dataset.cells.column(k);\n              if (Array.isArray(kcol) || ArrayBuffer.isView(kcol)) {\n                const ksumm = bakana.summarizeArray(kcol);\n                if (ksumm.type === \"continuous\") {\n                  annotation_keys[k] = {\n                    name: k,\n                    truncated: new Set(kcol).size >= 50,\n                    type: ksumm.type,\n                  };\n                } else if (ksumm.type === \"categorical\") {\n                  annotation_keys[k] = {\n                    name: k,\n                    truncated: ksumm.truncated === true,\n                    type: ksumm.type,\n                  };\n                }\n              }\n            }\n\n            let step_inputs_resp = {\n              annotations: annotation_keys,\n              genes: {},\n              num_cells: dataset.cells.numberOfRows(),\n              num_genes: {},\n            };\n\n            for (const [k, v] of Object.entries(dataset.features)) {\n              step_inputs_resp[\"genes\"][k] = {};\n              step_inputs_resp[\"num_genes\"][k] = v.numberOfRows();\n              for (const col of v.columnNames()) {\n                let kcol = v.column(col);\n                if (Array.isArray(kcol) || ArrayBuffer.isView(kcol)) {\n                  step_inputs_resp[\"genes\"][k][col] = kcol;\n                }\n              }\n\n              if (v.rowNames()) {\n                step_inputs_resp[\"genes\"][k][\"rowNames\"] = v.rowNames();\n              }\n            }\n            postSuccess(step_inputs, step_inputs_resp);\n\n            let step_embed = \"embedding\";\n            postAttempt(step_embed);\n            let step_embed_resp = {};\n\n            for (const [k, v] of Object.entries(dataset.reduced_dimensions)) {\n              if (k.toLowerCase() !== \"pca\") {\n                step_embed_resp[k] = {\n                  x: v[0].slice(),\n                  y: v[1].slice(),\n                };\n              }\n            }\n\n            postSuccess(step_embed, step_embed_resp);\n\n            if (custom_selection_state) {\n              custom_selection_state.free();\n            }\n\n            custom_selection_state = new bakana.CustomSelectionsStandalone(\n              dataset.matrix\n            );\n          }\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n    /**************** LOADING EXISTING ANALYSES *******************/\n  } else if (type === \"PREFLIGHT_INPUT\") {\n    loaded\n      .then(async (x) => {\n        let resp = {};\n        try {\n          // Registering the UIDs of each new dataset.\n          let current = {};\n          let summary = {};\n          for (const [k, v] of Object.entries(payload.inputs.files)) {\n            if (\"uid\" in v) {\n              if (!(v.uid in preflights)) {\n                preflights[v.uid] = createDataset(v);\n                preflights_summary[v.uid] = await preflights[v.uid].summary();\n              }\n              current[k] = preflights[v.uid];\n              summary[k] = summarizeResult(preflights_summary[v.uid], v);\n            } else {\n              let tmp_dataset = createDataset(v);\n              current[k] = tmp_dataset;\n              summary[k] = summarizeResult(current[k], v);\n            }\n          }\n\n          resp.status = \"SUCCESS\";\n          resp.details = summary;\n        } catch (e) {\n          console.error(e);\n          resp.status = \"ERROR\";\n          resp.reason = e.toString();\n        }\n\n        postMessage({\n          type: \"PREFLIGHT_INPUT_DATA\",\n          resp: resp,\n          msg: \"Success: PREFLIGHT_INPUT done\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    /**************** VERSUS MODE *******************/\n  } else if (type === \"computeVersusClusters\") {\n    loaded\n      .then((x) => {\n        let rank_type = payload.rank_type;\n        let modality = payload.modality;\n        let annotation = payload.annotation;\n\n        let annotation_vec = scran.factorize(getAnnotation(annotation));\n\n        let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n        let raw_res = mds.computeVersus(\n          annotation_vec.levels.indexOf(payload.left),\n          annotation_vec.levels.indexOf(payload.right)\n        );\n        let resp = bakana.formatMarkerResults(\n          raw_res.results[modality],\n          raw_res.left,\n          rank_type\n        );\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"computeVersusClusters\",\n            resp: resp,\n            msg: \"Success: COMPUTE_VERSUS_CLUSTERS done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeVersusSelections\") {\n    loaded\n      .then((x) => {\n        let rank_type = payload.rank_type;\n        let res = custom_selection_state.computeVersus(\n          payload.left,\n          payload.right\n        );\n        let resp = bakana.formatMarkerResults(\n          res[\"results\"][payload.modality],\n          payload.left,\n          rank_type\n        );\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"computeVersusSelections\",\n            resp: resp,\n            msg: \"Success: COMPUTE_VERSUS_SELECTIONS done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    //   /**************** OTHER EVENTS FROM UI *******************/\n  } else if (type === \"getMarkersForCluster\") {\n    loaded\n      .then((x) => {\n        let cluster = payload.cluster;\n        let rank_type = payload.rank_type;\n        let modality = payload.modality;\n        let annotation = payload.annotation;\n\n        let annotation_vec = scran.factorize(getAnnotation(annotation));\n        let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n        let raw_res = mds.fetchResults()[modality];\n\n        let resp = bakana.formatMarkerResults(\n          raw_res,\n          annotation_vec.levels.indexOf(cluster),\n          rank_type\n        );\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"setMarkersForCluster\",\n            resp: resp,\n            msg: \"Success: GET_MARKER_GENE done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getGeneExpression\") {\n    loaded\n      .then((x) => {\n        let row_idx = payload.gene;\n        let modality = payload.modality;\n\n        var vec = dataset.matrix.get(modality).row(row_idx);\n\n        postMessage(\n          {\n            type: \"setGeneExpression\",\n            resp: {\n              gene: row_idx,\n              expr: vec,\n            },\n            msg: \"Success: GET_GENE_EXPRESSION done\",\n          },\n          [vec.buffer]\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeCustomMarkers\") {\n    loaded\n      .then((x) => {\n        custom_selection_state.addSelection(payload.id, payload.selection);\n        postMessage({\n          type: \"computeCustomMarkers\",\n          msg: \"Success: COMPUTE_CUSTOM_MARKERS done\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getMarkersForSelection\") {\n    loaded\n      .then((x) => {\n        let rank_type = payload.rank_type.replace(/-.*/, \"\"); // summary type doesn't matter for pairwise comparisons.\n\n        let raw_res = custom_selection_state.fetchResults(payload.cluster)[\n          payload.modality\n        ];\n        let resp = bakana.formatMarkerResults(raw_res, 1, rank_type);\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"setMarkersForCustomSelection\",\n            resp: resp,\n            msg: \"Success: GET_MARKER_GENE done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"removeCustomMarkers\") {\n    loaded\n      .then((x) => {\n        custom_selection_state.removeSelection(payload.id);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getAnnotation\") {\n    loaded\n      .then((x) => {\n        let annot = payload.annotation;\n        let vec, output;\n\n        vec = getAnnotation(annot);\n        // dataset.cells.column(annot);\n\n        if (ArrayBuffer.isView(vec)) {\n          output = {\n            type: \"array\",\n            values: vec.slice(),\n          };\n        } else {\n          let uniq_vals = [];\n          let uniq_map = {};\n          let indices = new Int32Array(vec.length);\n          vec.map((x, i) => {\n            if (!(x in uniq_map)) {\n              uniq_map[x] = uniq_vals.length;\n              uniq_vals.push(x);\n            }\n            indices[i] = uniq_map[x];\n          });\n\n          output = {\n            type: \"factor\",\n            index: indices,\n            levels: uniq_vals,\n          };\n        }\n\n        let extracted = [];\n        extractBuffers(output, extracted);\n        postMessage(\n          {\n            type: \"setAnnotation\",\n            resp: {\n              annotation: annot,\n              values: output,\n            },\n            msg: \"Success: GET_ANNOTATION done\",\n          },\n          extracted\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeFeaturesetSummary\") {\n    loaded\n      .then(async (x) => {\n        let { annotation, rank_type, cluster, modality } = payload;\n        let index = rank_type.indexOf(\"-\");\n        let resp;\n\n        if (default_selection === annotation) {\n          let sel_indices =\n            custom_selection_state.fetchSelectionIndices(cluster);\n          let num_cells = dataset.cells.numberOfRows();\n\n          let arr_sel_indices = new Uint8Array(num_cells);\n          sel_indices.map((x) => arr_sel_indices.set([1], x));\n          let annotation_vec = scran.factorize(arr_sel_indices);\n\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n          let anno_markers = mds.fetchResults()[modality];\n\n          feature_set_enrich_state.ready().then((x) => {\n            resp = feature_set_enrich_state.computeEnrichment(\n              anno_markers,\n              annotation_vec.levels.indexOf(1),\n              rank_type.slice(0, index),\n              rank_type.slice(index + 1)\n            );\n            postSuccess(\"computeFeaturesetSummary\", resp);\n          });\n        } else {\n          let annotation_vec = scran.factorize(getAnnotation(annotation));\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n          let anno_markers = mds.fetchResults()[modality];\n\n          feature_set_enrich_state.ready().then((x) => {\n            resp = feature_set_enrich_state.computeEnrichment(\n              anno_markers,\n              annotation_vec.levels.indexOf(cluster),\n              rank_type.slice(0, index),\n              rank_type.slice(index + 1)\n            );\n            postSuccess(\"computeFeaturesetSummary\", resp);\n          });\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeFeaturesetVSSummary\") {\n    loaded\n      .then(async (x) => {\n        let { annotation, rank_type, left, right, modality } = payload;\n        let index = rank_type.indexOf(\"-\");\n        let resp;\n        if (default_selection === annotation) {\n          let anno_markers = custom_selection_state.computeVersus(left, right);\n\n          feature_set_enrich_state.ready().then((x) => {\n            resp = feature_set_enrich_state.computeEnrichment(\n              anno_markers.results[modality],\n              0,\n              rank_type.slice(0, index),\n              rank_type.slice(index + 1)\n            );\n            postSuccess(\"computeFeaturesetVSSummary\", resp);\n          });\n        } else {\n          let annotation_vec = scran.factorize(getAnnotation(annotation));\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n          let raw_res = mds.computeVersus(\n            annotation_vec.levels.indexOf(payload.left),\n            annotation_vec.levels.indexOf(payload.right)\n          );\n\n          feature_set_enrich_state.ready().then((x) => {\n            resp = feature_set_enrich_state.computeEnrichment(\n              raw_res.results[modality],\n              raw_res.left,\n              rank_type.slice(0, index),\n              rank_type.slice(index + 1)\n            );\n            postSuccess(\"computeFeaturesetVSSummary\", resp);\n          });\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getFeatureScores\") {\n    loaded\n      .then((x) => {\n        let { index } = payload;\n\n        let resp = feature_set_enrich_state.computePerCellScores(index);\n        postSuccess(\"setFeatureScores\", resp);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getFeatureGeneIndices\") {\n    loaded\n      .then((x) => {\n        let { index, cluster, annotation, modality, rank_type } = payload;\n\n        let resp = feature_set_enrich_state.fetchFeatureSetIndices(index);\n\n        let raw_res, marker_resp;\n\n        if (default_selection === annotation) {\n          raw_res = custom_selection_state.fetchResults(payload.cluster)[\n            payload.modality\n          ];\n          marker_resp = bakana.formatMarkerResults(\n            raw_res,\n            1,\n            payload.rank_type\n          );\n        } else {\n          let annotation_vec = scran.factorize(getAnnotation(annotation));\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n          raw_res = mds.fetchResults()[modality];\n          // cache_anno_markers[annotation][modality];\n\n          marker_resp = bakana.formatMarkerResults(\n            raw_res,\n            annotation_vec.levels.indexOf(cluster),\n            rank_type\n          );\n        }\n\n        let indices = marker_resp.ordering\n          .map((x, i) => (resp.includes(x) ? i : -100))\n          .filter((x) => x !== -100);\n\n        let filtered_marker_resp = {};\n        for (const [k, v] of Object.entries(marker_resp)) {\n          filtered_marker_resp[k] = v\n            .map((x, i) => (indices.includes(i) ? x : -100))\n            .filter((x) => x !== -100);\n        }\n\n        postSuccess(\"setFeatureGeneIndices\", filtered_marker_resp);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"initFeaturesetEnrich\") {\n    loaded.then(async (x) => {\n      let { modality } = payload;\n\n      if (feature_set_enrich_state) {\n        feature_set_enrich_state.free();\n      }\n\n      feature_set_enrich_state = new bakana.FeatureSetEnrichmentStandalone(\n        dataset.features[modality],\n        { normalized: dataset.matrix.get(modality) }\n      );\n\n      feature_set_enrich_state.ready().then((x) => {\n        let collections = feature_set_enrich_state.fetchCollectionDetails();\n        let sets = feature_set_enrich_state.fetchSetDetails();\n        let resp = {\n          collections: collections,\n          sets: {\n            names: sets.names,\n            descriptions: sets.descriptions,\n            sizes: sets.sizes.slice(),\n            collections: sets.collections.slice(),\n          },\n        };\n        postSuccess(\"feature_set_enrichment\", resp);\n      });\n    });\n  } else {\n    console.error(\"MIM:::msg type incorrect\");\n    postError(type, \"Type not defined\", fatal);\n  }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [841,534,377], function() { return __webpack_require__(9747); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"377\":\"676821c7\",\"484\":\"7594d5c1\",\"534\":\"0569fe6b\",\"841\":\"3bb3130c\",\"909\":\"5f72aea9\",\"933\":\"2b53d6a2\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t747: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([841,534,377].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DownloadsDB","init","get","_x","_get","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","url","params","force","_trans","_download_store","data_check","found","req","res","buffer","trans","download_store","data_saving","_args2","wrap","_context2","prev","next","length","undefined","result","transaction","objectStore","Promise","resolve","already","onsuccess","event","payload","onerror","sent","abrupt","fetch","ok","status","arrayBuffer","putrequest","put","stop","proxy","proxyAndCache","_proxyAndCache","_callee3","_context3","downloads","encodeURIComponent","Uint8Array","extractBuffers","object","store","Array","isArray","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","err","e","f","constructor","Object","_i","_Object$entries","entries","_Object$entries$_i","_slicedToArray","ArrayBuffer","isView","push","postAttempt","step","postMessage","type","concat","postSuccess","info","transferable","resp","postError","fatal","reason","toString","bakana","gesel","_ref","_callee","file","start","end","full","_context","Response","String","_x2","_x3","_x4","_ref2","_x5","remotes","code","default_selection","preflights","preflights_summary","dataset","cache_anno_markers","custom_selection_state","feature_set_enrich_state","createDataset","args","setOpts","format","h5","options","rds","zipname","zipfile","Error","summarizeResult","summary","cells_summary","cells","columnNames","k","kcol","column","tmp_meta","columns","numberOfCells","numberOfRows","modality_features","_step2","v","tmod_summary","_iterator2","numberOfFeatures","rownames","rowNames","_step3","_iterator3","all_assay_names","modality_assay_names","reduced_dimension_names","getMarkerStandAloneForAnnot","annotation","annotation_vec","mds","getMatrix","ids","slice","computeAll","loaded","getAnnotation","indexOf","splits","split","matrix","onmessage","msg","_msg$data","data","nthreads","Math","round","navigator","hardwareConcurrency","back_init","numberOfThreads","state_init","then","x","down_init","reject","indexedDB","open","onupgradeneeded","DownloadsDBClient","target","deleteObjectStore","createObjectStore","keyPath","output","catch","error","console","all","inputs","files","current","_i2","_Object$entries2","_Object$entries2$_i","_i3","_Object$entries3","_Object$entries3$_i","_k4","_v","_iterator4","_step4","_k5","mat","lnorm","step_inputs","annotation_keys","_iterator5","_step5","_k8","_kcol","ksumm","step_inputs_resp","_i4","_Object$entries4","_Object$entries4$_i","_k6","_v2","_iterator6","_step6","col","step_embed","step_embed_resp","_i5","_Object$entries5","_Object$entries5$_i","_k7","_v3","uid","clear","setOptions","load","normalized","available","scran","allowZeros","add","name","truncated","Set","size","annotations","genes","num_cells","num_genes","features","reduced_dimensions","toLowerCase","y","free","_i6","_Object$entries6","_Object$entries6$_i","tmp_dataset","details","t0","rank_type","modality","raw_res","computeVersus","levels","left","right","results","transferrable","cluster","fetchResults","row_idx","gene","vec","row","expr","addSelection","id","selection","replace","removeSelection","annot","values","uniq_vals","uniq_map","indices","Int32Array","map","i","index","extracted","_ref3","sel_indices","arr_sel_indices","anno_markers","_annotation_vec","_mds","_anno_markers","fetchSelectionIndices","set","ready","computeEnrichment","_ref4","_callee4","_context4","computePerCellScores","marker_resp","fetchFeatureSetIndices","ordering","includes","filter","filtered_marker_resp","_i7","_Object$entries7","_Object$entries7$_i","_ref5","_callee5","_context5","collections","fetchCollectionDetails","sets","fetchSetDetails","names","descriptions","sizes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","chunkId","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","p","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}