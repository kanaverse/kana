{"version":3,"file":"static/js/522.44959ef0.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/readers/index.js","../node_modules/jaspagate/src/general.js","../node_modules/bakana/browser/defaults.js","../node_modules/bakana/browser/index.js","../node_modules/bakana/browser/dump/interfaces.js","../node_modules/bakana/browser/dump/abstract/dump.js","../node_modules/bakana/browser/steps/inputs.js","../node_modules/bakana/browser/readers/alabaster-abstract.js","../node_modules/bakana/browser/steps/custom_selections.js","../node_modules/bioconductor/src/SingleCellExperiment.js","../node_modules/jaspagate/src/List.js","../node_modules/jaspagate/src/RangedSummarizedExperiment.js","../node_modules/jaspagate/src/utils.js","../node_modules/jaspagate/src/SummarizedExperiment.js","../node_modules/gesel/src/searchGenes.js","../node_modules/gesel/src/utils.js","../node_modules/bakana/browser/steps/feature_set_enrichment.js","../node_modules/jaspagate/src/DataFrame.js","../node_modules/bakana/browser/dump/DataFrame.js","../node_modules/gesel/src/findOverlappingSets.js","../node_modules/bakana/browser/readers/se.js","../node_modules/bakana/browser/readers/alabaster-zipped.js","../node_modules/jaspagate/src/SingleCellExperiment.js","../node_modules/bakana/browser/readers/h5ad.js","../node_modules/bakana/browser/readers/ArtifactDB-zipped.js","../node_modules/bioconductor/src/List.js","../node_modules/bakana/browser/steps/cell_labelling.js","../node_modules/jaspagate/src/metadata.js","../node_modules/scran.js/browser/transposeMatrix.js","../node_modules/bakana/browser/steps/utils/viz_parent.js","../node_modules/bakana/browser/analysis.js"],"sourcesContent":["export * from \"./10x.js\";\nexport * from \"./h5ad.js\";\nexport * from \"./mtx.js\"\nexport * from \"./se.js\";\nexport * from \"./ArtifactDB-abstract.js\";\nexport * from \"./ArtifactDB-zipped.js\";\nexport * from \"./alabaster-abstract.js\";\nexport * from \"./alabaster-zipped.js\";\nexport * from \"./utils/extract.js\";\nexport * from \"./abstract/file.js\";\n\nimport { TenxHdf5Dataset } from \"./10x.js\";\nimport { H5adDataset } from \"./h5ad.js\";\nimport { TenxMatrixMarketDataset } from \"./mtx.js\"\nimport { SummarizedExperimentDataset } from \"./se.js\";\nimport { ZippedArtifactdbDataset } from \"./ArtifactDB-zipped.js\";\n\n/**\n * Any class that satisfies the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md).\n * Each class contains methods to load data from some arbitrary data source into {@linkplain ScranMatrix} objects (for the counts)\n * and {@linkplain DataFrame} objects (for the feature or cell annotations).\n * The default set of known dataset reader classes is listed in the {@linkcode availableReaders} object\n * and includes {@linkplain TenxHdf5Dataset}, {@linkplain TenxMatrixMarketDataset}, {@linkplain H5adDataset} and {@linkplain SummarizedExperimentDataset} instances.\n *\n * @typedef Dataset\n */\n\n/**\n * A representation of a matrix of expression values, where the values are hosted on the Wasm heap for easier compute via [**scran.js**](https://github.com/kanaverse/scran.js).\n * See [here](https://kanaverse.github.io/scran.js/ScranMatrix.html) for more details.\n *\n * @external ScranMatrix\n */ \n\n/**\n * A representation of multiple {@linkplain external:ScranMatrix ScranMatrix} objects, where each object contains data for the same cells but across a different feature space, e.g., for different data modalities.\n * See [here](https://kanaverse.github.io/scran.js/MultiMatrix.html) for more details.\n *\n * @external MultiMatrix\n */ \n\n/**\n * A DataFrame from the [**bioconductor**](https://github.com/LTLA/bioconductor.js) package, where each column is represented by some arbitrary vector-like object.\n * See [here](https://ltla.github.io/bioconductor.js/DataFrame.html) for more details.\n *\n * @external DataFrame\n */ \n\n/**\n * All known dataset readers.\n * Each entry contains a {@linkplain Dataset} class with the key defined as the {@linkcode Dataset#format format} return value.\n */\nexport const availableReaders = {\n    \"10X\": TenxHdf5Dataset,\n    \"MatrixMarket\": TenxMatrixMarketDataset,\n    \"H5AD\": H5adDataset,\n    \"SummarizedExperiment\": SummarizedExperimentDataset,\n    \"ArtifactDB-zipped\": ZippedArtifactdbDataset\n};\n","import * as bioc from \"bioconductor\";\nimport * as list from \"./List.js\";\nimport * as df from \"./DataFrame.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as sce from \"./SingleCellExperiment.js\";\nimport { joinPath } from \"./utils.js\";\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link DataFrame}.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}. \n * @return {object} Object metadata.\n * @async\n */\nexport async function readObjectFile(path, globals) {\n    let payload = await globals.get(joinPath(path, \"OBJECT\"), { asBuffer: true });\n    try {\n        let dec = new TextDecoder;\n        return JSON.parse(dec.decode(payload));\n    } finally {\n        await globals.clean(payload);\n    }\n}\n\n/**\n * @type {object}\n * @desc Registry of reader functions.\n * Each key is a takane object type, and each value is a function that accepts the same arguments as {@linkcode readObject}.\n */\nexport const readObjectRegistry = {};\n\n/**\n * This function will inspect {@linkcode readObjectRegistry} to check if any reader function is supplied for the takane object type at `path`.\n * If found, it will use that function, otherwise it will fall back to the default functions:\n * \n * - {@linkcode readDataFrame}, to read {@link external:DataFrame DataFrame} objects.\n * - {@linkcode readSummarizedExperiment}, to read {@link external:SummarizedExperiment SummarizedExperiment} objects.\n * - {@linkcode readRangedSummarizedExperiment}, to read {@link external:RangedSummarizedExperiment RangedSummarizedExperiment} objects.\n * - {@linkcode readSingleCellExperiment}, to read {@link external:SingleCellExperiment SingleCellExperiment} objects.\n *\n * @param {string} path - Path to a takane-formatted object directory. \n * @param {?object} metadata - Object metadata.\n * If `null`, this is automatically loaded by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, to be passed to the reader functions for individual takane object types.\n *\n * @return Some in-memory representation of the takane object at `path`.\n * @async\n */\nexport async function readObject(path, metadata, globals, options = {}) {\n    if (metadata == null) {\n        metadata = await readObjectFile(path, globals);\n    }\n\n    let objtype = metadata[\"type\"];\n    if (objtype in readObjectRegistry) {\n        return readObjectRegistry[objtype](path, metadata, globals, options);\n\n    } else {\n        const defaults = {\n            \"simple_list\": list.readList,\n            \"data_frame\": df.readDataFrame,\n            \"summarized_experiment\": se.readSummarizedExperiment,\n            \"ranged_summarized_experiment\": rse.readRangedSummarizedExperiment,\n            \"single_cell_experiment\": sce.readSingleCellExperiment\n        };\n\n        if (objtype in defaults) {\n            return defaults[objtype](path, metadata, globals, options);\n        }\n\n        throw new Error(\"type '\" + objtype + \"' is not supported\");\n    }\n}\n\n/**\n * @type {Array}\n * @desc Registry of saving functions.\n * Each entry should be an array of length 2, containing a Javascript class and its saving function.\n * Each saving function should accept the same arguments as {@linkcode saveObject}.\n * Subclasses should be placed after their parents in this array.\n */\nexport const saveObjectRegistry = [];\n\n/**\n * This function will inspect {@linkcode saveObjectRegistry} to check if any saving function is supplied for `x`.\n * If found, it will use that function, otherwise it will fall back to the default functions:\n * \n * - {@linkcode saveDataFrame}, to save {@link external:DataFrame DataFrame} objects.\n * - {@linkcode saveSummarizedExperiment}, to save {@link external:SummarizedExperiment SummarizedExperiment} objects.\n * - {@linkcode saveRangedSummarizedExperiment}, to save {@link external:RangedSummarizedExperiment RangedSummarizedExperiment} objects.\n * - {@linkcode saveSingleCellExperiment}, to save {@link external:SingleCellExperiment SingleCellExperiment} objects.\n *\n * @param {Any} x - The takane-compatible object to be saved.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveObject(x, path, globals, options = {}) {\n    for (var i = saveObjectRegistry.length; i > 0; i--) {\n        const [cls, meth] = saveObjectRegistry[i - 1];\n        if (x instanceof cls) {\n            await meth(x, path, globals, options);\n            return;\n        }\n    }\n\n    const defaults = [\n        [bioc.SingleCellExperiment, sce.saveSingleCellExperiment],\n        [bioc.RangedSummarizedExperiment, rse.saveRangedSummarizedExperiment],\n        [bioc.SummarizedExperiment, se.saveSummarizedExperiment],\n        [bioc.DataFrame, df.saveDataFrame],\n        [bioc.List, list.saveList]\n    ];\n\n    for (const [cls, fun] of defaults) {\n        if (x instanceof cls) {\n            await fun(x, path, globals, options);\n            return;\n        }\n    }\n\n    throw new Error(\"object of type '\" + x.constructor.name + \"' is not supported\");\n}\n","import * as inputs from \"./steps/inputs.js\";\nimport * as qc from \"./steps/rna_quality_control.js\";\nimport * as qcadt from \"./steps/adt_quality_control.js\";\nimport * as qccrispr from \"./steps/crispr_quality_control.js\";\nimport * as filter from \"./steps/cell_filtering.js\";\nimport * as norm from \"./steps/rna_normalization.js\";\nimport * as normadt from \"./steps/adt_normalization.js\";\nimport * as normcrispr from \"./steps/crispr_normalization.js\";\nimport * as fsel from \"./steps/feature_selection.js\";\nimport * as pca from \"./steps/rna_pca.js\";\nimport * as pcaadt from \"./steps/adt_pca.js\";\nimport * as pcacrispr from \"./steps/crispr_pca.js\";\nimport * as combine from \"./steps/combine_embeddings.js\";\nimport * as correct from \"./steps/batch_correction.js\";\nimport * as index from \"./steps/neighbor_index.js\";\nimport * as snngraph from \"./steps/snn_graph_cluster.js\";\nimport * as tsne from \"./steps/tsne.js\";\nimport * as umap from \"./steps/umap.js\";\nimport * as kmeans from \"./steps/kmeans_cluster.js\";\nimport * as choose from \"./steps/choose_clustering.js\";\nimport * as markers from \"./steps/marker_detection.js\";\nimport * as custom from \"./steps/custom_selections.js\";\nimport * as enrichment from \"./steps/feature_set_enrichment.js\";\nimport * as labelling from \"./steps/cell_labelling.js\";\n\n/**\n * Generate an object containing all of the default analysis parameters.\n *\n * @return An object where each property corresponds to an analysis step and contains the default parameters for that step.\n * See the documentation for each step's `compute` method for more details:\n * \n * - {@linkcode InputsState#compute inputs}\n * - {@linkcode RnaQualityControlState#compute rna_quality_control}\n * - {@linkcode AdtQualityControlState#compute adt_quality_control}\n * - {@linkcode CrisprQualityControlState#compute crispr_quality_control}\n * - {@linkcode CellFiltering#compute cell_filtering}\n * - {@linkcode RnaNormalizationState#compute rna_normalization}\n * - {@linkcode AdtNormalizationState#compute adt_normalization}\n * - {@linkcode CrisprNormalizationState#compute crispr_normalization}\n * - {@linkcode FeatureSelectionState#compute feature_selection}\n * - {@linkcode RnaPcaState#compute rna_pca}\n * - {@linkcode AdtPcaState#compute adt_pca}\n * - {@linkcode CrisprPcaState#compute crispr_pca}\n * - {@linkcode NeighborIndexState#compute neighbor_index}\n * - {@linkcode TsneState#compute tsne}\n * - {@linkcode UmapState#compute umap}\n * - {@linkcode KmeansClusterState#compute kmeans_cluster}\n * - {@linkcode SnnGraphClusterState#compute snn_graph_cluster}\n * - {@linkcode ChooseClusteringState#compute choose_clustering}\n * - {@linkcode CellLabellingState#compute cell_labelling}\n * - {@linkcode FeatureSetEnrichmentState#compute feature_set_enrichment}\n *\n * See also {@linkcode configureBatchCorrection} and {@linkcode configureApproximateNeighbors} to synchronize certain parameter settings across multiple steps.\n */\nexport function analysisDefaults() {\n    var output = {};\n\n    output[inputs.step_name] = inputs.InputsState.defaults();\n    output[fsel.step_name] = fsel.FeatureSelectionState.defaults();\n\n    output[qc.step_name] = qc.RnaQualityControlState.defaults();\n    output[qcadt.step_name] = qcadt.AdtQualityControlState.defaults();\n    output[qccrispr.step_name] = qccrispr.CrisprQualityControlState.defaults();\n    output[filter.step_name] = filter.CellFilteringState.defaults();\n\n    output[norm.step_name] = norm.RnaNormalizationState.defaults();\n    output[normadt.step_name] = normadt.AdtNormalizationState.defaults();\n    output[normcrispr.step_name] = normcrispr.CrisprNormalizationState.defaults();\n\n    output[pca.step_name] = pca.RnaPcaState.defaults();\n    output[pcaadt.step_name] = pcaadt.AdtPcaState.defaults();\n    output[pcacrispr.step_name] = pcacrispr.CrisprPcaState.defaults();\n\n    output[combine.step_name] = combine.CombineEmbeddingsState.defaults();\n    output[correct.step_name] = correct.BatchCorrectionState.defaults();\n\n    output[index.step_name] = index.NeighborIndexState.defaults();\n    output[snngraph.step_name] = snngraph.SnnGraphClusterState.defaults();\n    output[tsne.step_name] = tsne.TsneState.defaults();\n    output[umap.step_name] = umap.UmapState.defaults();\n\n    output[kmeans.step_name] = kmeans.KmeansClusterState.defaults();\n    output[choose.step_name] = choose.ChooseClusteringState.defaults();\n\n    output[markers.step_name] = markers.MarkerDetectionState.defaults();\n    output[custom.step_name] = custom.CustomSelectionsState.defaults();\n\n    output[enrichment.step_name] = enrichment.FeatureSetEnrichmentState.defaults();\n    output[labelling.step_name] = labelling.CellLabellingState.defaults();\n\n    return output;\n}\n\nconst correctible_pca_steps = [pca.step_name, pcaadt.step_name, pcacrispr.step_name];\n\n/**\n * Set the batch correction parameters across multiple steps.\n * This is a convenient helper as the correction process is split across the PCA and batch correction steps.\n * For MNN, we project cells onto rotation vectors computed within each batch in the various PCA steps (e.g., {@linkplain PcaState}) before performing MNN correction in {@linkplain BatchCorrectionState};\n * for linear regression, we need to regress by block in the PCA without any additional correction in {@linkplain BatchCorrectionState};\n * and for no correction, we need to turn off any block handling in the PCA as well as removing any additional correction in {@linkplain BatchCorrectionState}.\n *\n * @param {object} parameters Object containing parameters for all steps, e.g., from {@linkcode analysisDefaults}.\n * @param {string} method Correction method to perform, one of `\"mnn\"`, \"`regress\"` or `\"none\"`.\n * \n * @return `parameters` is modified with appropriate parameters in `batch_correction`, `pca` and `adt_pca`.\n */\nexport function configureBatchCorrection(parameters, method) {\n    let correct_method;\n    let pca_blocker;\n\n    if (method == \"mnn\") {\n        correct_method = method;\n        pca_blocker = \"project\";\n    } else if (method == \"regress\") {\n        correct_method = \"none\";\n        pca_blocker = method;\n    } else if (method == \"none\") {\n        correct_method = method;\n        pca_blocker = method;\n    } else {\n        throw new Error(\"unknown correction method '\" + method + \"'\");\n    }\n\n    parameters[correct.step_name].method = correct_method;\n    for (const x of correctible_pca_steps) {\n        parameters[x].block_method = pca_blocker;\n    }\n\n    return parameters;\n}\n\n/**\n * Guess the `method` value from {@linkcode configureBatchCorrection} based on the parameter object.\n * This effectively consolidates the various correction parameters into a single setting.\n *\n * @param {object} parameters - Object containing parameters for all steps, typically after {@linkcode configureBatchCorrection}.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.strict] - Whether to only report the `method` when the set of parameters modified by {@linkcode configureBatchCorrection} are consistent.\n *\n * @return {?string} One of `\"mnn\"`, `\"regress\"` or `\"none\"`, based on the expected set of modifications from {@linkcode configureBatchCorrection}.\n * If `strict = false` and there is no exact match to the expected set, the most appropriate method is returned;\n * otherwise, if `strict = true`, `null` is returned.\n */\nexport function guessBatchCorrectionConfig(parameters, { strict = false } = {}) {\n    let pca_blockers = new Set(correctible_pca_steps.map(x => parameters[x].block_method));\n\n    let resp;\n    if (parameters[correct.step_name].method == \"mnn\") {\n        resp = \"mnn\";\n        if (strict) {\n            if (pca_blockers.size > 1 || !pca_blockers.has(\"project\")) {\n                resp = null;\n            }\n        }\n    } else {\n        if (pca_blockers.has(\"regress\")) {\n            if (strict && pca_blockers.size > 1) {\n                resp = null;\n            } else {\n                resp = \"regress\";\n            }\n        } else if (pca_blockers.has(\"none\")) {\n            if (strict && pca_blockers.size > 1) {\n                resp = null;\n            } else {\n                resp = \"none\";\n            }\n        } else {\n            // If pca block_methods are set to 'project',\n            // this doesn't really correspond to anything,\n            // but is closest to 'none'.\n            if (strict) {\n                resp = null;\n            } else {\n                resp = \"none\";\n            }\n        }\n    }\n\n    return resp;\n}\n\nconst approximatable_steps = [correct.step_name, combine.step_name, index.step_name];\n\n/**\n * Specify whether approximate neighbor searches should be performed across all affected steps.\n * This is a convenient helper as it is generally unnecessary to switch between exact and approximate searches in different steps.\n * Affected steps are {@linkplain BatchCorrectionState}, {@linkplain CombineEmbeddingsState} and {@linkplain NeighborIndexState}.\n *\n * @param {object} parameters Object containing parameters for all steps, e.g., from {@linkcode analysisDefaults}.\n * @param {boolean} approximate Whether to perform approximate nearest neighbor searces.\n * \n * @return `parameters` is modified with appropriate parameters in relevant steps, e.g., `batch_correction`, `combine_embeddings` and `neighbor_index`.\n */\nexport function configureApproximateNeighbors(parameters, approximate) {\n    for (const step of approximatable_steps) {\n        parameters[step].approximate = approximate;\n    }\n    return parameters;\n}\n\n/**\n * Guess the value of `approximate` from {@linkcode configureApproximateNeighbors} based on the parameter object.\n * This effectively consolidates the various approximation parameters into a single setting.\n *\n * @param {object} parameters - Object containing parameters for all steps, typically after {@linkcode configureApproximateNeighbors}.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.strict] - Whether to only report `approximate` when the set of parameters modified by {@linkcode configureApproximateNeighbors} are consistent.\n *\n * @return {?boolean} Whether or not approximate neighbor search was used.\n * If `strict = false` and there is a mixture of approximate and exact matches, an approximate search is reported;\n * otherwise, if `strict = true`, `null` is returned.\n */\nexport function guessApproximateNeighborsConfig(parameters, { strict = false } = {}) {\n    let approximates = new Set(approximatable_steps.map(x => parameters[x].approximate));\n    if (strict && approximates.size > 1) {\n        return null;\n    } else {\n        return approximates.has(true);\n    }\n}\n","export * from \"./defaults.js\";\nexport * from \"./analysis.js\";\nexport * from \"./serialize.js\";\nexport * from \"./readers/index.js\";\nexport * from \"./dump/index.js\";\n\nexport { setVisualizationAnimate } from \"./steps/utils/viz_parent.js\";\nexport { formatMarkerResults } from \"./steps/utils/markers.js\";\n\n// Need these exports to get their static methods.\nexport { RnaQualityControlState } from \"./steps/rna_quality_control.js\";\nexport { CellLabellingState } from \"./steps/cell_labelling.js\";\nexport { FeatureSetEnrichmentState } from \"./steps/feature_set_enrichment.js\"\n\n// Need these exports for manual construction.\nexport { MarkerDetectionStandalone } from \"./steps/marker_detection.js\";\nexport { CustomSelectionsStandalone } from \"./steps/custom_selections.js\";\nexport { FeatureSetEnrichmentStandalone } from \"./steps/feature_set_enrichment.js\";\nexport { CellLabellingStandalone } from \"./steps/cell_labelling.js\";\n\nimport { RnaQualityControlState } from \"./steps/rna_quality_control.js\";\nimport { CellLabellingState } from \"./steps/cell_labelling.js\";\nimport { FeatureSetEnrichmentState } from \"./steps/feature_set_enrichment.js\";\n\nimport * as scran from \"scran.js\";\nimport * as vizutils from \"./steps/utils/viz_parent.js\";\n\n/**\n * Initialize the backend for computation.\n * This is required prior to running any other **bakana** function.\n *\n * @param {object} [options] - Optional parameters.\n * @param {number} [options.numberOfThreads] - Number of threads used by **scran.js**.\n * @param {boolean} [options.localFile] - Whether to use local file paths for imported modules in **scran.js**.\n * This only needs to be `true` for old Node versions that do not support file URIs.\n * \n * @return A promise that resolves to `null` when initialization is complete.\n */\nexport function initialize({ numberOfThreads = 1, localFile = false } = {}) {\n    let s = scran.initialize({ \n        numberOfThreads: numberOfThreads,\n        localFile: localFile\n    });\n    vizutils.scranOptions.localFile = localFile;\n    return s.then(x => null); \n}\n\n/**\n * Terminate the backend, in particular shutting down all workers.\n * This is typically necessary for a clean shutdown in Node.js applications.\n *\n * @return A promise that resolves to `null` when all workers are terminated.\n */\nexport function terminate() {\n    RnaQualityControlState.flush();\n    CellLabellingState.flush();\n    FeatureSetEnrichmentState.flush();\n    let s = scran.terminate();\n    let w = vizutils.killAllWorkers();\n    return Promise.all([s, w]).then(x => null);\n}\n\n/**\n * Call a **scran.js** function.\n * This allows client applications to operate in the same **scran.js** memory space as **bakana** functions,\n * which is not guaranteed if applications import **scran.js** on their own (e.g., due to name mangling with Webpack).\n *\n * @param {function} fun - A function that accepts the **scran.js** module object and presumably calls some of its functions.\n *\n * @return The return value of `fun`.\n */\nexport function callScran(fun) {\n    return fun(scran);\n}\n","import * as scran from \"scran.js\";\nimport * as jsp from \"jaspagate\";\nimport * as internal from \"./abstract/dump.js\";\n\nfunction toStringType(data, options) {\n    let length = null;\n    if (\"maxStringLength\" in options) {\n        length = options.maxStringLength;\n    }\n    if (length == null) {\n        if (data == null) {\n            throw new Error(\"'maxStringLength' must be supplied if 'data' is null\"); \n        }\n        length = scran.findMaxStringLength(data, null);\n    }\n    return new scran.H5StringType(\"UTF-8\", length);\n}\n\nexport class AlabasterH5Group extends jsp.H5Group {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    writeAttribute(name, type, shape, data, options = {}) {\n        if (type == \"String\") {\n            type = toStringType(data, options);\n        }\n        this.#handle.writeAttribute(name, type, shape, data);\n    }\n\n    open(name) {\n        let out = this.#handle.open(name);\n        if (out instanceof scran.H5Group) {\n            return new AlabasterH5Group(out);\n        } else {\n            return new AlabasterH5DataSet(out);\n        }\n    }\n\n    children() {\n        return this.#handle.children;\n    }\n\n    createGroup(name) {\n        return new AlabasterH5Group(this.#handle.createGroup(name));\n    }\n\n    createDataSet(name, type, shape, options = {}) {\n        if (\"data\" in options) {\n            if (type == \"String\") {\n                type = toStringType(options.data, options);\n            }\n            return new AlabasterH5DataSet(this.#handle.writeDataSet(name, type, shape, options.data));\n        } else {\n            if (type == \"String\") {\n                type = toStringType(null, options);\n            }\n            return new AlabasterH5DataSet(this.#handle.createDataSet(name, type, shape));\n        }\n    }\n\n    close() {}\n}\n\nexport class AlabasterH5DataSet extends jsp.H5DataSet {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    writeAttribute(name, type, shape, data, options = {}) {\n        if (type == \"String\") {\n            type = toStringType(data, options);\n        }\n        this.#handle.writeAttribute(name, type, shape, data);\n    }\n\n    write(x) {\n        this.#handle.write(x);\n    }\n\n    close() {}\n}\n\nexport class AlabasterGlobalsInterface extends jsp.GlobalsInterface {\n    #directory;\n    #files;\n\n    constructor(directory, files) {\n        super();\n        this.#directory = directory;\n        this.#files = files;\n    }\n\n    get(path, options = {}) {\n        if (this.#directory !== null) {\n            const { asBuffer = true } = options;\n            return internal.read(this.#directory, path, asBuffer);\n        } else {\n            return this.#files[path];\n        }\n    }\n\n    clean(localPath) {}\n\n    async write(path, contents) {\n        if (this.#directory !== null) {\n            await internal.write(this.#directory, path, contents);\n        } else {\n            this.#files[path] = contents;\n        }\n    }\n\n    async mkdir(path) {\n        if (this.#directory !== null) {\n            await internal.mkdir(this.#directory, path);\n        }\n    }\n\n    async copy(from, to) {\n        if (this.#directory !== null) {\n            await internal.copy(this.#directory, from, to);\n        } else {\n            this.#files[to] = this.#files[from];\n        }\n    }\n\n    h5create(path) {\n        if (this.#directory !== null) {\n            let actual_path = jsp.joinPath(this.#directory, path);\n            let latest = scran.createNewHdf5File(actual_path);\n            let output = new AlabasterH5Group(latest);\n            output._path = actual_path;\n            return output;\n        } else {\n            let tmppath = scran.chooseTemporaryPath();\n            let latest = scran.createNewHdf5File(tmppath);\n            let output = new AlabasterH5Group(latest);\n            output._path = tmppath;\n            output._intended = path;\n            return output;\n        }\n    }\n\n    h5finish(handle, failed) {\n        if (this.#directory === null) {\n            if (!failed) {\n                this.write(handle._intended, scran.readFile(handle._path));\n            }\n            scran.removeFile(handle._path);\n        }\n    }\n}\n","// Stub file to ensure that something is loaded.\n\nexport function fsexists() {\n    return false;\n}\n\nexport function read(dir, path, asBuffer) {\n    throw new Error(\"read() is not supported in a web context\");\n}\n\nexport function write(dir, path, x) {\n    throw new Error(\"write() is not supported in a web context\");\n}\n\nexport function mkdir(dir, path) {\n    throw new Error(\"mkdir() is not supported in a web context\");\n}\n\nexport function copy(dir, from, to) {\n    throw new Error(\"copy() is not supported in a web context\");\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as iutils from \"../readers/index.js\";\nexport const step_name = \"inputs\";\n\nconst RAW_SUBSET_OVERRIDE = \"raw_subset_indices\";\n\n/**\n * This step handles the loading of all datasets into memory.\n * This wraps various matrix initialization functions in [**scran.js**](https://github.com/kanaverse/scran.js),\n * depending on the format of the supplied datasets.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class InputsState {\n    #parameters;\n    #cache;\n    #abbreviated;\n    #preserve_dataset_cache;\n\n    constructor(parameters = null, cache = null, abbreviated = null) {\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.#abbreviated = (abbreviated === null ? {} : abbreviated);\n        this.#preserve_dataset_cache = false;\n        this.changed = false;\n        return;\n    }\n\n    free() {\n        utils.freeCache(this.#cache.matrix);\n        utils.freeCache(this.#cache.raw_matrix);\n        utils.freeCache(this.#cache.block_ids);\n        utils.freeCache(this.#cache.raw_block_ids);\n        utils.freeCache(this.#cache.multi_block_ids);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    /**\n     * @return {external:MultiMatrix} A {@linkplain external:MultiMatrix MultiMatrix} object containing counts for one or more modalities.\n     * Each modality is represented by a separate count matrix, where each row of the matrix represents a feature of that modality.\n     * All matrices have the same number and ordering of cells in their columns.\n     */\n    fetchCountMatrix() {\n        return this.#cache.matrix;\n    }\n\n    /**\n     * @return {object} Object where each key is the name of a modality and each value is a {@linkplain external:DataFrame DataFrame}.\n     * Each row of the DataFrame corresponds to a feature in that modality \n     * (i.e., a row in the corresponding matrix from {@linkcode InputsState#fetchCountMatrix fetchCountMatrix})\n     * and each column represents a per-feature annotation field.\n     */\n    fetchFeatureAnnotations() {\n        return this.#cache.genes;\n    }\n\n    /**\n     * @return {external:DataFrame} {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * Each row of the DataFrame corresponds to a cell in {@linkcode InputsState#fetchCountMatrix fetchCountMatrix},\n     * and each column represents a per-cell annotation field.\n     *\n     * Note that this considers all cells in the dataset before QC filtering - \n     * see {@linkcode QualityControlState#applyFilter QualityControlState.applyFilter} to obtain a filtered version of each column.\n     */\n    fetchCellAnnotations() {\n        return this.#cache.annotations;\n    }\n\n    /**\n     * @return {?Int32WasmArray} Array of length equal to the number of cells in the dataset,\n     * identifying the block to which each cell is assigned.\n     * Alternatively `null`, if no blocking is performed.\n     */\n    fetchBlock() {\n        return this.#cache.block_ids;\n    }\n\n    /**\n     * @return {?Array} Array of names of the blocks, or `null` if no blocking is performed.\n     */\n    fetchBlockLevels() {\n        return this.#cache.block_levels;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Cloning the parameters to avoid pass-by-reference behavior affecting the\n        // InputsState object. We don't pass the files back here.\n        let output = { ...this.#parameters };\n        output.subset = this.constructor.#cloneSubset(output.subset);\n        return output;\n    }\n\n    fetchDatasets() {\n        return this.#cache.datasets;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to return a copy of the subsets to avoid pass-by-reference behaviors.\n     *\n     * @return {?Int32Array} Array containing the indices to use for direct subsetting -\n     * see {@linkcode InputsState#setDirectSubset setDirectSubset} for more information.\n     * Alternatively `null`, if direct subsetting is not performed.\n     */\n    fetchDirectSubset({ copy = true } = {}) {\n        if (RAW_SUBSET_OVERRIDE in this.#cache) {\n            let candidate = this.#cache[RAW_SUBSET_OVERRIDE];\n            return (copy ? candidate.slice() : candidate);\n        } else {\n            return null;\n        }\n    }\n\n    guessRnaFeatureTypes() {\n        if (!(\"RNA\" in this.#cache.genes)) {\n            return null;\n        }\n\n        if (!(\"inferred_rna_types\" in this.#cache)) {\n            this.#cache.inferred_rna_types = utils.guessFeatureTypes(this.#cache.genes[\"RNA\"]);\n        }\n\n        return this.#cache.inferred_rna_types;\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode InputsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            block_factor: null,\n            subset: null\n        };\n    }\n\n    /**\n     * Allow each {@linkplain Dataset} reader (i.e., the `datasets` in {@linkcode InputsState#compute compute}) to cache any intermediate results during loading.\n     * By default, this is disabled as caching increases memory usage of the analysis without any major runtime improvements to `compute` when the `datasets` do not change.\n     *\n     * Setting `cache = true` is only useful if the instances in `datasets` are to be re-used outside of **bakana**, or if they are to be re-used in `compute()` in different combinations. \n     * In such cases, there may be a runtime improvement that warrants the increase in memory usage.\n     * If caching is used, the user is responsible for releasing cached resources via each instance's `clear()` method once they are no longer needed.\n     *\n     * @param {boolean} cache - Whether to allow {@linkplain Dataset} instances to cache their results.\n     */\n    enableDatasetCache(cache) {\n        this.#preserve_dataset_cache = cache;\n        return;\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} datasets - An object containing data for one or more datasets.\n     * Each property corresponds to a single dataset and its value should satisfy the {@linkplain Dataset} contract.\n     * See the description of the argument of the same name in {@linkcode runAnalysis}.\n     * @param {object} parameters - Parameter object, equivalent to the `inputs` property of the `parameters` in {@linkcode runAnalysis}.\n     * @param {?string} [parameters.block_factor] - Name of the column of the cell annotations specifying the sample of origin for each cell.\n     * This is only used if a single count matrix is supplied.\n     *\n     * If `null`, all cells are assumed to originate from the same sample.\n     *\n     * If any entries of the blocking factor are invalid (i.e., `null`), they are removed from downstream analyses.\n     * @param {?subset} [parameters.subset] - Object describing if any pre-analysis subsetting should be applied.\n     * This should contain `field`, a string specifying a field of the column annotation.\n     *\n     * - For categorical variables, the object should also contain `values`, an array of allowed values for that annotation.\n     *   Cells are only retained if they are associated with any of the allowable values for that annotation field.\n     * - For continuous variables, the object should also contain `ranges`, an array of arrays.\n     *   Each inner array should contain two numbers defining the start and end of a range.\n     *   Ranges should be sorted and non-overlapping (boundaries excepted).\n     *\n     * If `subset` is `null`, no subsetting is performed and all cells are used in the downstream analysis.\n     *\n     * @return The object is updated with the new results.\n     * A promise is returned that resolves once input loading is complete, after which downstream steps can be run.\n     */\n    async compute(datasets, parameters) {\n        parameters = utils.defaultizeParameters(parameters, InputsState.defaults());\n        this.changed = false;\n\n        // Don't bother proceeding with any of the below\n        // if we're operating from a reloaded state.\n        if (datasets !== null) {\n            let tmp_abbreviated = {};\n            for (const [key, val] of Object.entries(datasets)) {\n                tmp_abbreviated[key] = { format: val.constructor.format(), details: val.abbreviate() };\n            }\n\n            if (utils.changedParameters(tmp_abbreviated, this.#abbreviated)) {\n                await load_and_cache(datasets, this.#cache, this.#preserve_dataset_cache);\n                this.#abbreviated = tmp_abbreviated;\n                this.#cache.datasets = { ...datasets }; // making a deep-ish copy to avoid pass-by-reference links.\n                delete this.#cache.inferred_rna_types;\n                this.changed = true;\n            }\n        }\n\n        if (this.changed || this.#parameters.block_factor !== parameters.block_factor) {\n            block_and_cache(parameters.block_factor, this.#cache);\n            this.changed = true;\n        }\n\n        // final condition handles loss of 'matrix' when setDirectSubset() is called.\n        if (this.changed || (!(RAW_SUBSET_OVERRIDE in this.#cache) && utils.changedParameters(parameters.subset, this.#parameters.subset)) || !(\"matrix\" in this.#cache)) { \n            subset_and_cache(parameters.subset, this.#cache);\n            this.changed = true;\n        }\n\n        this.#parameters = parameters;\n        this.#parameters.subset = InputsState.#cloneSubset(this.#parameters.subset);\n        return;\n    }\n\n    /******************************\n     ******** Subsetting **********\n     ******************************/\n\n    static #cloneSubset(subset) {\n        // We use a dedicated cloning function to handle Infs,\n        // as these get converted to nulls by the JSON stringify.\n        if (subset == null) {\n            return subset;\n        }\n\n        let clone = { ...subset };\n        if (\"values\" in clone) {\n            clone.values = clone.values.slice();\n        }\n\n        if (\"ranges\" in clone) {\n            clone.ranges = clone.ranges.map(x => x.slice());\n        }\n\n        return clone;\n    }\n\n    /**\n     * Undo the effect of subsetting on an array of indices.\n     * This works with all subset specifications, e.g., via `parameters.subset` in {@linkcode InputsState#compute compute}, with {@linkcode InputsState#setDirectSubset setDirectSubset},\n     * or even from the implicit subsetting when the factor specified in `parameters.block` contains `null` entries.\n     *\n     * @param {Array|TypedArray} indices - Array of column indices to the subsetted matrix.\n     * Note that this will be modified in-place.\n     *\n     * @return Entries of `indices` are replaced with indices to the pre-subsetted matrix.\n     */\n    undoSubset(indices) {\n        if (\"matrix\" in this.#cache) {\n            let max_index = this.fetchCountMatrix().numberOfColumns();\n            for (const x of indices) {\n                if (x < 0 || x >= max_index) {\n                    throw new Error(\"entries of 'indices' should be less than the number of cells in the dataset\");\n                }\n            }\n        }\n\n        // Setting the subset to null, if the parameter-level subset hasn't\n        // been set yet. This is because we might get indirectly called via\n        // setDirectSubset() before compute() has been run.\n        let subset = null;\n        if (\"subset\" in this.#parameters) {\n            subset = this.#parameters.subset;\n        }\n\n        let keep = harvest_subset_indices(subset, this.#cache);\n        if (keep !== null) {\n            indices.forEach((x, i) => { indices[i] = keep[x] });\n        }\n    }\n\n    #configureIndices(indices, copy, onOriginal) {\n        // scran.js's subset functions will pick up out-of-range indices.\n        utils.checkIndices(indices, null);\n\n        // We make a copy here to take ownership of the underlying memory,\n        // otherwise any edits in the caller would mutate the new InputsState's\n        // indices by reference.\n        if (copy) {\n            indices = indices.slice();\n        }\n\n        if (!onOriginal) {\n            this.undoSubset(indices);\n        }\n\n        return indices;\n    }\n\n    /**\n     * Unlike most of the other methods, `setDirectSubset` can be called on an InputsState before {@linkcode InputsState#compute compute}.\n     * This means that a user can create the state object from {@linkcode createAnalysis},\n     * specify a subset of cells via `setDirectSubset` on the (currently empty) InputsState object in `inputs`,\n     * and then call {@linkcode runAnalysis} to execute an analysis on the desired subset of cells.\n     * \n     * @param {TypedArray|Array} indices - Array containing the indices for the desired subset of cells.\n     * This should be sorted and non-duplicate.\n     * Any existing subset in this object will be overridden by `indices`.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `indices` before storing it inside the returned state object.\n     * If `false`, it is assumed that the caller makes no further use of the passed `indices`.\n     * @param {boolean} [options.onOriginal=false] - Whether `indices` contains indices on the original dataset or on the dataset in `state`.\n     * This distinction is only relevant if the current InputsState object already contains a specified subset.\n     * If `false`, the `indices` are assumed to refer to the already-subsetted dataset that exists in `state`;\n     * if `true`, the `indices` are assumed to refer to the original dataset from which the subset in `state` was created.\n     *\n     * @return The dataset in this InputsState object is subsetted to the desired `indices`.\n     */\n    setDirectSubset(indices, { copy = true, onOriginal = false } = {}) {\n        if (indices !== null) {\n            this.#cache[RAW_SUBSET_OVERRIDE] = this.#configureIndices(indices, copy, onOriginal);\n        } else {\n            delete this.#cache[RAW_SUBSET_OVERRIDE];            \n        }\n\n        // Flag that it needs to be rerun.\n        scran.free(this.#cache.matrix);\n        delete this.#cache.matrix;\n    }\n\n    createDirectSubset(indices, { copy = true, onOriginal = false } = {}) {\n        let new_cache = {};\n        new_cache[RAW_SUBSET_OVERRIDE] = this.#configureIndices(indices, copy, onOriginal);\n\n        // Need to manually copy everything in 'this.#cache' that is set in\n        // load_and_cache or block_and_cache.\n\n        // Making explicit clones to take ownership.\n        new_cache.raw_matrix = this.#cache.raw_matrix.clone();\n        for (const x of [ \"multi_block_ids\", \"raw_block_ids\" ]) {\n            if (x in this.#cache) {\n                if (this.#cache[x] === null) {\n                    new_cache[x] = null;\n                } else {\n                    new_cache[x] = this.#cache[x].clone();\n                }\n            }\n        }\n\n        // These can probably be copied directly, given that they are always\n        // replaced wholesale in the various *_and_cache functions, rather than\n        // being modified in-place.\n        for (const x of [ \"raw_annotations\", \"genes\", \"multi_block_levels\", \"raw_block_levels\" ]) {\n            if (x in this.#cache) {\n                new_cache[x] = this.#cache[x];\n            }\n        }\n\n        subset_and_cache(null, new_cache);\n\n        let new_params = this.fetchParameters();\n        new_params.subset = null;\n\n        return new InputsState(new_params, new_cache, this.#abbreviated);\n    }\n}\n\n/************************************\n ******* Internals - loading ********\n ************************************/\n\nconst known_modalities = [ \"RNA\", \"ADT\", \"CRISPR\" ];\n\nfunction bind_single_modality(modality, loaded) {\n    let output = {};\n\n    try {\n        let gnames = [];\n        let mats = [];\n        for (var i = 0; i < loaded.length; i++) {\n            mats.push(loaded[i].matrix.get(modality));\n\n            let primary_id = loaded[i].primary_ids[modality];\n            if (primary_id == null) {\n                throw new Error(\"modality '\" + modality + \"' lacks a primary identifier for dataset \" + String(i));\n            }\n            gnames.push(primary_id);\n        }\n\n        let merged = scran.cbindWithNames(mats, gnames);\n        output.matrix = merged.matrix;\n\n        // Extracting gene information from the first object. We won't make\n        // any attempt at merging and deduplication across objects.\n        output.features = bioc.SLICE(loaded[0].features[modality], merged.indices);\n\n    } catch (e) {\n        utils.freeCache(output.matrix);\n        throw e;\n    }\n\n    return output;\n}\n\nfunction bind_datasets(names, loaded) {\n    let common_modes = [];\n    for (const mod of known_modalities) {\n        let okay = true;\n        for (const l of loaded) {\n            if (!l.matrix.has(mod)) {\n                okay = false;\n                break;\n            }\n        }\n        if (okay) {\n            common_modes.push(mod);\n        }\n    }\n\n    if (common_modes.length == 0) {\n        throw new Error(\"failed to find common modalities across all datasets\");\n    }\n\n    let blocks;\n    let output = { \n        matrix: new scran.MultiMatrix, \n        features: {}\n    };\n\n    try {\n        for (const k of common_modes) {\n            let current = bind_single_modality(k, loaded);\n            output.matrix.add(k, current.matrix);\n            output.features[k] = current.features;\n        }\n\n        let annos = loaded.map(x => x.cells);\n        output.cells = bioc.flexibleCombineRows(annos);\n\n        // Generating a block vector.\n        let ncells = new Array(loaded.length);\n        loaded.forEach((x, i) => { ncells[i] = x.matrix.numberOfColumns(); });\n        blocks = scran.createBlock(ncells);\n        output.block_ids = blocks;\n        output.block_levels = names;\n\n        let nice_barr = new Array(blocks.length);\n        blocks.forEach((x, i) => { nice_barr[i] = names[x]; })\n        output.cells.$setColumn(\"__batch__\", nice_barr);\n\n    } catch (e) {\n        utils.freeCache(blocks);\n        utils.freeCache(output.matrix);\n        throw e;\n    } \n\n    return output;\n}\n\nfunction rename_dataset(single) {\n    let modalities = single.matrix.available();\n    if (modalities.length == 0) {\n        throw new Error(\"no available modalities\");\n    }\n\n    let output = { \n        matrix: new scran.MultiMatrix, \n        features: {}\n    };\n\n    try {\n        for (const k of known_modalities) {\n            if (!single.matrix.has(k)) {\n                continue;\n            }\n\n            output.matrix.add(k, single.matrix.get(k));\n            output.features[k] = single.features[k];\n        }\n    } catch (e) {\n        scran.free(output.matrix);\n        throw e;\n    }\n\n    output.cells = single.cells;\n    output.block_ids = null;\n    output.block_levels = null;\n\n    return output;\n}\n\nasync function load_datasets(datasets, preserve_dataset_cache) {\n    // Ensure we have a reproducible order; otherwise the batch\n    // order becomes dependent on the JS engine's ordering.\n    let names = Object.keys(datasets);\n    names.sort();\n\n    let loaded = [];\n    try {\n        for (const key of names) {\n            // Too much hassle to convert this into a Promise.all(), because we\n            // need to make sure it gets freed properly on failure.\n            loaded.push(await datasets[key].load({ cache: preserve_dataset_cache }));\n        }\n    } catch (e) {\n        // If any one fails, we free the rest.\n        for (const x of loaded) {\n            scran.free(x.matrix);\n        }\n        throw e;\n    }\n\n    let output;\n    if (names.length == 1) {\n        try {\n            output = rename_dataset(loaded[0]);\n        } catch (e) {\n            scran.free(loaded[0].matrix);\n            throw e;\n        }\n    } else {\n        try {\n            output = bind_datasets(names, loaded);\n        } finally {\n            // No need to hold references to the individual matrices once the\n            // binding is complete, so we release them.\n             for (const x of loaded) {\n                scran.free(x.matrix);\n            }\n        }\n    }\n\n    return output;\n}\n\n/******************************************\n ******* Internals - miscellaneous ********\n ******************************************/\n\nconst invalid_block_id = -1;\n\nfunction harvest_subset_indices(subset, cache) {\n    let keep;\n\n    if (RAW_SUBSET_OVERRIDE in cache) {\n        keep = cache[RAW_SUBSET_OVERRIDE];\n    } else if (subset == null) {\n        keep = null;\n    } else {\n        if (!cache.raw_annotations.hasColumn(subset.field)) {\n            throw new Error(\"failed to find '\" + subset.field + \"' in the column annotations\");\n        }\n\n        let anno = cache.raw_annotations.column(subset.field);\n        keep = [];\n\n        if (\"values\" in subset) {\n            let allowed = new Set(subset.values);\n            anno.forEach((x, i) => {\n                if (allowed.has(x)) {\n                    keep.push(i);\n                }\n            });\n        } else {\n            // Check each entry to see whether it belongs to the range.\n            // This is cheaper than sorting anything, assuming there \n            // aren't that many ranges.\n            anno.forEach((x, i) => {\n                for (const r of subset.ranges) {\n                    if (x >= r[0] && x <= r[1]) {\n                        keep.push(i);\n                        return;\n                    }\n                }\n            });\n        }\n    }\n\n    // Filter out invalid block IDs. Note that this might get called\n    // before compute() is run (via undoSubset), so we need to protect\n    // against the case where the raw_block_ids has not been set yet.\n    if (\"raw_block_ids\" in cache && cache.raw_block_ids !== null) {\n        let bids = cache.raw_block_ids.array();\n\n        let keep2 = [];\n        if (keep !== null) {\n            for (const i of keep) {\n                if (bids[i] !== invalid_block_id) {\n                    keep2.push(i);\n                }\n            }\n        } else {\n            for (var i = 0; i < bids.length; i++) {\n                if (bids[i] !== invalid_block_id) {\n                    keep2.push(i);\n                }\n            }\n        }\n        keep = keep2;\n    }\n\n    return keep;\n}\n\nfunction check_subset_ranges(ranges) { \n    if (ranges.length % 2 !== 0) {\n        throw new Error(\"'ranges' should have two columns in 'subset'\");\n    }\n    for (var i = 1; i < ranges.length; i++) {\n        if (ranges[i] < ranges[i-1]) {\n            throw new Error(\"'ranges' should be sorted in increasing order\");\n        }\n    }\n}\n\n/************************************\n ******* Internals - caching ********\n ************************************/\n\nasync function load_and_cache(new_datasets, cache, preserve_dataset_cache) {\n    utils.freeCache(cache.raw_matrix);\n    utils.freeCache(cache.matrix); // freeing this as well, to release all references and potentially release memory.\n    utils.freeCache(cache.multi_block_ids);\n\n    let res = await load_datasets(new_datasets, preserve_dataset_cache);\n    cache.raw_matrix = res.matrix;\n    cache.raw_annotations = res.cells;\n    cache.multi_block_ids = res.block_ids;\n    cache.multi_block_levels = res.block_levels;\n    cache.genes = res.features;\n}\n\nfunction block_and_cache(block_factor, cache) {\n    utils.freeCache(cache.raw_block_ids);\n\n    let blocks = null;\n    let block_levels = null;\n\n    if (block_factor !== null) {\n        // Single matrix with a batch factor.\n        try {\n            let anno_batch = cache.raw_annotations.column(block_factor);\n            if (anno_batch.length != cache.raw_matrix.numberOfColumns()) {\n                throw new Error(\"length of blocking factor '\" + block_factor + \"' should be equal to the number of cells\"); \n            }\n            let converted = scran.convertToFactor(anno_batch, { action: \"none\", placeholder: invalid_block_id });\n            blocks = converted.ids;\n            block_levels = converted.levels;\n        } catch (e) {\n            utils.freeCache(blocks);\n            throw e;\n        }\n    } else {\n        if (cache.multi_block_ids !== null) { \n            // Creating a view so that freeing of this object is a no-op.\n            // We're downstream of load_and_cache so any freeing of\n            // multi_block_ids would require block_and_cache to rerun\n            // anyway, so we don't have to worry about invalidation.\n            blocks = cache.multi_block_ids.view();\n        } else {\n            blocks = null;\n        }\n        block_levels = cache.multi_block_levels;\n    }\n\n    cache.raw_block_ids = blocks;\n    cache.raw_block_levels = block_levels;\n}\n\nfunction subset_and_cache(subset, cache) {\n    utils.freeCache(cache.matrix);\n    utils.freeCache(cache.block_ids);\n\n    let keep = harvest_subset_indices(subset, cache);\n\n    let new_annotations;\n    let new_matrix;\n    let new_block_ids;\n    let new_block_levels;\n\n    try {\n        if (keep === null) {\n            new_annotations = cache.raw_annotations;\n\n            // Need to make a clone so that it can be freed independently of the original.\n            // This is cheap as only the shared pointer is cloned, not the underlying data.\n            new_matrix = cache.raw_matrix.clone();\n\n            if (cache.raw_block_ids !== null) {\n                // A view also works, given that we're downstream of the generating\n                // process for raw_block_ids and thus our lifetime is always tied to it.\n                new_block_ids = cache.raw_block_ids.view();\n                new_block_levels = cache.raw_block_levels;\n            } else {\n                new_block_ids = null;\n                new_block_levels = null;\n            }\n\n        } else {\n            new_annotations = bioc.SLICE(cache.raw_annotations, keep);\n\n            if (cache.raw_block_ids !== null) {\n                let subsetted = scran.subsetFactor({ ids: cache.raw_block_ids, levels: cache.raw_block_levels }, keep);\n                new_block_ids = subsetted.ids;\n                new_block_levels = subsetted.levels;\n            } else {\n                new_block_ids = null;\n                new_block_levels = null;\n            }\n\n            new_matrix = new scran.MultiMatrix;\n            for (const key of cache.raw_matrix.available()) {\n                let current = cache.raw_matrix.get(key);\n                new_matrix.add(key, scran.subsetColumns(current, keep));\n            }\n        }\n\n    } catch (e) {\n        utils.freeCache(new_matrix);\n        utils.freeCache(new_block_ids);\n        throw e;\n    }\n\n    cache.annotations = new_annotations;\n    cache.block_levels = new_block_levels;\n    cache.block_ids = new_block_ids;\n    cache.matrix = new_matrix;\n}\n\n/**************************\n ******** Linking *********\n **************************/\n\nvar file2link = null;\nvar link2file = null;\n\n/**\n * Specify a function to create links for data files.\n *\n * @param {function} fun - Function that accepts:\n *\n * - `format`: the string containing the format of the dataset that owns the file.\n * - `file`: a {@linkplain SimpleFile} representing the file contents.\n *\n * It should return a string containing some unique identifier to the file.\n * This is most typically used to register the file with some user-specified database system for later retrieval.\n *\n * @return `fun` is set as the global link creator for this step. \n * The _previous_ value of the creator is returned.\n */\nexport function setCreateLink(fun) {\n    let previous = file2link;\n    file2link = fun;\n    return previous;\n}\n\n/**\n * Specify a function to resolve links for data files.\n *\n * @param {function} fun - Function that accepts a string containing a linking idenfier and returns any value that can be used in the {@linkplain SimpleFile} constructor\n * i.e., a Uint8Array, File (on browser) or string containing a file path (on Node.js).\n * This is most typically used to retrieve a file from some user-specified database system.\n *\n * @return `fun` is set as the global resolver for this step. \n * The _previous_ value of the resolver is returned.\n */\nexport function setResolveLink(fun) {\n    let previous = link2file;\n    link2file = fun;\n    return previous;\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\nimport * as jsp from \"jaspagate\";\n\n/**\n * Any class that satisfies the AlabasterProjectNavigator contract, so called as it is intended to \"navigate\" an alabaster-formatted object directory.\n * This should provide the following methods:\n * \n * - `get(path, asBuffer)`, a (possibly async) method that accepts a string `path` containing a relative path to a file inside an object directory. \n *   This should return a string containing a path to the file on the local filesystem, or a Uint8Array containing the contents of the file if no local filesystem exists.\n *   If `asBuffer = true`, a Uint8Array must be returned.\n * - `exists(path)`, a (possibly async) method that accepts a string `path` containing a relative path to a file inside an object directory. \n *   This should return a boolean indicating whether `path` exists in the object directory.\n * - `clean(localPath)`, a (possibly async) method that accepts a string containing a local path returned by `get()`.\n *   It should remove any temporary file that was created by `get()` at `localPath`.\n *   This will not be called if `get()` returns a Uint8Array.\n *\n * @typedef AlabasterProjectNavigator\n */\n\n/****************************\n *** Jaspagate interfaces ***\n ****************************/\n\nclass AlabasterH5Group extends jsp.H5Group {\n    #handle;\n    #flush;\n\n    constructor(handle, flush) {\n        super();\n        this.#handle = handle;\n        this.#flush = flush;\n    }\n\n    attributes() {\n        return this.#handle.attributes;\n    }\n\n    readAttribute(attr) {\n        let ares = this.#handle.readAttribute(attr);\n        return { values: ares.values, shape: ares.shape };\n    }\n\n    children() {\n        return Array.from(Object.keys(this.#handle.children));\n    }\n\n    open(name) {\n        let out = this.#handle.open(name);\n        if (out instanceof scran.H5Group) {\n            return new AlabasterH5Group(out);\n        } else {\n            return new AlabasterH5DataSet(out);\n        }\n    }\n\n    close() {}\n\n    _flush() {\n        this.#flush();\n    }\n}\n\nclass AlabasterH5DataSet extends jsp.H5DataSet {\n    #handle;\n\n    constructor(handle) {\n        super();\n        this.#handle = handle;\n    }\n\n    attributes() {\n        return this.#handle.attributes;\n    }\n\n    readAttribute(attr) {\n        let ares = this.#handle.readAttribute(attr);\n        return { values: ares.values, shape: ares.shape };\n    }\n\n    type() {\n        let type = this.#handle.type;\n        if (type instanceof scran.H5StringType) {\n            return \"String\";\n        } else if (type instanceof scran.H5CompoundType) {\n            return type.members;\n        } else {\n            return type;\n        }\n    }\n\n    shape() {\n        return this.#handle.shape;\n    }\n\n    values() {\n        return this.#handle.values;\n    }\n\n    close() {}\n}\n\nclass AlabasterGlobalsInterface extends jsp.GlobalsInterface {\n    #navigator;\n\n    constructor(navigator) {\n        super();\n        this.#navigator = navigator;\n    }\n\n    get(path, options = {}) {\n        const { asBuffer = false } = options;\n        return this.#navigator.get(path, asBuffer);\n    }\n\n    exists(path) {\n        return this.#navigator.exists(path);\n    }\n\n    clean(localPath) {\n        this.#navigator.clean(localPath); \n    }\n\n    async h5open(path) {\n        let realized = scran.realizeFile(await this.get(path));\n        try {\n            return new AlabasterH5Group(new scran.H5File(realized.path), realized.flush);\n        } catch (e) {\n            realized.flush();\n            throw e;\n        }\n    }\n\n    h5close(handle) {\n        handle._flush();\n    }\n}\n\n/*********************\n *** Assay readers ***\n *********************/\n\nclass MockMatrix {\n    #nrow;\n    #ncol;\n    #path;\n\n    constructor(nrow, ncol, path) {\n        this.#nrow = nrow;\n        this.#ncol = ncol;\n        this.#path = path;\n    }\n\n    _bioconductor_NUMBER_OF_ROWS() {\n        return this.#nrow;\n    }\n\n    _bioconductor_NUMBER_OF_COLUMNS() {\n        return this.#ncol;\n    }\n\n    async realize(globals, forceInteger, forceSparse) {\n        let metadata = await jsp.readObjectFile(this.#path, globals);\n        if (metadata.type == \"delayed_array\") {\n            let contents = await globals.get(jsp.joinPath(this.#path, \"array.h5\"));\n            try {\n                let realized = scran.realizeFile(contents);\n                try {\n                    let handle = new scran.H5File(realized.path);\n                    let output = await extract_delayed(handle.open(\"delayed_array\"), this.#path, globals, forceInteger, forceSparse);\n                    if (output == null) {\n                        throw new Error(\"currently only supporting bakana-generated log-counts for delayed arrays\");\n                    }\n                    return output;\n                } finally {\n                    realized.flush();\n                }\n            } finally {\n                await globals.clean(contents);\n            }\n        } else {\n            return extract_matrix(this.#path, metadata, globals, forceInteger, forceSparse);\n        }\n    }\n}\n\nasync function extract_matrix(path, metadata, globals, forceInteger, forceSparse) {\n    if (metadata.type == \"compressed_sparse_matrix\") {\n        let contents = await globals.get(jsp.joinPath(path, \"matrix.h5\"));\n        try {\n            let realized = scran.realizeFile(contents);\n            try {\n                let fhandle = new scran.H5File(realized.path);\n                const name = \"compressed_sparse_matrix\";\n\n                let dhandle = fhandle.open(name);\n                const shape = dhandle.open(\"shape\").values; \n                const layout = dhandle.readAttribute(\"layout\").values[0];\n\n                let out = scran.initializeSparseMatrixFromHdf5Group(realized.path, name, shape[0], shape[1], (layout == \"CSR\"), { forceInteger });\n                return out;\n            } finally {\n                realized.flush();\n            }\n        } finally {\n            await globals.clean(contents);\n        }\n\n    } else if (metadata.type == \"dense_array\") {\n        let contents = await globals.get(jsp.joinPath(path, \"array.h5\"));\n        try {\n            let realized = scran.realizeFile(contents);\n            try {\n                let fhandle = new scran.H5File(realized.path);\n                const name = \"dense_array\";\n                let dhandle = fhandle.open(name);\n                let transposed = false;\n                if (dhandle.attributes.indexOf(\"transposed\") >= 0) {\n                    let trans_info = dhandle.readAttribute(\"transposed\");\n                    transposed = (trans_info.values[0] != 0);\n                }\n\n                return scran.initializeMatrixFromHdf5Dataset(realized.path, name + \"/data\", { transposed, forceInteger, forceSparse });\n            } finally {\n                realized.flush();\n            }\n        } finally {\n            await globals.clean(contents);\n        }\n\n    } else {\n        throw new Error(\"unknown matrix type '\" + metadata.type + \"'\");\n    }\n}\n\nasync function extract_delayed(handle, path, globals, forceInteger, forceSparse) {\n    const dtype = handle.readAttribute(\"delayed_type\").values[0];\n    if (dtype === \"operation\") {\n        let optype = handle.readAttribute(\"delayed_operation\").values[0];\n\n        if (optype === \"unary arithmetic\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n\n            const dhandle = handle.open(\"value\");\n            let arg = dhandle.values;\n            let along = \"row\";\n            if (dhandle.shape.length == 0) {\n                arg = arg[0];\n            } else {\n                along = (handle.open(\"along\").values[0] === 0 ? \"row\" : \"column\");\n            }\n\n            return scran.delayedArithmetic(\n                seed,\n                handle.open(\"method\").values[0],\n                arg,\n                {\n                    right: handle.open(\"side\").values[0] === \"right\",\n                    along: along,\n                    inPlace: true\n                }\n            );\n\n        } else if (optype === \"unary math\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const meth = handle.open(\"method\").values[0];\n            let base = null;\n            if (meth == \"log\") {\n                if (\"base\" in handle.children) {\n                    base = handle.open(\"base\").values[0];\n                }\n            }\n            return scran.delayedMath(\n                seed,\n                meth,\n                {\n                    logBase: base,\n                    inPlace: true\n                }\n            );\n\n        } else if (optype == \"transpose\") {\n            const seed = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const perm = handle.open(\"permutation\").values;\n            if (perm[0] == 1 && perm[1] == 0) {\n                return scran.transpose(seed, { inPlace: true });\n            } else if (perm[0] == 0 && perm[1] == 1) {\n                return seed;\n            } else {\n                throw new Error(\"invalid permutation for transposition operation at '\" + path + \"'\");\n            }\n\n        } else if (optype == \"subset\") {\n            let mat = await extract_delayed(handle.open(\"seed\"), path, globals, forceInteger, forceSparse)\n            const ihandle = handle.open(\"index\");\n            if (\"0\" in ihandle.children) {\n                mat = scran.subsetRows(mat, ihandle.open(\"0\").values, { inPlace: true });\n            }\n            if (\"1\" in ihandle.children) {\n                mat = scran.subsetColumns(mat, ihandle.open(\"1\").values, { inPlace: true });\n            }\n            return mat;\n\n        } else if (optype == \"combine\") {\n            const shandle = handle.open(\"seeds\");\n            let seeds = [];\n            try {\n                const nchildren = Object.keys(shandle.childen).length;\n                for (var c = 0; c < nchildren; c++) {\n                    seeds.push(await extract_delayed(shandle.open(String(c)), path, globals, forceInteger, forceSparse));\n                }\n                if (handle.open(\"along\").values[0] == 0) {\n                    return scran.rbind(seeds);\n                } else {\n                    return scran.cbind(seeds);\n                }\n            } finally {\n                for (const s of seeds) {\n                    scran.free(s);\n                }\n            }\n\n        } else {\n            throw new Error(\"unsupported delayed operation '\" + optype + \"'\");\n        }\n\n    } else if (dtype === \"array\") {\n        let atype = handle.readAttribute(\"delayed_array\").values[0];\n\n        if (atype === \"custom takane seed array\") {\n            let index = handle.open(\"index\").values[0];\n            let seed_path = jsp.joinPath(path, \"seeds\", String(index));\n            let seed_metadata = await jsp.readObjectFile(seed_path, globals);\n            let mat;\n            let output;\n            try {\n                return await extract_matrix(seed_path, seed_metadata, globals, forceInteger, forceSparse); \n            } finally {\n                scran.free(mat);\n            }\n\n        } else if (atype == \"dense array\") {\n            let is_native = handle.open(\"native\").values[0] != 0;\n            return scran.initializeMatrixFromHdf5Dataset(handle.file, handle.name + \"/data\", { transposed: !is_native, forceInteger, forceSparse });\n\n        } else if (atype == \"sparse matrix\") {\n            const shape = handle.open(\"shape\").values; \n            const is_csr = handle.open(\"by_column\").values[0] == 0;\n            return scran.initializeSparseMatrixFromHdf5Group(handle.file, handle.name, shape[0], shape[1], is_csr, { forceInteger });\n\n        } else {\n            throw new Error(\"unsupported delayed array '\" + atype + \"'\");\n        }\n\n    } else {\n        throw new Error(\"unsupported delayed type '\" + dtype + \"'\");\n    }\n\n    return output;\n}\n\nfunction readMockAssay(nrow, ncol, path, metadata, globals, options) {\n    return new MockMatrix(nrow, ncol, path);\n}\n\nfunction readMockReducedDimension(ncol, path, metadata, globals, options) {\n    return new MockMatrix(ncol, 2, path);\n}\n\n/*************************\n *** Utility functions ***\n *************************/\n\nfunction apply_over_experiments(se, fun) {\n    let main_experiment_name = \"\";\n    let is_sce = se instanceof bioc.SingleCellExperiment;\n    if (is_sce && se.mainExperimentName() !== null) {\n        main_experiment_name = se.mainExperimentName();\n    }\n\n    let output = {};\n    output[main_experiment_name] = fun(se);\n    if (is_sce) {\n        for (const alt of se.alternativeExperimentNames()) {\n            if (alt !== main_experiment_name) { // do not clobber the main experiment!\n                output[alt] = fun(se.alternativeExperiment(alt));\n            }\n        }\n    }\n    return output;\n}\n\nfunction extract_all_features(se) {\n    return apply_over_experiments(se, x => x.rowData());\n}\n\nfunction extract_all_assay_names(se) {\n    return apply_over_experiments(se, x => x.assayNames());\n}\n\nfunction simplify_List_columns(df) { // avoid the hassle of dealing with List compatibility problems in the rest of bakana.\n    for (const k of df.columnNames()) {\n        let col = df.column(k);\n        if (col instanceof bioc.List) {\n            df.setColumn(k, col.toArray(), { inPlace: true });\n        }\n    }\n    return null;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment in the **alabaster** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain AlabasterProjectNavigator} class.\n * Subclasses should define `abbreviate()` and `serialize()` methods, as well as the static `format()` and `unserialize()` methods - \n * see the [Dataset contract](https://github.com/LTLA/bakana/blob/master/docs/related/custom_readers.md) for more details.\n */\nexport class AbstractAlabasterDataset {\n    #navigator;\n    #raw_se;\n    #options;\n\n    /**\n     * @param {AlabasterProjectNavigator} navigator - A navigator object that describes how to obtain files from the alabaster-formatted object directory.\n     */\n    constructor(navigator) {\n        this.#navigator = navigator;\n        this.#options = AbstractAlabasterDataset.defaults();\n        this.#raw_se = null;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractAlabasterDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractAlabasterDataset#load load} (but not {@linkcode AbstractAlabasterDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?string} [options.rnaExperiment] - Name of the main/alternative experiment containing gene expression data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no RNA data is assumed to be present.\n     * @param {?string} [options.adtExperiment] - Name of the main/alternative experiment containing ADT data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no ADTs are assumed to be present.\n     * @param {?string} [options.crisprExperiment] - Name of the main/alternative experiment containing CRISPR guide data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no CRISPR guides are assumed to be present.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractAlabasterDataset#load load} or {@linkcode AbstractAlabasterDataset#summary summary}.\n     */\n    clear() {\n        this.#raw_se = null;\n    }\n\n    #create_globals() { \n        return new AlabasterGlobalsInterface(this.#navigator);\n    }\n\n    async #populate() {\n        if (this.#raw_se === null) {\n            this.#raw_se = await jsp.readObject(\n                \".\",\n                null, \n                this.#create_globals(),\n                {\n                    DataFrame_readNested: false,\n                    DataFrame_readMetadata: false,\n                    SummarizedExperiment_readAssay: readMockAssay,\n                    SummarizedExperiment_readMetadata: false,\n                    SingleCellExperiment_readReducedDimension: false\n                }\n            );\n            simplify_List_columns(this.#raw_se.columnData());\n            apply_over_experiments(this.#raw_se, y => simplify_List_columns(y.rowData()));\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async\n     */\n    async summary({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = {\n            modality_features: extract_all_features(this.#raw_se),\n            cells: this.#raw_se.columnData(),\n            modality_assay_names: extract_all_assay_names(this.#raw_se)\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode AbstractAlabasterDataset#load load} but the order of values may be different.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned object.\n     * @async\n     */\n    async previewPrimaryIds({ cache = false } = {}) {\n        await this.#populate();\n\n        let fmapping = {\n            RNA: this.#options.rnaExperiment, \n            ADT: this.#options.adtExperiment, \n            CRISPR: this.#options.crisprExperiment \n        };\n\n        let raw_features = extract_all_features(this.#raw_se);\n        let altnames = [];\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            altnames = this.#raw_se.alternativeExperimentNames();\n        }\n        let preview = futils.extractRemappedPrimaryIds(raw_features, altnames, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode AbstractAlabasterDataset#defaults defaults} or with {@linkcode AbstractAlabasterDataset#setOptions setOptions}.\n     *\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_se.columnData()\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        let experiments_by_name = apply_over_experiments(this.#raw_se, x => x);\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null || !(v.exp in experiments_by_name)) {\n                    continue;\n                }\n                let chosen_se = experiments_by_name[v.exp];\n                let loaded = await chosen_se.assay(v.assay).realize(this.#create_globals(), /* forceInteger = */ true, /* forceSparse = */ true);\n                output.matrix.add(k, loaded);\n                output.features[k] = chosen_se.rowData();\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) in the **ArtifactDB** format.\n * This is intended as a virtual base class; applications should define subclasses that are tied to a specific {@linkplain AlabasterProjectNavigator} class.\n */\nexport class AbstractAlabasterResult {\n    #navigator;\n    #raw_se;\n    #options;\n\n    /**\n     * @param {AlabasterNavigator} navigator - A navigator object that describes how to obtain files from an alabaster-formatted object directory.\n     */\n    constructor(navigator) {\n        this.#navigator = navigator;\n        this.#options = AbstractAlabasterResult.defaults();\n        this.#raw_se = null;\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractAlabasterResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractAlabasterResult#load load} (but not {@linkcode AbstractAlabasterResult#summary summary}.\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode AbstractAlabasterResult#load load} or {@linkcode AbstractAlabasterResult#summary summary}.\n     */\n    clear() {\n        this.#raw_se = null;\n    }\n\n    #create_globals() { \n        return new AlabasterGlobalsInterface(this.#navigator);\n    }\n\n    async #populate() {\n        if (this.#raw_se === null) {\n            this.#raw_se = await jsp.readObject(\n                \".\",\n                null, \n                this.#create_globals(),\n                {\n                    DataFrame_readNested: false,\n                    DataFrame_readMetadata: false,\n                    SummarizedExperiment_readAssay: readMockAssay,\n                    SummarizedExperiment_readMetadata: false,\n                    SingleCellExperiment_readReducedDimension: readMockReducedDimension\n                }\n            );\n            simplify_List_columns(this.#raw_se.columnData());\n            apply_over_experiments(this.#raw_se, y => simplify_List_columns(y.rowData()));\n        }\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractAlabasterResult#load load}.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async \n     */\n    async summary({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = {\n            modality_features: extract_all_features(this.#raw_se),\n            cells: this.#raw_se.columnData(),\n            modality_assay_names: extract_all_assay_names(this.#raw_se),\n            reduced_dimension_names: []\n        };\n\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            output.reduced_dimension_names = this.#raw_se.reducedDimensionNames();\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode AbstractAlabasterResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode AbstractAlabasterResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     * @async\n     */\n    async load({ cache = false } = {}) {\n        await this.#populate();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_se.columnData(),\n            reduced_dimensions: {}\n        };\n\n        if (this.#raw_se instanceof bioc.SingleCellExperiment) {\n            let chosen_rd = this.#options.reducedDimensionNames;\n            if (chosen_rd === null) {\n                chosen_rd = this.#raw_se.reducedDimensionNames();\n            }\n            for (const k of chosen_rd) {\n                let current = await this.#raw_se.reducedDimension(k).realize(this.#create_globals(), /* forceInteger = */ false, /* forceSparse = */ false);\n                try {\n                    let collected = [];\n                    let ncol = current.numberOfColumns();\n                    for (var c = 0; c < ncol; c++) {\n                        collected.push(current.column(c));\n                    }\n                    output.reduced_dimensions[k] = collected;\n                } finally {\n                    scran.free(current);\n                }\n            }\n        }\n\n        // Now fetching the assay matrix.\n        const experiments_by_name = apply_over_experiments(this.#raw_se, x => x);\n        try {\n            for (const [name, chosen_se] of Object.entries(experiments_by_name)) {\n                let curassay = this.#options.primaryAssay;\n                if (typeof curassay == \"object\") {\n                    if (name in curassay) {\n                        curassay = curassay[name];\n                    } else {\n                        continue;\n                    }\n                }\n\n                let curnormalized = this.#options.isPrimaryNormalized;\n                if (typeof curnormalized == \"object\") {\n                    if (name in curnormalized) {\n                        curnormalized = curnormalized[name];\n                    } else {\n                        curnormalized = true;\n                    }\n                }\n\n                let loaded = await chosen_se.assay(curassay).realize(this.#create_globals(), /* forceInteger= */ !curnormalized, /* forceSparse = */ true);\n                output.matrix.add(name, loaded);\n\n                if (!curnormalized) {\n                    let normed = scran.normalizeCounts(loaded, { allowZeros: true });\n                    output.matrix.add(name, normed);\n                }\n\n                output.features[name] = chosen_se.rowData();\n            }\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./utils/general.js\";\nimport * as markers from \"./utils/markers.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as rna_norm_module from \"./rna_normalization.js\";\nimport * as adt_norm_module from \"./adt_normalization.js\";\nimport * as crispr_norm_module from \"./crispr_normalization.js\";\n\nexport const step_name = \"custom_selections\";\n\n/************************\n ****** Internals *******\n ************************/\n\nclass SelectionManager {\n    constructor(selections = null, cache = null) {\n        this._selections = (selections == null ? {} : selections);\n        this._cache = (cache == null ? { results: {} } : cache);\n    }\n\n    #liberate(i) {\n        for (const [k, v] of Object.entries(this._cache.results[i].raw)) {\n            v.free();                                                \n        }\n    }\n\n    free() {\n        utils.freeCache(this._cache.buffer);\n        delete this._cache.buffer;\n\n        for (const k of Object.keys(this._cache.results)) {\n            this.#liberate(k);\n        }\n        this._cache.results = {};        \n\n        markers.freeVersusResults(this._cache.versus);\n        delete this._cache.versus;\n    }\n\n    addSelection(id, selection, to_use, matfun, block, copy, lfc_threshold, compute_auc) {\n        let mat = matfun(to_use[0]);\n        let ncells = mat.numberOfColumns();\n        utils.checkIndices(selection, ncells);\n\n        // Assumes that we have at least one cell in and outside the selection!\n        var buffer = utils.allocateCachedArray(ncells, \"Int32Array\", this._cache);\n        buffer.fill(0);\n        var tmp = buffer.array();\n        selection.forEach(element => { tmp[element] = 1; });\n\n        let res = {};\n        for (const k of to_use) {\n            let mat = matfun(k);\n            res[k] = scran.scoreMarkers(mat, buffer, { block: block, threshold: lfc_threshold, computeAuc: compute_auc }); \n        }\n              \n        // Removing previous results, if there were any.\n        if (id in this._cache.results) {\n            this.#liberate(id);\n        }\n      \n        this._cache.results[id] = { \"raw\": res };\n\n        // making a copy to take ownership.\n        if (copy) {\n            selection = selection.slice();\n        }\n        this._selections[id] = selection;\n        return;\n    }\n\n    removeSelection(id) {\n        this.#liberate(id);\n        delete this._cache.results[id];\n        delete this._selections[id];\n        return;\n    }\n\n    fetchResults(id) {\n        return this._cache.results[id].raw;\n    }\n\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        let raw = this._selections[id];\n        if (copy) {\n            raw = raw.slice();\n        }\n        return raw;\n    }\n\n    fetchSelections({ copy = true, force = null } = {}) {\n        let replacement = {};\n\n        for (const [k, v] of Object.entries(this._selections)) {\n            let store = v;\n            let needs_copy = copy;\n\n            if (force !== null) {\n                if (force == \"Array\") {\n                    if (!(v instanceof Array)) {\n                        store = Array.from(v);\n                        needs_copy = false;\n                    }\n                } else if (force == \"Int32Array\") {\n                    if (!(v instanceof Int32Array)) {\n                        store = new Int32Array(v);\n                        needs_copy = false;\n                    }\n                }\n            } \n\n            if (needs_copy) {\n                store = store.slice();\n            }\n            replacement[k] = store;\n        }\n        return replacement;        \n    }\n\n    computeVersus(left, right, to_use, matfun, block, lfc_threshold, compute_auc) {\n        if (!(\"versus\" in this._cache)) {\n            this._cache[\"versus\"] = {};\n        }\n        let cache = this._cache.versus;\n\n        let cache_info = markers.locateVersusCache(left, right, cache);\n        let left_index = (cache_info.left_small ? 0 : 1);\n        let right_index = (cache_info.left_small ? 1 : 0);\n\n        if (cache_info.run) {\n            // No need to free this afterwards; we don't own the normalized matrices anyway.\n            let matrices = new scran.MultiMatrix;\n            for (const modality of to_use) {\n                matrices.add(modality, matfun(modality));\n            }\n\n            let selections = this._selections;\n            if (!(left in selections && right in selections)) {\n                throw new Error(\"invalid selection ID requested in versus mode\");\n            }\n\n            let leftsel = selections[left];\n            let rightsel = selections[right];\n            if (leftsel.length == 0 || rightsel.length == 0) {\n                throw new Error(\"non-zero entries should be present for both requested selections in versus mode\");\n            }\n\n            let triplets = [];\n            leftsel.forEach(x => {\n                triplets.push({ \"index\": x, \"cluster\": left_index });\n            });\n            rightsel.forEach(x => {\n                triplets.push({ \"index\": x, \"cluster\": right_index });\n            });\n\n            triplets.sort((a, b) => a.index - b.index);\n            let keep = triplets.map(x => x.index);\n            let new_clusters = triplets.map(x => x.cluster);\n            markers.computeVersusResults(matrices, new_clusters, block, keep, cache_info.cached, lfc_threshold, compute_auc);\n        }\n\n        return { \n            results: cache_info.cached,\n            left: left_index,\n            right: right_index\n        };\n    }\n}\n\n/********************\n ****** State *******\n ********************/\n\n/**\n * Applications can perform marker detection on custom selections of cells.\n * This allows users to dynamically select cells on a UI and quickly obtain a list of distinguishing markers for that selection.\n * This wraps the [`scoreMarkers`](https://kanaverse.github.io/scran.js/global.html#scoreMarkers) function \n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * Users should not construct these instances manually; instead, they are automatically assembled by {@linkcode createAnalysis}.\n * Similarly, users should not directly call the {@linkcode CustomSelectionsCore#compute compute} method, which is instead invoked by {@linkcode runAnalysis}.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CustomSelectionsState {\n    #filter;\n    #norm_states;\n\n    #manager;\n    #parameters;\n\n    constructor(filter, norm_states, parameters = null, cache = null) {\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(norm_states.RNA instanceof rna_norm_module.RnaNormalizationState)) {\n            throw new Error(\"'norm_states.RNA' should be an RnaNormalizationState object\");\n        }\n        if (!(norm_states.ADT instanceof adt_norm_module.AdtNormalizationState)) {\n            throw new Error(\"'norm_states.ADT' should be an AdtNormalizationState object\");\n        }\n        if (!(norm_states.CRISPR instanceof crispr_norm_module.CrisprNormalizationState)) {\n            throw new Error(\"'norm_states.CRISPR' should be an CrisprNormalizationState object\");\n        }\n        this.#norm_states = norm_states;\n\n        let selections = null;\n        if (parameters !== null && \"selections\" in parameters) {\n            selections = parameters.selections;\n        }\n\n        this.#manager = new SelectionManager(selections, cache);\n        this.#parameters = {};\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        this.#manager.free();\n        return;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return {\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        };\n    }\n\n    /**\n     * Add a custom selection and compute its markers.\n     * It is assumed that {@linkcode runAnalysis} was already run on this instance before calling this method.\n     *\n     * @param {string} id A unique identifier for the new custom selection.\n     * @param {Array|TypedArray} selection The indices of the cells in the selection.\n     * Indices should refer to positions of cells in the QC-filtered matrix, not the original matrix.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before storing it inside this object.\n     * If `false`, it is assumed that the caller makes no further modifications to the passed `selection`.\n     *\n     * @return The custom selection is added to the state and calculation of its markers is performed.\n     * Nothing is returned.\n     */\n    addSelection(id, selection, { copy = true } = {}) {\n        this.#addSelection(id, selection, copy, this.#parameters.lfc_threshold, this.#parameters.compute_auc);\n    }\n\n    #addSelection(id, selection, copy, lfc_threshold, compute_auc) {\n        let to_use = utils.findValidUpstreamStates(this.#norm_states);\n        this.#manager.addSelection(\n            id, \n            selection, \n            to_use, \n            modality => this.#norm_states[modality].fetchNormalizedMatrix(),\n            this.#filter.fetchFilteredBlock(),\n            copy,\n            lfc_threshold,\n            compute_auc\n        );\n        return;\n    }\n\n    /**\n     * Remove a custom selection and its results from the state.\n     *\n     * @param {string} id - An identifier for the selection to be removed.\n     *\n     * @return The specified selection and its results are removed from the state.\n     * Nothing is returned.\n     */\n    removeSelection(id) {\n        this.#manager.removeSelection(id);\n        return;\n    }\n\n    /**\n     * @param {string} id - An identifier for the desired selection.\n     *\n     * @return {object} Object containing the markers for the desired selection.\n     * Each key is a modality name while each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object,\n     * containing the marker detection results across all features of the corresponding modality.\n     * The set of cells in the selection is denoted as group 1, while all cells outside of the selection are denoted as group 0.\n     */\n    fetchResults(id) {\n        return this.#manager.fetchResults(id);\n    }\n\n    /**\n     * Retrieve the indices for a selection of interest.\n     *\n     * @param {string} id - The identifier for the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     *\n     * @return {Array|TypedArray} Array of indices in the requested selection.\n     * Note that indices are relative to the filtered matrix - \n     * use {@linkcode CellFilteringState#undoFiltering CellFilteringState.undoFiltering} to convert them to indices on the original dataset.\n     */\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        return this.#manager.fetchSelectionIndices(id, { copy });\n    }\n\n    /**\n     * Retrieve indices for all selections.\n     *\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     * @param {?string} [force=null] - Whether to force each `selection` to be an `\"Array\"` or \"`Int32Array\"`.\n     * If `null`, the existing type of each selection is used.\n     *\n     * @return {object} Object where the keys are the selection names and the values are arrays of indices for each selection.\n     * Each array is a copy and can be modified without affecting the CustomSelectionsState.\n     * See {@linkcode CustomSelectionsState#fetchSelectionIndices fetchSelectionIndices} for more details on the interpretation of the indices.\n     */\n    fetchSelections({ copy = true, force = null } = {}) {\n        return this.#manager.fetchSelections({ copy, force });\n    }\n\n    /**\n     * @param {object} parameters - Parameter object, equivalent to the `custom_selections` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {number} [parameters.lfc_threshold] - Log-fold change threshold to use when computing the Cohen's d and AUC for each pairwise comparison.\n     * @param {boolean} [parameters.compute_auc] - Whether to compute the AUCs.\n     * Setting this to `false` will skip AUC calculations and improve speed and memory efficiency.\n     *\n     * @return The state is updated by removing stale selections if the QC filter was altered.\n     */\n    compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CustomSelectionsState.defaults());\n        this.changed = false;\n\n        /* If the QC filter was re-run, all of the selections are invalidated as\n         * the identity of the indices may have changed.\n         */\n        if (this.#filter.changed) {\n            this.#manager.free();\n            this.#manager = new SelectionManager;\n            this.changed = true;\n        }\n\n        /* If the parameters changed, we recompute all the per-selection markers.\n         * Technically we would need to re-run detection on the existing selections\n         * if the normalization changed but the QC was the same. In practice, this\n         * never happens, so we'll deal with it later.\n         */\n        if (parameters.lfc_threshold !== this.#parameters.lfc_threshold || parameters.compute_auc != this.#parameters.compute_auc) {\n            for (const [key, value] of Object.entries(this.#manager._selections)) {\n                this.#addSelection(key, value, false, parameters.lfc_threshold, parameters.compute_auc);\n            }\n            this.#parameters.lfc_threshold = parameters.lfc_threshold;\n            this.#parameters.compute_auc = parameters.compute_auc;\n            this.changed = true;\n        }\n\n        return;\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CustomSelectionsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two selections for more detailed examination of the differences between them.\n     *\n     * @param {string} left - Identifier of one selection in which to find upregulated markers.\n     * @param {string} right - Identifier of another selection to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` selection are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `right` selection are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        let to_use = utils.findValidUpstreamStates(this.#norm_states);\n        return this.#manager.computeVersus(\n            left, \n            right, \n            to_use,\n            modality => this.#norm_states[modality].fetchNormalizedMatrix(),\n            this.#filter.fetchFilteredBlock(),\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n    }\n}\n\n/*************************\n ****** Standalone *******\n *************************/\n\n/**\n * Standalone version of {@linkplain CustomSelectionsState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own normalized matrices and blocking factor to compute the various marker statistics for each custom selection.\n * Users are also responsible for ensuring that the lifetime of the supplied objects exceeds that of the constructed CustomSelectionsStandalone instance,\n * i.e., the Wasm-related `free()` methods are not called while the MarkerDetectionStandalone instance is still in operation.\n */\nexport class CustomSelectionsStandalone {\n    #normalized;\n    #block;\n    #block_levels;\n\n    #manager;\n    #parameters;\n\n    #missing_map;\n\n    /**\n     * @param {external:MultiMatrix} normalized - A {@linkplain external:MultiMatrix MultiMatrix} of log-normalized values for multiple modalities.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in any value of `normalized`, containing the block assignments for each column.\n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(normalized, { block = null } = {}) {\n        let N = null;\n        for (const k of normalized.available()) {\n            let alt = normalized.get(k).numberOfColumns();\n            if (N != null) {\n                if (alt != N) {\n                    throw new Error(\"all matrices in 'normalized' should have the same number of columns as the length of 'groups'\");\n                }\n            } else {\n                N = alt;\n            }\n        }\n\n        this.#block = null;\n        this.#block_levels = null;\n        this.#missing_map = null;\n\n        if (block !== null) {\n            if (block.length != N) {\n                throw new Error(\"'block' should have the same length as the number of columns in each entry of 'normalized'\");\n            }\n\n            let dump = utils.subsetInvalidFactors([ block ]);\n            if (dump.retain !== null) {\n                let revmap = new Int32Array(N);\n                revmap.fill(-1);\n                dump.retain.forEach((y, i) => { revmap[y] = i; });\n                this.#missing_map = { to: revmap, from: dump.retain };\n\n                let new_matrices = new scran.MultiMatrix;\n                let temp = scran.createInt32WasmArray(dump.retain.length);\n                try {\n                    temp.set(dump.retain);\n                    for (const k of normalized.available()) {\n                        new_matrices.add(k, scran.subsetColumns(normalized.get(k), temp))\n                    }\n                } catch (e) {\n                    scran.free(new_matrices);\n                    throw e;\n                } finally {\n                    scran.free(temp);\n                }\n\n                this.#normalized = new_matrices;\n            } else {\n                this.#normalized = normalized.clone();\n            }\n\n            this.#block = dump.arrays[0].ids;\n            this.#block_levels = dump.arrays[0].levels;\n        } else {\n            this.#normalized = normalized.clone();\n        }\n\n        this.#manager = new SelectionManager;\n        this.#parameters = CustomSelectionsState.defaults();\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#normalized);\n        scran.free(this.#block);\n        this.#manager.free();\n        return;\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return {\n            lfc_threshold: this.#parameters.lfc_threshold,\n            compute_auc: this.#parameters.compute_auc\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to copy the return value on output.\n     * Set to `false` for greater efficiency in strictly read-only applications.\n     *\n     * @return {Array} Array of levels for the blocking factor.\n     * Block indices in the {@linkplain external:ScoreMarkersResults ScoreMarkersResults} instances returned by {@linkcode fetchResults} can be cross-referenced to this array.\n     */\n    fetchBlockLevels({ copy = true } = {}) {\n        let ret = this.#block_levels;\n        return (copy ? ret.slice() : ret);\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#normalized;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CustomSelectionsState#compute compute} for details.\n     */\n    static defaults() {\n        return {\n            lfc_threshold: 0,\n            compute_auc: true\n        };\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode CustomSelectionsStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see the argument of the same name in {@linkcode CustomSelectionsState#compute CustomSelectionsState.compute} for more details.\n     *\n     * @return The state is updated with the new parameters.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CustomSelectionsStandalone.defaults());\n        if (this.#parameters.lfc_threshold !== parameters.lfc_threshold || \n            this.#parameters.compute_auc !== parameters.compute_auc)\n        {\n            this.#manager.free();\n        }\n        this.#parameters = parameters;\n        return;\n    }\n\n    /**\n     * Add a custom selection and compute its markers.\n     * Users should run {@linkcode CustomSelectionsCore#compute compute} at least once before calling this function.\n     *\n     * @param {string} id - A unique identifier for the new custom selection.\n     * @param {Array|TypedArray} selection - The indices of the cells in the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before storing it inside this object.\n     * If `false`, it is assumed that the caller makes no further modifications to the passed `selection`.\n     *\n     * @return The custom selection is added to the state and calculation of its markers is performed.\n     * Nothing is returned.\n     */\n    addSelection(id, selection, { copy = true } = {}) {\n        let selection_internal = selection;\n\n        // Removing the invalid observations.\n        if (this.#missing_map !== null) { \n            let collected = [];\n            let revmap = this.#missing_map.to;\n            for (const i of selection) {\n                let j = revmap[i];\n                if (j >= 0) {\n                    collected.push(j);\n                }\n            }\n            selection_internal = collected;\n        }\n\n        this.#manager.addSelection(\n            id, \n            selection_internal,\n            this.#normalized.available(),\n            modality => this.#normalized.get(modality),\n            this.#block,\n            copy,\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n\n        return;\n    }\n\n    /**\n     * Remove a custom selection and its results from the state.\n     *\n     * @param {string} id - An identifier for the selection to be removed.\n     *\n     * @return The specified selection and its results are removed from the state.\n     * Nothing is returned.\n     */\n    removeSelection(id) {\n        this.#manager.removeSelection(id);\n        return;\n    }\n\n    /**\n     * @param {string} id - An identifier for the desired selection.\n     *\n     * @return {object} Object containing the markers for the desired selection.\n     * Each key is a modality name while each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object,\n     * containing the marker detection results across all features of the corresponding modality.\n     * The set of cells in the selection is denoted as group 1, while all cells outside of the selection are denoted as group 0.\n     */\n    fetchResults(id) {\n        return this.#manager.fetchResults(id);\n    }\n\n    #unmap(ids) {\n        // Restoring the indices after adjusting for the invalid observations,\n        // so that users get back indices relative to the input matrices.\n        if (this.#missing_map !== null) {\n            ids.forEach((x, i) => {\n                ids[i] = this.#missing_map.from[x];\n            });\n        }\n        return;\n    }\n\n    /**\n     * Retrieve the indices for a selection of interest.\n     *\n     * @param {string} id - The identifier for the selection.\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     *\n     * @return {Array|TypedArray} Array of indices in the requested selection.\n     */\n    fetchSelectionIndices(id, { copy = true } = {}) {\n        let output = this.#manager.fetchSelectionIndices(id, { copy });\n        this.#unmap(output);\n        return output;\n    }\n\n    /**\n     * Retrieve indices for all selections.\n     *\n     * @param {object} [options] - Optional parameters.\n     * @param {boolean} [options.copy=true] - Whether to make a copy of `selection` before returning it.\n     * If `false`, it is assumed that the caller does not modify the selection.\n     * @param {?string} [force=null] - Whether to force each `selection` to be an `\"Array\"` or \"`Int32Array\"`.\n     * If `null`, the existing type of each selection is used.\n     *\n     * @return {object} Object where the keys are the selection names and the values are arrays of indices for each selection.\n     * Each array is a copy and can be modified without affecting the CustomSelectionsState.\n     */\n    fetchSelections({ copy = true, force = null } = {}) {\n        let output = this.#manager.fetchSelections({ copy, force });\n        for (const [k, v] of Object.entries(output)) {\n            this.#unmap(v);\n        }\n        return output;\n    }\n\n    /**\n     * Extract markers for a pairwise comparison between two selections, \n     * for more detailed examination of the differences between them.\n     *\n     * @param {string} left - Identifier of one selection in which to find upregulated markers.\n     * @param {string} right - Identifier of another selection to be compared against `left`.\n     *\n     * @return {object} Object containing:\n     *\n     * - `results`: object containing the marker statistics for the comparison between two clusters.\n     *    Each key is a modality name and each value is a {@linkplain external:ScoreMarkersResults ScoreMarkersResults} object.\n     * - `left`: index of the group corresponding to the `left` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `left` selection are defined as `output.results.RNA.cohen(output.left)`.\n     * - `right`: index of the group corresponding to the `right` selection in each ScoreMarkersResults object.\n     *    e.g., Cohen's d for the RNA markers of the `right` selection are defined as `output.results.RNA.cohen(output.right)`.\n     */\n    computeVersus(left, right) {\n        return this.#manager.computeVersus(\n            left, \n            right, \n            this.#normalized.available(),\n            modality => this.#normalized.get(modality),\n            this.#block,\n            this.#parameters.lfc_threshold,\n            this.#parameters.compute_auc\n        );\n    }\n}\n","import * as generics from \"./AllGenerics.js\";\nimport * as rse from \"./RangedSummarizedExperiment.js\";\nimport * as se from \"./SummarizedExperiment.js\";\nimport * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as il from \"./InternalList.js\";\n\n/**\n * A SingleCellExperiment is a {@linkplain RangedSummarizedExperiment} subclass that contains additional fields for storing reduced dimensions and alternative experiments.\n * It supports the same set of generics as the {@linkplain SummarizedExperiment}.\n *\n * Each reduced dimension instance should have number of rows equal to the number of columns of the SingleCellExperiment.\n * Each instance is expected to provide methods for the following generics:\n *\n * - {@linkcode NUMBER_OF_ROWS}\n * - {@linkcode SLICE_2D}\n * - {@linkcode COMBINE_ROWS}\n * - {@linkcode CLONE}\n *\n * Each alternative experiment should be a {@linkplain SummarizedExperiment} with number of columns equal to that of the SingleCellExperiment.\n *\n * Constructors of RangedSummarizedExperiment subclasses should be callable with no arguments, possibly creating an empty object with no properties.\n * This will be used by the `_bioconductor_CLONE`, `_bioconductor_COMBINE_ROWS`, `_bioconductor_COMBINE_COLUMNS` and `_bioconductor_SLICE_2D` methods to return an instance of the subclass.\n *\n * @extends RangedSummarizedExperiment\n */\nexport class SingleCellExperiment extends rse.RangedSummarizedExperiment {\n    /**\n     * @param {Object} assays - Object where keys are the assay names and values are multi-dimensional arrays of experimental data.\n     * @param {Object} [options={}] - Optional parameters, including those used in the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {?(GRanges|GroupedGRanges)} [options.rowRanges=null] - Genomic ranges corresponding to each row, see the {@linkplain RangedSummarizedExperiment} constructor.\n     * @param {Object|Map} [options.reducedDimensions={}] - Object containing named reduced dimensions.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns of the assays.\n     * @param {?Array} [options.reducedDimensionOrder=null] - Array containing the order of the reduced dimensions.\n     * This should have the same values as the keys of `reducedDimensions`, and defaults to those keys if `null`.\n     * @param {Object|Map} [options.alternativeExperiments={}] - Object containing named alternative experiments.\n     * Each value should be a 2-dimensional object with number of columns equal to that of the assays.\n     * @param {?Array} [options.alternativeExperimentOrder=null] - Array containing the order of the alternative experiments.\n     * This should have the same values as the keys of `alternativeExperiments`, and defaults to those keys if `null`.\n     * @param {?string} [options.mainExperimentName=null] - Main experiment name, possibly `null` if the main experiment is unnamed.\n     */\n    constructor(assays, options={}) {\n        if (arguments.length == 0) {\n            super();\n            return;\n        }\n\n        let { reducedDimensions = {}, reducedDimensionOrder = null, alternativeExperiments = {}, alternativeExperimentOrder = null, rowRanges = null, mainExperimentName = null } = options;\n        super(assays, rowRanges, options);\n        let ncols = this.numberOfColumns();\n\n        try {\n            this._reducedDimensions = new il.InternalList(reducedDimensions, reducedDimensionOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize reduced dimension list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._reducedDimensions.names()) {\n            let v = this._reducedDimensions.entry(k);\n            if (generics.NUMBER_OF_ROWS(v) !== ncols) {\n                throw new Error(\"number of rows for reduced dimension '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        try {\n            this._alternativeExperiments = new il.InternalList(alternativeExperiments, alternativeExperimentOrder);\n        } catch (e) {\n            throw new Error(\"failed to initialize alternative experiment list for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        for (const k of this._alternativeExperiments.names()) {\n            let v = this._alternativeExperiments.entry(k);\n            if (!(v instanceof se.SummarizedExperiment)) {\n                throw new Error(\"alternative experiment '\" + k + \"' is not a SummarizedExperiment\");\n            }\n            if (v.numberOfColumns(v) !== ncols) {\n                throw new Error(\"number of columns for alternative experiment '\" + k + \"' is not equal to number of columns for this \" + this.constructor.className);\n            }\n        }\n\n        this._mainExperimentName = mainExperimentName;\n        return;\n    }\n\n    static className = \"SingleCellExperiment\";\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the reduced dimensions.\n     */\n    reducedDimensionNames() {\n        return this._reducedDimensions.names();\n    }\n\n    /**\n     * @param {string|number} i - Reduced dimension to retrieve, either by name or index.\n     * @return {*} The contents of reduced dimension `i` as an multi-dimensional array-like object.\n     */\n    reducedDimension(i) {\n        let output;\n        try {\n            output = this._reducedDimensions.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Map} Map where keys are the names and values are the reduced dimensions.\n     */\n    reducedDimensions() {\n        return this._reducedDimensions.entries();\n    }\n\n    /**\n     * @return {Array} Array of strings containing the (ordered) names of the alternative experiments.\n     */\n    alternativeExperimentNames() {\n        return this._alternativeExperiments.names();\n    }\n\n    /**\n     * @param {string|number} i - Alternative experiment to retrieve, either by name or index.\n     * @return {SummarizedExperiment} The specified alternative experiment `i`. \n     */\n    alternativeExperiment(i) {\n        let output;\n        try {\n            output = this._alternativeExperiments.entry(i);\n        } catch (e) {\n            throw new Error(\"failed to retrieve the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return output;\n    }\n\n    /**\n     * @return {Map} Map where keys are the names and values are the alternative experiments.\n     */\n    alternativeExperiments() {\n        return this._alternativeExperiments.entries();\n    }\n\n    /**\n     * @return {?string} The name of the main experiment, possibly `null` if this is unnamed.\n     */\n    mainExperimentName() {\n        return this._mainExperimentName;\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeReducedDimension(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified reduced dimension from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $removeReducedDimension(i) {\n        return this.removeReducedDimension(i, { inPlace: true });\n    }\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to add, either by name or index.\n     * - If `i` is a number, the reduced dimension at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of reduced dimensions.\n     * - If `i` is a string, any reduced dimension with the same name is replaced.\n     *   If no such reduced dimension exists, a new reduced dimension is appended to the list of reduced dimensions.\n     * @param {*} value - Multi-dimensional array-like object to set/add as the reduced dimension.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimension(i, value, { inPlace = false } = {}) {\n        if (generics.NUMBER_OF_ROWS(value) != this.numberOfColumns()) {\n            throw new Error(\"number of rows of 'value' should be the same as the number of columns of this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._reducedDimensions = target._reducedDimensions.set(i, value, { inPlace });\n        return target;\n    }\n\n    $setReducedDimension(i, value) {\n        return this.setReducedDimension(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the reduced dimension names.\n     * This should be of the same length as the number of reduced dimensions and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified reduced dimension names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensionNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = target._reducedDimensions.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the reduced dimension names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $setReducedDimensionNames(names) {\n        return this.setReducedDimensionNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Object|Map} value - Object containing zero, one or more multi-dimensional array-like objects in the values.\n     * Each value should be a 2-dimensional object with number of rows equal to the number of columns in this SingleCellExperiment.\n     * Keys are reduced dimension names, each of which should be present in `order`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @param {Array|boolean} [options.newOrder=false] - Whether to replace the order of reduced dimensions with the order of keys in `value`.\n     * If `false`, the existing order in {@linkcode SingleCellExperiment#reducedDimensionNames reducedDimensionNames} is used.\n     * If an array is provided, this is used as the order.\n     * If `null`, this has the same effect as `true`.\n     *\n     * @return {SingleCellExperiment} A SingleCellExperiment with the new reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setReducedDimensions(value, { inPlace = false, newOrder = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (newOrder === false) {\n            newOrder = target._reducedDimensions.names();\n        } else if (newOrder == true) {\n            newOrder = null;\n        }\n        try {\n            target._reducedDimensions = new il.InternalList(value, newOrder);\n        } catch (e) {\n            throw new Error(\"failed to replace reduced dimension list for this SingleCellExperiment; \" + e.message, { cause: e });\n        }\n\n        let sce_nc = target.numberOfColumns();\n        for (const k of target._reducedDimensions.names()) {\n            let current = target._reducedDimensions.entry(k);\n            let nr = generics.NUMBER_OF_ROWS(current);\n            if (nr !== sce_nc) {\n                throw new Error(\"mismatch in the number of rows for reduced dimension '\" + k + \"' compared to the number of columns in the SingleCellExperiment\");\n            }\n        }\n\n        return target;\n    }\n\n    $setReducedDimensions(value, { newOrder = false } = {}) {\n        return this.setReducedDimensions(value, { inPlace: true, newOrder });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the reduced dimensions to retain in the slice.\n     * This should refer to unique reduced dimension names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with sliced reduced dimensions.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceReducedDimensions(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._reducedDimensions = this._reducedDimensions.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the reduced dimensions for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $sliceReducedDimensions(i) {\n        return this.sliceReducedDimensions(i, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    /**\n     * @param {string|number} i - Identity of the reduced dimension to remove, either by name or index.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment after removing the specified assay.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    removeAlternativeExperiment(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.delete(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to remove the specified alternative experiment from this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $removeAlternativeExperiment(i) {\n        return this.removeAlternativeExperiment(i, { inPlace: true });;\n    }\n\n    /**\n     * @param {string|number} i - Identity of the alternative experiment to add, either by name or index.\n     * - If `i` is a number, the alternative experiment at the specified index is replaced.\n     *   `i` should be non-negative and less than the number of alternative experiments.\n     * - If `i` is a string, any alternative experiment with the same name is replaced.\n     *   If no such alternative experiment exists, a new alternative experiment is appended to the list of alternative experiments.\n     * @param {SummarizedExperiment} value - A SummarizedExperiment to set/add as the alternative experiment.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiment(i, value, { inPlace = false } = {}) {\n        if (!(value instanceof se.SummarizedExperiment) || generics.NUMBER_OF_COLUMNS(value) != this.numberOfColumns()) {\n            throw new Error(\"'value' should be a SummarizedExperiment with the same number of columns as this SingleCellExperiment\");\n        }\n        let target = cutils.setterTarget(this, inPlace);\n        target._alternativeExperiments = target._alternativeExperiments.set(i, value, { inPlace });\n        return target;\n    }\n\n    $setAlternativeExperiment(i, value) {\n        return this.setAlternativeExperiment(i, value, { inPlace: true });\n    }\n\n    /**\n     * @param {Array} names - Array of strings containing the alternative experiment names.\n     * This should be of the same length as the number of alternative experiments and contain unique values.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with modified alternative experiment names.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperimentNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = target._alternativeExperiments.setNames(names, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to set the alternative experiment names for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $setAlternativeExperimentNames(names) {\n        return this.setAlternativeExperimentNames(names, { inPlace: true });\n    }\n\n    /**\n     * @param {Object|Map} value - Object containing zero, one or more {@link SummarizedExperiment} objects in the values.\n     * Each value should have the same number of columns as this SingleCellExperiment.\n     * Keys are alternative experiment names, each of which should be present in `order`.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @param {Array|boolean} [options.newOrder=false] - Whether to replace the order of alternative experiments with the order of keys in `value`.\n     * If `false`, the existing order in {@linkcode SingleCellExperiment#alternativeExperimentNames alternativeExperimentNames} is used.\n     * If an array is provided, this is used as the order.\n     * If `null`, this has the same effect as `true`.\n     *\n     * @return {SingleCellExperiment} A SingleCellExperiment with the new alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setAlternativeExperiments(value, { inPlace = false, newOrder = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (newOrder === false) {\n            newOrder = target._alternativeExperiments.names();\n        } else if (newOrder == true) {\n            newOrder = null;\n        }\n        try {\n            target._alternativeExperiments = new il.InternalList(value, newOrder);\n        } catch (e) {\n            throw new Error(\"failed to replace alternative experiment list for this SingleCellExperiment; \" + e.message, { cause: e });\n        }\n\n        let sce_nc = target.numberOfColumns();\n        for (const k of target._alternativeExperiments.names()) {\n            let current = target._alternativeExperiments.entry(k);\n            let nr = generics.NUMBER_OF_COLUMNS(current);\n            if (nr !== sce_nc) {\n                throw new Error(\"mismatch in the number of columns for alternative experiment '\" + k + \"' compared to the SingleCellExperiment\");\n            }\n        }\n\n        return target;\n    }\n\n    $setAlternativeExperiments(value, { newOrder = false } = {}) {\n        return this.setAlternativeExperiments(value, { inPlace: true, newOrder });\n    }\n\n    /**\n     * @param {Array} i - Array of strings or indices specifying the alternative experiments to retain in the slice.\n     * This should refer to unique alternative experiment names.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {SingleCellExperiment} The SingleCellExperiment with sliced alternative experiments.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceAlternativeExperiments(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        try {\n            target._alternativeExperiments = this._alternativeExperiments.slice(i, { inPlace });\n        } catch (e) {\n            throw new Error(\"failed to slice the alternative experiments for this \" + this.constructor.className + \"; \" + e.message, { cause: e });\n        }\n        return target;\n    }\n\n    $sliceAlternativeExperiments(i) {\n        return this.sliceAlternativeExperiments(i, { inPlace: true });\n    }\n\n    /**\n     * @return {?string} name - The name of the main experiment, possibly `null` if this is unnamed.\n     * @param {Object} [options={}] - Optional parameters.\n     * @param {boolean} [options.inPlace=false] - Whether to mutate this SingleCellExperiment instance in place.\n     * If `false`, a new instance is returned.\n     * @return {SingleCellExperiment} A SingleCellExperiment with a new main experiment name.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setMainExperimentName(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        target._mainExperimentName = name;\n        return target;\n    }\n\n    $setMainExperimentName(name) {\n        return this.setMainExperimentName(name, { inPlace: true });\n    }\n\n    /**************************************************************************\n     **************************************************************************\n     **************************************************************************/\n\n    _bioconductor_SLICE_2D(rows, columns, { allowView = false }) {\n        let output = super._bioconductor_SLICE_2D(rows, columns, { allowView });\n\n        if (columns !== null) {\n            output._reducedDimensions = this._reducedDimensions.apply(v => generics.SLICE_2D(v, columns, null, { allowView }));\n            output._alternativeExperiments = this._alternativeExperiments.apply(v => generics.SLICE_2D(v, null, columns, { allowView }));\n        } else {\n            output._reducedDimensions = this._reducedDimensions;\n            output._alternativeExperiments = this._alternativeExperiments;\n        }\n\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_COMBINE_ROWS(objects) {\n        let output = super._bioconductor_COMBINE_ROWS(objects);\n        output._reducedDimensions = this._reducedDimensions;\n        output._alternativeExperiments = this._alternativeExperiments;\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_COMBINE_COLUMNS(objects) {\n        let output = super._bioconductor_COMBINE_COLUMNS(objects);\n\n        let all_rd = [this._reducedDimensions];\n        let all_ae = [this._alternativeExperiments];\n        for (const x of objects) {\n            all_rd.push(x._reducedDimensions);\n            all_ae.push(x._alternativeExperiments);\n        }\n\n        try {\n            output._reducedDimensions = il.InternalList.parallelCombine(all_rd, generics.COMBINE_ROWS);\n        } catch (e) {\n            throw new Error(\"failed to combine reduced dimensions for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        try {\n            output._alternativeExperiments = il.InternalList.parallelCombine(all_ae, generics.COMBINE_COLUMNS);\n        } catch (e) {\n            throw new Error(\"failed to combine alternative experiments for \" + this.constructor.className + \" objects; \" + e.message, { cause: e });\n        }\n\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n\n    _bioconductor_CLONE({ deepCopy }) {\n        let output = super._bioconductor_CLONE({ deepCopy });\n        output._reducedDimensions = cutils.cloneField(this._reducedDimensions, deepCopy);\n        output._alternativeExperiments = cutils.cloneField(this._alternativeExperiments, deepCopy);\n        output._mainExperimentName = this._mainExperimentName;\n        return output;\n    }\n}\n","import { List, IntegerList, StringList, BooleanList, NumberList } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, exceedsInt32, jsonBuffer } from \"./utils.js\";\n\nfunction load_number(x) {\n    if (x === \"NaN\") {\n        return Number.NaN;\n    } else if (x === \"Inf\") {\n        return Number.POSITIVE_INFINITY;\n    } else if (x === \"-Inf\") {\n        return Number.NEGATIVE_INFINITY;\n    } else {\n        return x;\n    }\n}\n\nfunction load_vector(x, constructor, options, typedarray) {\n    let vals = x.values;\n    let scalar = false;\n    if (!(vals instanceof Array)) {\n        vals = [vals];\n        scalar = true;\n    }\n    let output = constructor(vals);\n    if (\"names\" in x) {\n        output.setNames(x.names, { inPlace: true });\n    } else {\n        if (scalar) {\n            if (\"List_toScalar\" in options && options.List_toScalar) {\n                return output.get(0);\n            }\n        } else if (typedarray !== null && output.toArray().every(y => y !== null)) {\n            if (\"List_toTypedArray\" in options && options.List_toTypedArray) {\n                return new typedarray(output.toArray());\n            }\n        }\n    }\n    output._jaspalite_scalar = scalar;\n    return output;\n}\n\nasync function load_json_list(x, path, globals, options) {\n    if (x.type == \"list\") {\n        let contents = [];\n        for (const y of x.values) {\n            contents.push(await load_json_list(y, path, globals, options));\n        }\n        let output = new List(contents);\n        if (\"names\" in x) {\n            output.setNames(x.names, { inPlace: true });\n        }\n        return output;\n\n    } else if (x.type == \"integer\") {\n        return load_vector(x, v => new IntegerList(v), options, Int32Array);\n\n    } else if (x.type == \"number\") {\n        return load_vector(x, v => new NumberList(v.map(load_number)), options, Float64Array);\n\n    } else if (x.type == \"string\") {\n        return load_vector(x, v => new StringList(v), options, null);\n\n    } else if (x.type == \"boolean\") {\n        return load_vector(x, v => new BooleanList(v), options, null);\n\n    } else if (x.type == \"factor\") {\n        // Whatever, just turn it into a StringList.\n        return load_vector(\n            x,\n            v => {\n                let copy = v.slice();\n                for (var i = 0; i < copy.length; i++) {\n                    if (copy[i] !== null) {\n                        copy[i] = x.levels[copy[i]];\n                    }\n                }\n                return new StringList(copy);\n            },\n            options,\n            null\n        );\n\n    } else if (x.type == \"nothing\") {\n        return null;\n\n    } else if (x.type == \"external\") {\n        return readObject(joinPath(path, \"other_contents\", String(x.index)), null, globals, options);\n\n    } else {\n        throw new Error(\"unknown JSON list type '\" + x.type + \"'\");\n    }\n}\n\n/**\n * An R-style list that allows access by name or index. \n * @external List \n * @see {@link https://ltla.github.io/bioconductor.js/List.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:List List}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {boolean} [options.List_toScalar=false] - Whether to report unnamed scalars as Javascript scalars. \n * Integers are automatically converted to floating-point.\n * If `false`, scalars are reported as instances of an appropriately-typed {@link List} subclass with length 1 and a `_jaspalite_scalar` property.\n * @param {boolean} [options.List_toTypedArray=false] - Whether to report unnamed integer/number vectors without missing values as TypedArrays.\n * If `false`, such vectors are reported as instances of an appropriately-typed {@link List} subclass.\n *\n * @return {external:List} The list.\n * @async\n */\nexport async function readList(path, metadata, globals, options = {}) {\n    if (metadata.simple_list.format !== \"json.gz\") {\n        throw new Error(\"list formats other than 'json.gz' are currently not supported\");\n    }\n    let contents = await globals.get(joinPath(path, \"list_contents.json.gz\"), { asBuffer: true });\n\n    const stream = new Blob([contents]).stream();\n    const decompressed_stream = stream.pipeThrough(new DecompressionStream(\"gzip\"));\n    let chunks = [];\n    let counter = 0;\n    for await (const chunk of decompressed_stream) {\n        chunks.push(chunk);\n        counter += chunk.length;\n    }\n    let decompressed_final = new Uint8Array(counter);\n    counter = 0;\n    for (const chunk of chunks) {\n        decompressed_final.set(chunk, counter);\n        counter += chunk.length;\n    }\n\n    let dec = new TextDecoder;\n    let str = dec.decode(decompressed_final);\n    let x = JSON.parse(str);\n    return load_json_list(x, path, globals, options);\n}\n\nfunction dump_number_array(x) {\n    let output = Array.from(x);\n    for (var i = 0; i < output.length; i++) {\n        let current = output[i];\n        if (Number.isNaN(current)) {\n            output[i] = \"NaN\";\n        } else if (current == Number.POSITIVE_INFINITY) {\n            output[i] = \"Inf\";\n        } else if (current == Number.NEGATIVE_INFINITY) {\n            output[i] = \"-Inf\";\n        }\n    }\n    return output;\n}\n\nfunction dump_vector(x) {\n    let vals = x.toArray();\n    if (vals.length == 1 && \"_jaspagate_scalar\" in x && x._jaspagate_scalar) {\n        return vals[0];\n    } else {\n        return vals;\n    }\n}\n\nasync function dump_json_list(x, path, globals, options, state) {\n    if (x instanceof Array) {\n        let output = { \"type\": \"list\", \"values\": [] };\n\n        if (x.length) {\n            let all_strings = true;\n            let all_bools = true;\n            let all_numbers = true;\n            for (const e of x) {\n                if (e !== null) {\n                    if (typeof e !== \"string\") {\n                        all_strings = false;\n                    }\n                    if (typeof e !== \"boolean\") {\n                        all_bools = false;\n                    }\n                    if (typeof e !== \"number\") {\n                        all_numbers = false;\n                    }\n                }\n            }\n\n            if (all_strings) {\n                output.type = \"string\";\n                output.values = x;\n            } else if (all_bools) {\n                output.type = \"boolean\";\n                output.values = x;\n            } else if (all_numbers) {\n                output.type = \"number\";\n                output.values = dump_number_array(x);\n            } else {\n                for (const e of x) {\n                    output.values.push(await dump_json_list(e, path, globals, options, state));\n                }\n            }\n        }\n\n        return output;\n\n    } else if (x instanceof List) {\n        let output = { \"type\": \"list\", \"values\": [] }\n        if (x instanceof IntegerList) {\n            output.type = (exceedsInt32(x) ? \"number\" : \"integer\");\n            output.values = dump_vector(x);\n        } else if (x instanceof NumberList) {\n            output.type = \"number\";\n            output.values = dump_vector(x);\n        } else if (x instanceof StringList) {\n            output.type = \"string\";\n            output.values = dump_vector(x);\n        } else if (x instanceof BooleanList) {\n            output.type = \"boolean\";\n            output.values = dump_vector(x);\n        } else {\n            for (const v of x) {\n                output.values.push(await dump_json_list(v, path, globals, options, state));\n            }\n        }\n        if (x.names() !== null) {\n            output.names = x.names();\n        }\n        return output;\n\n    } else if (x === null) {\n        return { \"type\": \"nothing\" };\n\n    } else if (x.constructor === Object) {\n        let output = { \"type\": \"list\", \"values\": [], \"names\": [] };\n        for (const [k, v] of Object.entries(x)) {\n            output.names.push(k);\n            output.values.push(await dump_json_list(v, path, globals, options, state));\n        }\n        return output;\n\n    } else if (x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Uint8Array || x instanceof Uint16Array) {\n        return { \"type\": \"integer\", \"values\": Array.from(x) }\n\n    } else if (x instanceof Uint32Array || x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        return { \"type\": \"number\", \"values\": Array.from(x).map(y => Number(y)) }\n\n    } else if (x instanceof Float64Array || x instanceof Float32Array) {\n        return { \"type\": \"number\", \"values\": dump_number_array(x) };\n\n    } else if (typeof x == \"number\") {\n        return { \"type\": \"number\", \"values\": x };\n\n    } else if (typeof x == \"string\") {\n        return { \"type\": \"string\", \"values\": x };\n\n    } else if (typeof x == \"boolean\") {\n        return { \"type\": \"boolean\", \"values\": x };\n\n    } else {\n        if (\"List_saveOther\" in options) {\n            let converted = options.List_saveOther(x);\n            if (converted !== null) {\n                return converted;\n            }\n        }\n\n        let odir = joinPath(path, \"other_contents\");\n        if (!(await globals.exists(odir))) {\n            await globals.mkdir(odir);\n        }\n        let curdex = state.index;\n        await saveObject(x, joinPath(odir, String(curdex)), globals, options);\n        state.index++;\n        return { \"type\": \"external\", \"index\": curdex };\n    }\n}\n\n/**\n * @param {external:List} x - The list.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function} [?options.List_saveOther=null] - Function to save custom class instances within a list, without resorting to a reference to an external object.\n * This should accept `y`, an instance of a custom object, and return an object containing the contents of `y` in the **uzuki2** JSON format.\n * If the class of `y` is not supported, `null` should be returned instead.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveList(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n\n    let objmeta = {\n        type: \"simple_list\",\n        simple_list: {\n            version: \"1.1\",\n            format: \"json.gz\"\n        }\n    };\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(objmeta));\n\n    let converted = await dump_json_list(x, path, globals, options, { index: 0 });\n    let stringified = JSON.stringify(converted);\n\n    const stream = new Blob([stringified]).stream();\n    const compressed_stream = stream.pipeThrough(new CompressionStream(\"gzip\"));\n    let chunks = [];\n    let counter = 0;\n    for await (const chunk of compressed_stream) {\n        chunks.push(chunk);\n        counter += chunk.length;\n    }\n    let compressed_final = new Uint8Array(counter);\n    counter = 0;\n    for (const chunk of chunks) {\n        compressed_final.set(chunk, counter);\n        counter += chunk.length;\n    }\n\n    await globals.write(joinPath(path, \"list_contents.json.gz\"), compressed_final);\n}\n","import { RangedSummarizedExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { readSummarizedExperiment, saveSummarizedExperiment } from \"./SummarizedExperiment.js\"; \nimport { joinPath, jsonBuffer } from \"./utils.js\";\n\n/**\n * A ranged summarized experiment.\n * @external RangedSummarizedExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/RangedSummarizedExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:RangedSummarizedExperiment RangedSummarizedExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, see also {@link readSummarizedExperiment}.\n *\n * @return {external:RangedSummarizedExperiment} The ranged summarized experiment object.\n * @async\n */\nexport async function readRangedSummarizedExperiment(path, metadata, globals, options = {}) {\n    let se = await readSummarizedExperiment(path, metadata, globals, options);\n\n    let rse = new RangedSummarizedExperiment(\n        se.assays(),\n        null,\n        {\n            assayOrder: se.assayNames(),\n            rowData: se.rowData(),\n            columnData: se.columnData(),\n            rowNames: se.rowNames(),\n            columnNames: se.columnNames(),\n            metadata: se.metadata(),\n        }\n    );\n\n    return rse;\n}\n\n/**\n * @param {external:RangedSummarizedExperiment} x - The ranged summarized experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options, see also {@linkcode saveSummarizedExperiment}.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveRangedSummarizedExperiment(x, path, globals, options = {}) {\n    await saveSummarizedExperiment(x, path, globals, options);\n    const existing = await readObjectFile(path, globals);\n    existing.type = \"ranged_summarized_experiment\";\n    existing.ranged_summarized_experiment = { \"version\": \"1.0\" };\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(existing));\n}\n","/**\n * Join paths while accounting for `.` inputs.\n *\n * @param {string} args - One or more strings containing path components.\n * These should not have leading or trailing `/` but may be equal to `.`\n *\n * @return The joined path.\n */\nexport function joinPath(...args) {\n    let output = args[0];\n    for (var i = 1; i < args.length; i++) {\n        let current = args[i];\n        if (output == \".\") {\n            output = current;\n        } else if (current != \".\") {\n            output += \"/\" + current;\n        }\n    }\n    return output;\n}\n\nexport function exceedsInt32(x) {\n    const upper = 2**31, lower = -upper;\n    for (const v of x) {\n        if (v !== null && (v < lower || v >= upper)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction substitutePlaceholder(x, placeholder, outclass) {\n    let output = new outclass(x.length);\n    x.forEach((y, i) => {\n        output[i] = (y === null ? placeholder : y);\n    });\n    return output;\n}\n\nexport function formatIntegerArrayForHdf5(x) {\n    let has_missing = x.some(y => y == null);\n\n    if (exceedsInt32(x)) {\n        let placeholder = null;\n        if (has_missing) {\n            placeholder = Number.NaN;\n            x = substitutePlaceholder(x, placeholder, Float64Array);\n        }\n        return { integer: false, data: x, placeholder: placeholder };\n    }\n\n    if (!has_missing) {\n        return { integer: true, data: x, placeholder: null };\n    }\n\n    let output = { integer: true, data: null, placeholder: null };\n\n    // Quickly searching some of the most obvious candidates.\n    const upper = 2**31, lower = -upper;\n    for (const candidate of [lower, upper - 1, 0]) {\n        if (!x.some(y => y == candidate)) {\n            output.placeholder = candidate;\n            break;\n        }\n    }\n\n    if (output.placeholder === null) {\n        let everything = new Set(x);\n        for (var i = lower + 1; i < upper - 1; i++) {\n            if (!everything.has(i)) {\n                output.placeholder = i;\n                break;\n            }\n        }\n    }\n\n    if (output.placeholder === null) {\n        output.integer = false;\n        output.placeholder = Number.NaN;\n    }\n\n    output.data = substitutePlaceholder(x, output.placeholder, Int32Array);\n    return output;\n}\n\nexport function formatNumberArrayForHdf5(x) {\n    if (!x.some(y => y == null)) {\n        return { data: x, placeholder: null };\n    }\n\n    // Quickly searching some of the most obvious candidates.\n    if (!x.some(Number.isNaN)) {\n        return { data: substitutePlaceholder(x, Number.NaN, Float64Array), placeholder: Number.NaN };\n    }\n\n    for (const candidate of [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.MAX_VALUE, -Number.MAX_VALUE, 0]) {\n        if (!x.some(y => y == candidate)) {\n            return { data: substitutePlaceholder(x, candidate, Float64Array), placeholder: candidate };\n        }\n    }\n\n    let previous = -Number.MAX_VALUE;\n    let sorted = (new Float64Array(x.filter(Number.isFinite))).sort();\n    let chosen;\n    for (const y of sorted) {\n        let candidate = previous + (y - previous) / 2;\n        if (candidate != previous && candidate != y) {\n            chosen = candidate;\n            break;\n        }\n        previous = y;\n    }\n\n    return { data: substitutePlaceholder(x, chosen, Float64Array), placeholder: chosen };\n}\n\nexport function formatStringArrayForHdf5(x) {\n    if (!x.some(y => y == null)) {\n        return { data: x, placeholder: null };\n    }\n\n    let placeholder = \"NA\";\n    if (x.some(y => y == \"NA\")) { // Quickly searching the most obvious candidates.\n        let everything = new Set(x);\n        placeholder += \"_\";\n        while (everything.has(placeholder)) {\n            placeholder += \"_\";\n        }\n    }\n\n    return { data: x.map(y => y == null ? placeholder : y), placeholder: placeholder };\n}\n\nexport function formatBooleanArrayForHdf5(x) {\n    return { \n        data: substitutePlaceholder(x, 2, Uint8Array),\n        placeholder: (x.some(y => y == null) ? 2 : null)\n    };\n}\n\nexport function jsonBuffer(obj) {\n    const str = JSON.stringify(obj);\n    const enc = new TextEncoder;\n    return enc.encode(str);\n}\n","import { DataFrame, SummarizedExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, jsonBuffer } from \"./utils.js\";\nimport { readAnnotatedMetadata, saveAnnotatedMetadata } from \"./metadata.js\";\n\n/**\n * A summarized experiment.\n * @external SummarizedExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/SummarizedExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:SummarizedExperiment SummarizedExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {?function} [options.SummarizedExperiment_readAssay=null] - How to read the assays.\n * If `null`, {@linkcode readObject} is used.\n * If a function is provided, it should accept `nrow` and `ncol` (the number of rows and columns in the SummarizedExperiment, respectively) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `nrow`\n * and [`NUMBER_OF_COLUMNS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_COLUMNS) is equal to `ncol`. \n * @param {function|boolean} [options.SummarizedExperiment_readMetadata=true] - How to read the metadata.\n * If `true`, {@linkcode readObject} is used, while if `false`, metadata will be skipped.\n * If a function is provided, it should accept `path`, `metadata`, `globals` and `options` (as described above), and return a {@link external:List List}.\n *\n * @return {external:SummarizedExperiment} The summarized experiment object.\n * @async\n */\nexport async function readSummarizedExperiment(path, metadata, globals, options = {}) {\n    let read_assay = null;\n    if (\"SummarizedExperiment_readAssay\" in options) {\n        read_assay = options.SummarizedExperiment_readAssay;\n    }\n\n    let handle_stack = [];\n    const se_options = {};\n    const assays = {};\n    const name_path = joinPath(path, \"assays/names.json\");\n    if (await globals.exists(name_path)) {\n        let names_contents = await globals.get(name_path, { asBuffer: true });\n        const dec = new TextDecoder;\n        const assay_names = JSON.parse(dec.decode(names_contents));\n\n        se_options.assayOrder = assay_names;\n        for (const [i, aname] of Object.entries(assay_names)) {\n            let assay_path = joinPath(path, \"assays\", String(i));\n            let assay_meta = await readObjectFile(assay_path, globals);\n            if (read_assay === null) {\n                assays[aname] = await readObject(assay_path, assay_meta, globals, options);\n            } else {\n                assays[aname] = await read_assay(metadata.summarized_experiment.dimensions[0], metadata.summarized_experiment.dimensions[1], assay_path, assay_meta, globals, options);\n\n            }\n        }\n    }\n\n    if (await globals.exists(joinPath(path, \"column_data/OBJECT\"))) {\n        let cd = await readObject(joinPath(path, \"column_data\"), null, globals, options);\n        se_options.columnData = cd;\n        se_options.columnNames = cd.rowNames();\n    } else if (Object.keys(assays).length == 0) {\n        se_options.columnData = new DataFrame({}, { numberOfRows: 0 });\n    }\n\n    if (await globals.exists(joinPath(path, \"row_data/OBJECT\"))) {\n        let cd = await readObject(joinPath(path, \"row_data\"), null, globals, options);\n        se_options.rowData = cd;\n        se_options.rowNames = cd.rowNames();\n    } else if (Object.keys(assays).length == 0) {\n        se_options.rowData = new DataFrame({}, { numberOfRows: 0 });\n    }\n\n    se_options.metadata = await readAnnotatedMetadata(joinPath(path, \"other_data\"), globals, options, \"SummarizedExperiment_readMetadata\")\n    return new SummarizedExperiment(assays, se_options);\n}\n\n/**\n * @param {external:SummarizedExperiment} x - The summarized experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveSummarizedExperiment(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer({\n        type: \"summarized_experiment\",\n        summarized_experiment: {\n            version: \"1.0\",\n            dimensions: [ x.numberOfRows(), x.numberOfColumns() ]\n        }\n    }));\n\n    const assay_names = x.assayNames();\n    if (assay_names.length > 0) {\n        const adir = joinPath(path, \"assays\");\n        await globals.mkdir(adir);\n        await globals.write(joinPath(adir, \"names.json\"), jsonBuffer(assay_names));\n        for (const [i, aname] of Object.entries(assay_names)) {\n            await saveObject(x.assay(aname), joinPath(adir, String(i)), globals, options);\n        }\n    }\n\n    if (x.columnData().numberOfColumns() > 0 || x.columnNames() !== null) {\n        const cd = x.columnData().setRowNames(x.columnNames());\n        await saveObject(cd, joinPath(path, \"column_data\"), globals, options);\n    }\n\n    if (x.rowData().numberOfColumns() > 0 || x.rowNames() !== null) {\n        const cd = x.rowData().setRowNames(x.rowNames());\n        await saveObject(cd, joinPath(path, \"row_data\"), globals, options);\n    }\n\n    await saveAnnotatedMetadata(x.metadata(), joinPath(path, \"other_data\"), globals, options);\n}\n","import { fetchAllGenes } from \"./fetchAllGenes.js\";\nimport { mapGenesByIdentifier } from \"./mapGenesByIdentifier.js\";\n\n/**\n * @param {string} species - Taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {Array} queries - Array of strings containing gene identifiers of some kind (e.g., Ensembl, symbol, Entrez).\n * @param {object} [options={}] - Optional parameters.\n * @param {?Array} [options.types=null] - Array of strings specifying the identifier types to use for searching.\n * The exact choice of strings depends on how the references were constructed.\n * If `null`, it defaults to an array containing `\"entrez\"`, `\"ensembl\"` and `\"symbol\"`.\n * @param {boolean} [options.ignoreCase=true] - Whether to perform case-insensitive matching.\n *\n * @return {Array} An array of length equal to `queries`.\n * Each element of the array is an array containing the **gesel** gene IDs with any identifiers that match the corresponding search string.\n * See {@linkcode fetchAllGenes} for more details on the interpretation of these IDs.\n *\n * @async\n */\nexport async function searchGenes(species, queries, { types = null, ignoreCase = true } ={}) {\n    if (types === null) {\n        types = [ \"entrez\", \"ensembl\", \"symbol\" ];\n    }\n\n    let promises = [];\n    for (const t of types) {\n        promises.push(mapGenesByIdentifier(species, t, { lowerCase: ignoreCase }));\n    }\n    let resolved = await Promise.all(promises);\n\n    let mapping = [];\n    for (var i = 0; i < queries.length; i++) {\n        let current = queries[i];\n        if (current.length == 0) {\n            mapping.push([]);\n            continue;\n        }\n\n        if (ignoreCase) {\n            current = current.toLowerCase();\n        }\n\n        let findings = [];\n        for (var j = 0; j < types.length; j++) {\n            let val = resolved[j].get(current);\n            if (typeof val !== \"undefined\") {\n                for (const v of val) {\n                    findings.push(v);\n                }\n            }\n        }\n\n        mapping.push(findings);\n    }\n\n    return mapping;\n}\n\n","import * as pako from \"pako\";\n\nexport var default_download = (base, file, start, end) => {\n    let url = base + \"/\" + file;\n    if (start == null || end == null) {\n        return fetch(url);\n    } else {\n        return fetch(url, { headers: { Range: \"bytes=\" + String(start) + \"-\" + String(end) } }); \n    }\n}\n\nvar reference_base_url = \"https://github.com/LTLA/gesel-feedstock/releases/download/indices-v0.2.2\";\n\n/**\n * Get or set the base URL for the pre-built references.\n * By default, it uses the `indices-*` release files from [the feedstock repository](https://github.com/LTLA/gesel-feedstock).\n * Setters should call this function before calling any **gesel** functions that might fetch resources.\n *\n * @param {string} [url] - Base URL to use for the prebuilt references.\n *\n * @return {string} If `url` is not supplied, the current base URL is returned.\n *\n * If `url` is supplied, it is set as the base URL, and the previous base URL is returned.\n */\nexport function referenceBaseUrl(url) {\n    if (typeof url == \"undefined\") {\n        return reference_base_url;\n    } else {\n        let old = reference_base_url;\n        reference_base_url == url;\n        return old;\n    }\n}\n\nexport var reference_download = (file, start = null, end = null) => default_download(reference_base_url, file, start, end);\n\n/**\n * Get or set the global download function to fetch pre-built references.\n * By default, it uses the global `fetch` in browsers and later versions of Node.js.\n * Applications may specify a different function, e.g., to handle authentication or caching; \n * this should be done before calling any other **gesel** functions that might fetch resources.\n *\n * @param {function} [fun] - Function that performs a GET request to an index file, returning a Response object containing the file contents.\n * This accepts three arguments:\n *\n * - The base name of the pre-built index file of interest (e.g., `\"10090_collections.tsv.gz\"`).\n * - The starting byte of the request.\n * - The ending byte of the request.\n *\n * If all three arguments are specified, the function should perform a HTTP range request to obtain the specified range of bytes.\n * If only the first argument is supplied, the function should download the entire file.\n *\n * @return {function} If `fun` is not supplied, the current global downloader is returned.\n *\n * If `fun` is supplied, it is used to set the global downloader, and the previous global value of the function is returned.\n */\nexport function referenceDownload(fun) {\n    let prev = reference_download;\n    if (typeof fun !== \"undefined\") {\n        reference_download = fun;\n    }\n    return prev;\n}\n\n// For back-compatibility.\nexport function setReferenceDownload(fun) {\n    return referenceDownload(fun);\n}\n\nvar gene_base_url = \"https://github.com/LTLA/gesel-feedstock/releases/download/genes-v1.0.0\";\n\n/**\n * Get or set the base URL for the gene information.\n * By default, it uses the `genes-*` release files from [the feedstock repository](https://github.com/LTLA/gesel-feedstock).\n * Setters should call this function before calling any other **gesel** functions that might fetch resources.\n *\n * @param {string} [url] - Base URL to use for the gene informatin.\n *\n * @return {string} If `url` is not supplied, the current base URL is returned.\n *\n * If `url` is supplied, it is set as the base URL, and the previous base URL is returned.\n */\nexport function geneBaseUrl(url) {\n    if (typeof url == \"undefined\") {\n        return gene_base_url;\n    } else {\n        let old = gene_base_url;\n        gene_base_url == url;\n        return old;\n    }\n}\n\nexport var gene_download = (file) => default_download(gene_base_url, file, null, null);\n\n/**\n * Set the global download function to fetch gene information.\n * By default, it uses the global `fetch` in browsers and later versions of Node.js.\n * Applications may specify a different function, e.g., to handle authentication or caching; \n * this should be done before calling any other **gesel** functions that might fetch resources.\n *\n * @param {function} [fun] - Function that performs a GET request to an index file, returning a Response object containing the file contents.\n * This should accept the base name of the pre-built index file of interest (e.g., `\"9606_symbol.tsv.gz\"`).\n *\n * @return {function} If `fun` is not supplied, the current global downloader is returned.\n *\n * If `fun` is supplied, it is used to set the global downloader, and the previous global value of the function is returned.\n */\nexport function geneDownload(fun) {\n    let prev = gene_download;\n    if (typeof fun !== \"undefined\") {\n        gene_download = fun;\n    }\n    return prev;\n}\n\n// For back-compatibility.\nexport function setGeneDownload(fun) {\n    return geneDownload(fun);\n}\n\nexport function decompressLines(buffer) {\n    var contents = pako.inflate(new Uint8Array(buffer));\n    const txt = new TextDecoder();\n    var lines = txt.decode(contents).split(\"\\n\");\n\n    if (lines[lines.length - 1] == \"\") {\n        return lines.slice(0, lines.length - 1); // remove empty string at trailing newline.\n    } else {\n        return lines;\n    }\n}\n\nexport async function retrieveRanges(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lengths = decompressLines(buffer);\n\n    var ranges = [0];\n    for (var i = 0; i < lengths.length; i++) { \n        ranges.push(ranges[i] + Number(lengths[i]) + 1);\n    }\n    return ranges;\n}\n\nexport async function retrieveNamedRanges(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lines = decompressLines(buffer);\n\n    var last = 0;\n    var ranges = new Map; \n    var order = [];\n    for (var i = 0; i < lines.length; i++) { \n        let split = lines[i].split(\"\\t\");\n        let next = last + Number(split[1]) + 1; // +1 for the newline.\n        ranges.set(split[0], [last, next]);\n        order.push(split[0]);\n        last = next;\n    }\n\n    return { ranges, order };\n}\n\nexport async function retrieveRangesWithExtras(resource) {\n    var res = await reference_download(resource + \".ranges.gz\");\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var buffer = await res.arrayBuffer();\n    var lines = decompressLines(buffer);\n\n    var ranges = [0];\n    var extra = [];\n    for (var i = 0; i < lines.length; i++) {\n        let split = lines[i].split(\"\\t\");\n        ranges.push(ranges[i] + Number(split[0]) + 1); // +1 for the newline.\n        extra.push(Number(split[1]));\n    }\n\n    return { ranges, extra };\n}\n\nexport function retrieveBytesByIndex(resource, ranges, index) {\n    var start = ranges[index];\n    var end = ranges[index + 1];\n    return retrieveBytes(resource, start, end);\n}\n\nexport async function retrieveBytes(resource, start, end) {\n    end--; // ignore the newline.\n\n    var res = await reference_download(resource, start, end);\n    if (!res.ok) {\n        throw \"failed to fetch ranges for '\" + resource + \"'\";\n    }\n\n    var txt = await res.text();\n    return txt.slice(0, end - start); // make sure we limit it to the requested length.\n}\n\nexport function convertToUint32Array(txt) { // Building back the indices from the diffs.\n    var output = [];\n\n    if (txt !== \"\") {\n        var last = 0;\n        txt.split(\"\\t\").forEach(x => {\n            var y = Number(x) + last;\n            output.push(y);\n            last = y;\n        });\n    }\n\n    return new Uint32Array(output);\n}\n\n/**\n * @param {Array} arrays - Array of arrays over which to compute the intersection.\n * @return {Array} Intersection of all arrays in `arrays`.\n */\nexport function intersect(arrays) {\n    if (arrays.length == 0) {\n        return [];\n    } else if (arrays.length == 1) {\n        return arrays[0];\n    }\n\n    let ref = new Set(arrays[0]);\n    for (var i = 1; i < arrays.length; i++) {\n        let running = new Set;\n        for (const x of arrays[i]) {\n            if (ref.has(x)) {\n                running.add(x);\n            }\n        }\n        ref = running;\n    }\n\n    return Array.from(ref);\n}\n\nasync function fetch_sizes_internal(species, _sizes, full, initialize, funSizes, funFound) {\n    let sizes = _sizes.get(species);\n    if (typeof sizes == \"undefined\") {\n        let found = await full(species, { download: false });\n\n        if (found !== null) {\n            // Pulling it from the full info instead, if we already got it.\n            return funFound(found);\n        }\n\n        await initialize(species);\n        sizes = _sizes.get(species);\n    }\n\n    return funSizes(sizes);\n}\n\nexport function fetchSizes(species, _sizes, full, initialize) {\n    return fetch_sizes_internal(\n        species, \n        _sizes, \n        full, \n        initialize, \n        x => x, \n        y => {\n            let tmp_sizes = [];\n            for (const x of y) {\n                tmp_sizes.push(x.size);\n            }\n            _sizes.set(species, tmp_sizes);\n            return tmp_sizes;\n        }\n    );\n}\n\nexport function fetchNumber(species, _sizes, full, initialize) {\n    return fetch_sizes_internal(\n        species,\n        _sizes,\n        full,\n        initialize,\n        x => x.length,\n        x => x.length\n    );\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as gesel from \"gesel\";\n\nimport * as utils from \"./utils/general.js\";\nimport * as mutils from \"./utils/markers.js\";\nimport * as rutils from \"../readers/index.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as filter_module from \"./cell_filtering.js\";\nimport * as norm_module from \"./rna_normalization.js\";\nimport * as markers_module from \"./marker_detection.js\";\n\nexport const step_name = \"feature_set_enrichment\";\n\n/********************************************\n ******** Internals for collections *********\n ********************************************/\n\nclass FeatureSetManager {\n    #cache;\n\n    constructor() {\n        this.#cache = {};\n    }\n\n    free() {\n        utils.freeCache(this.#cache.set_buffer);\n        this.#cache = {};\n    }\n\n    static flush() {\n        // TODO: call a gesel flush() function.\n        return;\n    }\n\n    static setDownload(fun) {\n        console.warn(\"'FeatureSetState.setDownload' is a no-op, uses 'gesel.setReferenceDownload' and 'gesel.setGeneDownload' instead\");\n        return;\n    }\n\n    async #prepare(feats, species, gene_id_column, gene_id_type) {\n        let data_id_col;\n        if (gene_id_column == null) {\n            data_id_col = feats.rowNames();\n            if (data_id_col == null) {\n                // If there truly is no annotation, then we avoid throwing,\n                // and we just make the rest of this function a no-op.\n                species = []; \n            }\n        } else {\n            data_id_col = feats.column(gene_id_column);\n        }\n\n        let search_options = { types: [ gene_id_type.toLowerCase() ] };\n\n        // To avoid repeated rellocations on array resizing, we create\n        // preallocated arrays within each species and then do a single COMBINE\n        // across species. We provide an initial element so that COMBINE works\n        // correctly when there are no species.\n        let collection_offset = 0;\n        let all_collection_names = [[]];\n        let all_collection_descriptions = [[]];\n        let all_collection_species = [[]];\n\n        let set_offset = 0;\n        let all_set_names = [[]];\n        let all_set_descriptions = [[]];\n        let all_set_indices = [[]];\n        let all_set_sizes = [new Int32Array];\n        let all_set_collections = [new Int32Array];\n\n        let mapped_genes = new Set;\n        let remapped = new Array(feats.numberOfRows());\n        for (var r = 0; r < remapped.length; r++) {\n            remapped[r] = [];\n        }\n\n        for (const spec of species) {\n            // Mapping our features to those in the gesel database. \n            let gene_mapping = await gesel.searchGenes(spec, data_id_col, search_options);\n            for (var i = 0; i < gene_mapping.length; i++) {\n                if (gene_mapping[i].length > 0) {\n                    mapped_genes.add(i);\n                }\n            }\n\n            // Formatting the details for each set. This includes reindexing\n            // the gesel gene IDs to refer to row indices of 'feats'.\n            let all_sets2genes = await gesel.fetchGenesForAllSets(spec);\n            let set_indices = gesel.reindexGenesForAllSets(gene_mapping, all_sets2genes);\n\n            let all_sets = await gesel.fetchAllSets(spec);\n            let nsets = all_sets.length;\n            let set_names = new Array(nsets);\n            let set_descriptions = new Array(nsets);\n            let set_sizes = new Int32Array(nsets);\n            let set_collections = new Int32Array(nsets);\n\n            for (var i = 0; i < nsets; i++) {\n                let current = all_sets[i];\n                set_names[i] = current.name;\n                set_descriptions[i] = current.description;\n                set_collections[i] = current.collection + collection_offset; // offset effectively \"namespaces\" collections from different species.\n                set_sizes[i] = set_indices[i].length;\n            }\n\n            all_set_names.push(set_names);\n            all_set_descriptions.push(set_descriptions);\n            all_set_indices.push(set_indices);\n            all_set_sizes.push(set_sizes);\n            all_set_collections.push(set_collections);\n\n            // Updating the gene->set mapping for input features.\n            let all_genes2sets = await gesel.fetchSetsForAllGenes(spec);\n            let current_remapped = gesel.reindexSetsForAllGenes(gene_mapping, all_genes2sets);\n            for (var i = 0; i < gene_mapping.length; i++) {\n                let current = current_remapped[i];\n                for (var j = 0; j < current.length; j++) {\n                    current[j] += set_offset; // offset effectively \"namespaces\" sets from different species.\n                }\n                remapped[i].push(current);\n            }\n\n            // Sticking the collection details somewhere.\n            let all_collections = await gesel.fetchAllCollections(spec);\n            let ncollections = all_collections.length;\n            let collection_names = new Array(ncollections);\n            let collection_descriptions = new Array(ncollections);\n            let collection_species = new Array(ncollections);\n\n            for (var i = 0; i < ncollections; i++) {\n                collection_names[i] = all_collections[i].title;\n                collection_descriptions[i] = all_collections[i].description;\n                collection_species[i] = spec;\n            }\n\n            all_collection_names.push(collection_names);\n            all_collection_descriptions.push(collection_descriptions);\n            all_collection_species.push(collection_species);\n\n            set_offset += nsets;\n            collection_offset += ncollections;\n        }\n\n        this.#cache.universe = (new Int32Array(mapped_genes)).sort();\n\n        this.#cache.sets = {\n            names: bioc.COMBINE(all_set_names),\n            descriptions: bioc.COMBINE(all_set_descriptions),\n            sets: bioc.COMBINE(all_set_indices),\n            sizes: bioc.COMBINE(all_set_sizes),\n            collections: bioc.COMBINE(all_set_collections)\n        };\n\n        this.#cache.collections = {\n            names: bioc.COMBINE(all_collection_names),\n            descriptions: bioc.COMBINE(all_collection_descriptions),\n            species: bioc.COMBINE(all_collection_species)\n        };\n\n        if (species.length > 0) {\n            for (var r = 0; r < remapped.length; r++) {\n                remapped[r] = bioc.COMBINE(remapped[r]);\n            }\n        } else {\n            for (var r = 0; r < remapped.length; r++) {\n                remapped[r] = new Uint32Array;\n            }\n        }\n        this.#cache.mapping_to_sets = remapped;\n\n        return;\n    }\n\n    async buildCollections(old_parameters, guess_ids, species, gene_id_column, gene_id_type, annofun, guessfun) {\n        if (\n            guess_ids !== old_parameters.guess_ids ||\n            (\n                !guess_ids && \n                (\n                    old_parameters.gene_id_column !== gene_id_column || \n                    old_parameters.gene_id_type !== gene_id_type ||\n                    utils.changedParameters(old_parameters.species, species)\n                )\n            )\n        ) {\n            let gene_id_column2 = gene_id_column;\n            let gene_id_type2 = gene_id_type;\n            let species2 = species;\n\n            if (guess_ids) {\n                let auto = configure_feature_parameters(guessfun());\n                gene_id_column2 = auto.gene_id_column;\n                gene_id_type2 = auto.gene_id_type;\n                species2 = auto.species;\n            }\n\n            await this.#prepare(annofun(), species2, gene_id_column2, gene_id_type2);\n            return true;\n        }\n\n        return false;\n    }\n\n    fetchCollectionDetails() {\n        return this.#cache.collections;\n    }\n\n    fetchSetDetails() {\n        return { \n            names: this.#cache.sets.names,\n            descriptions: this.#cache.sets.descriptions,\n            sizes: this.#cache.sets.sizes,\n            collections: this.#cache.sets.collections\n        };\n    }\n\n    fetchUniverseSize() {\n        return this.#cache.universe.length;\n    }\n\n    computeEnrichment(group, effect_size, summary, markers, top_markers) {\n        // Renaming things for back-compatibility.\n        if (effect_size == \"delta_detected\") {\n            effect_size = \"deltaDetected\";\n        } else if (effect_size == \"cohen\") {\n            effect_size = \"cohensD\";\n        } else if (effect_size == \"lfc\") {\n            effect_size = \"deltaDetected\";\n        }\n        if (summary == \"min_rank\") {\n            summary = \"min-rank\";\n        }\n\n        let use_largest = true;\n        let min_threshold = null;\n        if (summary == \"min-rank\") {\n            use_largest = false;\n        } else {\n            min_threshold = (effect_size == \"auc\" ? 0.5 : 0);\n        }\n\n        let stats = markers[effect_size](group, { summary: summary, copy: false });\n        let in_set = scran.chooseTopMarkers(\n            bioc.SLICE(stats, this.#cache.universe),\n            top_markers,\n            {\n                useLargest: use_largest,\n                threshold: min_threshold\n            }\n        );\n        in_set.forEach((x, i) => {\n            let gene = this.#cache.universe[x];\n            in_set[i] = this.#cache.mapping_to_sets[gene];\n        });\n\n        let overlaps = gesel.countSetOverlaps(in_set);\n        let set_ids = new Int32Array(overlaps.length);\n        let counts = new Int32Array(overlaps.length);\n        let sizes = new Int32Array(overlaps.length);\n        let indices = new Int32Array(overlaps.length);\n        for (var i = 0; i < overlaps.length; i++) {\n            indices[i] = i;\n            let x = overlaps[i];\n            set_ids[i] = x.id;\n            counts[i] = x.count;\n            sizes[i] = this.#cache.sets.sizes[x.id];\n        }\n\n        let num_top = in_set.length;\n        let pvalues = scran.hypergeometricTest(counts, num_top, sizes, this.#cache.universe.length);\n        indices.sort((a, b) => pvalues[a] - pvalues[b]); // Sorting by p-value.\n        return {\n            set_ids: bioc.SLICE(set_ids, indices),\n            counts: bioc.SLICE(counts, indices),\n            pvalues: bioc.SLICE(pvalues, indices),\n            num_markers: num_top\n        };\n    }\n\n    fetchFeatureSetIndices(set_id) {\n        return this.#cache.sets.sets[set_id];\n    }\n\n    computePerCellScores(set_id, normalized, block) {\n        let indices = this.fetchFeatureSetIndices(set_id);\n        // console.log(bioc.SLICE(this.#inputs.fetchFeatureAnnotations().RNA.column(\"id\"), indices));\n\n        let features = utils.allocateCachedArray(normalized.numberOfRows(), \"Uint8Array\", this.#cache, \"set_buffer\");\n        features.fill(0);\n        let farr = features.array();\n        indices.forEach(x => { farr[x] = 1; }); \n\n        return scran.scoreGsdecon(normalized, features, { block: block });\n    }\n}\n\n/*******************************************\n ******** Internals for parameters *********\n *******************************************/\n\nfunction all_defaults() {\n    return {\n        skip: false,\n        guess_ids: true,\n        species: [],\n        gene_id_column: null, \n        gene_id_type: \"ENSEMBL\", \n        top_markers: 100\n    };\n}\n\nfunction configure_feature_parameters(guesses) {\n    let best_key = null;\n    let best = { type: \"symbol\", species: \"9606\", confidence: 0 };\n\n    if (\"row_names\" in guesses) {\n        let val = guesses.row_names;\n        if (val.confidence > best.confidence) {\n            best = val;\n        }\n    }\n\n    for (const [key, val] of Object.entries(guesses.columns)) {\n        if (val.confidence > best.confidence) {\n            best = val;\n            best_key = key;\n        }\n    }\n\n    return {\n        gene_id_column: best_key,\n        gene_id_type: best.type.toUpperCase(),\n        species: [best.species]\n    };\n}\n\nfunction dereference_parameters(parameters) {\n    parameters.species = bioc.CLONE(parameters.species); // make a copy to avoid pass-by-ref behavior.\n    return parameters;\n}\n\nfunction fetch_parameters(parameters) {\n    // Avoid pass-by-reference behavior.\n    let out = { ...parameters };\n    out.species = bioc.CLONE(out.species);\n    return out;\n}\n\n/************************\n ******** State *********\n ************************/\n\n/**\n * This step tests for enrichment of particular feature sets in the set of top marker genes,\n * based on marker rankings from {@linkplain MarkerDetectionState}.\n * It wraps the [`testFeatureSetEnrichment`](https://kanaverse.github.io/scran.js/global.html#testFeatureSetEnrichment) \n * and [`scoreGsdecon`](https://kanaverse.github.io/scran.js/global.html#scoreGsdecon) functions\n * from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * This class uses the [**gesel**](https://npmjs.org/package/gesel) package to download the default gene set databases for the relevant organisms.\n * Its behavior can be tuned by setting global **gesel** variables, e.g., using the [`referenceDownload`](https://ltla.github.io/gesel/global.html#referenceDownload) function.\n * \n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class FeatureSetEnrichmentState {\n    #inputs;\n    #filter;\n    #normalized;\n\n    #parameters;\n    #manager;\n\n    constructor(inputs, filter, normalized, markers, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        if (!(filter instanceof filter_module.CellFilteringState)) {\n            throw new Error(\"'filter' should be a CellFilteringState object\");\n        }\n        this.#filter = filter;\n\n        if (!(normalized instanceof norm_module.RnaNormalizationState)) {\n            throw new Error(\"'normalized' should be a RnaNormalizationState object from './rna_normalization.js'\");\n        }\n        this.#normalized = normalized;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#manager = new FeatureSetManager;\n        this.changed = false;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        this.#manager.free();\n        return; \n    }\n\n    valid() {\n        let mat = this.#inputs.fetchCountMatrix();\n        return mat.has(\"RNA\");\n    }\n\n    /**\n     * Obtain the details about the feature set collections in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {object} Object with the following properties:\n     *\n     * - `names`: Array of strings of length equal to the number of feature set collections, containing the names of the collections.\n     * - `descriptions`: Array of strings of length equal to `names`, containing the descriptions for all collections.\n     * - `species`: Array of strings of length equal to `names`, containing the taxonomy IDs for all collections.\n     */\n    fetchCollectionDetails() {\n        return this.#manager.fetchCollectionDetails();\n    }\n\n    /**\n     * Obtain the details about the feature sets in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {object} Object with the following properties:\n     *\n     * - `names`: Array of strings of length equal to the number of feature sets across all collections, containing the names of those sets.\n     * - `descriptions`: Array of strings of length equal to `names`, containing the set descriptions.\n     * - `sizes`: Int32Array of length equal to `names`, containing the set sizes.\n     *   Each set's size is defined as the number of features in the dataset that are successfully mapped to a member of the set.\n     * - `collections`: Int32Array of length equal to `names`, specifying the collection to which the set belongs.\n     *   This is interpreted as the index of the arrays in {@linkcode fetchCollectionDetails}.\n     */\n    fetchSetDetails() {\n        return this.#manager.fetchSetDetails();\n    }\n\n    /**\n     * Obtain the size of the universe of features that were successfully mapped to features in the reference database.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @return {number} Number of features from the input dataset that were successfully mapped to at least one gene in the reference database.\n     */\n    fetchUniverseSize() {\n        return this.#manager.fetchUniverseSize();\n    }\n\n    /**\n     * Compute enrichment of top markers in each feature set.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {external:ScoreMarkersResults} markers - Arbitrary marker detection results for an RNA modality, with the same order and identity of genes as from the upstream {@linkplain InputsState}.\n     * This is most typically the output from {@linkcode MarkerDetectionState#fetchResults MarkerDetectionState.fetchResults} or equivalents from {@linkplain CustomSelectionsState}.\n     * @param {number} group - Index of the group of interest inside `markers`.\n     * @param {string} effect_size - Effect size to use for ranking.\n     * This should be one of `\"cohen\"`, `\"auc\"`, `\"lfc\"` or `\"delta_detected\"`.\n     * @param {string} summary - Summary statistic to use for ranking.\n     * This should be one of `\"min\"`, `\"mean\"` or `\"min_rank\"`.\n     *\n     * @return {object} Object containing the following properties:\n     *\n     * - `set_ids`: Int32Array of length equal to the number of sets, containing the set IDs.\n     *   Each entry is an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     * - `counts`: Int32Array of length equal to `set_ids`, containing the number of markers present in each set.\n     * - `pvalues`: Float64Array of length equal to `counts`, containing the enrichment p-values for each set.\n     * - `num_markers`: number of markers selected for testing.\n     *\n     * Sets are guaranteed to be sorted by increasing p-value in `pvalues`.\n     */\n    computeEnrichment(markers, group, effect_size, summary) {\n        return this.#manager.computeEnrichment(group, effect_size, summary, markers, this.#parameters.top_markers);\n    }\n\n    /**\n     * Extract row indices of the members of a desired feature set of interest.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Int32Array} Array containing the row indices of the RNA count matrix corresponding to the genes in the specified set.\n     */\n    fetchFeatureSetIndices(set_id) {\n        return this.#manager.fetchFeatureSetIndices(set_id);\n    }\n\n    /**\n     * Compute per-cell scores for the activity of a feature set.\n     * It is assumed that {@linkcode runAnalysis} was already run on this FeatureSetEnrichmentState instance before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentState#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Object} Object containing:\n     *\n     * - `indices`: Int32Array containing the row indices of the genes in the set, relative to the RNA count matrix.\n     * - `weights`: Float64Array containing the weights of each gene in the set.\n     * - `scores`: Float64Array containing the feature set score for each cell.\n     */\n    computePerCellScores(set_id) {\n        return this.#manager.computePerCellScores(set_id, this.#normalized.fetchNormalizedMatrix(), this.#filter.fetchFilteredBlock());\n    }\n\n    // Soft-deprecated.\n    fetchPerCellScores(collection, set_index) {\n        return this.computePerCellScores(collection, set_index);\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    static flush() {\n        return;\n    }\n\n    static setDownload(fun) {\n        return FeatureSetManager.setDownload(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellFilteringState#compute compute} for details.\n     */\n    static defaults() {\n        return all_defaults();\n    }\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `feature_set_enrichment` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {boolean} parameters.skip - Whether to skip the preparation of feature set collections.\n     * If `true`, none of the other methods (e.g., {@linkcode FeatureSetEnrichmentState#computeEnrichment computeEnrichment},\n     * {@linkcode FeatureSetEnrichmentState#computePerCellScores computePerCellScores}) should be called.\n     * @param {boolean} parameters.guess_ids - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column`, `gene_id_type`.\n     * @param {Array} parameters.species - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be a taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) supported by **gesel**.\n     * This is used internally to filter `collections` to the entries relevant to these species. \n     * Ignored if `guess_ids = true`.\n     * @param {?(string|number)} parameters.gene_id_column - Name or index of the column of the RNA entry of\n     * {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `guess_ids = true`.\n     * @param {string} parameters.gene_id_type - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `guess_ids = true`.\n     * @param {number} parameters.top_markers - Number of top markers to use when testing for enrichment.\n     *\n     * @return The state is updated with new results.\n     */\n    async compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, FeatureSetEnrichmentState.defaults());\n        this.changed = false;\n\n        if (this.#inputs.changed) {\n            this.changed = true;\n        }\n        if (parameters.skip !== this.#parameters.skip) {\n            this.changed = true;\n        }\n\n        if (this.valid() && !parameters.skip) {\n            if (this.changed) { // Force an update.\n                this.#parameters = {};\n            }\n\n            let modified = await this.#manager.buildCollections(\n                this.#parameters, \n                parameters.guess_ids, \n                parameters.species, \n                parameters.gene_id_column, \n                parameters.gene_id_type, \n                () => this.#inputs.fetchFeatureAnnotations()[\"RNA\"],\n                () => this.#inputs.guessRnaFeatureTypes()\n            );\n            if (modified) {\n                this.changed = true;\n            }\n\n            if (parameters.top_markers !== this.#parameters.top_markers) {\n                this.changed = true;\n            }\n        }\n\n        this.#parameters = dereference_parameters(parameters);\n        return;\n    }\n}\n\n/*****************************\n ******** Standalone *********\n *****************************/\n\n/**\n * Standalone version of {@linkplain FeatureSetEnrichmentState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own annotations to prepare the collections for enrichment calculations.\n * Users should await on the return value of the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method after construction.\n * Once resolved, other methods in this class may be used.\n *\n * This class uses the [**gesel**](https://npmjs.org/package/gesel) package to download the default gene set databases for the relevant organisms.\n * Its behavior can be tuned by setting global **gesel** variables, e.g., using the [`referenceDownload`](https://ltla.github.io/gesel/global.html#referenceDownload) function.\n */\nexport class FeatureSetEnrichmentStandalone {\n    #annotations;\n    #guesses;\n\n    #normalized;\n    #block;\n    #backmap;\n\n    #pre_parameters;\n    #parameters;\n    #manager;\n\n    /**\n     * @param {external:DataFrame} annotations - A {@linkplain external:DataFrame DataFrame} of per-gene annotations, where each row corresponds to a gene.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(external:ScranMatrix)} [options.normalized=null] - A {@linkcode external:ScranMatrix ScranMatrix} of log-normalized expression values,\n     * to be used in {@linkcode FeatureSetEnrichmentStandalone#computePerCellScores FeatureSetEnrichmentStandalone.computePerCellScores}.\n     * Each row corresponds to a gene in the same order as `annotations`. \n     * @param {?(Array|TypedArray)} [options.block=null] - Array of length equal to the number of columns in `normalized`, containing the block assignments for each column. \n     * If `null`, all columns are assigned to the same block.\n     */\n    constructor(annotations, { normalized = null, block = null } = {}) {\n        this.#annotations = annotations;\n        this.#guesses = null;\n\n        this.#normalized = null;\n        this.#block = null;\n        this.#backmap = null;\n\n        if (normalized !== null) {\n            if (normalized.numberOfRows() !== this.#annotations.numberOfRows()) {\n                throw new Error(\"number of rows of 'annotations' and 'normalized' should be identical\");\n            }\n\n            if (block !== null) {\n                if (normalized.numberOfColumns() !== block.length) {\n                    throw new Error(\"number of columns of 'normalized' should equal the length of 'block'\");\n                }\n\n                let dump = utils.subsetInvalidFactors([ block ]);\n                if (dump.retain !== null) {\n                    this.#normalized = scran.subsetColumns(normalized, dump.retain);\n                    this.#backmap = dump.retain;\n                } else {\n                    this.#normalized = normalized.clone();\n                }\n\n                this.#block = dump.arrays[0].ids;\n            } else {\n                this.#normalized = normalized.clone();\n            }\n        }\n\n        this.#pre_parameters = FeatureSetEnrichmentStandalone.defaults();\n        this.#parameters = {};\n        this.#manager = new FeatureSetManager; \n    }\n\n    #guessFeatureTypes() {\n        if (this.#guesses == null) {\n            this.#guesses = utils.guessFeatureTypes(this.#annotations);\n        }\n        return this.#guesses;\n    }\n\n    // Testing functions to check that the sanitization worked correctly.\n    _peekMatrices() {\n        return this.#normalized;\n    }\n\n    _peekBlock() {\n        return this.#block;\n    }\n\n    /**\n     * Frees all resources associated with this instance.\n     */\n    free() {\n        scran.free(this.#block);\n        scran.free(this.#normalized);\n        this.#manager.free();\n        return; // nothing extra to free here.\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode FeatureSetEnrichmentStandalone#setParameters setParameters} for details.\n     */\n    static defaults() {\n        return all_defaults();\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode FeatureSetEnrichmentStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see {@linkcode FeatureSetEnrichmentState#compute FeatureSetEnrichmentState.compute} for details.\n     *\n     * @return The object is updated with new parameters.\n     * Note that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method should be called in order for the new parameters to take effect.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, FeatureSetEnrichmentStandalone.defaults(), [\"automatic\"]);\n\n        // For some back-compatibility.\n        if (typeof parameters.guess_ids == \"undefined\") {\n            parameters.guess_ids = parameters.automatic;\n        }\n\n        this.#pre_parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * This should be called after construction and/or {@linkcode FeatureSetEnrichmentStandalone#setParameters setParameters}. \n     * Users should wait for the return value to resolve before calling any other methods of this class.\n     * \n     * @return Feature set collections are loaded into memory. \n     * @async\n     */\n    async ready() {\n        let { guess_ids, species, gene_id_column, gene_id_type, top_markers } = this.#pre_parameters;\n\n        // For some back-compatibility.\n        if (typeof guess_ids == \"undefined\") {\n            guess_ids = parameters.automatic;\n        }\n\n        await this.#manager.buildCollections(\n            this.#parameters,\n            guess_ids, \n            species, \n            gene_id_column, \n            gene_id_type, \n            () => this.#annotations,\n            () => this.#guessFeatureTypes()\n        );\n\n        this.#parameters = this.#pre_parameters;\n    }\n\n    /**\n     * Obtain the details about the feature set collections in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {object} Object containing the details about the available feature set collections,\n     * see {@linkcode FeatureSetEnrichmentState#fetchCollectionDetails FeatureSetEnrichmentState.fetchCollectionDetails} for more details.\n     */\n    fetchCollectionDetails() {\n        return this.#manager.fetchCollectionDetails();\n    }\n\n    /**\n     * Obtain the details about the feature sets in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {object} Object containing the details about the available feature sets,\n     * see {@linkcode FeatureSetEnrichmentState#fetchSetDetails FeatureSetEnrichmentState.fetchSetDetails} for more details.\n     */\n    fetchSetDetails() {\n        return this.#manager.fetchSetDetails();\n    }\n\n    /**\n     * Obtain the size of the universe of features that were successfully mapped to features in the reference database.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @return {number} Number of features from the input dataset that were successfully mapped to at least one gene in the reference database.\n     */\n    fetchUniverseSize() {\n        return this.#manager.fetchUniverseSize();\n    }\n\n    /**\n     * Compute enrichment of top markers in each feature set.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {external:ScoreMarkersResults} markers - Marker detection results for an RNA modality.\n     * @param {number} group - Group index of interest.\n     * @param {string} effect_size - Effect size to use for ranking.\n     * This should be one of `\"cohen\"`, `\"auc\"`, `\"lfc\"` or `\"delta_detected\"`.\n     * @param {string} summary - Summary statistic to use for ranking.\n     * This should be one of `\"min\"`, `\"mean\"` or `\"min_rank\"`.\n     *\n     * @return {object} Object containing statistics for the enrichment of the top marker genes in each feature set.\n     * See {@linkcode FeatureSetEnrichmentState#computeEnrichment FeatureSetEnrichmentState.computeEnrichment} for more details.\n     */\n    computeEnrichment(markers, group, effect_size, summary) {\n        return this.#manager.computeEnrichment(group, effect_size, summary, markers, this.#parameters.top_markers);\n    }\n\n    /**\n     * Extract row indices of the members of a desired feature set of interest.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentStandalone#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Int32Array} Array containing the row indices of the RNA count matrix corresponding to the genes in the specified set.\n     */\n    fetchFeatureSetIndices(set_id) {\n        return this.#manager.fetchFeatureSetIndices(set_id);\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#pre_parameters);\n    }\n\n    /**\n     * Compute per-cell scores for the activity of a feature set.\n     * It is assumed that the {@linkcode FeatureSetEnrichmentStandalone#ready ready} method has already resolved before calling this method.\n     *\n     * @param {number} set_id - Feature set ID, defined as an index into the arrays returned by {@linkcode FeatureSetEnrichmentStandalone#fetchSetDetails fetchSetDetails}.\n     *\n     * @return {Object} Object containing the per-cell scores for the feature set activity.\n     * See {@linkcode FeatureSetEnrichmentState#computePerCellScores FeatureSetEnrichmentState.computePerCellScores} for more details.\n     */\n    computePerCellScores(set_id) {\n        if (this.#normalized == null) {\n            throw new Error(\"no normalized matrix supplied in constructor\");\n        }\n\n        let output = this.#manager.computePerCellScores(set_id, this.#normalized, this.#block);\n\n        if (this.#backmap !== null) {\n            let backfilled = new Float64Array(output.scores.length);\n            backfilled.fill(Number.NaN);\n            this.#backmap.forEach((x, i) => {\n                backfilled[x] = output.scores[i];\n            });\n            output.scores = backfilled;\n        }\n\n        return output;\n    }\n}\n","import { DataFrame, List, IntegerList, NumberList, BooleanList, StringList } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { joinPath, formatNumberArrayForHdf5, formatIntegerArrayForHdf5, formatStringArrayForHdf5, formatBooleanArrayForHdf5, jsonBuffer } from \"./utils.js\";\nimport { readAnnotatedMetadata, saveAnnotatedMetadata } from \"./metadata.js\";\n\n/**\n * A data frame of columnar data.\n * @external DataFrame\n * @see {@link https://ltla.github.io/bioconductor.js/DataFrame.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:DataFrame DataFrame}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function|boolean} [options.DataFrame_readNested=true] - How to read columns containing nested objects.\n * If `true`, {@linkcode readObject} is used, while if `false`, nested objects will be skipped.\n * If a function is provided, it should accept `nrow` (the number of rows in the data frame) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `nrow`. \n * @param {function|boolean} [options.DataFrame_readMetadata=true] - How to read the metadata.\n * If `true`, {@linkcode readObject} is used, while if `false`, metadata will be skipped.\n * If a function is provided, it should accept `path`, `metadata`, `globals` and `options` (as described above), and return a {@link external:List List}.\n * @param {boolean} [options.DataFrame_toTypedArray=false] - Whether to report integer/number vectors without missing values as TypedArrays.\n * If `false`, vectors are reported as instances of an appropriately-typed {@link List} subclass.\n *\n * @return {external:DataFrame} The data frame.\n * @async\n */\nexport async function readDataFrame(path, metadata, globals, options = {}) {\n    let read_nested = true; \n    if (\"DataFrame_readNested\" in options) {\n        read_nested = options.DataFrame_readNested;\n    } \n    let typedarray = true;\n    if (\"DataFrame_toTypedArray\" in options) {\n        typedarray = options.DataFrame_toTypedArray;\n    }\n\n    let fhandle = await globals.h5open(joinPath(path, \"basic_columns.h5\")); \n    let handle_stack = [fhandle];\n    try {\n        let ghandle = fhandle.open(\"data_frame\");\n        handle_stack.push(ghandle);\n        let dhandle = ghandle.open(\"data\");\n        handle_stack.push(dhandle);\n\n        let cnhandle = ghandle.open(\"column_names\");\n        handle_stack.push(cnhandle);\n        let nrows = Number(ghandle.readAttribute(\"row-count\").values[0]);\n        let colnames = cnhandle.values();\n        cnhandle.close();\n        handle_stack.pop();\n\n        let collected = {};\n        let skip_nested = false;\n        let kids = dhandle.children();\n        for (const [i, k] of Object.entries(colnames)) {\n            let iname = String(i)\n            if (kids.indexOf(iname) < 0) {\n                if (read_nested !== false) {\n                    let nest_path = joinPath(path, \"other_columns\", iname);\n                    let nest_meta = await readObjectFile(nest_path, globals);\n                    if (read_nested === true) {\n                        collected[k] = await readObject(nest_path, nest_meta, globals, options);\n                    } else {\n                        collected[k] = await read_nested(nrows, nest_path, nest_meta, globals, options);\n                    }\n                } else {\n                    skip_nested = true;\n                }\n                continue;\n            }\n\n            let child_handle = dhandle.open(iname);\n            handle_stack.push(child_handle);\n\n            if (child_handle instanceof H5DataSet) {\n                let vals;\n                let rawvals = child_handle.values();\n                let type = child_handle.readAttribute(\"type\").values[0];\n\n                let child_attrs = child_handle.attributes();\n                let has_missing = child_attrs.indexOf(\"missing-value-placeholder\") >= 0;\n                let missing_attr;\n                if (has_missing) {\n                    missing_attr = child_handle.readAttribute(\"missing-value-placeholder\").values[0];\n                }\n\n                if (type == \"number\") {\n                    if (has_missing || !typedarray) {\n                        vals = Array.from(rawvals)\n                        if (Number.isNaN(missing_attr)) {\n                            for (let i = 0; i < vals.length; i++) {\n                                if (Number.isNaN(vals[i])) {\n                                    vals[i] = null;\n                                }\n                            }\n                        } else {\n                            for (let i = 0; i < vals.length; i++) {\n                                if (vals[i] == missing_attr) {\n                                    vals[i] = null;\n                                }\n                            }\n                        }\n                        vals = new NumberList(vals);\n                    } else {\n                        vals = new Float64Array(rawvals); // force it to be floating-point.\n                    }\n\n                } else if (type == \"boolean\") {\n                    vals = new Array(rawvals.length)\n                    if (has_missing) {\n                        for (let i = 0; i < rawvals.length; i++) {\n                            if (rawvals[i] == missing_attr) {\n                                vals[i] = null;\n                            } else {\n                                vals[i] = (rawvals[i] != 0);\n                            }\n                        }\n                    } else {\n                        for (let i = 0; i < rawvals.length; i++) {\n                            vals[i] = (rawvals[i] != 0);\n                        }\n                    }\n                    vals = new BooleanList(vals);\n\n                } else if (type == \"integer\") {\n                    if (has_missing || !typedarray) {\n                        vals = Array.from(rawvals);\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                        vals = new IntegerList(vals);\n                    } else {\n                        vals = new Int32Array(rawvals);\n                    }\n\n                } else if (type == \"string\") {\n                    vals = rawvals.slice(); // make a copy, to be safe.\n                    if (has_missing) {\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                    }\n                    vals = new StringList(vals);\n\n                } else {\n                    throw new Error(\"unknown type '\" + type + \"' in column '\" + k + \"' of a DataFrame at '\" + path + \"'\");\n                }\n\n                collected[k] = vals;\n\n            } else if (child_handle instanceof H5Group) {\n                let type = child_handle.readAttribute(\"type\").values[0];\n\n                if (type == \"factor\") {\n                    let lhandle = child_handle.open(\"levels\");\n                    handle_stack.push(lhandle);\n                    let levels = lhandle.values();\n                    lhandle.close();\n                    handle_stack.pop();\n\n                    let cohandle = child_handle.open(\"codes\");\n                    handle_stack.push(cohandle);\n                    let codes = cohandle.values();\n                    let code_attrs = cohandle.attributes();\n\n                    // Just reading factors as string vectors here, as we don't have a separate\n                    // representation in Javascript for a factor.\n                    let vals = Array(codes.length);\n                    if (code_attrs.indexOf(\"missing-value-placeholder\") >= 0) {\n                        let missing_attr = cohandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (let i = 0; i < codes.length; i++) {\n                            if (codes[i] == missing_attr) {\n                                vals[i] = null;\n                            } else {\n                                vals[i] = levels[codes[i]];\n                            }\n                        }\n                    } else {\n                        for (let i = 0; i < codes.length; i++) {\n                            vals[i] = levels[codes[i]];\n                        }\n                    }\n\n                    collected[k] = new StringList(vals);\n                    cohandle.close();\n                    handle_stack.pop();\n\n                } else if (type == \"vls\") {\n                    let hhandle = child_handle.open(\"heap\");\n                    handle_stack.push(hhandle);\n                    let heap = hhandle.values();\n                    hhandle.close();\n                    handle_stack.pop();\n\n                    let phandle = child_handle.open(\"pointers\");\n                    handle_stack.push(phandle);\n                    let pointers = phandle.values();\n                    let pointer_attrs = phandle.attributes();\n\n                    let vals = new Array(pointers.length);\n                    let dec = new TextDecoder;\n                    for (let i = 0; i < pointers.length; i++) {\n                        const { offset, length } = pointers[i];\n                        let current = heap.slice(Number(offset), Number(offset + length));\n                        let early = current.indexOf(0);\n                        if (early >= 0) {\n                            current = current.slice(0, early);\n                        }\n                        vals[i] = dec.decode(current);\n                    }\n\n                    if (pointer_attrs.indexOf(\"missing-value-placeholder\") >= 0) {\n                        let missing_attr = phandle.readAttribute(\"missing-value-placeholder\").values[0];\n                        for (let i = 0; i < vals.length; i++) {\n                            if (vals[i] == missing_attr) {\n                                vals[i] = null;\n                            }\n                        }\n                    }\n\n                    collected[k] = new StringList(vals);\n                    phandle.close();\n                    handle_stack.pop();\n\n                } else {\n                    throw new Error(\"unknown type '\" + type + \"' in column '\" + k + \"' of a DataFrame at '\" + path + \"'\");\n                }\n\n            } else {\n                throw new Error(\"unknown type for column '\" + k + \"' at path '\" + path + \"'\");\n            }\n\n            child_handle.close();\n            handle_stack.pop();\n        }\n\n        let rownames = null;\n        let gkids = ghandle.children();\n        if (gkids.indexOf(\"row_names\") >= 0) {\n            let rnhandle = ghandle.open(\"row_names\");\n            handle_stack.push(rnhandle);\n            rownames = rnhandle.values();\n            rnhandle.close();\n            handle_stack.pop();\n        }\n\n        if (skip_nested) {\n            let new_colnames = [];\n            for (const cn of colnames) {\n                if (cn in collected) {\n                    new_colnames.push(cn);\n                }\n            }\n            colnames = new_colnames;\n        }\n\n        let metadata = await readAnnotatedMetadata(joinPath(path, \"other_annotations\"), globals, options, \"DataFrame_readMetadata\")\n        return new DataFrame(collected, { columnOrder: colnames, numberOfRows: nrows, rowNames: rownames, metadata: metadata });\n\n    } finally {\n        for (const handle of handle_stack.toReversed()) {\n            handle.close();\n        }\n        await globals.h5close(fhandle);\n    }\n}\n\n/**\n * @param {external:DataFrame} x - The data frame.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function} [?options.DataFrame_saveOther=null] - Function to save custom class instances as columns of a data frame, without resorting to a reference to an external object.\n * This should accept `y`, an instance of a custom object; `handle`, the {@link H5Group} in which `y` is to be saved; and `name`, the name of the child of `handle` in which to save `y`. \n * It should return `true` if `y` was saved and `false` otherwise (e.g., if it does not know how to handle the class of`y`).\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveDataFrame(x, path, globals, options = {}) {\n    await globals.mkdir(path);\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer({ type: \"data_frame\", data_frame: { version: \"1.1\" } }));\n\n    let externals = {};\n    let success = false;\n\n    let fhandle = await globals.h5create(joinPath(path, \"basic_columns.h5\"));\n    let handle_stack = [fhandle];\n    try {\n        let ghandle = fhandle.createGroup(\"data_frame\");\n        handle_stack.push(ghandle);\n        ghandle.writeAttribute(\"row-count\", \"Uint64\", [], [x.numberOfRows()]);\n        ghandle.createDataSet(\"column_names\", \"String\", [ x.numberOfColumns() ], { data: x.columnNames() }).close();\n        if (x.rowNames() != null) {\n            ghandle.createDataSet(\"row_names\", \"String\", [ x.numberOfRows() ], { data: x.rowNames() }).close();\n        }\n\n        let dhandle = ghandle.createGroup(\"data\");\n        for (const [i, k] of Object.entries(x.columnNames())) {\n            let iname = String(i);\n            let col = x.column(k);\n\n            if (col instanceof Uint8Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint8\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int8Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int8\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Uint16Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint16\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int16Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int16\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Uint32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Uint32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Int32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Int32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"integer\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BigUint64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BigInt64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]); // only up to int32 is supported by 'integer'.\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Float32Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float32\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Float64Array) {\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: col });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof IntegerList) {\n                let formatted = formatIntegerArrayForHdf5(col.toArray());\n                let dtype;\n                let htype;\n                if (formatted.integer) {\n                    dtype = \"integer\";\n                    htype = \"Int32\";\n                } else {\n                    dtype = \"number\";\n                    htype = \"Float64\";\n                }\n                let chandle = dhandle.createDataSet(iname, htype, [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [dtype]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", htype, [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof NumberList) {\n                let formatted = formatNumberArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"Float64\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"Float64\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof StringList) {\n                let formatted = formatStringArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"String\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"string\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"String\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof BooleanList) {\n                let formatted = formatBooleanArrayForHdf5(col.toArray());\n                let chandle = dhandle.createDataSet(iname, \"Int8\", [ formatted.data.length ], { data: formatted.data });\n                handle_stack.push(chandle);\n                chandle.writeAttribute(\"type\", \"String\", [], [\"boolean\"]);\n                if (formatted.placeholder !== null) {\n                    chandle.writeAttribute(\"missing-value-placeholder\", \"Int8\", [], [formatted.placeholder]);\n                }\n                chandle.close();\n                handle_stack.pop();\n\n            } else if (col instanceof Array) {\n                // Try to guess the type of everything.\n                let types = new Set;\n                let has_missing = false;\n                for (const entry of col) {\n                    if (entry == null) {\n                        has_missing = true;\n                    } else {\n                        types.add(typeof entry);\n                    }\n                }\n\n                let okay = false;\n                if (types.size == 0) {\n                    let chandle = dhandle.createDataSet(iname, \"Uint8\", [ df.numberOfRows() ], { data: new Uint8Array(df.numberOfRows()) });\n                    handle_stack.push(chandle);\n                    chandle.writeAttribute(\"type\", \"String\", [], [ \"boolean\" ]);\n                    chandle.close();\n                    handle_stack.pop();\n                    okay = true;\n\n                } else if (types.size == 1) {\n                    // Javascript doesn't have native integers, so we'll save it all as 'number'.\n                    if (types.has(\"number\")) {\n                        let formatted = formatNumberArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"Float64\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"number\"]);\n                        if (formatted.placeholder !== null) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"Float64\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n\n                    } else if (types.has(\"boolean\")) {\n                        let formatted = formatBooleanArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"Uint8\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"boolean\"]);\n                        if (formatted.placeholder !== null) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"Uint8\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n\n                    } else if (types.has(\"string\")) {\n                        let formatted = formatStringArrayForHdf5(col);\n                        let chandle = dhandle.createDataSet(iname, \"String\", [ col.length ], { data: formatted.data });\n                        handle_stack.push(chandle);\n                        chandle.writeAttribute(\"type\", \"String\", [], [\"string\"]);\n                        if (has_missing) {\n                            chandle.writeAttribute(\"missing-value-placeholder\", \"String\", [], [ formatted.placeholder ]);\n                        }\n                        chandle.close();\n                        handle_stack.pop();\n                        okay = true;\n                    }\n                }\n\n                if (!okay) {\n                    externals[iname] = new List(col);\n                }\n\n            } else {\n                let handled = false;\n                if (\"DataFrame_saveOther\" in options) {\n                    handled = options.DataFrame_saveOther(col, dhandle, iname);\n                }\n                if (!handled) {\n                    externals[iname] = col;\n                }\n            }\n        }\n\n        success = true;\n    } finally {\n        for (const handle of handle_stack.toReversed()) {\n            handle.close();\n        }\n        await globals.h5finish(fhandle, !success);\n    }\n\n    let external_array = Object.entries(externals);\n    if (external_array.length > 0) {\n        let other_dir = joinPath(path, \"other_columns\");\n        await globals.mkdir(other_dir);\n        for (const [iname, col] of external_array) {\n            await saveObject(col, joinPath(other_dir, iname), globals, options);\n        }\n    }\n\n    await saveAnnotatedMetadata(x.metadata(), joinPath(path, \"other_annotations\"), globals, options);\n}\n","import * as wa from \"wasmarrays.js\";\nimport * as bioc from \"bioconductor\";\n\n// Monkey-patching these methods so that we can use these WasmArrays as columns in a bioc.DataFrame.\nwa.Uint8WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\nwa.Int32WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\nwa.Float64WasmArray.prototype._bioconductor_LENGTH = function() { return this.length; };\n\nexport function formatColumnData(state, all_modalities, main_modality, all_other_metadata, store_per_modality) {\n    let keep_raw = state.cell_filtering.fetchKeep();\n    let keep = [];\n    if (keep_raw !== null) {\n        keep_raw.forEach((x, i) => {\n            if (x) { keep.push(i); }\n        });\n    }\n\n    let all_coldata = {};\n    {\n        let full = state.inputs.fetchCellAnnotations();\n        all_coldata[main_modality] = (keep_raw === null ? full : bioc.SLICE(full, keep));\n\n        let nrows = all_coldata[main_modality].numberOfRows();\n        for (const k of all_modalities) {\n            if (k !== main_modality) {\n                all_coldata[k] = new bioc.DataFrame({}, { numberOfRows: nrows });\n            }\n        }\n    }\n\n    // Quality control.\n    if (state.rna_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::RNA::quality_control\");\n        let target = (store_per_modality ? \"RNA\" : main_modality);\n\n        let rdf = all_coldata[target];\n        rdf = rdf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().sum({ copy: false })));\n        rdf = rdf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().detected({ copy: false })));\n        rdf = rdf.setColumn(prefix + \"::proportions\", state.cell_filtering.applyFilter(state.rna_quality_control.fetchMetrics().subsetProportion(0, { copy: false })));\n        all_coldata[target] = rdf;\n\n        all_other_metadata[target].set(\n            prefix,\n            { \n                \"filters\": {\n                    \"sums\": state.rna_quality_control.fetchFilters().sum(),\n                    \"detected\": state.rna_quality_control.fetchFilters().detected(),\n                    \"proportions\": state.rna_quality_control.fetchFilters().subsetProportion(0)\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (state.adt_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::ADT::quality_control\");\n        let target = (store_per_modality ? \"ADT\" : main_modality);\n\n        let adf = all_coldata[target];\n        adf = adf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().sum({ copy: false })));\n        adf = adf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().detected({ copy: false })));\n        adf = adf.setColumn(prefix + \"::igg_totals\", state.cell_filtering.applyFilter(state.adt_quality_control.fetchMetrics().subsetSum(0, { copy: false })));\n        all_coldata[target] = adf;\n\n        all_other_metadata[target].set(\n            prefix,\n            {\n                \"filters\": {\n                    \"detected\": state.adt_quality_control.fetchFilters().detected(),\n                    \"igg_totals\": state.adt_quality_control.fetchFilters().subsetSum(0)\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (state.crispr_quality_control.valid()) {\n        let prefix = (store_per_modality ? \"kana::quality_control\" : \"kana::CRISPR::quality_control\");\n        let target = (store_per_modality ? \"CRISPR\" : main_modality);\n\n        let cdf = all_coldata[target];\n        cdf = cdf.setColumn(prefix + \"::sums\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().sum({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::detected\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().detected({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::max_proportion\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().maxProportion({ copy: false })));\n        cdf = cdf.setColumn(prefix + \"::max_index\", state.cell_filtering.applyFilter(state.crispr_quality_control.fetchMetrics().maxIndex({ copy: false })));\n        all_coldata[target] = cdf;\n\n        all_other_metadata[target].set(\n            prefix,\n            {\n                \"filters\": {\n                    \"max_count\": state.crispr_quality_control.fetchFilters().maxValue()\n                }\n            },\n            { inPlace: true }\n        );\n    }\n\n    if (keep_raw !== null) {\n        all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::quality_control::retained_indices\", keep);\n    }\n\n    // Size Factors.\n    if (state.rna_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::RNA::size_factors\");\n        let target = (store_per_modality ? \"RNA\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.rna_normalization.fetchSizeFactors());\n    }\n\n    if (state.adt_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::ADT::size_factors\");\n        let target = (store_per_modality ? \"ADT\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.adt_normalization.fetchSizeFactors());\n    }\n\n    if (state.crispr_normalization.valid()) {\n        let field = (store_per_modality ? \"kana::size_factors\" : \"kana::CRISPR::size_factors\");\n        let target = (store_per_modality ? \"CRISPR\" : main_modality);\n        all_coldata[target] = all_coldata[target].setColumn(field, state.crispr_normalization.fetchSizeFactors());\n    }\n\n    {\n        // Incrementing to avoid cluster names starting from 0. Note that there's\n        // no need to respect the reportOneIndex setting, as cluster names are\n        // not indices with respect to anything. The only thing they need to match\n        // with is the marker table names, and we increment there (in markers.js) as well.\n        let clusters = state.choose_clustering.fetchClusters().map(x => x + 1);\n        all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::clusters\", clusters);\n    }\n\n    {\n        let block = state.cell_filtering.fetchFilteredBlock();\n        if (block !== null) {\n            let stringy = new Array(block.length);\n            let levels = state.inputs.fetchBlockLevels();\n            block.forEach((x, i) => { stringy[i] = levels[x]; }); \n            all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::block\", stringy);\n        }\n    }\n\n    // Custom selections, stored as boolean arrays.\n    {\n        let customs = state.custom_selections.fetchSelections({ copy: false });\n        let nrows = all_coldata[main_modality].numberOfRows();\n        for (const [v, k] of Object.entries(customs)) {\n            let as_bool = new Array(nrows);\n            as_bool.fill(false);\n            k.forEach(index => { as_bool[index] = true; });\n            all_coldata[main_modality] = all_coldata[main_modality].setColumn(\"kana::custom_selections::\" + v, as_bool);\n        }\n    }\n\n    return all_coldata;\n}\n","import { fetchSetSizes } from \"./fetchSingleSet.js\";\nimport { fetchSetsForGene, effectiveNumberOfGenes } from \"./fetchSetsForGene.js\";\nimport * as enrich from \"./testEnrichment.js\";\n\n/**\n * @param {string} species - The taxonomy ID of the species of interest, e.g., `\"9606\"` for human.\n * @param {Array} genes - Array of unique integers containing user-supplied gene IDs, see {@linkcode fetchAllGenes} for details.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.includeSize=true] - Whether to include the size of each set in the output.\n * @param {boolean} [options.testEnrichment=true] - Whether to compute the enrichment p-value for each set with {@linkcode testEnrichment}.\n * The list and universe sizes will only count genes that are involved in at least one set, by checking {@linkcode fetchSetsForGene} and {@linkcode effectiveNumberOfGenes} respectively.\n * @param {boolean} [options.forceDownload=false] - See {@linkcode fetchSetsForGene}.\n *\n * @return {Array} An array of objects, where each object corresponds to a set that has non-zero overlaps with `genes`.\n * Each object contains:\n *\n * - `id`: the ID of the set in {@linkcode fetchAllSets}.\n * - `count`: the number of genes in the set that overlap with genes in `genes`.\n * - `size`: the size of each set.\n *   Only included if `includeSize = true`.\n * - `pvalue`: the enrichment p-value.\n *   Only included if `testEnrichment = true`.\n *\n * @async\n */\nexport async function findOverlappingSets(species, genes, { includeSize = true, testEnrichment = true, forceDownload = false } = {}) {\n    await fetchSetsForGene(species, null, { forceDownload });\n\n    let promises = [];\n    let queried = new Set;\n    for (const g of genes) {\n        if (!queried.has(g)) {\n            promises.push(fetchSetsForGene(species, g));\n            queried.add(g);\n        }\n    }\n\n    let collected = await Promise.all(promises);\n    let output = countSetOverlaps(collected);\n\n    let sets_sizes = (includeSize || testEnrichment ? await fetchSetSizes(species) : null);\n    if (includeSize) {\n        for (const details of output) {\n            details.size = sets_sizes[details.id];\n        }\n    }\n    if (testEnrichment) {\n        let effective_list = 0; // only considering genes involved in at least one set.\n        for (const v of collected) {\n            effective_list += (v.length > 0);\n        }\n        let universe = await effectiveNumberOfGenes(species);\n        for (const details of output) {\n            details.pvalue = enrich.testEnrichment(details.count, effective_list, sets_sizes[details.id], universe);\n        }\n    }\n\n    return output;\n}\n\n/**\n * This is a utility function that is called internally by {@linkcode findOverlappingSets}.\n * However, it can be used directly to obtain overlap counts if the gene-to-set mappings are manually obtained.\n *\n * @param {Array} setsForSomeGenes - Array where each entry corresponds to a gene and contains an array of the set IDs containing that gene.\n * Each inner array is typically the result of calling {@linkcode fetchSetsForGene}.\n *\n * @return {Array} An array of objects, where each object corresponds to a set that is present in at least one entry of `setsForSomeGenes`.\n * Each object contains:\n *\n * - `id`: the ID of the set in {@linkcode fetchAllSets}.\n * - `count`: the number of genes in the set that overlap with genes in `genes`.\n */\nexport function countSetOverlaps(setsForSomeGenes) {\n    var set_count = new Map;\n    for (const found of setsForSomeGenes) {\n        for (const set of found) {\n            let current = set_count.get(set);\n            if (typeof current == \"undefined\") {\n                set_count.set(set, 1);\n            } else {\n                set_count.set(set, current + 1);\n            }\n        }\n    }\n\n    let output = [];\n    for (const [id, count] of set_count) {\n        let id0 = Number(id);\n        let details = { \n            \"id\": id0,\n            \"count\": count\n        };\n        output.push(details);\n    }\n\n    return output;\n}\n\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as afile from \"./abstract/file.js\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction load_listData_names(lhandle) {\n    let ndx = lhandle.findAttribute(\"names\");\n    if (ndx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let names;\n    try {\n        nhandle = lhandle.attribute(ndx);\n        names = nhandle.values();\n    } catch(e) {\n        throw new Error(\"failed to load listData names; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    if (names.length != lhandle.length()) {\n        throw new Error(\"expected names to have same length as listData\");\n    }\n    return names;\n}\n\nconst acceptable_df_subclasses = { \"DFrame\": \"S4Vectors\" };\n\nfunction load_data_frame(handle) {\n    check_class(handle, acceptable_df_subclasses, \"DFrame\");\n\n    let columns = {};\n    let colnames = [];\n    let lhandle;\n    try {\n        lhandle = handle.attribute(\"listData\");\n        if (!(lhandle instanceof scran.RdsGenericVector)) {\n            throw new Error(\"listData slot should be a generic list\");\n        }\n\n        colnames = load_listData_names(lhandle);\n        if (colnames == null) {\n            throw new Error(\"expected the listData list to be named\");\n        }\n\n        for (var i = 0; i < lhandle.length(); i++) {\n            let curhandle;\n            try {\n                curhandle = lhandle.load(i);\n\n                if (curhandle instanceof scran.RdsVector && !(curhandle instanceof scran.RdsGenericVector)) {\n                    let curcol = curhandle.values();\n\n                    // Expand factors, if we detect them.\n                    if (curhandle.findAttribute(\"class\") >= 0) {\n                        let clshandle;\n                        let levhandle;\n                        try {\n                            clshandle = curhandle.attribute(\"class\");\n                            if (clshandle.values().indexOf(\"factor\") >= 0 && curhandle.findAttribute(\"levels\") >= 0) {\n                                levhandle = curhandle.attribute(\"levels\");\n                                let copy = curcol.slice();\n                                copy.forEach((x, i) => { copy[i] = x - 1 }); // get back to 0-based indices.\n                                curcol = bioc.SLICE(levhandle.values(), copy);\n                            }\n                        } finally {\n                            scran.free(clshandle);\n                            scran.free(levhandle);\n                        }\n                    }\n\n                    columns[colnames[i]] = curcol;\n\n                } else if (curhandle instanceof scran.RdsS4Object && check_acceptable_class(curhandle, acceptable_df_subclasses)) {\n                    // Handle nested DataFrames.\n                    columns[colnames[i]] = load_data_frame(curhandle);\n                }\n\n            } finally {\n                scran.free(curhandle);\n            }\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve data from DataFrame's listData; \" + e.message);\n    } finally {\n        scran.free(lhandle);\n    }\n\n    // Loading the row names.\n    let rnhandle;\n    let rownames = null;\n    try {\n        rnhandle = handle.attribute(\"rownames\");\n        if (rnhandle instanceof scran.RdsStringVector) {\n            rownames = rnhandle.values();\n        }\n    } catch(e) {\n        throw new Error(\"failed to retrieve row names from DataFrame; \" + e.message);\n    } finally {\n        scran.free(rnhandle);\n    }\n\n    // Loading the number of rows.\n    let nrows = null;\n    if (colnames.length == 0 && rownames == null) {\n        let nrhandle;\n        try {\n            nrhandle = handle.attribute(\"nrows\");\n            if (!(nrhandle instanceof scran.RdsIntegerVector)) {\n                throw new Error(\"expected an integer vector as the 'nrows' slot\");\n            }\n            let NR = nrhandle.values();\n            if (NR.length != 1) {\n                throw new Error(\"expected an integer vector of length 1 as the 'nrows' slot\");\n            }\n            nrows = NR[0];\n        } catch (e) {\n            throw new Error(\"failed to retrieve nrows from DataFrame; \" + e.message);\n        } finally {\n            scran.free(nrhandle);\n        }\n    }\n\n    return new bioc.DataFrame(columns, { columnOrder: colnames, rowNames: rownames, numberOfRows: nrows });\n}\n\nfunction check_acceptable_class(handle, accepted) {\n    for (const [k, v] of Object.entries(accepted)) {\n        if (handle.className() == k && handle.packageName() == v) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction check_class(handle, accepted, base) {\n    if (!(handle instanceof scran.RdsS4Object)) {\n        throw new Error(\"expected an S4 object as the data frame\");\n    }\n    if (!check_acceptable_class(handle, accepted)) {\n        throw new Error(\"object is not a \" + base + \" or one of its recognized subclasses\");\n    }\n}\n\nfunction extract_NAMES(handle) {\n    let nidx = handle.findAttribute(\"NAMES\");\n    if (nidx < 0) {\n        return null;\n    }\n\n    let nhandle;\n    let output = null;\n    try {\n        nhandle = handle.attribute(nidx);\n        if (nhandle instanceof scran.RdsStringVector) {\n            output = nhandle.values();\n        }\n    } catch(e) {\n        throw new Error(\"failed to extract NAMES; \" + e.message);\n    } finally {\n        scran.free(nhandle);\n    }\n\n    return output;\n}\n\nfunction extract_features(handle) {\n    let rowdata;\n    let names = null;\n\n    let rrdx = handle.findAttribute(\"rowRanges\");\n    if (rrdx < 0) {\n        // This is a base SummarizedExperiment.\n        let rhandle;\n        try {\n            rhandle = handle.attribute(\"elementMetadata\");\n            rowdata = load_data_frame(rhandle);\n        } catch(e) {\n            throw new Error(\"failed to extract features from the rowData; \" + e.message);\n        } finally {\n            scran.free(rhandle);\n        }\n        names = extract_NAMES(handle);\n\n    } else {\n        // Everything else is assumed to be an RSE.\n        let rrhandle;\n        let output;\n        try {\n            rrhandle = handle.attribute(rrdx);\n            let ehandle = rrhandle.attribute(\"elementMetadata\");\n            try {\n                rowdata = load_data_frame(ehandle);\n            } catch(e) {\n                throw new Error(\"failed to extract mcols from the rowRanges; \" + e.message);\n            } finally {\n                scran.free(ehandle);\n            }\n\n            let pidx = rrhandle.findAttribute(\"partitioning\");\n            if (pidx < 0) { // if absent, we'll assume it's a GRanges.\n                let r2handle;\n                try {\n                    r2handle = rrhandle.attribute(\"ranges\");\n                    names = extract_NAMES(r2handle);\n                } catch(e) {\n                    throw new Error(\"failed to extract names from the rowRanges; \" + e.message);\n                } finally {\n                    scran.free(r2handle);\n                }\n            } else { // otherwise, it's a GRangesList.\n                let phandle;\n                try {\n                    phandle = rrhandle.attribute(pidx);\n                    names = extract_NAMES(phandle);\n                } catch(e) {\n                    throw new Error(\"failed to extract names from the rowRanges; \" + e.message);\n                } finally {\n                    scran.free(phandle);\n                }\n            }\n\n        } catch(e) {\n            throw new Error(\"failed to extract features from the rowRanges; \" + e.message);\n        } finally {\n            scran.free(rrhandle);\n        }\n    }\n\n    if (names !== null) {\n        rowdata.$setRowNames(names);\n    }\n    return rowdata;\n}\n\nfunction extract_assay_names(handle) {\n    let output;\n    let ahandle;\n    let dhandle;\n    let lhandle;\n\n    try {\n        ahandle = handle.attribute(\"assays\");\n        dhandle = ahandle.attribute(\"data\");\n        lhandle = dhandle.attribute(\"listData\");\n\n        output = load_listData_names(lhandle);\n        if (output == null) {\n            output = new Array(lhandle.length());\n            output.fill(\"\");\n        }\n    } catch(e) {\n        throw new Error(\"failed to extract assay data; \" + e.message);\n    } finally {\n        scran.free(ahandle);\n        scran.free(lhandle);\n        scran.free(dhandle);\n    }\n\n    return output;\n}\n\nfunction extract_assay(handle, assay, forceInteger) {\n    let output;\n    let ahandle;\n    let dhandle;\n    let lhandle;\n\n    try {\n        ahandle = handle.attribute(\"assays\");\n        dhandle = ahandle.attribute(\"data\");\n        lhandle = dhandle.attribute(\"listData\");\n\n        // Choosing the assay index.\n        let chosen = null;\n        if (typeof assay == \"string\") {\n            let names = load_listData_names(lhandle);\n            if (assay !== null && names != null) {\n                for (var n = 0; n < names.length; n++) {\n                    if (names[n] == assay) {\n                        chosen = n;\n                        break;\n                    }\n                }\n            }\n            if (chosen == null) {\n                throw new Error(\"no assay named '\" + assay + \"'\");\n            }\n        } else {\n            if (assay >= lhandle.length()) {\n                throw new Error(\"assay index \" + String(assay) + \" out of range\");\n            }\n            chosen = assay;\n        }\n\n        let xhandle;\n        try {\n            xhandle = lhandle.load(chosen);\n            output = scran.initializeSparseMatrixFromRds(xhandle, { forceInteger });\n        } catch(e) {\n            throw new Error(\"failed to initialize sparse matrix from assay; \" + e.message);\n        } finally {\n            scran.free(xhandle);\n        }\n\n    } catch(e) {\n        throw new Error(\"failed to extract assay data; \" + e.message);\n    } finally {\n        scran.free(ahandle);\n        scran.free(lhandle);\n        scran.free(dhandle);\n    }\n\n    return output;\n}\n\nfunction extract_main_exp_name(handle) {\n    let int_handle;\n    let name_handle;\n    let me_handle;\n\n    try {\n        let int_dx = handle.findAttribute(\"int_metadata\");\n        if (int_dx < 0) {\n            return \"\";\n        }\n        int_handle = handle.attribute(int_dx);\n\n        let name_dx = int_handle.findAttribute(\"names\");\n        if (name_dx < 0) {\n            return \"\";\n        }\n\n        name_handle = int_handle.attribute(name_dx);\n        let names = name_handle.values();\n        let me_dx = names.indexOf(\"mainExpName\");\n        if (me_dx < 0) {\n            return \"\";\n        }\n\n        me_handle = int_handle.load(me_dx);\n        let me_name = me_handle.values();\n        if (me_name.length != 1 || typeof me_name[0] !== \"string\") {\n            return \"\";\n        } else {\n            return me_name[0];\n        }\n    } finally {\n        scran.free(int_handle);\n        scran.free(name_handle);\n        scran.free(me_handle);\n    }\n}\n\nfunction extract_alt_exps(handle) {\n    let output = { handles: {}, order: [] };\n    let indx = handle.findAttribute(\"int_colData\");\n    if (indx < 0) {\n        return output;\n    }\n\n    let in_handle;\n    let inld_handle;\n    let innn_handle;\n    let ae_handle;\n    let aeld_handle;\n    let aenn_handle;\n\n    try {\n        in_handle = handle.attribute(indx);\n        let inld_dx = in_handle.findAttribute(\"listData\");\n        if (inld_dx < 0) {\n            return output;\n        }\n\n        inld_handle = in_handle.attribute(inld_dx);\n        let innn_dx = inld_handle.findAttribute(\"names\");\n        if (innn_dx < 0) {\n            return output;\n        }\n\n        innn_handle = inld_handle.attribute(innn_dx);\n        let in_names = innn_handle.values();\n        let ae_dx = in_names.indexOf(\"altExps\");\n        if (ae_dx < 0) {\n            return output;\n        }\n\n        ae_handle = inld_handle.load(ae_dx);\n        let aeld_dx = ae_handle.findAttribute(\"listData\");\n        if (aeld_dx < 0) {\n            return output;\n        }\n\n        aeld_handle = ae_handle.attribute(aeld_dx);\n        let aenn_dx = aeld_handle.findAttribute(\"names\");\n        if (aenn_dx < 0) {\n            return output;\n        }\n\n        aenn_handle = aeld_handle.attribute(aenn_dx);\n        let ae_names = aenn_handle.values();\n\n        for (var i = 0; i < ae_names.length; i++) {\n            let curhandle;\n            try {\n                curhandle = aeld_handle.load(i);\n                let asehandle = curhandle.attribute(\"se\");\n                output.handles[ae_names[i]] = asehandle;\n                output.order.push(ae_names[i]);\n                check_for_se(asehandle);\n            } catch (e) {\n                throw new Error(\"failed to load alternative Experiment '\" + ae_names[i] + \"'; \" + e.message);\n            } finally {\n                scran.free(curhandle);\n            }\n        }\n\n    } catch(e) {\n        for (const v of Object.values(output.handles)) {\n            scran.free(v);\n        }\n        throw e;\n\n    } finally {\n        scran.free(aenn_handle);\n        scran.free(aeld_handle);\n        scran.free(innn_handle);\n        scran.free(inld_handle);\n        scran.free(in_handle);\n    }\n\n    return output;\n}\n\nfunction extract_reduced_dims(handle) {\n    let output = { handles: {}, order: [] };\n    let indx = handle.findAttribute(\"int_colData\");\n    if (indx < 0) {\n        return output;\n    }\n\n    let in_handle;\n    let inld_handle;\n    let innn_handle;\n    let rd_handle;\n    let rdld_handle;\n    let rdnn_handle;\n\n    try {\n        in_handle = handle.attribute(indx);\n        let inld_dx = in_handle.findAttribute(\"listData\");\n        if (inld_dx < 0) {\n            return output;\n        }\n\n        inld_handle = in_handle.attribute(inld_dx);\n        let innn_dx = inld_handle.findAttribute(\"names\");\n        if (innn_dx < 0) {\n            return output;\n        }\n\n        innn_handle = inld_handle.attribute(innn_dx);\n        let in_names = innn_handle.values();\n        let rd_dx = in_names.indexOf(\"reducedDims\");\n        if (rd_dx < 0) {\n            return output;\n        }\n\n        rd_handle = inld_handle.load(rd_dx);\n        let rdld_dx = rd_handle.findAttribute(\"listData\");\n        if (rdld_dx < 0) {\n            return output;\n        }\n\n        rdld_handle = rd_handle.attribute(rdld_dx);\n        let rdnn_dx = rdld_handle.findAttribute(\"names\");\n        if (rdnn_dx < 0) {\n            return output;\n        }\n\n        rdnn_handle = rdld_handle.attribute(rdnn_dx);\n        let rd_names = rdnn_handle.values();\n\n        for (var i = 0; i < rd_names.length; i++) {\n            let curhandle;\n            try {\n                curhandle = rdld_handle.load(i);\n                let okay = false;\n\n                if (curhandle.type() == \"double\" && curhandle.findAttribute(\"dim\") >= 0) { // only accepting double-precision matrics.\n                    let dimhandle = curhandle.attribute(\"dim\");\n                    if (dimhandle.length() == 2) {\n                        output.handles[rd_names[i]] = { handle: curhandle, dimensions: dimhandle.values() };\n                        output.order.push(rd_names[i]);\n                        okay = true;\n                    }\n                }\n\n                if (!okay) {\n                    scran.free(curhandle);\n                }\n            } catch (e) {\n                throw new Error(\"failed to load reduced dimension '\" + rd_names[i] + \"'; \" + e.message);\n            }\n        }\n\n    } catch(e) {\n        for (const v of Object.values(output.handles)) {\n            scran.free(v.handle);\n        }\n        throw e;\n\n    } finally {\n        scran.free(rdnn_handle);\n        scran.free(rdld_handle);\n        scran.free(innn_handle);\n        scran.free(inld_handle);\n        scran.free(in_handle);\n    }\n\n    return output;\n}\n\nfunction check_for_se(handle) {\n    check_class(handle, { \n        \"SummarizedExperiment\": \"SummarizedExperiment\",\n        \"RangedSummarizedExperiment\": \"SummarizedExperiment\",\n        \"SingleCellExperiment\": \"SingleCellExperiment\",\n        \"SpatialExperiment\": \"SpatialExperiment\"\n    }, \"SummarizedExperiment\");\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset stored as a SummarizedExperiment object (or one of its subclasses) inside an RDS file.\n */\nexport class SummarizedExperimentDataset {\n    #rds_file;\n\n    #rds_handle;\n    #se_handle;\n\n    #main_exp_name;\n    #alt_handles;\n    #alt_handle_order;\n\n    #raw_features;\n    #raw_cells;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"rds\", file: fun(this.#rds_file) }];\n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} rdsFile - Contents of a RDS file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(rdsFile) {\n        if (rdsFile instanceof afile.SimpleFile) {\n            this.#rds_file = rdsFile;\n        } else {\n            this.#rds_file = new afile.SimpleFile(rdsFile);\n        }\n\n        this.#options = SummarizedExperimentDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode SummarizedExperimentDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            rnaCountAssay: 0, \n            adtCountAssay: 0, \n            crisprCountAssay: 0,\n            rnaExperiment: \"Gene Expression\", \n            adtExperiment: \"Antibody Capture\", \n            crisprExperiment: \"CRISPR Guide Capture\",\n            primaryRnaFeatureIdColumn: null, \n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null \n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode SummarizedExperimentDataset#load load} (but not {@linkcode SummarizedExperimentDataset#summary summary}).\n     * @param {string|number} [options.rnaCountAssay] - Name or index of the assay containing the RNA count matrix.\n     * @param {string|number} [options.adtCountAssay] - Name or index of the assay containing the ADT count matrix.\n     * @param {string|number} [options.crisprCountAssay] - Name or index of the assay containing the CRISPR count matrix.\n     * @param {?string} [options.rnaExperiment] - Name of the main/alternative experiment containing gene expression data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no RNA data is assumed to be present.\n     * @param {?string} [options.adtExperiment] - Name of the main/alternative experiment containing ADT data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no ADTs are assumed to be present.\n     * @param {?string} [options.crisprExperiment] - Name of the main/alternative experiment containing CRISPR guide data,\n     * as reported in the keys of the `modality_assay_names` of {@linkcode AbstractAlabasterDataset#summary summary}).\n     * If `i` is `null` or the name does not exist, it is ignored and no CRISPR guides are assumed to be present.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the primary identifier is defined as the existing row names.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the existing row names (if they exist) are used as the primary identifier.\n     * However, if no row names are present in the SummarizedExperiment, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode SummarizedExperimentDataset#load load} or {@linkcodeSummarizedExperimentDataset#summary summary}.\n     */\n    clear() {\n        scran.free(this.#se_handle);\n        if (typeof this.#alt_handles != 'undefined' && this.#alt_handles !== null) {\n            for (const v of Object.values(this.#alt_handles)) {\n                scran.free(v);\n            }\n        }\n        scran.free(this.#rds_handle);\n\n        this.#se_handle = null;\n        this.#alt_handles = null;\n        this.#rds_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"SummarizedExperiment\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #initialize() {\n        if (this.#rds_handle !== null) {\n            return;\n        }\n\n        this.#rds_handle = scran.readRds(this.#rds_file.content());\n        this.#se_handle = this.#rds_handle.value();\n        try {\n            check_for_se(this.#se_handle);\n            const { handles, order } = extract_alt_exps(this.#se_handle);\n            this.#alt_handles = handles;\n            this.#alt_handle_order = order;\n            this.#main_exp_name = extract_main_exp_name(this.#se_handle);\n        } catch (e) {\n            this.#se_handle.free();\n            this.#rds_handle.free();\n            throw e;\n        }\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#initialize();\n        this.#raw_features = {};\n        this.#raw_features[this.#main_exp_name] = extract_features(this.#se_handle);\n\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in this.#raw_features)) {\n                try {\n                    this.#raw_features[k] = extract_features(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#initialize();\n        let chandle = this.#se_handle.attribute(\"colData\");\n        try {\n            this.#raw_cells = load_data_frame(chandle);\n        } catch(e) {\n            throw new Error(\"failed to extract colData from a SummarizedExperiment; \" + e.message);\n        } finally {\n            scran.free(chandle);\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    If a modality's assays are unnamed, an array of empty strings is returned instead.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    summary({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let assays = {};\n        assays[this.#main_exp_name] = extract_assay_names(this.#se_handle);\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in assays)) {\n                try {\n                    assays[k] = extract_assay_names(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: assays\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode SummarizedExperimentDataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n\n        let fmapping = { \n            RNA: this.#options.rnaExperiment,\n            ADT: this.#options.adtExperiment,\n            CRISPR: this.#options.crisprExperiment\n        };\n\n        let preview = futils.extractRemappedPrimaryIds(this.#raw_features, this.#alt_handle_order, fmapping, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode SummarizedExperimentDataset#defaults defaults} or with {@linkcode SummarizedExperimentDataset#setOptions setOptions}.\n     */\n    load({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells\n        };\n\n        let mapping = { \n            RNA: { exp: this.#options.rnaExperiment, assay: this.#options.rnaCountAssay },\n            ADT: { exp: this.#options.adtExperiment, assay: this.#options.adtCountAssay },\n            CRISPR: { exp: this.#options.crisprExperiment, assay: this.#options.crisprCountAssay }\n        };\n\n        try {\n            for (const [k, v] of Object.entries(mapping)) {\n                if (v.exp === null) {\n                    continue;\n                }\n\n                let handle;\n                if (v.exp === this.#main_exp_name) {\n                    handle = this.#se_handle;\n                } else if (v.exp in this.#alt_handles) {\n                    handle = this.#alt_handles[v.exp];\n                } else {\n                    continue;\n                }\n\n                let loaded = extract_assay(handle, v.assay, true);\n                output.matrix.add(k, loaded);\n                output.features[k] = this.#raw_features[v.exp];\n            }\n\n            output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode SummarizedExperimentDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {SummarizedExperimentDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"rds\") {\n            throw new Error(\"expected exactly one file of type 'rds' for SummarizedExperiment unserialization\");\n        }\n        let output = new SummarizedExperimentDataset(files[0].file);\n        output.setOptions(options);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Pre-computed analysis results stored as a SummarizedExperiment object (or one of its subclasses) inside an RDS file.\n */\nexport class SummarizedExperimentResult {\n    #rds_file;\n\n    #rds_handle;\n    #se_handle;\n\n    #main_exp_name;\n    #alt_handles;\n    #alt_handle_order;\n\n    #raw_features;\n    #raw_cells;\n    #rd_handles;\n    #rd_handle_order;\n\n    #options;\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} rdsFile - Contents of a RDS file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(rdsFile) {\n        if (rdsFile instanceof afile.SimpleFile) {\n            this.#rds_file = rdsFile;\n        } else {\n            this.#rds_file = new afile.SimpleFile(rdsFile);\n        }\n\n        // Cloning to avoid pass-by-reference links.\n        this.#options = SummarizedExperimentResult.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode AbstractArtifactdbResults#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryAssay: 0,\n            isPrimaryNormalized: true,\n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode AbstractArtifactdbResult#load load} (but not {@linkcode AbstractArtifactdbResult#summary summary}).\n     * @param {object|string|number} [options.primaryAssay] - Assay containing the relevant data for each modality.\n     *\n     * - If a string, this is used as the name of the assay across all modalities.\n     * - If a number, this is used as the index of the assay across all modalities.\n     * - If any object, the key should be the name of a modality and the value may be either a string or number specifying the assay to use for that modality.\n     *   Modalities absent from this object will not be loaded.\n     * @param {object|boolean} [options.isPrimaryNormalized] - Whether or not the assay for a particular modality has already been normalized.\n     *\n     * - If a boolean, this is used to indicate normalization status of assays across all modalities.\n     *   If `false`, that modality's assay is assumed to contain count data and is subjected to library size normalization. \n     * - If any object, the key should be the name of a modality and the value should be a boolean indicating whether that modality's assay has been normalized.\n     *   Modalities absent from this object are assumed to have been normalized.\n     * @param {?Array} [options.reducedDimensionNames] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        // Cloning to avoid pass-by-reference links.\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = bioc.CLONE(v);\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory.\n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode SummarizedExperimentResult#load load} or {@linkcodeSummarizedExperimentResult#summary summary}.\n     */\n    clear() {\n        scran.free(this.#se_handle);\n\n        if (typeof this.#alt_handles != 'undefined' && this.#alt_handles !== null) {\n            for (const v of Object.values(this.#alt_handles)) {\n                scran.free(v);\n            }\n        }\n\n        if (typeof this.#rd_handles != 'undefined' && this.#rd_handles !== null) {\n            for (const v of Object.values(this.#rd_handles)) {\n                scran.free(v.handle);\n            }\n        }\n\n        scran.free(this.#rds_handle);\n\n        this.#se_handle = null;\n        this.#alt_handles = null;\n        this.#rds_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n    }\n\n    #initialize() {\n        if (this.#rds_handle !== null) {\n            return;\n        }\n\n        this.#rds_handle = scran.readRds(this.#rds_file.content());\n        this.#se_handle = this.#rds_handle.value();\n        try {\n            check_for_se(this.#se_handle);\n\n            {\n                const { handles, order } = extract_alt_exps(this.#se_handle);\n                this.#alt_handles = handles;\n                this.#alt_handle_order = order;\n                this.#main_exp_name = extract_main_exp_name(this.#se_handle);\n            }\n\n            {\n                const { handles, order } = extract_reduced_dims(this.#se_handle);\n                this.#rd_handles = handles;\n                this.#rd_handle_order = order;\n            }\n\n        } catch (e) {\n            this.#se_handle.free();\n            this.#rds_handle.free();\n            throw e;\n        }\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n\n        this.#initialize();\n        this.#raw_features = {};\n        this.#raw_features[this.#main_exp_name] = extract_features(this.#se_handle);\n\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in this.#raw_features)) {\n                try {\n                    this.#raw_features[k] = extract_features(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n\n        this.#initialize();\n        let chandle = this.#se_handle.attribute(\"colData\");\n        try {\n            this.#raw_cells = load_data_frame(chandle);\n        } catch(e) {\n            throw new Error(\"failed to extract colData from a SummarizedExperiment; \" + e.message);\n        } finally {\n            scran.free(chandle);\n        }\n\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode SummarizedExperimentResult#load load}.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     * \n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `modality_features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `modality_assay_names`: an object where each key is a modality name and each value is an Array containing the names of available assays for that modality.\n     *    Unnamed assays are represented as `null` names.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    summary({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let assays = {};\n        assays[this.#main_exp_name] = extract_assay_names(this.#se_handle);\n        for (const [k, v] of Object.entries(this.#alt_handles)) {\n            if (!(k in assays)) {\n                try {\n                    assays[k] = extract_assay_names(v);\n                } catch (e) {\n                    console.warn(\"failed to extract features for alternative Experiment '\" + k + \"'; \" + e.message);\n                }\n            }\n        }\n\n        let output = {\n            modality_features: this.#raw_features,\n            cells: this.#raw_cells,\n            modality_assay_names: assays,\n            reduced_dimension_names: this.#rd_handle_order\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode SummarizedExperimentResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode SummarizedExperimentResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     *\n     * If the main experiment is unnamed, its modality name is set to an empty string.\n     * If the main experiment's name is the same as any alternative experiment name, the former will be reported in the returned objects.\n     */\n    load({ cache = false } = {}) {\n        this.#initialize();\n        this.#features();\n        this.#cells();\n\n        let output = { \n            matrix: new scran.MultiMatrix,\n            features: {},\n            cells: this.#raw_cells,\n            reduced_dimensions: {}\n        };\n\n        // Fetch the reduced dimensions first.\n        let reddims = this.#options.reducedDimensionNames;\n        if (reddims == null) {\n            reddims = this.#rd_handle_order;\n        }\n\n        for (const k of reddims) {\n            let v = this.#rd_handles[k];\n            let acquired = [];\n            let dims = v.dimensions;\n            let contents = v.handle.values();\n            for (var d = 0; d < dims[1]; d++) {\n                acquired.push(contents.slice(d * dims[0], (d + 1) * dims[0]));\n            }\n            output.reduced_dimensions[k] = acquired;\n        }\n\n        // Now fetching the assay matrix.\n        try {\n            for (const [k, v] of Object.entries(this.#raw_features)) {\n                let curassay = this.#options.primaryAssay;\n                if (typeof curassay == \"object\") {\n                    if (k in curassay) {\n                        curassay = curassay[k];\n                    } else {\n                        continue;\n                    }\n                }\n\n                let curnormalized = this.#options.isPrimaryNormalized;\n                if (typeof curnormalized == \"object\") {\n                    if (k in curnormalized) {\n                        curnormalized = curnormalized[k];\n                    } else {\n                        curnormalized = true;\n                    }\n                }\n\n                let handle;\n                if (k === this.#main_exp_name) {\n                    handle = this.#se_handle;\n                } else {\n                    handle = this.#alt_handles[k];\n                }\n\n                let loaded = extract_assay(handle, curassay, !curnormalized);\n                output.matrix.add(k, loaded);\n\n                if (!curnormalized) {\n                    let normed = scran.normalizeCounts(loaded, { allowZeros: true });\n                    output.matrix.add(k, normed);\n                }\n\n                output.features[k] = this.#raw_features[k];\n            }\n\n        } catch (e) {\n            scran.free(output.matrix);\n            throw e;\n        }\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n}\n","import JSZip from \"jszip\";\nimport * as jsp from \"jaspagate\";\nimport * as adb from \"./alabaster-abstract.js\";\nimport * as afile from \"./abstract/file.js\";\n\nclass ZippedProjectNavigator {\n    #zipfile;\n    #ziphandle;\n    #prefix;\n\n    constructor(zipfile, ziphandle, prefix) {\n        this.#zipfile = zipfile;\n        this.#ziphandle = null;\n        this.#prefix = prefix;\n    }\n\n    async get(path, asBuffer) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n        // We always return a buffer.\n        return this.#ziphandle.file(jsp.joinPath(this.#prefix, path)).async(\"uint8array\");\n    }\n\n    exists(path) {\n        return this.#ziphandle.file(jsp.joinPath(this.#prefix, path)) !== null; \n    }\n\n    clean(path) {}\n};\n\n/**\n * Search a ZIP file for SummarizedExperiments to use in {@linkplain ZippedAlabasterDataset} or {@linkplain ZippedAlabasterResult}.\n *\n * @param {JSZip} handle - A handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n * \n * @return {Map} Object where the keys are the paths/names of possible SummarizedExperiment objects,\n * and each value is a 2-element array of dimensions.\n */\nexport async function searchZippedAlabaster(handle) {\n    let candidates = [];\n    for (const name of Object.keys(handle.files)) {\n        if (name == \"OBJECT\") {\n            candidates.push(\"\");\n        } else if (name.endsWith(\"/OBJECT\")) {\n            candidates.push(name.slice(0, name.length - 6));\n        }\n    }\n    candidates.sort();\n\n    const nonchildren = new Map;\n    let counter = 0;\n    while (counter < candidates.length) {\n        let prefix = candidates[counter];\n        counter++;\n        let contents = await handle.file(prefix + \"OBJECT\").async(\"string\");\n\n        let meta = {};\n        try {\n            meta = JSON.parse(contents);\n        } catch(e) {\n            ;\n        }\n\n        if (\"summarized_experiment\" in meta) {\n            nonchildren.set(prefix == \"\" ? \".\" : prefix.slice(0, prefix.length - 1), meta.summarized_experiment.dimensions);\n            while (counter < candidates.length) {\n                if (!candidates[counter].startsWith(prefix)) {\n                    break;\n                }\n                counter++;\n            }\n        }\n    }\n\n    return nonchildren;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset as a ZIP file containing a SummarizedExperiment in the **alabaster** representation.\n * Specifically, the ZIP file should contain the contents of an **alabaster** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractAlabasterDataset\n */\nexport class ZippedAlabasterDataset extends adb.AbstractAlabasterDataset {\n    #zipfile;\n    #prefix;\n\n    /**\n     * @param {string} prefix - Name of the SummarizedExperiment object inside the ZIP file.\n     * This should be `.` if the `OBJECT` file is stored at the root of the ZIP file,\n     * otherwise it should be the relative path to the object directory containing the `OBJECT` file.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedAlabasterDataset instance.\n     */\n    constructor(prefix, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle, prefix);\n        super(nav);\n        this.#zipfile = zipfile;\n        this.#prefix = prefix;\n    }\n\n    /**\n     * @return {string} String specifying the format for this dataset.\n     */\n    static format() {\n        return \"alabaster-zipped\";\n    }\n\n    #dump_summary(fun) {\n        let files = [ { type: \"zip\", file: fun(this.#zipfile) } ]; \n        let opt = this.options();\n        opt.datasetPrefix = this.#prefix; // storing the name as a special option... can't be bothered to store it as a separate file.\n        return { files: files, options: opt };\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { \n            return { size: f.size(), name: f.name() }\n        });\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ZippedAlabasterDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ZippedAlabasterDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"zip\") {\n            throw new Error(\"expected exactly one file of type 'zip' for Zipped alabaster unserialization\");\n        }\n\n        let prefix = options.datasetPrefix;\n        delete options.datasetPrefix;\n\n        let output = new ZippedAlabasterDataset(prefix, files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Result as a ZIP file containing a SummarizedExperiment in the **alabaster** representation,\n * Specifically, the ZIP file should contain the contents of an **alabaster** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractAlabasterResult\n */\nexport class ZippedAlabasterResult extends adb.AbstractAlabasterResult {\n    /**\n     * @param {string} prefix - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedAlabasterDataset instance.\n     */\n    constructor(prefix, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle, prefix);\n        super(nav);\n    }\n}\n","import { SingleCellExperiment } from \"bioconductor\";\nimport { H5Group, H5DataSet } from \"./h5.js\";\nimport { readObject, readObjectFile, saveObject } from \"./general.js\";\nimport { readRangedSummarizedExperiment, saveRangedSummarizedExperiment } from \"./RangedSummarizedExperiment.js\"; \nimport { joinPath, jsonBuffer } from \"./utils.js\";\n\n/**\n * A single-cell experiment.\n * @external SingleCellExperiment \n * @see {@link https://ltla.github.io/bioconductor.js/SingleCellExperiment.html}\n */\n\n/**\n * @param {string} path - Path to the takane-formatted object directory containing the {@link external:SingleCellExperiment SingleCellExperiment}.\n * @param {object} metadata - Takane object metadata, typically generated by calling {@linkcode readObjectFile} on `path`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n * @param {function|boolean} [options.SingleCellExperiment_readReducedDimension=true] - How to read each dimensionality reduction result.\n * If `true`, {@linkcode readObject} is used, while if `false`, the reduced dimensions will be skipped.\n * If a function is provided, it should accept `ncol` (the number of columns in the SingleCellExperiment) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return an object (possibly asynchronously) for which [`NUMBER_OF_ROWS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_ROWS) is equal to `ncol`. \n * @param {function|boolean} [options.SingleCellExperiment_readAlternativeExperiment=true] - How to read each alternative experiment.\n * If `true`, {@linkcode readObject} is used, while if `false`, the alternative experiments will be skipped.\n * If a function is provided, it should accept `ncol` (the number of columns in the SingleCellExperiment) as well as `path`, `metadata`, `globals` and `options` (as described above);\n * and should return a {@link external:SummarizedExperiment SummarizedExperiment} (possibly asynchronously)\n * for which [`NUMBER_OF_COLUMNS`](https://ltla.github.io/bioconductor.js/global.html#NUMBER_OF_COLUMNS) is equal to `ncol`. \n *\n * @return {external:SingleCellExperiment} The single-cell experiment object.\n * @async\n */\nexport async function readSingleCellExperiment(path, metadata, globals, options = {}) {\n    let rse = await readRangedSummarizedExperiment(path, metadata, globals, options);\n\n    let sce = new SingleCellExperiment(\n        rse.assays(),\n        {\n            assayOrder: rse.assayNames(),\n            rowRanges: rse.rowRanges(),\n            rowData: rse.rowData(),\n            columnData: rse.columnData(),\n            rowNames: rse.rowNames(),\n            columnNames: rse.columnNames(),\n            metadata: rse.metadata(),\n        }\n    );\n\n    if (\"main_experiment_name\" in metadata.single_cell_experiment) {\n        sce.setMainExperimentName(metadata.single_cell_experiment.main_experiment_name, { inPlace: true });\n    }\n\n    let read_rd = true;\n    if (\"SingleCellExperiment_readReducedDimension\" in options) {\n        read_rd = options.SingleCellExperiment_readReducedDimension;\n    }\n    if (read_rd !== false) {\n        const rdpath = joinPath(path, \"reduced_dimensions/names.json\");\n        if (await globals.exists(rdpath)) {\n            let names_contents = await globals.get(rdpath, { asBuffer: true });\n            const dec = new TextDecoder;\n            const reddim_names = JSON.parse(dec.decode(names_contents));\n            for (const [i, rname] of Object.entries(reddim_names)) {\n                let rdpath = joinPath(path, \"reduced_dimensions\", String(i));\n                let rdmeta = await readObjectFile(rdpath, globals);\n                let currd;\n                if (read_rd === true) {\n                    currd = await readObject(rdpath, rdmeta, globals, options);\n                } else {\n                    currd = await read_rd(sce.numberOfColumns(), rdpath, rdmeta, globals, options);\n                }\n                sce.setReducedDimension(rname, currd, { inPlace: true });\n            }\n        }\n    }\n\n    let read_ae = true;\n    if (\"SingleCellExperiment_readAlternativeExperiment\" in options) {\n        read_ae = options.SingleCellExperiment_readAlternativeExperiment;\n    }\n    if (read_ae !== false) {\n        const aepath = joinPath(path, \"alternative_experiments/names.json\");\n        if (await globals.exists(aepath)) {\n            let names_contents = await globals.get(aepath, { asBuffer: true });\n            const dec = new TextDecoder;\n            const altexp_names = JSON.parse(dec.decode(names_contents));\n            for (const [i, aname] of Object.entries(altexp_names)) {\n                let aepath = joinPath(path, \"alternative_experiments\", String(i));\n                let aemeta = await readObjectFile(aepath, globals);\n                let curae;\n                if (read_ae === true) {\n                    curae = await readObject(aepath, aemeta, globals, options);\n                } else {\n                    curae = await read_ae(sce.numberOfColumns(), aepath, aemeta, globals, options);\n                }\n                sce.setAlternativeExperiment(aname, curae, { inPlace: true });\n            }\n        }\n    }\n\n    return sce;\n}\n\n/**\n * @param {external:SingleCellExperiment} x - The single-cell experiment.\n * @param {string} path - Path to the directory in which to save `x`.\n * @param {object} globals - Object satisfying the {@link GlobalsInterface}.\n * @param {object} [options={}] - Further options.\n *\n * @return `x` is stored at `path`.\n * @async\n */\nexport async function saveSingleCellExperiment(x, path, globals, options = {}) {\n    await saveRangedSummarizedExperiment(x, path, globals, options);\n\n    const existing = await readObjectFile(path, globals);\n    existing.type = \"single_cell_experiment\";\n    existing.single_cell_experiment = { \"version\": \"1.0\" };\n    let mexp = x.mainExperimentName();\n    if (mexp !== null) {\n        existing.single_cell_experiment.main_experiment_name = mexp;\n    }\n    await globals.write(joinPath(path, \"OBJECT\"), jsonBuffer(existing));\n\n    const reddim_names = x.reducedDimensionNames();\n    if (reddim_names.length > 0) {\n        let rddir = joinPath(path, \"reduced_dimensions\");\n        await globals.mkdir(rddir);\n        await globals.write(joinPath(rddir, \"names.json\"), jsonBuffer(reddim_names));\n        for (const [i, rname] of Object.entries(reddim_names)) {\n            await saveObject(x.reducedDimension(rname), joinPath(rddir, String(i)), globals, options);\n        }\n    }\n\n    const altexp_names = x.alternativeExperimentNames();\n    if (altexp_names.length > 0) {\n        let aedir = joinPath(path, \"alternative_experiments\")\n        await globals.mkdir(aedir);\n        await globals.write(joinPath(aedir, \"names.json\"), jsonBuffer(altexp_names));\n        for (const [i, aname] of Object.entries(altexp_names)) {\n            await saveObject(x.alternativeExperiment(aname), joinPath(aedir, String(i)), globals, options);\n        }\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as eutils from \"./utils/extract.js\";\nimport * as futils from \"./utils/features.js\";\nimport * as afile from \"./abstract/file.js\";\n\n/**************************\n ******* Internals ********\n **************************/\n\nfunction extract_assay_details(handle) {\n    if (handle instanceof scran.H5DataSet) {\n        return {\n            rows: handle.shape[0],\n            columns: handle.shape[1],\n            sparse: false\n        };\n\n    } else if (handle instanceof scran.H5Group) {\n        let shape_info = handle.readAttribute(\"shape\");\n        let enc_info = handle.readAttribute(\"encoding-type\");\n        // Yes, the flip is deliberate, because of how H5AD puts its features in the columns.\n        return {\n            rows: shape_info.values[1],\n            columns: shape_info.values[0],\n            sparse: true,\n            csc: enc_info.values[0] == \"csr_matrix\" \n        }\n\n    } else {\n        throw new Error(\"unknown type for a H5AD assay matrix\");\n    }\n}\n\nfunction fetch_assay_details(handle, path) {\n    let available = [];\n    let types = {};\n    if (\"X\" in handle.children) {\n        available.push(\"X\");\n        types[\"X\"] = extract_assay_details(handle.open(\"X\"));\n    } \n\n    if (\"layers\" in handle.children) {\n        let lhandle = handle.open(\"layers\");\n        if (!(lhandle instanceof scran.H5Group)) {\n            throw new Error(\"expected a 'layers' group in a H5AD file\");\n        }\n        for (const k of Object.keys(lhandle.children)) {\n            const aname = \"layers/\" + k;\n            available.push(aname);\n            types[aname] = extract_assay_details(lhandle.open(k));\n        }\n    }\n\n    if (available.length == 0) {\n        throw new Error(\"failed to find any assay in the H5AD file\");\n    }\n\n    let deets = types[available[0]];\n    return {\n        names: available,\n        rows: deets.rows,\n        columns: deets.columns,\n        details: types\n    };\n}\n\nfunction load_data_frame(handle) {\n    let columns = {};\n\n    for (const [key, val] of Object.entries(handle.children)) {\n        if (val == \"DataSet\") {\n            let dhandle = handle.open(key, { load: true });\n            if (dhandle.type === \"Enum\") {\n                let dvals = dhandle.values;\n                let options = new Array(dvals.length);\n                let levels = dhandle.levels;\n                dvals.forEach((x, i) => {\n                    options[i] = levels[x];\n                });\n                columns[key] = options;\n            } else if (dhandle.type !== \"Other\") {\n                columns[key] = dhandle.values;\n            }\n\n        } else if (val == \"Group\") {\n            // Factor encoding for H5AD versions >= 0.8.0.\n            let subhandle = handle.open(key);\n            if (\"categories\" in subhandle.children && \"codes\" in subhandle.children) {\n                let current_levels = eutils.extractHdf5Strings(subhandle, \"categories\");\n                let codes = subhandle.open(\"codes\", { load: true }).values;\n                columns[key] = bioc.SLICE(current_levels, codes);\n            }\n        }\n    }\n\n    // Factor encoding for H5AD versions < 0.8.0.\n    if (\"__categories\" in handle.children && handle.children[\"__categories\"] == \"Group\") {\n        let chandle = handle.open(\"__categories\");\n\n        for (const [key, val] of Object.entries(chandle.children)) {\n            if (key in columns) {\n                let current_levels = eutils.extractHdf5Strings(chandle, key);\n                if (!current_levels) {\n                    console.warn(`ignoring invalid levels for nominally categorical key '${key}' in the H5AD reader`)\n                    continue;\n                }\n                columns[key] = bioc.SLICE(current_levels, columns[key]);\n            }\n        }\n    }\n\n    if (Object.keys(columns).length == 0) {\n        return null;\n    } else {\n        let rn = null;\n        if (\"_index\" in columns) {\n            rn = columns._index;\n            delete columns._index;\n        }\n        return new bioc.DataFrame(columns, { rowNames: rn });\n    }\n}\n\nfunction fetch_features(handle) {\n    if (\"var\" in handle.children && handle.children[\"var\"] == \"Group\") {\n        let vhandle = handle.open(\"var\");\n        return load_data_frame(vhandle);\n    }\n    return null;\n}\n\nfunction fetch_cells(handle) {\n    if (\"obs\" in handle.children && handle.children[\"obs\"] == \"Group\") {\n        let ohandle = handle.open(\"obs\");\n        return load_data_frame(ohandle);\n    }\n    return null;\n}\n\nfunction load_matrix(path, name, details, options) {\n    if (details.sparse) {\n        return scran.initializeSparseMatrixFromHdf5Group(path, name, details.rows, details.columns, !(details.csc), options);\n    } else {\n        return scran.initializeSparseMatrixFromHdf5Dataset(path, name, options);\n    }\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset in the H5AD format.\n */\nexport class H5adDataset {\n    #h5_file;\n    #h5_path;\n    #h5_flush;\n    #h5_handle;\n\n    #raw_features;\n    #raw_cells;\n    #assay_details;\n\n    #options;\n\n    #dump_summary(fun) {\n        let files = [{ type: \"h5\", file: fun(this.#h5_file) }]; \n        let options = this.options();\n        return { files, options };\n    }\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a H5AD file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = H5adDataset.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode H5adDataset#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return {\n            countMatrixName: null, \n            featureTypeColumnName: null, \n            featureTypeRnaName: \"Gene Expression\", \n            featureTypeAdtName: \"Antibody Capture\", \n            featureTypeCrisprName: \"CRISPR Guide Capture\", \n            primaryRnaFeatureIdColumn: null,\n            primaryAdtFeatureIdColumn: null,\n            primaryCrisprFeatureIdColumn: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode H5adDataset#load load} (but not {@linkcode H5adDataset#summary summary}).\n     * @param {?string} [options.countMatrixName] - Name of the layer containing the count matrix.\n     * If `null`, the \"X\" dataset is used if it is present in the file, or the first available layer if no \"X\" dataset is present.\n     * @param {?string} [options.featureTypeColumnName] - Name of the per-feature annotation column containing the feature types.\n     * If `null`, no column is assumed to contain feature type information.\n     * @param {?string} [options.featureTypeRnaName] - Name of the feature type for gene expression.\n     * If `null` or the string is not present among the feature types, no RNA features are to be loaded.\n     *\n     * If no feature type information is available in the dataset (i.e., `featureTypeColumnName = null`), all features are considered to be genes by default.\n     * This behavior can also be explicitly requested by setting this argument to the only non-`null` value among all `featureType*Name` parameters.\n     * @param {?string} [options.featureTypeAdtName] - Name of the feature type for ADTs.\n     * If `null` or the string is not present among the feature types, no ADT features are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be ADTs.\n     * @param {?string} [options.featureTypeCrisprName] - Name of the feature type for CRISPR guides.\n     * If `null` or the string is not present among the feature types, no guides are to be loaded.\n     *\n     * If no feature type information is available in the dataset and this argument is set to the only non-`null` value among all `featureType*Name` parameters, all features are considered to be guides.\n     * @param {?(string|number)} [options.primaryRnaFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for gene expression.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryAdtFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the ADTs.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     * @param {?(string|number)} [options.primaryCrisprFeatureIdColumn] - Name or index of the column of the `features` {@linkplain external:DataFrame DataFrame} that contains the primary feature identifier for the CRISPR guides.\n     *\n     * If `i` is `null` or invalid (e.g., out of range index, unavailable name), it is ignored and the row names (from the `_index` group) are used as the primary identifiers.\n     * If no row names are present in this situation, no primary identifier is defined.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            this.#options[k] = v;\n        }\n    }\n\n    #instantiate() {\n        if (this.#h5_path != null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n        this.#h5_handle = new scran.H5File(this.#h5_path);\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory. \n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode H5adDataset#load load} or {@linkcodeH5adDataset#summary summary}.\n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n        this.#h5_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#assay_details = null;\n    }\n\n    /**\n     * @return {string} Format of this dataset class.\n     * @static\n     */\n    static format() {\n        return \"H5AD\";\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { return { name: f.name(), size: f.size() }; });\n    }\n\n    #fetch_assay_details() {\n        if (this.#assay_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        this.#assay_details = fetch_assay_details(this.#h5_handle, this.#h5_path);\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let feats = fetch_features(this.#h5_handle);\n        if (feats == null) {\n            this.#fetch_assay_details();\n            feats = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.rows });\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let cells = fetch_cells(this.#h5_handle);\n        if (cells === null) {\n            this.#fetch_assay_details();\n            cells = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.columns })\n        }\n\n        this.#raw_cells = cells;\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `all_features`: a {@linkplain external:DataFrame DataFrame} of per-feature annotations.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `all_assay_names`: an Array of strings containing names of potential count matrices.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n\n        let output = {\n            all_features: this.#raw_features,\n            cells: this.#raw_cells,\n            all_assay_names: this.#assay_details.names\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    #feature_type_mapping() {\n        return {\n            RNA: this.#options.featureTypeRnaName, \n            ADT: this.#options.featureTypeAdtName,\n            CRISPR: this.#options.featureTypeCrisprName\n        };\n    }\n\n    #primary_mapping() {\n        return {\n            RNA: this.#options.primaryRnaFeatureIdColumn, \n            ADT: this.#options.primaryAdtFeatureIdColumn,\n            CRISPR: this.#options.primaryCrisprFeatureIdColumn\n        };\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} An object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     * The contents are the same as the `primary_ids` returned by {@linkcode H5adDataset#load load} but the order of values may be different.\n     */\n    previewPrimaryIds({ cache = false } = {}) {\n        this.#features();\n        let preview = futils.extractSplitPrimaryIds(this.#raw_features, this.#options.featureTypeColumnName, this.#feature_type_mapping(), \"RNA\", this.#primary_mapping());\n        if (!cache) {\n            this.clear();\n        }\n        return preview;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the intermediate results for re-use in subsequent calls to any methods with a `cache` option.\n     * If `true`, users should consider calling {@linkcode H5adDataset#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `primary_ids`: an object where each key is a modality name and each value is an array (usually of strings) containing the primary feature identifiers for each row in that modality.\n     *\n     * Modality names are guaranteed to be one of `\"RNA\"`, `\"ADT\"` or `\"CRISPR\"`.\n     * We assume that the instance already contains an appropriate mapping from the observed feature types to each expected modality,\n     * either from the {@linkcode H5adDataset#defaults defaults} or with {@linkcode H5adDataset#setOptions setOptions}.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n\n        let chosen_assay = this.#options.countMatrixName;\n        if (chosen_assay == null) {\n            chosen_assay = this.#assay_details.names[0];\n        }\n\n        let loaded = load_matrix(this.#h5_path, chosen_assay, this.#assay_details.details[chosen_assay], { forceInteger: true, layered: true }); \n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, this.#options.featureTypeColumnName, this.#feature_type_mapping(), \"RNA\");\n        output.cells = this.#raw_cells;\n\n        output.primary_ids = futils.extractPrimaryIds(output.features, this.#primary_mapping());\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode H5adDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {H5adDataset} A new instance of this class.\n     * @static\n     */\n    static async unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"h5\") {\n            throw new Error(\"expected exactly one file of type 'h5' for H5AD unserialization\");\n        }\n        let output = new H5adDataset(files[0].file);\n        output.setOptions(options);\n        return output;\n    }\n}\n\n/************************\n ******* Results ********\n ************************/\n\n/**\n * Pre-computed analysis results in the H5AD format.\n */\nexport class H5adResult {\n    #h5_file;\n    #h5_path;\n    #h5_flush;\n    #h5_handle;\n\n    #raw_features;\n    #raw_cells;\n    #assay_details;\n    #reddim_details;\n\n    #options;\n\n    /**\n     * @param {SimpleFile|string|Uint8Array|File} h5File - Contents of a H5AD file.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     */\n    constructor(h5File) {\n        if (h5File instanceof afile.SimpleFile) {\n            this.#h5_file = h5File;\n        } else {\n            this.#h5_file = new afile.SimpleFile(h5File);\n        }\n\n        this.#options = H5adResult.defaults();\n        this.clear();\n    }\n\n    /**\n     * @return {object} Default options, see {@linkcode H5adResult#setOptions setOptions} for more details.\n     */\n    static defaults() {\n        return { \n            primaryMatrixName: null, \n            isPrimaryNormalized: true,\n            featureTypeColumnName: null, \n            reducedDimensionNames: null\n        };\n    }\n\n    /**\n     * @return {object} Object containing all options used for loading.\n     */\n    options() {\n        return { ...(this.#options) };\n    }\n\n    /**\n     * @param {object} options - Optional parameters that affect {@linkcode H5adResult#load load} (but not {@linkcode H5adResult#summary summary}).\n     * @param {?string} [options.primaryMatrixName] - Name of the layer containing the primary matrix.\n     * If `null`, the \"X\" dataset is used if it is present in the file, or the first available layer if no \"X\" dataset is present.\n     * @param {boolean} [options.isPrimaryNormalized] - Whether the primary matrix is already normalized.\n     * If `false`, it is assumed to contain count data and is subjected to library size normalization within each modality.\n     * @param {?string} [options.featureTypeColumnName] - Name of the per-feature annotation column containing the feature types.\n     * If `null`, no column is assumed to contain the feature types, and all features are assumed to be genes (i.e., only the RNA modality is present).\n     * @param {?Array} [options.reducedDimensionNames=null] - Array of names of the reduced dimensions to load.\n     * If `null`, all reduced dimensions found in the file are loaded.\n     */\n    setOptions(options) {\n        for (const [k, v] of Object.entries(options)) {\n            if (k == \"reducedDimensionNames\") {\n                this.#options[k] = bioc.CLONE(v); // avoid pass-by-reference links.\n            } else {\n                this.#options[k] = v;\n            }\n        }\n    }\n\n    /**\n     * Destroy caches if present, releasing the associated memory. \n     * This may be called at any time but only has an effect if `cache = true` in {@linkcode H5adResult#load load} or {@linkcode H5adResult#summary summary}.\n     */\n    clear() {\n        if (typeof this.#h5_flush == \"function\") {\n            this.#h5_flush();\n        }\n        this.#h5_flush = null;\n        this.#h5_path = null;\n        this.#h5_handle = null;\n\n        this.#raw_features = null;\n        this.#raw_cells = null;\n        this.#assay_details = null;\n        this.#reddim_details = null;\n    }\n\n    #instantiate() {\n        if (this.#h5_path != null) {\n            return;\n        }\n\n        let info = scran.realizeFile(this.#h5_file.content());\n        this.#h5_path = info.path;\n        this.#h5_flush = info.flush;\n        this.#h5_handle = new scran.H5File(this.#h5_path);\n    }\n\n    #fetch_assay_details() {\n        if (this.#assay_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        this.#assay_details = fetch_assay_details(this.#h5_handle, this.#h5_path);\n        return;\n    }\n\n    #features() {\n        if (this.#raw_features !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let feats = fetch_features(this.#h5_handle);\n        if (feats == null) {\n            this.#fetch_assay_details();\n            feats = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.rows });\n        }\n\n        this.#raw_features = feats;\n        return;\n    }\n\n    #cells() {\n        if (this.#raw_cells !== null) {\n            return;\n        }\n        this.#instantiate();\n\n        let cells = fetch_cells(this.#h5_handle);\n        if (cells === null) {\n            this.#fetch_assay_details();\n            cells = new bioc.DataFrame({}, { numberOfRows: this.#assay_details.columns })\n        }\n\n        this.#raw_cells = cells;\n        return;\n    }\n\n    #fetch_reddim_details() {\n        if (this.#reddim_details !== null) {\n            return;\n        }\n        this.#instantiate();\n        \n        let available = [];\n        if (\"obsm\" in this.#h5_handle.children && this.#h5_handle.children[\"obsm\"] == \"Group\") {\n            let ohandle = this.#h5_handle.open(\"obsm\");\n            for (const [k, v] of Object.entries(ohandle.children)) {\n                if (v == \"DataSet\") {\n                    available.push(k);\n                }\n            }\n        }\n\n        this.#reddim_details = { names: available };\n        return;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode H5adResult#load load}.\n     * If `true`, users should consider calling {@linkcode H5adResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `all_features`: a {@linkplain external:DataFrame DataFrame} of per-feature annotations.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} of per-cell annotations.\n     * - `all_assay_names`: an Array of strings containing names of potential primary matrices.\n     * - `reduced_dimension_names`: an Array of strings containing names of dimensionality reduction results.\n     */\n    summary({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n        this.#fetch_reddim_details();\n\n        let output = {\n            all_features: this.#raw_features,\n            cells: this.#raw_cells,\n            all_assay_names: this.#assay_details.names,\n            reduced_dimension_names: this.#reddim_details.names\n        };\n\n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {boolean} [options.cache=false] - Whether to cache the results for re-use in subsequent calls to this method or {@linkcode H5adResult#summary summary}.\n     * If `true`, users should consider calling {@linkcode H5adResult#clear clear} to release the memory once this dataset instance is no longer needed.\n     *\n     * @return {object} Object containing the per-feature and per-cell annotations.\n     * This has the following properties:\n     *\n     * - `features`: an object where each key is a modality name and each value is a {@linkplain external:DataFrame DataFrame} of per-feature annotations for that modality.\n     * - `cells`: a {@linkplain external:DataFrame DataFrame} containing per-cell annotations.\n     * - `matrix`: a {@linkplain external:MultiMatrix MultiMatrix} containing one {@linkplain external:ScranMatrix ScranMatrix} per modality.\n     * - `reduced_dimensions`: an object containing the dimensionality reduction results.\n     *   Each value is an array of arrays, where each inner array contains the coordinates for one dimension.\n     */\n    load({ cache = false } = {}) {\n        this.#features();\n        this.#cells();\n        this.#fetch_assay_details();\n        this.#fetch_reddim_details();\n\n        let chosen_assay = this.#options.primaryMatrixName;\n        if (chosen_assay == null) {\n            chosen_assay = this.#assay_details.names[0];\n        }\n        let loaded = load_matrix(this.#h5_path, chosen_assay, this.#assay_details.details[chosen_assay], { forceInteger: !this.#options.isPrimaryNormalized });\n        let output = futils.splitScranMatrixAndFeatures(loaded, this.#raw_features, this.#options.featureTypeColumnName, null, \"\");\n        output.cells = this.#raw_cells;\n\n        if (!this.#options.isPrimaryNormalized) {\n            for (const mod of output.matrix.available()) {\n                let mat = output.matrix.get(mod);\n                output.matrix.add(mod, scran.normalizeCounts(mat, { allowZeros: true }));\n            }\n        }\n\n        // Loading the dimensionality reduction results.\n        let chosen_reddims = this.#options.reducedDimensionNames;\n        if (chosen_reddims == null) {\n            chosen_reddims = this.#reddim_details.names;\n        }\n\n        let reddims = {};\n        if (chosen_reddims.length) {\n            let ohandle = this.#h5_handle.open(\"obsm\");\n            for (const k of chosen_reddims) {\n                let loaded = ohandle.open(k, { load: true });\n                let shape = loaded.shape;\n                let ncells = shape[0];\n                let ndims = shape[1];\n                let transposed = scran.transposeMatrix(ncells, ndims, loaded.values, { columnMajor: false }); // HDF5 stores matrices in row-major format.\n                let contents = [];\n                for (var d = 0; d < ndims; d++) {\n                    let offset = d * ncells;\n                    contents.push(transposed.slice(offset, offset + ncells));\n                }\n                reddims[k] = contents;\n            }\n        }\n        output.reduced_dimensions = reddims;\n        \n        if (!cache) {\n            this.clear();\n        }\n        return output;\n    }\n\n}\n","import * as adb from \"./ArtifactDB-abstract.js\";\nimport JSZip from \"jszip\";\nimport * as afile from \"./abstract/file.js\";\n\nclass ZippedProjectNavigator {\n    #zipfile;\n    #ziphandle;\n\n    constructor(zipfile, ziphandle) {\n        this.#zipfile = zipfile;\n        this.#ziphandle = null;\n    }\n\n    async file(path) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n        return await this.#ziphandle.file(path).async(\"uint8array\");\n    }\n\n    async metadata(path) {\n        if (this.#ziphandle == null) {\n            this.#ziphandle = await JSZip.loadAsync(this.#zipfile.buffer());\n        }\n\n        while (1) {\n            if (!path.endsWith(\".json\")) { \n                path += \".json\";\n            }\n\n            let contents = await this.#ziphandle.file(path).async(\"string\");\n            let values = JSON.parse(contents);\n\n            if (values[\"$schema\"].startsWith(\"redirection/\")){\n                path = values.redirection.targets[0].location;\n            } else {\n                return values;\n            }\n        }\n    }\n\n    clear() {\n        this.#ziphandle = null;\n    }\n};\n\n/**\n * Search a ZIP file for SummarizedExperiments to use in {@linkplain ZippedArtifactdbDataset} or {@linkplain ZippedArtifactdbResult}.\n *\n * @param {JSZip} handle - A handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n * \n * @return {Map} Object where the keys are the paths/names of possible SummarizedExperiment objects,\n * and each value is a 2-element array of dimensions.\n */\nexport async function searchZippedArtifactdb(handle) {\n    // Sorting by the number of slashes.\n    let all_json = [];\n    for (const name of Object.keys(handle.files)) {\n        if (name.endsWith(\".json\")) {\n            all_json.push({ name: name, path: name.split(\"/\") });\n        }\n    }\n    all_json.sort((a, b) => a.path.length - b.path.length);\n\n    let found_se = new Map;\n    let nonchildren = new Map;\n    let redirects = new Map;\n\n    for (const x of all_json) {\n        // Avoid loading JSONs for files in subdirectories of known SEs.\n        let current = found_se;\n        let already_found = false;\n\n        for (const comp of x.path) {\n            let val = current.get(comp);\n            if (typeof val === \"undefined\") {\n                val = new Map;\n                current.set(comp, val);\n            } else if (val === null) {\n                already_found = true;\n                break;\n            }\n            current = val;\n        }\n\n        // Otherwise, we load it in and peel out some information.\n        if (!already_found) {\n            let contents = await handle.file(x.name).async(\"string\");\n            let values = JSON.parse(contents);\n            if (\"summarized_experiment\" in values) {\n                nonchildren.set(values.path, values.summarized_experiment.dimensions);            \n            } else if (values[\"$schema\"].startsWith(\"redirection/\")) {\n                redirects.set(values.path, values.redirection.targets[0].location);\n            }\n        }\n    }\n\n    for (const [rr, loc] of redirects) {\n        let found = nonchildren.get(loc);\n        if (typeof found !== \"undefined\") {\n            nonchildren.delete(loc);\n            nonchildren.set(rr, found);\n        }\n    }\n\n    return nonchildren;\n}\n\n/************************\n ******* Dataset ********\n ************************/\n\n/**\n * Dataset as a ZIP file containing a SummarizedExperiment in the **ArtifactDB** representation,\n * e.g., as produced by {@linkcode saveSingleCellExperiment}.\n * Specifically, the ZIP file should contain the contents of an **ArtifactDB** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractArtifactdbDataset\n */\nexport class ZippedArtifactdbDataset extends adb.AbstractArtifactdbDataset {\n    #zipfile;\n    #name;\n\n    /**\n     * @param {string} name - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedArtifactdbDataset instance.\n     */\n    constructor(name, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle);\n        super(name, nav);\n        this.#zipfile = zipfile;\n        this.#name = name;\n    }\n\n    /**\n     * @return {string} String specifying the format for this dataset.\n     */\n    static format() {\n        return \"ArtifactDB-zipped\";\n    }\n\n    #dump_summary(fun) {\n        let files = [ { type: \"zip\", file: fun(this.#zipfile) } ]; \n        let opt = this.options();\n        opt.datasetName = this.#name; // storing the name as a special option... can't be bothered to store it as a separate file.\n        return { files: files, options: opt };\n\n    }\n\n    /**\n     * @return {object} Object containing the abbreviated details of this dataset.\n     */\n    abbreviate() {\n        return this.#dump_summary(f => { \n            return { size: f.size(), name: f.name() }\n        });\n    }\n\n    /**\n     * @return {object} Object describing this dataset, containing:\n     *\n     * - `files`: Array of objects representing the files used in this dataset.\n     *   Each object corresponds to a single file and contains:\n     *   - `type`: a string denoting the type.\n     *   - `file`: a {@linkplain SimpleFile} object representing the file contents.\n     * - `options`: An object containing additional options to saved.\n     */\n    serialize() {\n        return this.#dump_summary(f => f);\n    }\n\n    /**\n     * @param {Array} files - Array of objects like that produced by {@linkcode ZippedArtifactdbDataset#serialize serialize}.\n     * @param {object} options - Object containing additional options to be passed to the constructor.\n     * @return {ZippedArtifactdbDataset} A new instance of this class.\n     * @static\n     */\n    static unserialize(files, options) {\n        if (files.length != 1 || files[0].type != \"zip\") {\n            throw new Error(\"expected exactly one file of type 'zip' for Zipped ArtifactDB unserialization\");\n        }\n\n        let name = options.datasetName;\n        delete options.datasetName;\n\n        let output = new ZippedArtifactdbDataset(name, files[0].file);\n        output.setOptions(output);\n        return output;\n    }\n}\n\n/***********************\n ******* Result ********\n ***********************/\n\n/**\n * Result as a ZIP file containing a SummarizedExperiment in the **ArtifactDB** representation,\n * e.g., as produced by {@linkcode saveSingleCellExperiment}.\n * Specifically, the ZIP file should contain the contents of an **ArtifactDB** project directory.\n * This project directory may contain multiple objects; the SummarizedExperiment of interest is identified in the constructor.\n *\n * @extends AbstractArtifactdbResult\n */\nexport class ZippedArtifactdbResult extends adb.AbstractArtifactdbResult {\n    /**\n     * @param {string} name - Name of the SummarizedExperiment object inside the project directory.\n     * @param {SimpleFile|string|File} zipfile - Contents of the ZIP file containing the project directory.\n     * On browsers, this may be a File object.\n     * On Node.js, this may also be a string containing a file path.\n     * @param {object} [options={}] - Optional parameters. \n     * @param {?JSZip} [options.existingHandle=null] - An existing handle into the ZIP file, generated using the [**JSZip**](https://stuk.github.io/jszip/) package.\n     * If an existing handle already exists, passing it in here will allow it to be re-used for greater efficiency.\n     * If `null`, a new handle is created for this ZippedArtifactdbDataset instance.\n     */\n    constructor(name, zipfile, options={}) {\n        let ziphandle = null;\n        if (\"existingHandle\" in options) {\n            ziphandle = options.existingHandle;\n            delete options.existingHandle;\n        } else {\n            if (!(zipfile instanceof afile.SimpleFile)) {\n                zipfile = new afile.SimpleFile(zipfile);\n            }\n        }\n\n        let nav = new ZippedProjectNavigator(zipfile, ziphandle);\n        super(name, nav);\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as cutils from \"./clone-utils.js\";\nimport * as generics from \"./AllGenerics.js\";\n\nclass IndexedNames {\n    constructor(names) {\n        this._names = names;\n        this._lookup = new Map;\n    }\n\n    names() {\n        return this._names;\n    }\n\n    nameToIndexUncached(name) {\n        if (this._lookup.has(name)) {\n            return this._lookup.get(name);\n        }\n        return this._names.indexOf(name);\n    }\n\n    nameToIndex(name, { error = true } = {}) {\n        if (this._lookup.has(name)) {\n            return this._lookup.get(name);\n        }\n\n        for (var i = this._lookup.size; i < this._names.length; i++) {\n            const current = this._names[i];\n            if (this._lookup.has(current)) {\n                continue; // only keep the first instance of a duplicated name.\n            }\n            this._lookup.set(current, i);\n            if (this._names[i] == name) {\n                return i;\n            }\n        }\n\n        if (error) {\n            throw new Error(\"no matching name for '\" + name + \"' in this \" + this.constructor.className);\n        } else {\n            return -1;\n        }\n    }\n\n    indexToName(i) {\n        return this._names[i];\n    }\n\n    append(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        }\n        target._names.push(name);\n        return target;\n    }\n\n    set(i, name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        } else {\n            if (target._lookup.size > i) { // if the lookup never got to that point, we don't have to wipe it.\n                target._lookup = new Map;\n            }\n        }\n        target._names[i] = name;\n        return target;\n    }\n\n    delete(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._names = target._names.slice();\n            target._lookup = new Map; // always making a new map to avoid sharing lookup tables between instances with different names.\n        } else {\n            if (target._lookup.size > i) { // i.e., if the lookup never got to that point, we don't have to wipe it.\n                target._lookup = new Map;\n            }\n        }\n        target._names.splice(i, 1);\n        return target;\n    }\n\n    _bioconductor_CLONE({ deepCopy = true }) {\n        let output = new this.constructor;\n        output._names = cutils.cloneField(this._names, deepCopy);\n        output._lookup = cutils.cloneField(this._lookup, deepCopy);\n        return output;\n    }\n}\n\n/**\n * An R-style list with optional names.\n * Callers can get/set individual elements by positional index or name.\n * Operations like slicing and combining will apply to both the values and names.\n *\n * The List defines methods for the following generics:\n *\n * - {@linkcode LENGTH}\n * - {@linkcode SLICE}\n * - {@linkcode COMBINE}\n * - {@linkcode CLONE}\n *\n * We explicitly allow duplicates in the names to avoid errors when slicing or combining.\n * Otherwise, it would be impossible to construct a slice with duplicate indices or to combine multiple `List` instances with shared names.\n *\n * Constructors of List subclasses should be callable with no arguments, possibly creating an empty object with no properties.\n * This will be used by the `_bioconductor_CLONE`, `_bioconductor_SLICE` and `_bioconductor_COMBINE` methods to return an instance of the subclass.\n */\nexport class List {\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * For Maps or objects, the values (in order of iteration) are used as the List elements.\n     * If no argument is supplied, it defaults to an empty Array.\n     * @param {Object} [options={}] - Further options.\n     * @param {?Array} [options.names=null] - An array of strings containing the names of the List elements.\n     * If provided, this should be of the same length as `values`.\n     * If `values` is a Map or object, `names` should have the same keys.\n     * If `values` is an array, the names may contain duplicate strings.\n     * If `null` and `values` is an array, the List will be unnamed.\n     */\n    constructor(values, { names = null } = {}) {\n        if (arguments.length == 0) {\n            this._values = [];\n            this._names = null;\n            return;\n        }\n\n        if (values instanceof Array) {\n            if (names !== null) {\n                if (names.length != values.length) {\n                    throw new Error(\"'names' and 'values' should have the same length\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                }\n                names = new IndexedNames(names);\n            }\n\n            this._values = values;\n            this._names = names;\n\n        } else if (values instanceof Map) {\n            let arr = [];\n            if (names == null) {\n                names = [];\n                for (const [n, v] of values) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"keys of 'values' should be strings\");\n                    }\n                    names.push(n);\n                    arr.push(v);\n                }\n\n            } else {\n                if (names.length != values.size) {\n                    throw new Error(\"size of 'values' should be equal to length of 'names'\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                    if (!values.has(n)) {\n                        throw new Error(\"missing name '\" + n + \"' in 'values'\");\n                    }\n                    arr.push(values.get(n));\n                }\n            }\n\n            this._values = arr;\n            this._names = new IndexedNames(names);\n\n        } else {\n            let arr = [];\n            if (names == null) {\n                names = [];\n                for (const [n, v] of Object.entries(values)) {\n                    names.push(n);\n                    arr.push(v);\n                }\n\n            } else {\n                if (names.length != Object.keys(values).length) {\n                    throw new Error(\"size of 'values' should be equal to length of 'names'\");\n                }\n                for (const n of names) {\n                    if (typeof n != \"string\") {\n                        throw new Error(\"'names' should be an array of strings\");\n                    }\n                    if (!(n in values)) {\n                        throw new Error(\"missing name '\" + n + \"' in 'values'\");\n                    }\n                    arr.push(values[n]);\n                }\n            }\n\n            this._values = arr;\n            this._names = new IndexedNames(names);\n        }\n    }\n\n    /**\n     * @return {?Array} Array of names of the List elements, or `null` if the List is unnamed.\n     */\n    names() {\n        if (this._names == null) {\n            return null;\n        } else {\n            return this._names.names();\n        }\n    }\n\n    /**\n     * @return {Array} Array containing the List elements.\n     */\n    values() {\n        return this._values;\n    }\n\n    /**\n     * @return {number} Length of the list.\n     */\n    length() {\n        return this._values.length;\n    }\n\n    static className = \"List\";\n\n    /***********************************************/\n\n    #check_index(i) {\n        if (i < 0 || i >= this._values.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to retrieve.\n     * This should be non-negative and less than {@linkcode List#length length}.\n     * @return The `i`-th List element.\n     */\n    getByIndex(i) {\n        this.#check_index(i);\n        return this._values[i];\n    }\n\n    /**\n     * @param {string} name - Name of the List element to retrieve.\n     * This should be present in {@linkcode List#names names}.\n     * @return The List element corresponding to `name`.\n     * If duplicates of `name` are present in the list, the first occurrence is returned.\n     */\n    getByName(name) {\n        if (this._names === null) {\n            throw new Error(\"no available names in this \" + this.constructor.className);\n        }\n        let candidate = this._names.nameToIndex(name);\n        return this._values[candidate];\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the List element to retrieve.\n     * Numbers are passed to {@linkcode List#getByIndex getByIndex} and strings are passed to {@linkcode List#getByName getByName}.\n     * @return The List element at/for `i`.\n     */\n    get(i) {\n        if (typeof i == \"number\") {\n            return this.getByIndex(i);\n        } else {\n            return this.getByName(i);\n        }\n    }\n\n    /**\n     * @param {string} name - Name of a List element.\n     * @return {boolean} Whether the name exists in this List.\n     */\n    has(name) {\n        return this.nameToIndex(name) >= 0;\n    }\n\n    /**\n     * @param {string} name - Name of a List element.\n     * @return {number} Index of the name in {@linkcode List#names names}.\n     * If duplicate names are present, the first occurrence is returned.\n     * If the name is not present, -1 is returned.\n     */\n    nameToIndex(name) {\n        return this._names.nameToIndex(name, { error: false });\n    }\n\n    /***********************************************/\n\n    /**\n     * @return {Array} Array of values, equivalent to {@linkcode List#values values}.\n     */\n    toArray() {\n        return this._values;\n    }\n\n    /**\n     * @return {Map} Map of name-value pairs.\n     * If duplicate names are present, only the value for the first occurrence is reported.\n     * If the List is unnamed, an error is thrown.\n     */\n    toMap() {\n        if (this._names == null) {\n            throw new Error(\"no available names in this '\" + this.constructor.className + \"'\");\n        }\n        let output = new Map;\n        let names = this._names.names();\n        for (var i = 0; i < this._values.length; i++) {\n            const curname = names[i];\n            if (output.has(curname)) {\n                continue;\n            }\n            output.set(curname, this._values[i]);\n        }\n        return output;\n    }\n\n    /**\n     * @return {Object} Object of name-value pairs.\n     * If duplicate names are present, only the value for the first occurrence is reported.\n     * If the List is unnamed, an error is thrown.\n     */\n    toObject() {\n        if (this._names == null) {\n            throw new Error(\"no available names in this '\" + this.constructor.className + \"'\");\n        }\n        let output = {};\n        let names = this._names.names();\n        for (var i = 0; i < this._values.length; i++) {\n            const curname = names[i];\n            if (curname in output) {\n                continue;\n            }\n            output[curname] = this._values[i];\n        }\n        return output;\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} i - Index of the List element to set.\n     * This should be non-negative and no greater than {@linkcode List#length length}.\n     * If `i` is less than `length`, the `i`-th element is replaced by `x`.\n     * If `i` is equal to `length`, `x` is appended to the end of the list.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - Name for the List element at `i`.\n     * If `i` is less than `length`, the name of the `i`-th element is replaced by `name`.\n     * If `i` is equal to `length`, the name of the newly-appended element is set to `name`.\n     * If the List did not previously have any names, the names of all other elements are set to an empty string.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setByIndex(i, x, { name = null, inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (i < 0 || i > this._values.length) {\n            throw new Error(\" index '\" + String(i) + \"' out of range for this \" + this.constructor.className);\n        }\n\n        if (i == target._values.length) {\n            target._values.push(x);\n            if (name == null) {\n                if (target._names != null) {\n                    target._names = target._names.append(\"\", { inPlace });\n                }\n\n            } else {\n                if (typeof name != \"string\") {\n                    throw new Error(\"'name' should be a string\");\n                }\n                if (target._names == null) {\n                    const new_names = new Array(target._values.length).fill(\"\");\n                    new_names[i] = name;\n                    target._names = new IndexedNames(new_names);\n                } else {\n                    target._names = target._names.append(name, { inPlace });\n                }\n            }\n\n        } else {\n            target._values[i] = x;\n            if (name !== null) {\n                if (target._names === null) {\n                    const new_names = new Array(target._values.length).fill(\"\");\n                    new_names[i] = name;\n                    target._names = new IndexedNames(new_names);\n                } else {\n                    target._names = target._names.set(i, name, { inPlace });\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set.\n     * If this already exists in {@linkcode List#names names}, the corresponding element is replaced by `x`.\n     * Otherwise, `x` is appended to the List with the name `name`.\n     * If the List did not previously have any names, the names of all other elements are set to an empty string.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setByName(name, x, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (target._names !== null) {\n            let candidate = target._names.nameToIndex(name, { error: false });\n            if (candidate < 0) {\n                target._values.push(x);\n                target._names = target._names.append(name, { inPlace });\n            } else {\n                target._values[candidate] = x;\n            }\n        } else {\n            const new_names = new Array(target._values.length).fill(\"\");\n            new_names.push(name);\n            target._names = new IndexedNames(new_names);\n            target._values.push(x);\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the list element to set.\n     * Numbers are passed to {@linkcode List#setByIndex setByIndex} and strings are passed to {@linkcode List#setByName setByName}.\n     * @param {*} x - Value of a List element.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * Only used if `i` is a number.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    set(i, x, { name = null, inPlace = false } = {}) {\n        if (typeof i == \"number\") {\n            return this.setByIndex(i, x, { name, inPlace });\n        } else {\n            return this.setByName(i, x, { inPlace });\n        }\n    }\n\n    /**\n     * @param {?Array} names - Array of strings of length equal to {@linkcode List#length length}.\n     * This may contain duplicates.\n     * Alternatively `null`, to remove existing names.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after replacing the names with `names`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    setNames(names, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        if (names !== null) {\n            if (names.length != this._values.length) {\n                throw new Error(\"'names' and 'values' should have the same length\");\n            }\n            for (const n of names) {\n                if (typeof n != \"string\") {\n                    throw new Error(\"'names' should be an array of strings\");\n                }\n            }\n        }\n\n        target._names = new IndexedNames(names);\n        return target;\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} i - Index of the List element to delete.\n     * This should be non-negative and no less than {@linkcode List#length length}.\n     * @param {Object} [options={}] - Further options.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `i`-th element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    deleteByIndex(i, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        this.#check_index(i);\n        target._values.splice(i, 1);\n        if (target._names !== null) {\n            target._names = target._names.delete(i, { inPlace });\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string} name - Name of the List element to delete.\n     * This should already exist in {@linkcode List#names names}.\n     * @param {?string} [options.name=null] - See the argument of the same name in {@linkcode List#setByName setByName}.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `name`d element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    deleteByName(name, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n        if (!inPlace) {\n            target._values = target._values.slice();\n        }\n\n        if (target._names == null) {\n            throw new Error(\"no available names in this \" + this.constructor.className);\n        }\n\n        // Don't cache as we're going to reset the lookup immediately, so it would be needlessly inefficient.\n        let candidate = this._names.nameToIndexUncached(name);\n        if (candidate < 0) {\n            throw new Error(\"no matching name for '\" + name + \"' in this \" + this.constructor.className);\n        }\n\n        target._values.splice(candidate, 1);\n        if (target._names !== null) {\n            target._names = target._names.delete(candidate, { inPlace });\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {string|number} i - Index or name of the List element to delete.\n     * Numbers are passed to {@linkcode List#deleteByIndex deleteByIndex} and strings are passed to {@linkcode List#deleteByName deleteByName}.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} The List after deleting the `i`-th element.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    delete(i, { inPlace = false } = {}) {\n        if (typeof i == \"number\") {\n            return this.deleteByIndex(i, { inPlace });\n        } else {\n            return this.deleteByName(i, { inPlace });\n        }\n    }\n\n    /***********************************************/\n\n    /**\n     * @param {number} start - Index of the first element in the slice.\n     * @param {number} end - Index past the last element in the slice.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} A List that is sliced to `[start, end)`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceRange(start, end, { inPlace = false } = {}) {\n        let target = cutils.setterTarget(this, inPlace);\n\n        target._values = target._values.slice(start, end);\n        if (this._names !== null) {\n            target._names = new IndexedNames(target._names.names().slice(start, end));\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} indices - Array of numbers or strings specifying the List elements to retain in the slice.\n     * Numbers are interpreted as positional indices while strings are interpreted as names.\n     * @param {Object} [options={}] - Further options.\n     * @param {boolean} [options.inPlace=false] - Whether to modify this List instance in place.\n     * If `false`, a new instance is returned.\n     *\n     * @return {List} A List containing the specified elements in `indices`.\n     * If `inPlace = true`, this is a reference to the current instance, otherwise a new instance is created and returned.\n     */\n    sliceIndices(indices, { inPlace = false } = {}) {\n        let new_names = [];\n        let new_values = [];\n\n        for (let i of indices) {\n            if (typeof i == \"string\") {\n                if (this._names == null) {\n                    throw new Error(\"no available names in this \" + this.constructor.className);\n                }\n                i = this._names.nameToIndex(i);\n            } else {\n                this.#check_index(i);\n            }\n\n            new_values.push(this._values[i]);\n            if (this._names !== null) {\n                new_names.push(this._names.indexToName(i));\n            }\n        }\n\n        let target = cutils.setterTarget(this, inPlace);\n        target._values = new_values;\n        if (this._names !== null) {\n            target._names = new IndexedNames(new_names);\n        }\n\n        target._lookup = new Map;\n        return target;\n    }\n\n    /***********************************************/\n\n    /**\n     * @return {iterator} An iterable iterator that can be used in, e.g., `for...of` constructs to loop over the List.\n     * The list values are directly returned during iteration, i.e., names are ignored.\n     */\n    [Symbol.iterator]() {\n        let counter = 0;\n        let all_values = this._values;\n        return {\n            next: function() {\n                if (counter < all_values.length) {\n                    let val = all_values[counter];\n                    counter++;\n                    return { done: false, value: val };\n                } else {\n                    return { done: true };\n                }\n            },\n            [Symbol.iterator]() {\n                return this;\n            },\n        }\n    }\n\n    /***********************************************/\n\n    _bioconductor_LENGTH() {\n        return this.length();\n    }\n\n    _bioconductor_SLICE(i, { allowView = false }) {\n        let sliced = this.sliceIndices(i);\n        let output = new this.constructor;\n        output._values = sliced._values;\n        output._names = sliced._names;\n        return output;\n    }\n\n    _bioconductor_CLONE({ deepCopy = true }) {\n        let output = new this.constructor;\n        output._values = cutils.cloneField(this._values, deepCopy);\n        output._names = cutils.cloneField(this._names, deepCopy);\n        return output;\n    }\n\n    _bioconductor_COMBINE(objects) {\n        let all_values = this._values.slice();\n        let all_names = null;\n        if (this._names !== null) {\n            all_names = this.names().slice();\n        }\n\n        for (let x of objects) {\n            if (!(x instanceof List)) {\n                x = new List(x);\n            }\n\n            const xvals = x.values();\n            for (const y of xvals) {\n                all_values.push(y);\n            }\n\n            const xnames = x.names();\n            if (xnames === null) {\n                if (all_names !== null) {\n                    for (const y of xvals) {\n                        all_names.push(\"\");\n                    }\n                }\n            } else {\n                if (all_names === null) {\n                    all_names = new Array(all_values.length - xvals.length).fill(\"\");\n                }\n                for (const yn of xnames) {\n                    all_names.push(yn);\n                }\n            }\n        }\n\n        let output = new this.constructor;\n        output._values = all_values;\n        output._names = new IndexedNames(all_names);\n        return output;\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains integers or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class IntegerList extends List {\n    #sanitize(x) {\n        if (x !== null && !Number.isInteger(x)) {\n            throw new Error(\"only integers or nulls can be stored in an IntegerList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain integers or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?number} x - Value of a List element as an integer or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?number} x - Value of a List element as an integer or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains numbers or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class NumberList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"number\") {\n            throw new Error(\"only numbers or nulls can be stored in a NumberList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain numbers or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?number} x - Value of a List element as a number or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?number} x - Value of a List element as a number or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains strings or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class StringList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"string\") {\n            throw new Error(\"only strings or nulls can be stored in a StringList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain strings or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?boolean} x - Value of a List element as a string or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?boolean} x - Value of a List element as a string or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n\n/**\n * Subclass of a {@linkplain List} that only contains booleans or `null`s.\n * If a `null` is present, it should be treated as a missing value.\n * @extends List\n */\nexport class BooleanList extends List {\n    #sanitize(x) {\n        if (x !== null && typeof x !== \"boolean\") {\n            throw new Error(\"only booleans or nulls can be stored in a StringList\");\n        }\n        return x;\n    }\n\n    /**\n     * @param {Array|Map|Object} values - Elements of the List.\n     * This should only contain booleans or `null`s.\n     * @param {Object} [options={}] - Further options.\n     */\n    constructor(values, options = {}) {\n        if (arguments.length == 0) {\n            super();\n        } else {\n            super(values, options);\n            for (const x of this._values) {\n                this.#sanitize(x);\n            }\n        }\n    }\n\n    /**\n     * @param {number} i - Index of the List element to set, see {@linkcode List#setByIndex List.setByIndex} for details.\n     * @param {?boolean} x - Value of a List element as a boolean or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByIndex List.setByIndex} for details.\n     *\n     * @return {List} The List after setting the `i`-th element to `x`, see {@linkcode List#setByIndex List.setByIndex} for details.\n     */\n    setByIndex(i, x, options = {}) {\n        return super.setByIndex(i, this.#sanitize(x), options);\n    }\n\n    /**\n     * @param {string} name - Name of the List element to set, see {@linkcode List#setByName List.setByName} for details.\n     * @param {?boolean} x - Value of a List element as a boolean or `null`.\n     * @param {Object} [options={}] - Further options, see {@linkcode List#setByName List.setByName} for details.\n     *\n     * @return {List} The List after setting the `name`d entry to `x`, see {@linkcode List#setByName List.setByName} for details.\n     */\n    setByName(name, x, options = {}) {\n        return super.setByName(name, this.#sanitize(x), options);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as bioc from \"bioconductor\";\nimport * as utils from \"./utils/general.js\";\nimport * as rutils from \"../readers/index.js\";\nimport * as inputs_module from \"./inputs.js\";\nimport * as norm_module from \"./rna_normalization.js\";\n\nconst baseUrl = \"https://github.com/kanaverse/singlepp-references/releases/download/2023-04-28\";\n\nexport const step_name = \"cell_labelling\";\n\n/************************************\n ****** Internals for loading *******\n ************************************/\n\nvar download_fun  = utils.defaultDownload;\n\nfunction set_download(fun) {\n    let previous = download_fun;\n    download_fun = fun;\n    return previous;\n}\n\nasync function acquire_file(name, suffix) {\n    let full = name + \"_\" + suffix;\n    let b = await download_fun(baseUrl + \"/\" + full);\n    return new rutils.SimpleFile(b, { name: full })\n}\n\nconst all_loaded = {};\n\nfunction flush_prepared(cache) {\n    if (\"prepared\" in cache) {\n        for (const v of Object.values(cache.prepared)) {\n            v.built.raw.free();\n        }\n        delete cache.prepared;\n    }\n}\n\nasync function process_genes(file) {\n    let gene_lines = await rutils.readLines2(file.content(), { compression: \"gz\" }); // gene names\n    let acquired = [];\n\n    for (const x of gene_lines) {\n        let val = null;\n        if (x !== \"\") {\n            val = x.split(\"\\t\");\n            if (val.length == 1) {\n                val = val[0];\n            }\n        }\n        acquired.push(val);\n    }\n\n    return acquired;\n}\n\nasync function load_reference(name, gene_id_type) {\n    let gene_suffix = \"genes_\" + gene_id_type.toLowerCase() + \".csv.gz\";\n\n    if (name in all_loaded) {\n        let output = all_loaded[name];\n        let known_genes = output.genes;\n        if (!(gene_id_type in known_genes)) {\n            known_genes[gene_id_type] = await process_genes(await acquire_file(name, gene_suffix));\n        }\n        return output;\n    }\n\n    const suffixes = [ \n        \"labels_fine.csv.gz\",\n        \"label_names_fine.csv.gz\",\n        \"markers_fine.gmt.gz\",\n        \"matrix.csv.gz\",\n        gene_suffix\n    ];\n\n    let contents = await Promise.all(suffixes.map(x => acquire_file(name, x)));\n\n    let loaded;\n    let stored;\n    try {\n        loaded = scran.loadLabelCellsReferenceFromBuffers(\n            contents[3].buffer(), // rank matrix\n            contents[2].buffer(), // markers\n            contents[0].buffer()  // label per sample\n        );\n\n        let labels = await rutils.readLines2(contents[1].content(), { compression: \"gz\" }); // full label names\n        stored = {\n            \"raw\": loaded, \n            \"labels\": labels,\n            \"genes\": {}\n        };\n\n        stored.genes[gene_id_type] = await process_genes(contents[4]);\n        all_loaded[name] = stored;\n\n    } catch (e) {\n        utils.freeCache(loaded);\n        throw e;\n    }\n\n    return stored;\n}\n\nfunction flush_loaded() {\n    for (const [k, v] of Object.entries(all_loaded)) {\n        v.raw.free();\n        delete all_loaded[k];\n    }\n}\n\n/*************************************\n ****** Internals for building *******\n *************************************/\n\nconst available_references = {\n    \"9606\": [ \"BlueprintEncode\", \"DatabaseImmuneCellExpression\", \"HumanPrimaryCellAtlas\", \"MonacoImmune\", \"NovershternHematopoietic\" ],\n    \"10090\": [ \"ImmGen\", \"MouseRNAseq\" ]\n};\n\nfunction internal_build_reference(name, gene_ids, gene_id_type) {\n    let built;\n    let output;\n    try {\n        let current = all_loaded[name];\n        let loaded = current.raw;\n\n        if (!(gene_id_type in current.genes)) {\n            throw new Error(\"unknown gene type '\" + gene_id_type + \"'\");\n        }\n        let chosen_ids = current.genes[gene_id_type];\n\n        built = scran.trainLabelCellsReference(gene_ids, loaded, chosen_ids); \n        output = {\n            \"loaded\": current,\n            \"built\": {\n                \"features\": chosen_ids,\n                \"raw\": built\n            }\n        };\n\n    } catch (e) {\n        utils.freeCache(built);\n        throw e;\n    }\n\n    return output;\n}\n\nasync function build_reference(cache, references, guess_ids, species, gene_id_column, gene_id_type, old_parameters, annofun, guessfun) {\n    if (\n        guess_ids !== old_parameters.guess_ids ||\n        utils.changedParameters(references, old_parameters.references) ||\n        (\n            !guess_ids &&\n            (\n                species !== old_parameters.species ||\n                gene_id_column !== old_parameters.gene_id_column ||\n                gene_id_type !== old_parameters.gene_id_type\n            )\n        )\n    ) {\n        let species2 = species;\n        let gene_id_column2 = gene_id_column;\n        let gene_id_type2 = gene_id_type;\n\n        if (guess_ids) {\n            let auto = CellLabellingState.configureFeatureParameters(guessfun());\n            species2 = auto.species;\n            gene_id_column2 = auto.gene_id_column;\n            gene_id_type2 = auto.gene_id_type;\n        }\n\n        let allowable = new Set;\n        for (const s of species2) {\n            if (s in available_references) {\n                available_references[s].forEach(x => { allowable.add(x); });\n            }\n        }\n\n        // Building each individual reference.\n        let feats = annofun();\n        let gene_ids = (gene_id_column2 == null ? feats.rowNames() : feats.column(gene_id_column2));\n        cache.gene_ids = gene_ids;\n\n        let valid = {};\n        if (gene_ids !== null) {\n            if (references == null) {\n                references = Array.from(allowable);\n            }\n            for (const ref of references) {\n                if (allowable.has(ref)) {\n                    await load_reference(ref, gene_id_type2);\n                    valid[ref] = internal_build_reference(ref, gene_ids, gene_id_type2);\n                }\n            }\n        }\n\n        flush_prepared(cache);\n        cache.prepared = valid;\n\n        // Building an integrated reference, if necessary.\n        let used_refs = Object.keys(valid);\n        if (used_refs.length > 1) {\n            let arr = Object.values(valid);\n            let loaded = arr.map(x => x.loaded.raw);\n            let feats = arr.map(x => x.built.features);\n            let built = arr.map(x => x.built.raw);\n\n            utils.freeCache(cache.integrated);\n            cache.integrated = scran.integrateLabelCellsReferences(gene_ids, loaded, feats, built);\n        } else {\n            utils.freeCache(cache.integrated);\n            delete cache.integrated;\n        }\n        cache.used_refs = used_refs;\n\n       return true;\n    }\n\n    return false;\n}\n\nfunction create_defaults() {\n    return {\n        references: null,\n        guess_ids: true,\n        species: [],\n        gene_id_column: null,\n        gene_id_type: \"ENSEMBL\"\n    };\n}\n\nfunction dereference_parameters(parameters) {\n    parameters.references = bioc.CLONE(parameters.references); // make a copy to avoid pass-by-reference behavior.\n    parameters.species = bioc.CLONE(parameters.species);\n    return parameters;\n}\n\nfunction fetch_parameters(parameters) {\n    // Avoid pass-by-reference behavior.\n    let out = { ...parameters };\n    out.references = bioc.CLONE(out.references);\n    out.species = bioc.CLONE(out.species);\n    return out;\n}\n\n/************************************\n ****** Internals for compute *******\n ************************************/\n\nfunction transform_results(names, results, assigned) {\n    let nclusters = results.numberOfCells();\n    let ntargets = names.length;\n    let output = new Array(nclusters);\n\n    for (var r = 0; r < nclusters; r++) {\n        let all_scores = {};\n        let cscores = results.scoreForCell(r);\n        for (var l = 0; l < ntargets; l++) {\n            all_scores[names[l]] = cscores[l];\n        }\n        output[r] = { best: names[assigned[r]], all: all_scores };\n    }\n\n    return output;\n}\n\nfunction assign_labels_internal(x, cache) {\n    let matrix = x;\n    let temp_cluster_means;\n    let temp_matrix;\n\n    // Converting marker results into means.\n    if (x instanceof scran.ScoreMarkersResults) {\n        let ngroups = x.numberOfGroups();\n\n        if (cache.gene_ids === null) {\n            matrix = null;                \n        } else {\n            let ngenes = cache.gene_ids.length;\n\n            // Creating a column-major array of mean vectors for each cluster.\n            temp_cluster_means = scran.createFloat64WasmArray(ngroups * ngenes);\n            for (var g = 0; g < ngroups; g++) {\n                let means = x.mean(g, { copy: false }); // Warning: direct view in wasm space - be careful.\n                if (means.length !== ngenes) {\n                    throw new Error(\"unexpected number of genes in marker results\");\n                }\n                let cluster_array = temp_cluster_means.array();\n                cluster_array.set(means, g * ngenes);\n            }\n\n            matrix = scran.initializeDenseMatrixFromDenseArray(ngenes, ngroups, temp_cluster_means, { columnMajor: true });\n        }\n    } else {\n        if (cache.gene_ids !== null && x.numberOfRows() !== cache.gene_ids.length) {\n            throw new Error(\"unexpected number of genes in the input matrix\"); \n        }\n    }\n\n    // Running classifications; this is a no-op if gene_ids = null as 'valid' should be empty.\n    let valid = cache.prepared;\n    let results = { per_reference: {} };\n    let raw = {};\n    for (const [key, ref] of Object.entries(valid)) {\n        let current = scran.labelCells(matrix, ref.built.raw);\n        raw[key] = current;\n        results.per_reference[key] = transform_results(ref.loaded.labels, current, current.predicted({ copy: false }));\n    }\n\n    if (\"integrated\" in cache) {\n        let single_results = [];\n        for (const key of cache.used_refs) { // enforce correct order.\n            single_results.push(raw[key]);\n        }\n\n        let current = scran.integrateLabelCells(matrix, single_results, cache.integrated);\n        results.integrated = transform_results(cache.used_refs, current, current.predicted({ copy: false }));\n        current.free();\n    }\n\n    for (const v of Object.values(raw)) {\n        v.free();\n    }\n    utils.freeCache(temp_matrix);\n    utils.freeCache(temp_cluster_means);\n\n    return results;\n}\n\nfunction assign_labels(x, group, cache) {\n    if (group === null) {\n        return assign_labels_internal(x, cache);\n    }\n\n    let to_collect = [];\n    let output;\n    try {\n        let dump = utils.subsetInvalidFactors([group]);\n        to_collect.push(dump.arrays[0].ids);\n\n        let mat = x;\n        if (dump.retain !== null) {\n            let sub = scran.subsetColumns(x, dump.retain);\n            to_collect.push(sub);\n            mat = sub;\n        }\n\n        let aggr = scran.aggregateAcrossCells(mat, dump.arrays[0].ids, { average: true });\n        to_collect.push(aggr);\n\n        let all_sums = aggr.allSums({ asTypedArray: false });\n        to_collect.push(all_sums);\n\n        let aggrmat = scran.initializeDenseMatrixFromDenseArray(\n            mat.numberOfRows(), \n            aggr.numberOfGroups(), \n            all_sums,\n            { columnMajor: true }\n        );\n        to_collect.push(aggrmat);\n\n        output = assign_labels_internal(aggrmat, cache);\n        output.groups = dump.arrays[0].levels;\n    } finally {\n        to_collect.forEach(utils.freeCache);\n    }\n\n    return output;\n}\n\n/********************\n ****** State *******\n ********************/\n\n/**\n * Cell labelling involves assigning cell type labels to clusters using the [**SingleR** algorithm](https://github.com/LTLA/CppSingleR),\n * based on [pre-formatted reference expression profiles](https://github.com/clusterfork/singlepp-references).\n * This wraps [`labelCells`](https://kanaverse.github.io/scran.js/global.html#labelCells)\n * and related functions from [**scran.js**](https://github.com/kanaverse/scran.js).\n *\n * In theory, we could do this at the single-cell level, but we use clusters instead to expedite the computation and simplify interpretation.\n * If multiple references are requested, we will use each for assignment before attempting to choose the best label for each cluster across references.\n *\n * Methods not documented here are not part of the stable API and should not be used by applications.\n * @hideconstructor\n */\nexport class CellLabellingState {\n    #inputs;\n    #parameters;\n    #cache;\n\n    constructor(inputs, parameters = null, cache = null) {\n        if (!(inputs instanceof inputs_module.InputsState)) {\n            throw new Error(\"'inputs' should be a State object from './inputs.js'\");\n        }\n        this.#inputs = inputs;\n\n        this.#parameters = (parameters === null ? {} : parameters);\n        this.#cache = (cache === null ? {} : cache);\n        this.changed = false;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /***************************\n     ******** Getters **********\n     ***************************/\n\n    valid() {\n        let mat = this.#inputs.fetchCountMatrix();\n        return mat.has(\"RNA\");\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        // Avoid any pass-by-reference activity.\n        let out = { ...this.#parameters };\n        out.references = bioc.CLONE(out.references);\n        out.species = bioc.CLONE(out.species);\n        return out;\n    }\n\n    /**\n     * @return {object} Object where each key is the name of a reference and each value is the number of shared features between the test and reference daatasets.\n     */\n    fetchNumberOfSharedFeatures() {\n        let output = {};\n        for (const key of this.#cache.used_refs) {\n            output[key] = this.#cache.prepared[key].built.raw.numberOfFeatures();\n        }\n        return output;\n    }\n\n    /****************************\n     ******** Defaults **********\n     ****************************/\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellLabellingState#compute compute} for details.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    static configureFeatureParameters(guesses) {\n        let best_key = null;\n        let best = { type: \"symbol\", species: \"9606\", confidence: 0 };\n\n        if (\"row_names\" in guesses) {\n            let val = guesses.row_names;\n            if (val.confidence > best.confidence) {\n                best = val;\n            }\n        }\n\n        for (const [key, val] of Object.entries(guesses.columns)) {\n           if (val.confidence > best.confidence) {\n                best = val;\n                best_key = key;\n            }\n        }\n\n        return {\n            gene_id_column: best_key,\n            species: [best.species],\n            gene_id_type: best.type.toUpperCase()\n        };\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, {@linkcode CellLabellingState#compute compute} will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingState} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode freeAnalysis}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    /**\n     * This method should not be called directly by users, but is instead invoked by {@linkcode runAnalysis}.\n     *\n     * @param {object} parameters - Parameter object, equivalent to the `cell_labelling` property of the `parameters` of {@linkcode runAnalysis}.\n     * @param {?Array} [parameters.references] - Array of strings specifying the names of the reference datasets, \n     * see {@linkcode CellLabellingState#availableReferences availableReferences} for more details.\n     * If `null`, all reference datasets from all species are used, and `guess_ids` is set to `true` to determine the relevant species.\n     * @param {boolean} [parameters.guess_ids] - Automatically choose feature-based parameters based on the feature annotation for the RNA modality.\n     * If `true`, the column of the annotation that best matches human/mouse Ensembl/symbols is identified and used to set `species`, `gene_id_column` and `gene_id_type`.\n     * @param {Array} [parameters.species] - Array of strings specifying zero, one or more species involved in this dataset.\n     * Each entry should be an NCBI taxonomy ID (e.g. `\"9606\"`, `\"10090\"`) as specified in {@linkcode CellLabellingState#availableReferences availableReferences}.\n     * This is used internally to filter `references` to the entries relevant to these species. \n     * Ignored if `guess_ids = true`.\n     * @param {?(string|number)} [parameters.gene_id_column] - Name or index of the column of the RNA entry of\n     * {@linkcode InputsState#fetchFeatureAnnotations InputsState.fetchFeatureAnnotations} containing the identity of each gene. \n     * If `null`, identifiers are taken from the row names.\n     * Ignored if `guess_ids = true`.\n     * @param {string} [parameters.gene_id_type] - Type of feature identifier in `gene_id_column`.\n     * This should be one of `\"ENSEMBL\"`, `\"SYMBOL\"` or `\"ENTREZ\"`\n     * Ignored if `guess_ids = true`.\n     *\n     * @return The object is updated with the new results.\n     * @async\n     */\n    async compute(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CellLabellingState.defaults());\n        if (!(\"references\" in parameters)) {\n            parameters.guess_ids = true;\n        }\n\n        this.changed = false;\n\n        if (this.valid()) {\n            this.changed = await build_reference(\n                this.#cache, \n                parameters.references, \n                parameters.guess_ids, \n                parameters.species, \n                parameters.gene_id_column, \n                parameters.gene_id_type, \n                this.#parameters, \n                () => this.#inputs.fetchFeatureAnnotations()[\"RNA\"],\n                () => this.#inputs.guessRnaFeatureTypes()\n            );\n        }\n\n        this.#parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in the upstream {@linkcode InputsState}.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain externl:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n\n/*****************************\n ******** Standalone *********\n *****************************/\n\n/**\n * Standalone version of {@linkplain CellLabellingState} that provides the same functionality outside of {@linkcode runAnalysis}.\n * Users can supply their own feature annotations to build the reference datasets prior to label assignment.\n * Users should await on the return value of the {@linkcode CellLabellingStandalone#ready ready} method after construction.\n * Once resolved, other methods in this class may be used.\n */\nexport class CellLabellingStandalone {\n    #parameters;\n    #cache;\n    #annotations;\n    #guesses;\n    #pre_parameters;\n\n    /**\n     * @param {external:DataFrame} annotations - Feature annotations for the dataset.\n     */\n    constructor(annotations) {\n        this.#parameters = {};\n        this.#pre_parameters = CellLabellingStandalone.defaults();\n        this.#annotations = annotations;\n        this.#cache = {};\n        this.#guesses = null;\n    }\n\n    free() {\n        flush_prepared(this.#cache);\n    }\n\n    /**\n     * @return {object} Object containing default parameters,\n     * see the `parameters` argument in {@linkcode CellLabellingStandalone#setParameters setParameters} for details.\n     */\n    static defaults() {\n        return create_defaults();\n    }\n\n    /**\n     * @return {object} Object containing the parameters.\n     */\n    fetchParameters() {\n        return fetch_parameters(this.#pre_parameters);\n    }\n\n    /***************************\n     ******** Remotes **********\n     ***************************/\n\n    /**\n     * Available references for each species.\n     * Each key is a taxonomy ID and each value is an array of strings containing the names of references for that species.\n     * @type {object}\n     */\n    static availableReferences = available_references;\n\n    /**\n     * Flush all cached references.\n     *\n     * By default, this class will cache the loaded references in a global cache for re-use across {@linkplain CellLabellingStandlone} instances.\n     * These cached references are not tied to any single instance and will not be removed by garbage collectors or by {@linkcode CellLabellingStandalone#free free}.\n     * Rather, this function should be called to release the relevant memory.\n     */\n    static flush() {\n        flush_loaded();\n        return;\n    }\n\n    /**\n     * Specify a function to download references for the cell labelling step.\n     *\n     * @param {function} fun - Function that accepts a single string containing a URL and returns any value that can be used in the {@linkplain SimpleFile} constructor.\n     * This is most typically a Uint8Array of that URL's contents, but it can also be a path to a locally cached file on Node.js.\n     *\n     * @return `fun` is set as the global downloader for this step. \n     * The _previous_ value of the downloader is returned.\n     */\n    static setDownload(fun) {\n        return set_download(fun);\n    }\n\n    /***************************\n     ******** Compute **********\n     ***************************/\n\n    #guessFeatureTypes() {\n        if (this.#guesses == null) {\n            this.#guesses = utils.guessFeatureTypes(this.#annotations);\n        }\n        return this.#guesses;\n    }\n\n    /**\n     * If this method is not called, the parameters default to those in {@linkcode CellLabellingStandalone.defaults defaults}.\n     *\n     * @param {object} parameters - Parameter object, see {@linkcode CellLabellingState#compute CellLabellingState.compute} for details.\n     * @return The object is updated with the new parameters.\n     * Note that this will not affect existing results computed by {@linkcode CellLabellingStandalone#computeLabels computeLabels}.\n     */\n    setParameters(parameters) {\n        parameters = utils.defaultizeParameters(parameters, CellLabellingStandalone.defaults());\n        this.#pre_parameters = dereference_parameters(parameters);\n    }\n\n    /**\n     * This should be called after construction and/or calling {@linkcode CellLabellingStandalone#setParameters setParameters}. \n     * Users should wait for the return value to resolve before calling any other methods of this class.\n     * \n     * @return Reference datasets are loaded into memory. \n     * @async\n     */\n    async ready() {\n        await build_reference(\n            this.#cache, \n            this.#pre_parameters.references, \n            this.#pre_parameters.guess_ids, \n            this.#pre_parameters.species, \n            this.#pre_parameters.gene_id_column, \n            this.#pre_parameters.gene_id_type, \n            this.#parameters, \n            () => this.#annotations,\n            () => this.#guessFeatureTypes()\n        );\n\n        this.#parameters = this.#pre_parameters;\n    }\n\n    /**\n     * @param {external:ScranMatrix|external:ScoreMarkersResults} x - A matrix of (normalized or unnormalized) expression values, with genes in rows and cells/clusters in columns.\n     * Alternatively, an object containing marker results, e.g., as computed by {@linkcode MarkerDetectionState}. \n     *\n     * In both cases, the identity of genes should correspond to that in `annotations` in the constructor of this instance.\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?(Array|TypedArray)} [options.group=null] - Array of length equal to the number of columns of `x`, containing grouping assignments.\n     * If provided, the average expression profile of each group is used for cell type labelling.\n     * This is only used if `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     * \n     * @return {object} Object containing:\n     *\n     * - `per_reference`: an object where each key is the name of a reference dataset and its value is an array.\n     *   Each array is of length equal to the number of columns of `x` (if matrix), groups in `x` (if marker results), or groups in `group`.\n     *   Each entry is an object containing `best`, the name of the best label assigned to a column/group in this reference;\n     *   and `all`, an object where each key is a label in this reference dataset and its value is the score for assigning that label to this column/group.\n     * - (optional) `integrated`: an array of length equal to the number of columns/groups.\n     *   Each entry is an object containing `best`, the name of the best reference for this column/group;\n     *   and `all`, an object where each key is the name of a reference dataset and its value is the score for this column/group.\n     *   This property is only reported if multiple references are used.\n     * - (optional) `groups`: an array of length equal to the number of groups, containing the identity of each group.\n     *   Only reported if an input `group` is supplied and `x` is a {@linkplain external:ScranMatrix ScranMatrix}.\n     */\n    computeLabels(x, { group = null } = {}) {\n        return assign_labels(x, group, this.#cache);\n    }\n}\n","import { readObject, saveObject, readObjectFile } from \"./general.js\";\n\nexport async function readAnnotatedMetadata(path, globals, options, optname) {\n    if (!(await globals.exists(path + \"/OBJECT\"))) { // check existence of file, not directory.\n        return {};\n    }\n\n    if (optname in options) {\n        let optional = options[optname];\n        if (optional === false) {\n            return {};\n        } else if (optional !== true) {\n            let meta = await readObjectFile(path, globals);\n            return optional(path, meta, globals, options);\n        }\n    }\n\n    return readObject(path, null, globals, options);\n}\n\nexport async function saveAnnotatedMetadata(x, path, globals, options) {\n    if (x.length() === 0) {\n        return;\n    }\n    await saveObject(x, path, globals, options);\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\n\n/**\n * Transpose a matrix that is stored as a contiguous TypedArray.\n *\n * @param {number} numberOfRows - Number of rows in the matrix.\n * @param {number} numberOfColumns - Number of columns in the matrix.\n * @param {WasmArray|Array|TypedArray} values - Values of all elements in the matrix.\n * This should have length equal to the product of `numberOfRows` and `numberOfColumns`.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.columnMajor=true] - Whether `values` contains the matrix in a column-major order.\n * @param {boolean} [options.asTypedArray=true] - Whether to return a Float64Array.\n * If `false`, a Float64WasmArray is returned instead.\n * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output size factors.\n * Length should be equal to that of `values`.\n * If `null`, an array is allocated by the function.\n *\n * @return {Float64Array|Float64WasmArray} Array containing the transposed contents of `values`.\n * If `buffer` is supplied, the function returns `buffer` if `asTypedArray = false`, or a view on `buffer` if `asTypedArray = true`.\n */\nexport function transposeMatrix(numberOfRows, numberOfColumns, values, options = {}) {\n    let { columnMajor = true, asTypedArray = true, buffer = null, ...others } = options;\n    utils.checkOtherOptions(others);\n\n    let local_buffer = null;\n    let input_buffer = null;\n    if (values.length !== numberOfRows * numberOfColumns) {\n        throw new Error(\"'buffer' should have length equal to the product of 'numberOfRows' and 'numberOfColumns'\");\n    }\n\n    try {\n        if (buffer === null) {\n            local_buffer = utils.createFloat64WasmArray(values.length);\n            buffer = local_buffer;\n        } else if (buffer.length != values.length) {\n            throw new Error(\"'buffer' should have length equal to the product of 'numberOfRows' and 'numberOfColumns'\");\n        }\n\n        input_buffer = utils.wasmifyArray(values, \"Float64WasmArray\");\n        wasm.call(module => module.transpose_matrix(numberOfRows, numberOfColumns, input_buffer.offset, columnMajor, buffer.offset));\n\n    } catch(e) {\n        utils.free(local_buffer);\n        throw e;\n    } finally {\n        utils.free(input_buffer);\n    }\n\n    return utils.toTypedArray(buffer, local_buffer == null, asTypedArray);\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./general.js\";\nimport * as aworkers from \"./abstract/workers_parent.js\";\n\nvar animateFun = (x, y, i) => null;\n\n/**\n * Specify a function to handle animation iterations for the low-dimensional embeddings.\n * The exact nature of this handling is arbitrary - developers may post the contents to another thread, save them to file, etc.\n *\n * @param {function} fun - Function to process each animation iteration.\n * This should accept four arguments, in the following order:\n * - A string containing either `\"tsne\"` or `\"umap\"`.\n * - A `Float64Array` containing the x-coordinates for each cell.\n * - A `Float64Array` containing the y-coordinates for each cell.\n * - An integer specifying the iteration number.\n *\n * @return `fun` is set as the global animator function for t-SNE and UMAP.\n * The _previous_ value of the animator is returned.\n */\nexport function setVisualizationAnimate(fun) {\n    let previous = animateFun;\n    animateFun = fun;\n    return previous;\n}\n\nexport var scranOptions = { numberOfThreads: 1 };\n\nexport function computeNeighbors(index, k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = scran.createInt32WasmArray(results.numberOfCells());\n        ibuf = scran.createInt32WasmArray(results.size());\n        dbuf = scran.createFloat64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nconst worker_registry = [];\nconst worker_cache_registry = [];\n\nfunction message_type(info) {\n    return info.type;\n}\n\nfunction handle_message(functions, info) {\n    if (message_type(info) == \"error\") {\n        functions.reject(info.error);\n    } else {\n        functions.resolve(info.data);\n    }\n}\n\nexport function sendTask(worker_id, payload, transferrable = []) {\n    let worker = worker_registry[worker_id];\n    let cache = worker_cache_registry[worker_id];\n\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        let functions = { \"resolve\": resolve, \"reject\": reject };\n        if (i in cache.promises) {\n            // Not sure if the JS engine guarantees that the resolve/reject is\n            // set up before the worker returns the message; for all we know,\n            // we could send the message (and hit the worker callback) before\n            // we run the set-up code. If that's the case, we simply resolve \n            // this Promise using the information provided in the callback.\n            handle_message(functions, cache.promises[i]);\n            delete cache.promises[i];\n        } else {\n            cache.promises[i] = functions;\n        }\n    });\n\n    cache.counter++;\n    payload.id = i;\n    aworkers.sendMessage(worker, payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, scranOptions) { \n    let n = worker_registry.length;\n    worker_registry.push(worker);\n    let cache = { counter: 0, promises: {} };\n    worker_cache_registry.push(cache);\n\n    aworkers.registerCallback(worker, msg => {\n        var type = message_type(msg.data);\n        if (type.endsWith(\"_iter\")) {\n            animateFun(type.slice(0, -5), msg.data.x, msg.data.y, msg.data.iteration);\n            return;\n        }\n\n        var id = msg.data.id;\n        if (id in cache.promises) {\n            handle_message(cache.promises[id], msg.data);\n            delete cache.promises[id];\n        } else {\n            // If the Promise setup in sendTask has not yet been scheduled in\n            // the event loop, we store the message so that it can be used\n            // directly to resolve the Promise during setup.\n            cache.promises[id] = msg.data;\n        }\n    });\n\n    return {\n        \"worker_id\": n,\n        \"ready\": sendTask(n, { \"cmd\": \"INIT\", scranOptions: scranOptions })\n    };\n}\n\nexport async function killWorker(worker_id) {\n    await sendTask(worker_id, { \"cmd\": \"KILL\" });\n    let worker = worker_registry[worker_id];\n    worker_registry[worker_id] = null;\n    return aworkers.terminateWorker(worker);\n}\n\nexport function killAllWorkers() {\n    let p = [];\n    for (var i = 0; i < worker_registry.length; i++) {\n        if (worker_registry[i] !== null) {\n            let p_ = killWorker(i);\n            if (p_) { // not null, not undefined.\n                p.push(p_);\n            }\n        }\n    }\n    return Promise.all(p).then(x => null);\n}\n\nexport function runWithNeighbors(worker_id, args, nn_out) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        transferrable = [\n            nn_out.runs.buffer,\n            nn_out.indices.buffer,\n            nn_out.distances.buffer\n        ];\n        run_msg.neighbors = nn_out;\n    }\n\n    return sendTask(worker_id, run_msg, transferrable);\n}\n","import * as scran from \"scran.js\";\n\nimport * as inputs from \"./steps/inputs.js\";\n\nimport * as qc from \"./steps/rna_quality_control.js\";\nimport * as qcadt from \"./steps/adt_quality_control.js\";\nimport * as qccrispr from \"./steps/crispr_quality_control.js\";\nimport * as filters from \"./steps/cell_filtering.js\";\n\nimport * as normalization from \"./steps/rna_normalization.js\";\nimport * as normadt from \"./steps/adt_normalization.js\";\nimport * as normcrispr from \"./steps/crispr_normalization.js\";\n\nimport * as variance from \"./steps/feature_selection.js\";\n\nimport * as pca from \"./steps/rna_pca.js\";\nimport * as pcaadt from \"./steps/adt_pca.js\";\nimport * as pcacrispr from \"./steps/crispr_pca.js\";\nimport * as combine from \"./steps/combine_embeddings.js\";\nimport * as correct from \"./steps/batch_correction.js\";\n\nimport * as index from \"./steps/neighbor_index.js\";\nimport * as cluster_choice from \"./steps/choose_clustering.js\";\nimport * as kmeans_cluster from \"./steps/kmeans_cluster.js\";\nimport * as snn_cluster from \"./steps/snn_graph_cluster.js\";\n\nimport * as tsne from \"./steps/tsne.js\";\nimport * as umap from \"./steps/umap.js\";\n\nimport * as cluster_markers from \"./steps/marker_detection.js\";\nimport * as label_cells from \"./steps/cell_labelling.js\";\nimport * as custom_markers from \"./steps/custom_selections.js\";\n\nimport * as feature_set_enrichment from \"./steps/feature_set_enrichment.js\";\n\nexport { setCreateLink, setResolveLink } from \"./steps/inputs.js\";\nexport { MarkerDetectionState } from \"./steps/marker_detection.js\";\nexport { CustomSelectionsState } from \"./steps/custom_selections.js\";\n\nconst step_inputs = inputs.step_name;\nconst step_qc = qc.step_name;\nconst step_qc_adt = qcadt.step_name;\nconst step_qc_crispr = qccrispr.step_name;\nconst step_filter = filters.step_name;\nconst step_norm = normalization.step_name;\nconst step_norm_adt = normadt.step_name;\nconst step_norm_crispr = normcrispr.step_name;\nconst step_feat = variance.step_name;\nconst step_pca = pca.step_name;\nconst step_pca_adt = pcaadt.step_name;\nconst step_pca_crispr = pcacrispr.step_name;\nconst step_combine = combine.step_name;\nconst step_correct = correct.step_name;\nconst step_neighbors = index.step_name;\nconst step_tsne = tsne.step_name;\nconst step_umap = umap.step_name;\nconst step_kmeans = kmeans_cluster.step_name;\nconst step_snn = snn_cluster.step_name;\nconst step_choice = cluster_choice.step_name;\nconst step_markers = cluster_markers.step_name;\nconst step_labels = label_cells.step_name;\nconst step_custom = custom_markers.step_name;\nconst step_enrichment = feature_set_enrichment.step_name;\n\nconst load_flag = \"_loaded\";\n\n/**\n * Create a new analysis state in preparation for calling {@linkcode runAnalysis}.\n * Multiple states can be created and used interchangeably within the same Javascript runtime.\n *\n * @return A promise that resolves to an object containing states for all analysis steps.\n * This object can be used as input into {@linkcode runAnalysis}.\n */\nexport async function createAnalysis() {\n    return create_analysis(new inputs.InputsState);\n}\n\nfunction create_analysis(input_state) {\n    let output = {};\n    output[step_inputs] = input_state;\n\n    output[step_qc] = new qc.RnaQualityControlState(output[step_inputs]);\n    output[step_qc_adt] = new qcadt.AdtQualityControlState(output[step_inputs]);\n    output[step_qc_crispr] = new qccrispr.CrisprQualityControlState(output[step_inputs]);\n\n    let qc_states = { \"RNA\": output[step_qc], \"ADT\": output[step_qc_adt], \"CRISPR\": output[step_qc_crispr] }\n    output[step_filter] = new filters.CellFilteringState(output[step_inputs], qc_states);\n\n    output[step_norm] = new normalization.RnaNormalizationState(output[step_qc], output[step_filter]);\n    output[step_norm_adt] = new normadt.AdtNormalizationState(output[step_qc_adt], output[step_filter]);\n    output[step_norm_crispr] = new normcrispr.CrisprNormalizationState(output[step_qc_crispr], output[step_filter]);\n\n    output[step_feat] = new variance.FeatureSelectionState(output[step_filter], output[step_norm]);\n\n    output[step_pca] = new pca.RnaPcaState(output[step_filter], output[step_norm], output[step_feat]);\n    output[step_pca_adt] = new pcaadt.AdtPcaState(output[step_filter], output[step_norm_adt]);\n    output[step_pca_crispr] = new pcacrispr.CrisprPcaState(output[step_filter], output[step_norm_crispr]);\n\n    let pca_states = { \"RNA\": output[step_pca], \"ADT\": output[step_pca_adt], \"CRISPR\": output[step_pca_crispr] }\n    output[step_combine] = new combine.CombineEmbeddingsState(pca_states);\n    output[step_correct] = new correct.BatchCorrectionState(output[step_filter], output[step_combine]);\n\n    output[step_neighbors] = new index.NeighborIndexState(output[step_correct]);\n\n    output[step_tsne] = new tsne.TsneState(output[step_neighbors]);\n    output[step_umap] = new umap.UmapState(output[step_neighbors]);\n\n    output[step_kmeans] = new kmeans_cluster.KmeansClusterState(output[step_correct]);\n    output[step_snn] = new snn_cluster.SnnGraphClusterState(output[step_neighbors]);\n    output[step_choice] = new cluster_choice.ChooseClusteringState(output[step_snn], output[step_kmeans]);\n\n    let norm_states = { \"RNA\": output[step_norm], \"ADT\": output[step_norm_adt], \"CRISPR\": output[step_norm_crispr] };\n    output[step_markers] = new cluster_markers.MarkerDetectionState(output[step_filter], norm_states, output[step_choice]);\n    output[step_labels] = new label_cells.CellLabellingState(output[step_inputs]);\n    output[step_enrichment] = new feature_set_enrichment.FeatureSetEnrichmentState(output[step_inputs], output[step_filter], output[step_norm]);\n    output[step_custom] = new custom_markers.CustomSelectionsState(output[step_filter], norm_states);\n\n    return Promise.all([output[step_tsne].ready(), output[step_umap].ready()]).then(val => output);\n}\n\n/**\n * Free the contents of an analysis state.\n * This releases memory on the **scran.js** Wasm heap and terminates any workers associated with this analysis.\n *\n * @param state An existing analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n *\n * @return A promise that resolves to `null` when all states are freed.\n */\nexport function freeAnalysis(state) {\n    let promises = [];\n    for (const [k, v] of Object.entries(state)) {\n        if (k == load_flag) {\n            continue;\n        }\n        let p = v.free();\n        if (p) { // not null, not undefined.\n            promises.push(p); \n        }\n    }\n    return Promise.all(promises).then(x => null);\n}\n\n/**\n * Run a basic single-cell RNA-seq analysis with the specified files and parameters.\n * This will cache the results from each step so that, if the parameters change, only the affected steps will be rerun.\n *\n * @param {object} state - Object containing the analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n * @param {object} datasets - Object where each (arbitrarily named) property corresponds to an input dataset.\n * Each dataset should be a object that satisfies the {@linkplain Dataset} contract.\n *\n * Alternatively, `datasets` may be `null` if the input datasets were already loaded and cached in `state`.\n * This avoids the need to respecify the inputs after a previous call to {@linkcode runAnalysis} or from {@linkcode loadAnalysis}.\n * @param {object} params - An object containing parameters for all steps.\n * See {@linkcode analysisDefaults} for more details.\n * @param {object} [options] - Optional parameters.\n * @param {?function} [options.startFun=null] - Function that is called when each step is started.\n * This should accept a single argument - the name of the step.\n * The return value is ignored, but any promises will be awaited before the analysis proceeds to the next step.\n * If `null`, nothing is executed.\n * @param {?function} [options.finishFun=null] - Function that is called on successful execution of each step.\n * This should accept a single argument - the name of the step.\n * The return value is ignored, but any promises will be awaited before the analysis proceeds to the next step.\n * If `null`, nothing is executed.\n * \n * @return A promise that resolves to `null` when all asynchronous analysis steps are complete.\n * The contents of `state` are modified by reference to reflect the latest state of the analysis with the supplied parameters.\n */\nexport async function runAnalysis(state, datasets, params, { startFun = null, finishFun = null } = {}) {\n    let quickStart = async step => {\n        if (startFun !== null) {\n            await startFun(step);\n        }\n    }\n\n    let quickFinish = async step => {\n        if (finishFun !== null) {\n            await finishFun(step);\n        }\n    }\n\n    let promises = [];\n    let deferredQuickFinish = (step, p) => {\n        if (finishFun !== null) {\n            if (state[step].changed) {\n                p = p.then(out => finishFun(step, state[step]));\n            } else {\n                p = p.then(out => finishFun(step));\n            }\n        }\n        promises.push(p);\n    }\n\n    /*** Loading ***/\n    await quickStart(step_inputs);\n    await state[step_inputs].compute(datasets, params[step_inputs]);\n    await quickFinish(step_inputs);\n\n    if (load_flag in state) {\n        // Force recompute for all downstream steps. This avoids mixing results\n        // from different versions if we're re-running off a reloaded state; if\n        // some steps rerun, but others don't, we end up with a bastard state\n        // from possibly different versions of this pipeline. It's also\n        // difficult to guarantee that enough results were saved for use in\n        // downstream steps, given that not everything is saved to file (and\n        // indeed, the requirements of downstream steps may change in future\n        // versions). So we just keep it simple and flush the whole state.\n        state[step_inputs].changed = true;\n        delete state[load_flag];\n    }\n\n    /*** Preprocessing steps ***/\n    let basic_steps = [\n        step_qc, step_qc_adt, step_qc_crispr,\n        step_filter,\n        step_norm, step_norm_adt, step_norm_crispr,\n        step_feat,\n        step_pca, step_pca_adt, step_pca_crispr,\n        step_combine,\n        step_correct,\n        step_neighbors\n    ];\n\n    for (const step of basic_steps) {\n        await quickStart(step);\n        await state[step].compute(params[step]);\n        await quickFinish(step);\n    }\n\n    /*** Visualization ***/\n    for (const step of [ step_tsne, step_umap ]) {\n        await quickStart(step);\n        let p = state[step].compute(params[step]);\n        deferredQuickFinish(step, p);\n    }\n\n    /*** Clustering ***/\n    let method = params[step_choice][\"method\"];\n\n    await quickStart(step_kmeans);\n    state[step_kmeans].compute(method == \"kmeans\", params[step_kmeans]);\n    await quickFinish(step_kmeans);\n\n    await quickStart(step_snn);\n    state[step_snn].compute(method == \"snn_graph\", params[step_snn]);\n    await quickFinish(step_snn);\n\n    await quickStart(step_choice);\n    state[step_choice].compute(params[step_choice]);\n    await quickFinish(step_choice);\n\n    /*** Markers and labels ***/\n    let remaining = [\n        step_markers,\n        step_labels,\n        step_custom,\n        step_enrichment\n    ];\n\n    for (const step of remaining) {\n        await quickStart(step);\n        await state[step].compute(params[step]);\n        await quickFinish(step);\n    }\n\n    await Promise.all(promises);\n    return null;\n}\n\n/**\n * Retrieve analysis parameters from a state object.\n *\n * @param {object} state - Object containing the analysis state, produced by {@linkcode createAnalysis} or {@linkcode loadAnalysis}.\n *\n * @return {object} Object containing the analysis parameters for each step, similar to that created by {@linkcode analysisDefaults}.\n */\nexport function retrieveParameters(state) {\n    let params = {};\n    for (const [k, v] of Object.entries(state)) {\n        if (k == load_flag) {\n            continue;\n        }\n        params[k] = v.fetchParameters();\n    }\n    return params;\n}\n\n/**\n * Create a new analysis state object consisting of a subset of cells from an existing analysis state.\n * This assumes that the existing state already contains loaded matrix data in its `inputs` property,\n * which allows us to create a cheap reference without reloading the data into memory.\n *\n * @param {object} state - State object such as that produced by {@linkcode createAnalysis} or {@linkcode linkAnalysis}.\n * This should already contain loaded data, e.g., after a run of {@linkcode runAnalysis}.\n * @param {TypedArray|Array} indices - Array containing the indices for the desired subset of cells.\n * This should be sorted and non-duplicate.\n * Any existing subset in `state` will be overridden by `indices`.\n * @param {object} [options] - Optional parameters.\n * @param {boolean} [options.copy=true] - Whether to make a copy of `indices` before storing it inside the returned state object.\n * If `false`, it is assumed that the caller makes no further use of the passed `indices`.\n * @param {boolean} [options.onOriginal=false] - Whether `indices` contains indices on the original dataset or on the dataset in `state`.\n * This distinction is only relevant if `state` itself contains an analysis of a subsetted dataset.\n * If `false`, the `indices` are assumed to refer to the columns of the already-subsetted dataset that exists in `state`;\n * if `true`, the `indices` are assumed to refer to the columns of the original dataset from which the subset in `state` was created.\n *\n * @return {object} A state object containing loaded matrix data in its `inputs` property.\n * Note that the other steps do not have any results, so this object should be passed through {@linkcode runAnalysis} before it can be used.\n */\nexport async function subsetInputs(state, indices, { copy = true, onOriginal = false } = {}) {\n    return create_analysis(state.inputs.createDirectSubset(indices, { copy: copy, onOriginal: onOriginal }));\n}\n"],"names":["availableReaders","TenxHdf5Dataset","TenxMatrixMarketDataset","H5adDataset","SummarizedExperimentDataset","ZippedArtifactdbDataset","async","readObjectFile","path","globals","payload","get","joinPath","asBuffer","dec","TextDecoder","JSON","parse","decode","clean","readObjectRegistry","readObject","metadata","options","arguments","length","undefined","objtype","defaults","list","df","se","rse","sce","Error","pca","pcaadt","pcacrispr","correct","combine","index","initialize","numberOfThreads","localFile","s","scran","vizutils","then","x","jsp","read","dir","write","mkdir","copy","from","to","step_name","RAW_SUBSET_OVERRIDE","_parameters","WeakMap","_cache","_abbreviated","_preserve_dataset_cache","_InputsState_brand","WeakSet","InputsState","constructor","parameters","cache","abbreviated","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","this","changed","free","utils","_classPrivateFieldGet","matrix","raw_matrix","block_ids","raw_block_ids","multi_block_ids","fetchCountMatrix","fetchFeatureAnnotations","genes","fetchCellAnnotations","annotations","fetchBlock","fetchBlockLevels","block_levels","fetchParameters","_this$constructor","output","_objectSpread","subset","_assertClassBrand","_cloneSubset","call","fetchDatasets","datasets","fetchDirectSubset","candidate","slice","guessRnaFeatureTypes","inferred_rna_types","block_factor","enableDatasetCache","compute","tmp_abbreviated","key","val","Object","entries","format","details","abbreviate","new_datasets","preserve_dataset_cache","res","names","keys","sort","loaded","push","load","e","single","available","features","k","known_modalities","has","add","cells","rename_dataset","blocks","common_modes","mod","okay","l","current","bind_single_modality","annos","map","bioc","ncells","Array","forEach","i","numberOfColumns","nice_barr","$setColumn","bind_datasets","load_datasets","raw_annotations","multi_block_levels","load_and_cache","anno_batch","column","converted","action","placeholder","invalid_block_id","ids","levels","view","raw_block_levels","block_and_cache","subset_and_cache","undoSubset","indices","max_index","keep","harvest_subset_indices","setDirectSubset","onOriginal","_configureIndices","createDirectSubset","new_cache","clone","new_params","values","ranges","modality","gnames","mats","primary_id","primary_ids","String","merged","hasColumn","field","anno","allowed","Set","r","bids","array","keep2","new_annotations","new_matrix","new_block_ids","new_block_levels","subsetted","_handle","_flush","AlabasterH5Group","handle","flush","super","attributes","readAttribute","attr","ares","shape","children","open","name","out","AlabasterH5DataSet","close","_handle2","type","members","_navigator","AlabasterGlobalsInterface","navigator","exists","localPath","h5open","realized","h5close","_nrow","_ncol","_path","MockMatrix","nrow","ncol","_bioconductor_NUMBER_OF_ROWS","_bioconductor_NUMBER_OF_COLUMNS","realize","forceInteger","forceSparse","extract_matrix","contents","extract_delayed","fhandle","dhandle","layout","transposed","indexOf","dtype","optype","seed","arg","along","right","inPlace","meth","base","logBase","perm","mat","ihandle","shandle","seeds","nchildren","childen","c","atype","is_native","file","is_csr","seed_path","seed_metadata","readMockAssay","readMockReducedDimension","apply_over_experiments","fun","main_experiment_name","is_sce","mainExperimentName","alt","alternativeExperimentNames","alternativeExperiment","extract_all_features","rowData","extract_all_assay_names","assayNames","simplify_List_columns","columnNames","col","setColumn","toArray","_navigator2","_raw_se","_options","_AbstractAlabasterDataset_brand","AbstractAlabasterDataset","rnaCountAssay","adtCountAssay","crisprCountAssay","rnaExperiment","adtExperiment","crisprExperiment","primaryRnaFeatureIdColumn","primaryAdtFeatureIdColumn","primaryCrisprFeatureIdColumn","setOptions","v","clear","summary","_populate","modality_features","columnData","modality_assay_names","previewPrimaryIds","fmapping","RNA","ADT","CRISPR","raw_features","altnames","preview","futils","_primary_mapping","mapping","exp","assay","experiments_by_name","chosen_se","_create_globals","DataFrame_readNested","DataFrame_readMetadata","SummarizedExperiment_readAssay","SummarizedExperiment_readMetadata","SingleCellExperiment_readReducedDimension","y","_navigator3","_raw_se2","_options2","_AbstractAlabasterResult_brand","AbstractAlabasterResult","primaryAssay","isPrimaryNormalized","reducedDimensionNames","_populate2","reduced_dimension_names","reduced_dimensions","chosen_rd","reducedDimension","_create_globals2","collected","curassay","curnormalized","normed","allowZeros","_SelectionManager_brand","SelectionManager","selections","_selections","results","buffer","_liberate","markers","versus","addSelection","id","selection","to_use","matfun","block","lfc_threshold","compute_auc","fill","tmp","element","threshold","computeAuc","removeSelection","fetchResults","raw","fetchSelectionIndices","fetchSelections","force","replacement","store","needs_copy","Int32Array","computeVersus","left","cache_info","left_index","left_small","right_index","run","matrices","leftsel","rightsel","triplets","a","b","new_clusters","cluster","cached","_filter","_norm_states","_manager","_CustomSelectionsState_brand","CustomSelectionsState","filter","norm_states","filter_module","rna_norm_module","adt_norm_module","crispr_norm_module","_addSelection","value","fetchNormalizedMatrix","fetchFilteredBlock","_normalized","_block","_block_levels","_manager2","_parameters2","_missing_map","_CustomSelectionsStandalone_brand","CustomSelectionsStandalone","normalized","N","dump","retain","revmap","new_matrices","temp","set","arrays","ret","_peekMatrices","_peekBlock","setParameters","selection_internal","j","_unmap","SingleCellExperiment","assays","reducedDimensions","reducedDimensionOrder","alternativeExperiments","alternativeExperimentOrder","rowRanges","ncols","_reducedDimensions","il","className","message","cause","entry","generics","_alternativeExperiments","_mainExperimentName","removeReducedDimension","target","cutils","delete","$removeReducedDimension","setReducedDimension","$setReducedDimension","setReducedDimensionNames","setNames","$setReducedDimensionNames","setReducedDimensions","newOrder","sce_nc","$setReducedDimensions","sliceReducedDimensions","$sliceReducedDimensions","removeAlternativeExperiment","$removeAlternativeExperiment","setAlternativeExperiment","$setAlternativeExperiment","setAlternativeExperimentNames","$setAlternativeExperimentNames","setAlternativeExperiments","$setAlternativeExperiments","sliceAlternativeExperiments","$sliceAlternativeExperiments","setMainExperimentName","$setMainExperimentName","_bioconductor_SLICE_2D","rows","columns","_ref","allowView","apply","_bioconductor_COMBINE_ROWS","objects","_bioconductor_COMBINE_COLUMNS","all_rd","all_ae","parallelCombine","_bioconductor_CLONE","_ref2","deepCopy","_defineProperty","load_number","Number","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","load_vector","typedarray","vals","scalar","List_toScalar","every","List_toTypedArray","_jaspalite_scalar","load_json_list","List","IntegerList","NumberList","Float64Array","StringList","BooleanList","readList","simple_list","decompressed_stream","Blob","stream","pipeThrough","DecompressionStream","chunks","counter","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_step","_iterator","_asyncIterator","next","done","chunk","err","return","decompressed_final","Uint8Array","str","readRangedSummarizedExperiment","readSummarizedExperiment","RangedSummarizedExperiment","assayOrder","rowNames","read_assay","se_options","name_path","names_contents","assay_names","aname","assay_path","assay_meta","summarized_experiment","dimensions","cd","DataFrame","numberOfRows","readAnnotatedMetadata","SummarizedExperiment","searchGenes","species","queries","types","ignoreCase","promises","t","mapGenesByIdentifier","lowerCase","resolved","Promise","all","toLowerCase","findings","default_download","start","end","url","fetch","headers","Range","reference_base_url","referenceBaseUrl","reference_download","referenceDownload","prev","gene_base_url","geneBaseUrl","gene_download","geneDownload","setGeneDownload","decompressLines","pako","lines","split","convertToUint32Array","txt","last","Uint32Array","_FeatureSetManager_brand","FeatureSetManager","set_buffer","setDownload","console","warn","buildCollections","old_parameters","guess_ids","gene_id_column","gene_id_type","annofun","guessfun","gene_id_column2","gene_id_type2","species2","auto","guesses","best_key","best","confidence","row_names","toUpperCase","configure_feature_parameters","_prepare","fetchCollectionDetails","collections","fetchSetDetails","sets","descriptions","sizes","fetchUniverseSize","universe","computeEnrichment","group","effect_size","top_markers","use_largest","min_threshold","stats","in_set","useLargest","gene","mapping_to_sets","overlaps","gesel","set_ids","counts","count","num_top","pvalues","num_markers","fetchFeatureSetIndices","set_id","computePerCellScores","farr","feats","data_id_col","search_options","collection_offset","all_collection_names","all_collection_descriptions","all_collection_species","set_offset","all_set_names","all_set_descriptions","all_set_indices","all_set_sizes","all_set_collections","mapped_genes","remapped","spec","gene_mapping","all_sets2genes","set_indices","all_sets","nsets","set_names","set_descriptions","set_sizes","set_collections","description","collection","all_genes2sets","current_remapped","all_collections","ncollections","collection_names","collection_descriptions","collection_species","title","dereference_parameters","fetch_parameters","_inputs","FeatureSetEnrichmentState","inputs","inputs_module","norm_module","valid","fetchPerCellScores","set_index","skip","_annotations","_guesses","_normalized2","_backmap","_pre_parameters","_FeatureSetEnrichmentStandalone_brand","FeatureSetEnrichmentStandalone","automatic","ready","_guessFeatureTypes","backfilled","scores","readDataFrame","read_nested","DataFrame_toTypedArray","handle_stack","ghandle","cnhandle","nrows","colnames","pop","skip_nested","kids","iname","nest_path","nest_meta","child_handle","H5DataSet","missing_attr","rawvals","has_missing","isNaN","H5Group","lhandle","cohandle","codes","code_attrs","hhandle","heap","phandle","pointers","pointer_attrs","offset","early","rownames","rnhandle","new_colnames","cn","columnOrder","toReversed","wa","prototype","_bioconductor_LENGTH","countSetOverlaps","setsForSomeGenes","set_count","Map","found","load_listData_names","nhandle","ndx","findAttribute","attribute","acceptable_df_subclasses","load_data_frame","check_class","curhandle","curcol","clshandle","levhandle","check_acceptable_class","nrhandle","NR","accepted","packageName","extract_NAMES","nidx","extract_features","rowdata","rrdx","rhandle","rrhandle","ehandle","pidx","r2handle","$setRowNames","extract_assay_names","ahandle","extract_assay","xhandle","chosen","n","extract_main_exp_name","int_handle","name_handle","me_handle","int_dx","name_dx","me_dx","me_name","extract_alt_exps","in_handle","inld_handle","innn_handle","ae_handle","aeld_handle","aenn_handle","handles","order","indx","inld_dx","innn_dx","ae_dx","aeld_dx","aenn_dx","ae_names","asehandle","check_for_se","_rds_file","_rds_handle","_se_handle","_main_exp_name","_alt_handles","_alt_handle_order","_raw_features","_raw_cells","_SummarizedExperimentDataset_brand","rdsFile","afile","_dump_summary","f","size","_initialize","_features","_cells","serialize","unserialize","files","content","chandle","_rds_file2","_rds_handle2","_se_handle2","_main_exp_name2","_alt_handles2","_alt_handle_order2","_raw_features2","_raw_cells2","_rd_handles","_rd_handle_order","_SummarizedExperimentResult_brand","SummarizedExperimentResult","_initialize2","_features2","_cells2","reddims","acquired","dims","d","rd_handle","rdld_handle","rdnn_handle","rd_dx","rdld_dx","rdnn_dx","rd_names","dimhandle","extract_reduced_dims","_zipfile","_ziphandle","_prefix","ZippedProjectNavigator","zipfile","ziphandle","prefix","JSZip","adb","ZippedAlabasterResult","existingHandle","readSingleCellExperiment","single_cell_experiment","read_rd","rdpath","reddim_names","rname","currd","rdmeta","read_ae","SingleCellExperiment_readAlternativeExperiment","aepath","altexp_names","curae","aemeta","extract_assay_details","sparse","shape_info","enc_info","csc","fetch_assay_details","deets","dvals","subhandle","current_levels","eutils","concat","rn","_index","fetch_features","fetch_cells","load_matrix","_h5_file","_h5_path","_h5_flush","_h5_handle","_assay_details","_H5adDataset_brand","h5File","countMatrixName","featureTypeColumnName","featureTypeRnaName","featureTypeAdtName","featureTypeCrisprName","_fetch_assay_details","all_features","all_assay_names","_feature_type_mapping","chosen_assay","layered","_instantiate","info","_h5_file2","_h5_path2","_h5_flush2","_h5_handle2","_assay_details2","_reddim_details","_H5adResult_brand","H5adResult","primaryMatrixName","_fetch_assay_details2","_fetch_reddim_details","chosen_reddims","ohandle","ndims","columnMajor","_instantiate2","endsWith","startsWith","redirection","targets","location","_zipfile2","_name","_ZippedArtifactdbDataset_brand","datasetName","opt","ZippedArtifactdbResult","IndexedNames","_names","_lookup","nameToIndexUncached","nameToIndex","error","indexToName","append","splice","_List_brand","_values","arr","getByIndex","_check_index","getByName","toMap","curname","toObject","setByIndex","new_names","setByName","deleteByIndex","deleteByName","sliceRange","sliceIndices","new_values","Symbol","iterator","all_values","_bioconductor_SLICE","sliced","_ref3","_bioconductor_COMBINE","all_names","xvals","xnames","yn","_IntegerList_brand","_sanitize","isInteger","_NumberList_brand","_sanitize2","_StringList_brand","_sanitize3","_BooleanList_brand","_sanitize4","download_fun","set_download","previous","acquire_file","suffix","full","baseUrl","rutils","all_loaded","flush_prepared","prepared","built","process_genes","gene_lines","compression","load_reference","gene_suffix","known_genes","suffixes","stored","flush_loaded","available_references","internal_build_reference","gene_ids","chosen_ids","build_reference","references","CellLabellingState","configureFeatureParameters","allowable","ref","used_refs","integrated","transform_results","assigned","nclusters","numberOfCells","ntargets","all_scores","cscores","scoreForCell","assign_labels_internal","temp_cluster_means","ngroups","numberOfGroups","ngenes","g","means","mean","per_reference","labels","predicted","single_results","temp_matrix","assign_labels","to_collect","sub","aggr","average","all_sums","allSums","asTypedArray","aggrmat","groups","fetchNumberOfSharedFeatures","numberOfFeatures","computeLabels","_cache2","_CellLabellingStandalone_brand","CellLabellingStandalone","optname","optional","transposeMatrix","others","_objectWithoutProperties","_excluded","local_buffer","input_buffer","wasm","module","transpose_matrix","animateFun","scranOptions","computeNeighbors","nn_index","fetchIndex","rbuf","ibuf","dbuf","runs","distances","worker_registry","worker_cache_registry","message_type","handle_message","functions","reject","resolve","data","sendTask","worker_id","transferrable","worker","p","aworkers","initializeWorker","msg","iteration","killWorker","runWithNeighbors","args","nn_out","run_msg","neighbors","step_inputs","step_qc","qc","step_qc_adt","qcadt","step_qc_crispr","qccrispr","step_filter","filters","step_norm","normalization","step_norm_adt","normadt","step_norm_crispr","normcrispr","step_feat","variance","step_pca","step_pca_adt","step_pca_crispr","step_combine","step_correct","step_neighbors","step_tsne","tsne","step_umap","umap","step_kmeans","kmeans_cluster","step_snn","snn_cluster","step_choice","cluster_choice","step_markers","cluster_markers","step_labels","label_cells","step_custom","custom_markers","step_enrichment","feature_set_enrichment","createAnalysis","create_analysis","input_state","qc_states","pca_states"],"sourceRoot":""}