{"version":3,"file":"static/js/866.54ed6e6d.chunk.js","mappings":"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","sources":["workers/KanaDBHandler.js","workers/DownloadsDBHandler.js","workers/helpers.js","utils/utils.js","workers/scran.worker.js","workers/translate.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["var kanaDB;\nvar init = null;\n\nexport function initialize() {\n  init = new Promise((resolve) => {\n    // initialize database on worker creation\n    kanaDB = indexedDB.open(\"KanaDB\", 2);\n\n    kanaDB.onupgradeneeded = (e) => {\n      var kanaDBClient = e.target.result;\n\n      // Currently purging all existing stores when the version is updated.\n      // At some point we may add a more sophisticated upgrade mechanism.\n      try {\n        kanaDBClient.deleteObjectStore(\"analysis\");\n      } catch (e) {}\n      try {\n        kanaDBClient.deleteObjectStore(\"analysis_meta\");\n      } catch (e) {}\n      try {\n        kanaDBClient.deleteObjectStore(\"file\");\n      } catch (e) {}\n      try {\n        kanaDBClient.deleteObjectStore(\"file_meta\");\n      } catch (e) {}\n\n      kanaDBClient.createObjectStore(\"analysis\", { keyPath: \"id\" });\n      kanaDBClient.createObjectStore(\"analysis_meta\", { keyPath: \"id\" });\n      kanaDBClient.createObjectStore(\"file\", { keyPath: \"id\" });\n      kanaDBClient.createObjectStore(\"file_meta\", { keyPath: \"id\" });\n    };\n\n    // Send existing stored analyses, if available.\n    kanaDB.onsuccess = () => {\n      resolve(get_records());\n    };\n\n    kanaDB.onerror = () => {\n      resolve(null);\n    };\n  });\n\n  return init;\n}\n\nfunction get_records() {\n  let store = kanaDB.result\n      .transaction([\"analysis_meta\"], \"readonly\")\n      .objectStore(\"analysis_meta\");\n\n  var allAnalysis = store.getAll();\n  return new Promise((resolve, reject) => {\n    allAnalysis.onsuccess = event => {\n      let vals = allAnalysis.result;\n\n      // no need to transfer the files themselves.\n      vals.forEach((x) => {\n        delete x.files;\n      }); \n\n      resolve(vals);\n    };\n  \n    allAnalysis.onerror = event => {\n      reject(new Error(`failed to query the analysis store in KanaDB: ${event.target.errorCode}`));\n    };\n  });\n}\n\nexport async function getRecords() {\n  await init;\n  return get_records();\n}\n\n/** Functions to save content **/\n\nexport async function saveFile(id, buffer) {\n  await init;\n  let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error when saving file ${id} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let file_store = trans.objectStore(\"file\");\n  let meta_store = trans.objectStore(\"file_meta\");\n\n  let request = meta_store.get(id);\n  let saving = new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      let meta = request.result;\n      if (typeof meta === \"undefined\") {\n        meta = { count: 1, id: id };\n      } else {\n        meta.count++;\n      }\n\n      var data_saving = new Promise((resolve, reject) => {\n        var putrequest = file_store.put({ id: id, payload: buffer.buffer });\n        putrequest.onsuccess = event => {\n          resolve(true);\n        };\n        putrequest.onerror = event => {\n          reject(new Error(`failed to save file ${id} in KanaDB: ${event.target.errorCode}`));\n        };\n      });\n\n      var ref_saving = new Promise((resolve, reject) => {\n        var putrequest = meta_store.put(meta);\n        putrequest.onsuccess = event => {\n          resolve(true);\n        };\n        putrequest.onerror = event => {\n          reject(new Error(`failed to save metadata for file ${id} in KanaDB: ${event.target.errorCode}`));\n        };\n      });\n\n      resolve(Promise.all([data_saving, ref_saving]));\n    };\n\n    request.onerror = event => {\n      reject(new Error(`failed to retrieve metadata ${id} in KanaDB: ${event.target.errorCode}`));\n    };\n  });\n\n  // Only await after attaching all event handlers.\n  await fin;\n  await saving;\n  return;\n}\n\nexport async function saveAnalysis(id, state, files, title) {\n  await init;\n  let trans = kanaDB.result.transaction(\n    [\"analysis\", \"analysis_meta\"],\n    \"readwrite\"\n  );\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error when saving analysis ${id} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let analysis_store = trans.objectStore(\"analysis\");\n  let meta_store = trans.objectStore(\"analysis_meta\");\n\n  let callback = new_id => {\n    var data_saving = new Promise((resolve, reject) => {\n      var putrequest = analysis_store.put({ id: new_id, payload: state.buffer });\n      putrequest.onsuccess = event => {\n        resolve(true);\n      };\n      putrequest.onerror = event => {\n        reject(new Error(`failed to save analysis file ${new_id} in KanaDB: ${event.target.errorCode}`));\n      };\n    });\n\n    var id_saving = new Promise((resolve, reject) => {\n      var putrequest = meta_store.put({\n        id: new_id,\n        files: files,\n        time: Number(new Date()),\n        title: title,\n      });\n      putrequest.onsuccess = event => {\n        resolve(true);\n      };\n      putrequest.onerror = event => {\n        reject(new Error(`failed to save analysis metadata ${new_id} in KanaDB: ${event.target.errorCode}`));\n      };\n    });\n\n    // DO NOT await the promises here!\n    return [new_id, data_saving, id_saving];\n  };\n\n  let output_promise;\n  if (id === null) {\n    let request = meta_store.getAll();\n    output_promise = new Promise((resolve, reject) => {\n      request.onsuccess = event => {\n        resolve(callback(String(request.result.length)));\n      };\n      request.onerror = event => {\n        reject(new Error(`failed to list existing analysis store in KanaDB: ${event.target.errorCode}`));\n      };\n    });\n  } else {\n    output_promise = callback(id);\n  }\n\n  // Only await after attaching all event handlers.\n  let output = await output_promise;\n  await fin;\n  return output[0];\n}\n\n/** Functions to load content **/\n\nexport async function loadFile(id) {\n  await init;\n  let file_store = kanaDB.result\n    .transaction([\"file\"], \"readonly\")\n    .objectStore(\"file\");\n\n  let meta_promise = new Promise((resolve, reject) => {\n    let request = file_store.get(id);\n    request.onsuccess = event => {\n      resolve(request.result !== undefined ? request.result : null);\n    };\n    request.onerror = event => {\n      reject(new Error(`failed to retrieve file ${id} from KanaDB: ${event.target.errorCode}`));\n    };\n  });\n\n  var meta = await meta_promise;\n  if (meta !== null) {\n    meta = new Uint8Array(meta[\"payload\"]);\n  }\n  return meta;\n}\n\nexport async function loadAnalysis(id) {\n  await init;\n  let analysis_store = kanaDB.result\n    .transaction([\"analysis\"], \"readonly\")\n    .objectStore(\"analysis\");\n\n  let ana_promise = new Promise((resolve, reject) => {\n    let request = analysis_store.get(id);\n    request.onsuccess = event => {\n      resolve(request.result !== undefined ? request.result : null);\n    };\n    request.onerror = event => {\n      reject(new Error(`failed to retrieve analysis ${id} from KanaDB: ${event.target.errorCode}`));\n    };\n  });\n\n  var meta = await ana_promise;\n  if (meta !== null) {\n    meta = new Uint8Array(meta[\"payload\"]);\n  }\n  return meta;\n}\n\n/** Functions to remove content **/\n\nasync function superResolver(x) {\n  let resolved = await x;\n  if (resolved instanceof Array) {\n    let replacement = [];\n    for (const y of resolved) {\n      replacement.push(await superResolver(y));\n    }\n    resolved = replacement;\n  }\n  return resolved;\n}\n\nfunction remove_file(id, file_store, meta_store) {\n  let request = meta_store.get(id);\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      let meta = request.result;\n      var refcount = meta[\"count\"] - 1;\n      var promises = [];\n\n      if (refcount === 0) {\n        promises.push(\n          new Promise((resolve, reject) => {\n            let request = file_store.delete(id);\n            request.onsuccess = event => {\n              resolve(true);\n            };\n            request.onerror = event => {\n              reject(new Error(`failed to remove file ${id} from KanaDB: ${event.target.errorCode}`));\n            };\n          })\n        );\n    \n        promises.push(\n          new Promise((resolve, reject) => {\n            let request = meta_store.delete(id);\n            request.onsuccess = event => {\n              resolve(true);\n            };\n            request.onerror = event => {\n              reject(new Error(`failed to remove file metadata ${id} from KanaDB: ${event.target.errorCode}`));\n            };\n          })\n        );\n  \n      } else {\n        promises.push(\n          new Promise((resolve, reject) => {\n            meta.count = refcount;\n            let request = meta_store.put(meta);\n            request.onsuccess = event => {\n              resolve(true);\n            };\n            request.onerror = event => {\n              reject(new Error(`failed to update file metadata ${id} in KanaDB: ${event.target.errorCode}`));\n            };\n          })\n        );\n      }\n\n      resolve(promises);\n    };\n\n    request.onerror = event => {\n      // console.log(event);\n      reject(new Error(`failed to retrieve file metadata ${id} from KanaDB: ${event.target.errorCode}`));\n    };\n  });\n}\n\nexport async function removeFile(id) {\n  await init;\n  let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error when removing file ${id} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let file_store = trans.objectStore(\"file\");\n  let meta_store = trans.objectStore(\"file_meta\");\n  let removal = remove_file(id, file_store, meta_store);\n\n  // Only await after attaching all event handlers.\n  await superResolver(removal);\n  await fin;\n  return;\n}\n\nexport async function removeAnalysis(id) {\n  await init;\n  let trans = kanaDB.result.transaction(\n    [\"analysis\", \"analysis_meta\", \"file\", \"file_meta\"],\n    \"readwrite\"\n  );\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error when removing analysis ${id} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let analysis_store = trans.objectStore(\"analysis\");\n  let analysis_meta_store = trans.objectStore(\"analysis_meta\");\n  let file_store = trans.objectStore(\"file\");\n  let file_meta_store = trans.objectStore(\"file_meta\");\n\n  let analysis_removal = new Promise((resolve, reject) => {\n    let request = analysis_store.delete(id);\n    request.onsuccess = event => {\n      resolve(true);\n    };\n    request.onerror = event => {\n      reject(new Error(`failed to delete analysis ${id} from KanaDB: ${event.target.errorCode}`));\n    };\n  })\n\n  // Removing all files as well.\n  let request = analysis_meta_store.get(id);\n  let file_removal = new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      let meta = request.result;\n\n      let my_promises = [];\n      for (const v of Object.values(meta[\"files\"][\"datasets\"])) {\n        for (const f of v[\"files\"]) {\n          my_promises.push(remove_file(f[\"id\"], file_store, file_meta_store));\n        }\n      }\n\n      // And THEN removing the analysis metadata, because otherwise\n      // we wouldn't know what the files were, obviously!\n      let deleted = new Promise((resolve, reject) => {\n        let request = analysis_meta_store.delete(id);\n        request.onsuccess = event => {\n          resolve(true);\n        };\n        request.onerror = event => {\n          reject(new Error(`failed to delete analysis metadata ${id} from KanaDB: ${event.target.errorCode}`));\n        };\n      })\n\n      my_promises.push(deleted);\n      resolve(my_promises);\n    };\n\n    request.onerror = event => {\n      reject(new Error(`failed to retrieve analysis metadata ${id} from KanaDB: ${event.target.errorCode}`));\n    };\n  });\n\n  // Only await after attaching all event handlers.\n  await analysis_removal;\n  await superResolver(file_removal);\n  await fin;\n  return true;\n}\n","var DownloadsDB;\nvar init = null;\n\nexport function initialize() {\n  if (init === null) {\n    init = new Promise((resolve, reject) => {\n      // initialize database on worker creation\n      DownloadsDB = indexedDB.open(\"DownloadsDB\", 3);\n\n      DownloadsDB.onupgradeneeded = (e) => {\n        var DownloadsDBClient = e.target.result;\n\n        // Currently purging all existing stores when the version is updated.\n        // At some point we may add a more sophisticated upgrade mechanism.\n        try {\n          DownloadsDBClient.deleteObjectStore(\"downloads\");\n        } catch (e) {}\n\n        DownloadsDBClient.createObjectStore(\"downloads\", { keyPath: \"url\" });\n      };\n\n      DownloadsDB.onsuccess = () => {\n        resolve(null);\n      };\n\n      DownloadsDB.onerror = () => {\n        reject(\"failed to initialize DownloadsDB\");\n      };\n    });\n  }\n\n  return init;\n}\n\nasync function fetchWithProgress(url, startFun, iterFun, endFun, params=null) {\n  let res;\n  if (params == null) {\n    res = await fetch(url);\n  } else {\n    res = await fetch(url, params);\n  }\n\n  if (!res.ok) {\n    throw new Error(\"oops, failed to download '\" + url + \"'\");\n  }\n\n  const cl = res.headers.get(\"content-length\"); // WARNING: this might be NULL!\n  const id = startFun(cl);\n\n  const reader = res.body.getReader();\n  const chunks = [];\n  let total = 0;\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    total += value.length;\n    iterFun(id, total);\n  }\n\n  let output = new Uint8Array(total);\n  let start = 0;\n  for (const x of chunks) {\n    output.set(x, start);\n    start += x.length;\n  }\n\n  endFun(id, total);\n  return output;\n}\n\nasync function fetchWrapper(url, params = null) {\n  try {\n    const out = await fetchWithProgress(\n      url,\n      (cl) => {\n        postMessage({\n          type: `DOWNLOAD for url: ` + String(url),\n          download: \"START\",\n          url: String(url),\n          total_bytes: String(cl),\n          msg: \"Total size is \" + String(cl) + \" bytes!\",\n        });\n        return url;\n      },\n      (id, sofar) => {\n        postMessage({\n          type: `DOWNLOAD for url: ` + String(url),\n          download: \"PROGRESS\",\n          url: String(url),\n          downloaded_bytes: String(sofar),\n          msg: \"Progress so far, got \" + String(sofar) + \" bytes!\",\n        });\n      },\n      (id, total) => {\n        postMessage({\n          type: `DOWNLOAD for url: ` + String(url),\n          download: \"COMPLETE\",\n          url: String(url),\n          msg: \"Finished, got \" + String(total) + \" bytes!\",\n        });\n      },\n      params\n    );\n\n    return out;\n  } catch (error) {\n    // console.log(\"oops error\", error)\n    postMessage({\n      type: `DOWNLOAD for url: ` + String(url),\n      download: \"START\",\n      url: String(url),\n      total_bytes: 100,\n    });\n\n    let req;\n    if (params == null) {\n      req = fetch(url);\n    } else {\n      req = fetch(url, params);\n    }\n\n    var res = await req;\n    if (!res.ok) {\n      throw new Error(\"failed to download '\" + url + \"' (\" + res.status + \")\");\n    }\n    var buffer = await res.arrayBuffer();\n\n    postMessage({\n      type: `DOWNLOAD for url: ` + String(url),\n      download: \"COMPLETE\",\n      url: String(url),\n    });\n    return new Uint8Array(buffer);\n  }\n}\n\nexport async function get(url, params = null, force = false) {\n  await init;\n\n  if (!force) {\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n    let download_store = trans.objectStore(\"downloads\");\n\n    var data_check = new Promise((resolve, reject) => {\n      var already = download_store.get(url);\n      already.onsuccess = event => {\n        if (already.result !== undefined) {\n          resolve(already.result.payload);\n        } else {\n          resolve(null);\n        }\n      };\n      already.onerror = event => {\n        reject(`failed to query DownloadsDB for ${url}: ${event.target.errorCode}`);\n      };\n    });\n\n    var found = await data_check;\n    if (found !== null) {\n      return found;\n    }\n  }\n\n  var buffer = await fetchWrapper(url, params)\n\n  // Technically, this isn't quite right, because we need to close the read\n  // transaction before opening the write transaction; multiple queries to\n  // the same URL from different workers could cause multiple downloads if\n  // they each miss each other's read check. But oh well; the auto-commit\n  // of IDB transactions means that it's hard to do any better. (Specifically,\n  // we can't do an async fetch while the transaction is still open, because\n  // it just closes before the fetch is done.)\n  let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n\n  // The Promise's function should evaluate immediately\n  // (see https://stackoverflow.com/questions/35177230/are-promises-lazily-evaluated) \n  // so the callbacks should be attached to the transaction before we return to the event loop.\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error for saving ${url} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let download_store = trans.objectStore(\"downloads\");\n  let saving = new Promise((resolve, reject) => {\n    var putrequest = download_store.put({ url: url, payload: buffer });\n    putrequest.onsuccess = event => {\n      resolve(true);\n    };\n    putrequest.onerror = event => {\n      reject(new Error(`failed to cache ${url} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  // Stack all awaits here, AFTER event handlers have been attached.\n  await saving;\n  await fin;\n  return buffer;\n}\n\nexport async function remove(url) {\n  await init;\n  let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n  let fin = new Promise((resolve, reject) => {\n    trans.oncomplete = (event) => {\n      resolve(null);\n    };\n    trans.onerror = (event) => {\n      reject(new Error(`transaction error for removing ${url} in DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  let download_store = trans.objectStore(\"downloads\")\n  let removal = new Promise((resolve, reject) => {\n    let request = download_store.delete(url);\n    request.onsuccess = event => {\n      resolve(true);\n    };\n    request.onerror = event => {\n      reject(new Error(`failed to remove ${url} from DownloadsDB: ${event.target.errorCode}`));\n    };\n  });\n\n  // Only await after attaching event handlers.\n  await removal;\n  await fin;\n  return;\n}\n","import * as bakana from \"bakana\";\nimport * as gesel from \"gesel\";\nimport * as remotes from \"bakana-remotes\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\n\n// Evade CORS problems and enable caching.\nconst proxy = \"https://cors-proxy.aaron-lun.workers.dev\";\nasync function proxyAndCache(url) {\n  let buffer = await downloads.get(proxy + \"/\" + encodeURIComponent(url));\n  return new Uint8Array(buffer);\n}\n\nbakana.CellLabellingState.setDownload(proxyAndCache);\ngesel.setGeneDownload(proxyAndCache);\nbakana.RnaQualityControlState.setDownload(proxyAndCache);\n\ngesel.referenceDownload(async (file, start, end) => {\n  let url = gesel.referenceBaseUrl() + \"/\" + file;\n  let full = proxy + \"/\" + encodeURIComponent(url);\n  if (start == null && end == null) {\n    let buffer = await downloads.get(full);\n    return new Response(buffer);\n  } else {\n    return fetch(full + \"?start=\" + String(start) + \"&end=\" + String(end));\n  }\n});\n\ngesel.geneDownload(async (file) => {\n  let url = gesel.geneBaseUrl() + \"/\" + file;\n  let buffer = await downloads.get(proxy + \"/\" + encodeURIComponent(url));\n  return new Response(buffer);\n});\n\nremotes.GypsumDataset.setDownloadFun(proxyAndCache);\nbakana.availableReaders[\"ExperimentHub\"] = remotes.GypsumDataset;\nbakana.availableReaders[\"gypsum\"] = remotes.GypsumDataset;\n\nexport function extractBuffers(object, store) {\n  if (!object) {\n    return;\n  }\n\n  if (Array.isArray(object)) {\n    for (const element of object) {\n      extractBuffers(element, store);\n    }\n  } else if (object.constructor == Object) {\n    for (const [key, element] of Object.entries(object)) {\n      extractBuffers(element, store);\n    }\n  } else if (ArrayBuffer.isView(object)) {\n    if (!(object.buffer instanceof ArrayBuffer)) {\n      throw \"only ArrayBuffers should be in the message payload\";\n    }\n    store.push(object.buffer);\n  }\n}\n\nexport function postAttempt(step) {\n  postMessage({\n    type: `${step}_START`,\n  });\n}\n\nexport function postSuccess(step, info) {\n  if (typeof info == \"undefined\") {\n    postMessage({\n      type: `${step}_CACHE`,\n    });\n  } else {\n    var transferable = [];\n    extractBuffers(info, transferable);\n    postMessage(\n      {\n        type: `${step}_DATA`,\n        resp: info,\n      },\n      transferable\n    );\n  }\n}\n\nexport function postError(type, err, fatal) {\n  postMessage({\n    type: `${type}_ERROR`,\n    resp: {\n      reason: err.toString(),\n      fatal: fatal,\n    },\n  });\n}\n\nexport function splitMetricsByBlock(metrics, blockLevels, blockIds) {\n  var output = {};\n  var blocks = blockIds.slice();\n  for (var b = 0; b < blockLevels.length; b++) {\n    let current = {};\n    for (const [key, val] of Object.entries(metrics)) {\n      current[key] = val.slice().filter((x, i) => blocks[i] == b);\n    }\n    output[blockLevels[b]] = current;\n  }\n  return output;\n}\n\nexport function splitThresholdsByBlock(thresholds, blockLevels) {\n  var output = {};\n  for (const x of blockLevels) {\n    output[x] = {};\n  }\n\n  for (const [key, val] of Object.entries(thresholds)) {\n    for (var b = 0; b < blockLevels.length; b++) {\n      output[blockLevels[b]][key] = val[b];\n    }\n  }\n\n  return output;\n}\n\nexport async function fetchStepSummary(state, step) {\n  // do not send any response to UI if they have not changed\n  if (!state[step].changed) {\n    return undefined;\n  }\n\n  if (step === \"inputs\") {\n    let output = {};\n\n    let ngenes = {};\n    for (const a of state[step].fetchCountMatrix().available()) {\n      ngenes[a] = state[step].fetchCountMatrix().get(a).numberOfRows();\n    }\n\n    let gene_info = {};\n    for (const [k, v] of Object.entries(\n      state[step].fetchFeatureAnnotations()\n    )) {\n      let info = {};\n      for (const c of v.columnNames()) {\n        let col = v.column(c);\n        if (Array.isArray(col)) {\n          info[c] = col;\n        }\n      }\n\n      if (Array.isArray(v.rowNames())) {\n        info[\"rownames\"] = v.rowNames();\n      }\n\n      gene_info[k] = info;\n    }\n\n    let cell_info = {};\n    for (const c of state[step].fetchCellAnnotations().columnNames()) {\n      let col = state[step].fetchCellAnnotations().column(c);\n      if (isArrayOrView(col)) {\n        const ksumm = describeColumn(col, {\n          all: false,\n          unique: true,\n          colname: c,\n        });\n        cell_info[c] = ksumm;\n      }\n    }\n\n    var blocks = state[step].fetchBlockLevels();\n    if (blocks !== null) {\n      const col = state[step].fetchBlock().slice();\n      if (isArrayOrView(col)) {\n        const ksumm = describeColumn(col, {\n          all: false,\n          unique: true,\n          colname: \"__batch__\",\n        });\n        cell_info[\"__batch__\"] = ksumm;\n      }\n    }\n\n    output = {\n      num_cells: state[step].fetchCountMatrix().numberOfColumns(),\n      num_genes: ngenes,\n      genes: gene_info,\n      annotations: cell_info,\n    };\n\n    return output;\n  } else if (step === \"rna_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sum(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().subsetProportion(0),\n    };\n\n    let output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      sums: state[step].fetchFilters().sum(),\n      detected: state[step].fetchFilters().detected(),\n      proportion: state[step].fetchFilters().subsetProportion(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    return output;\n  } else if (step === \"adt_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sum(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().subsetSum(0),\n    };\n\n    var output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      detected: state[step].fetchFilters().detected(),\n      proportion: state[step].fetchFilters().subsetSum(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    // We don't use sums for filtering but we do report it in the metrics,\n    // so we just add some NaNs to the thresholds for consistency.\n    for (const [k, v] of Object.entries(output.thresholds)) {\n      v.sums = NaN;\n    }\n\n    return output;\n  } else if (step === \"crispr_quality_control\") {\n    let metrics = {\n      sums: state[step].fetchMetrics().sum(),\n      detected: state[step].fetchMetrics().detected(),\n      proportion: state[step].fetchMetrics().maxProportion(),\n    };\n\n    let output = {};\n    var blocks = state[\"inputs\"].fetchBlockLevels();\n    if (blocks === null) {\n      blocks = [\"default\"];\n      output.data = { default: metrics };\n    } else {\n      let bids = state[\"inputs\"].fetchBlock();\n      output.data = splitMetricsByBlock(metrics, blocks, bids);\n    }\n\n    let listed = {\n      count: state[step].fetchFilters().maxValue(0),\n    };\n    output.thresholds = splitThresholdsByBlock(listed, blocks);\n\n    return output;\n  } else if (step === \"cell_filtering\") {\n    let remaining = 0,\n      keep_vec = null;\n    const keepBuff = state[step].fetchKeep();\n    if (keepBuff) {\n      keepBuff.forEach((x) => {\n        remaining += (x != 0);\n      });\n      keep_vec = keepBuff.slice();\n    } else {\n      remaining = state.inputs.fetchCountMatrix().numberOfColumns();\n    }\n    let output = { retained: remaining, keep: keep_vec };\n    return output;\n  } else if (step === \"rna_normalization\") {\n    return {};\n  } else if (step === \"adt_normalization\") {\n    return {};\n  } else if (step === \"crispr_normalization\") {\n    return {};\n  } else if (step === \"feature_selection\") {\n    let output = {\n      means: state[step].fetchResults().means(),\n      vars: state[step].fetchResults().variances(),\n      fitted: state[step].fetchResults().fitted(),\n      resids: state[step].fetchResults().residuals(),\n    };\n    return output;\n  } else if (\n    step === \"rna_pca\" ||\n    step === \"adt_pca\" ||\n    step === \"crispr_pca\"\n  ) {\n    let pcs = state[step].fetchPCs();\n    var var_exp = pcs.varianceExplained();\n    var total_var = pcs.totalVariance();\n    var_exp.forEach((x, i) => {\n      var_exp[i] = x / total_var;\n    });\n    return {\n      var_exp: var_exp,\n    };\n  } else if (step === \"combine_embeddings\") {\n    return {};\n  } else if (step === \"batch_correction\") {\n    return {};\n  } else if (step === \"neighbor_index\") {\n    return {};\n  } else if (step === \"tsne\" || step === \"umap\") {\n    return await state[step].fetchResults();\n  } else if (step === \"kmeans_cluster\") {\n    return {};\n  } else if (step === \"snn_graph_cluster\") {\n    return {};\n  } else if (step === \"choose_clustering\") {\n    var clusters = state[step].fetchClusters();\n    return { clusters: clusters.slice() };\n  } else if (step === \"marker_detection\") {\n    return {};\n  } else if (step === \"cell_labelling\") {\n    let markers = state.marker_detection.fetchResults();\n    if (\"RNA\" in markers) {\n      let results = state[step].computeLabels(markers.RNA);\n      // for (const [k, v] of Object.entries(results.per_reference)) { // TODO: return scores.\n      //   results.per_reference[k] = v.map(x => x.best);\n      // }\n      // if (\"integrated\" in results) {\n      //   results.integrated = results.integrated.map(x => x.best);\n      // }\n      return results;\n    } else {\n      return { per_reference: {} };\n    }\n  } else if (step === \"custom_selections\") {\n    return {};\n  } else if (step === \"feature_set_enrichment\") {\n    let collections = state.feature_set_enrichment.fetchCollectionDetails();\n    let sets = state.feature_set_enrichment.fetchSetDetails();\n    return {\n      collections: collections,\n      sets: {\n        names: sets.names,\n        descriptions: sets.descriptions,\n        sizes: sets.sizes.slice(),\n        collections: sets.collections.slice(),\n      },\n    };\n  }\n}\n\nexport function isArrayOrView(col) {\n  return Array.isArray(col) || ArrayBuffer.isView(col);\n}\n\nexport function describeColumn(\n  col,\n  { all = false, unique = false, colname = null } = {}\n) {\n  let res;\n  if (isArrayOrView(col)) {\n    res = bakana.summarizeArray(col);\n    const uqVals = new Set(col);\n    res[\"num_unique\"] = uqVals.size;\n\n    if ((uqVals.size <= 50) & unique) res[\"values\"] = [...uqVals].sort();\n    if (all) res[\"_all_\"] = col;\n\n    // if type is continous and unique values is less than 50, type is both\n    if (res[\"type\"] === \"continuous\" && uqVals.size <= 50) res[\"type\"] = \"both\";\n\n    if (typeof colname === \"string\" || colname instanceof String)\n      res[\"name\"] = colname;\n  }\n\n  return res;\n}\n\nexport function formatMarkerResults(results, group, rankEffect) {\n    if (!rankEffect || rankEffect === undefined) {\n        rankEffect = \"cohen-min-rank\";\n    }\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let increasing = false;\n        let summary; \n        if (rankEffect.match(/-mean$/)) {\n            summary = \"mean\";\n        } else if (rankEffect.match(/-min$/)) {\n            summary = \"minimum\";\n        } else if (rankEffect.match(/-min-rank$/)) {\n            summary = \"min-rank\";\n            increasing = true;\n        } else {\n            throw \"unknown rank type '\" + rankEffect + \"'\";\n        }\n\n        let ranking;\n        if (rankEffect.match(/^cohen-/)) {\n            ranking = results.cohensD(group, { summary: summary, copy: false });\n        } else if (rankEffect.match(/^auc-/)) {\n            ranking = results.auc(group, { summary: summary, copy: false });\n        } else if (rankEffect.match(/^lfc-/)) {\n            ranking = results.deltaMean(group, { summary: summary, copy: false });\n        } else if (rankEffect.match(/^delta-d-/)) {\n            ranking = results.deltaDetected(group, { summary: summary, copy: false });\n        } else {\n            throw \"unknown rank type '\" + rankEffect + \"'\";\n        }\n  \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_mean = reorder(results.mean(group, { copy: false }));\n    var stat_detected = reorder(results.detected(group, { copy: false }));\n    var stat_lfc = reorder(results.deltaMean(group, { summary: \"mean\", copy: false }));\n    var stat_delta_d = reorder(results.deltaDetected(group, { summary: \"mean\", copy: false }));\n\n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n","import { randomColor } from \"randomcolor\";\n\nexport const getColors = (data) => {\n  const palette = {\n    1: [\"#1b9e77\"],\n    2: [\"#1b9e77\", \"#d95f02\"],\n    3: [\"#1b9e77\", \"#d95f02\", \"#7570b3\"],\n    4: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\"],\n    5: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\"],\n    6: [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\", \"#e6ab02\"],\n    7: [\n      \"#1b9e77\",\n      \"#d95f02\",\n      \"#7570b3\",\n      \"#e7298a\",\n      \"#66a61e\",\n      \"#e6ab02\",\n      \"#a6761d\",\n    ],\n    8: [\n      \"#1b9e77\",\n      \"#d95f02\",\n      \"#7570b3\",\n      \"#e7298a\",\n      \"#66a61e\",\n      \"#e6ab02\",\n      \"#a6761d\",\n      \"#666666\",\n    ],\n    9: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n    ],\n    10: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n    ],\n    11: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n      \"#ffff99\",\n    ],\n    12: [\n      \"#a6cee3\",\n      \"#1f78b4\",\n      \"#b2df8a\",\n      \"#33a02c\",\n      \"#fb9a99\",\n      \"#e31a1c\",\n      \"#fdbf6f\",\n      \"#ff7f00\",\n      \"#cab2d6\",\n      \"#6a3d9a\",\n      \"#ffff99\",\n      \"#b15928\",\n    ],\n  };\n\n  let cluster_count = Math.max(...data) + 1;\n  let cluster_colors = null;\n  if (cluster_count > Object.keys(palette).length) {\n    cluster_colors = randomColor({\n      luminosity: \"dark\",\n      count: cluster_count + 1,\n    });\n  } else {\n    cluster_colors = palette[cluster_count.toString()];\n  }\n\n  return cluster_colors;\n};\n\nexport function isObject(object) {\n  return typeof object === \"object\" && Array.isArray(object) === false;\n}\n\nexport const code = \"K@a#$c3ll\";\n\n// this function is from https://developer.mozilla.org/en-US/docs/Glossary/Base64\nexport function utf8_to_b64(str) {\n  return window.btoa(unescape(encodeURIComponent(str)));\n}\n\nexport function generateUID(resource) {\n  let base = `${resource.format}`;\n  switch (resource.format) {\n    case \"SummarizedExperiment\":\n      base += `::${resource.rds.name}::${resource.rds.lastModified}::${resource.rds.size}`;\n      return utf8_to_b64(base);\n    case \"MatrixMarket\":\n      for (let key of [\"genes\", \"mtx\", \"annotations\"]) {\n        if (resource[key]) {\n          base += `::${resource[key].name}::${resource[key].lastModified}::${resource[key].size}`;\n        }\n      }\n      return utf8_to_b64(base);\n    case \"10X\":\n    case \"H5AD\":\n      base += `::${resource.h5.name}::${resource.h5.lastModified}::${resource.h5.size}`;\n      return utf8_to_b64(base);\n    case \"ExperimentHub\":\n      base += `::${resource.id}`;\n      return utf8_to_b64(base);\n    case \"ZippedArtifactdb\":\n      base += `::${resource.zipname}::${resource.zipfile}`;\n      return utf8_to_b64(base);\n    case \"ZippedADB\":\n      base += `::${resource.zipname}::${resource.zipfile}`;\n      return utf8_to_b64(base);\n    default:\n      throw Error(`format: ${resource.format} does not exist`);\n      break;\n  }\n}\n\nexport const MODALITIES = [\"RNA\", \"ADT\", \"CRISPR\"];\n\nexport const getMinMax = (arr) => {\n  var max = -Number.MAX_VALUE,\n    min = Number.MAX_VALUE;\n  arr.forEach(function (x) {\n    if (max < x) {\n      max = x;\n    }\n    if (min > x) {\n      min = x;\n    }\n  });\n  return [min, max];\n};\n\nexport const defaultColor = \"#5F6B7C\";\n\nexport const default_cluster = `${code}::CLUSTERS`;\nexport const default_selection = `${code}::SELECTION`;\n\nexport const getComputedCols = (cols) => {\n  return Object.keys(cols)\n    .filter(\n      (x) =>\n        cols[x].name === default_cluster ||\n        ((cols[x].name.startsWith(code) || cols[x].name === \"__batch__\") &&\n          cols[x].type !== \"continuous\" &&\n          (cols[x][\"type\"] === \"both\" ||\n            (cols[x][\"type\"] === \"categorical\" &&\n              cols[x][\"truncated\"] === false)))\n    )\n    .filter((x) => !cols[x].name.replace(`${code}::`, \"\").startsWith(\"QC\"));\n};\n\nexport const showComputedSection = (cols, custom) => {\n  return getComputedCols(cols).length > 0 || Object.keys(custom).length > 0;\n};\n\nexport const getSuppliedCols = (cols) => {\n  return Object.keys(cols).filter(\n    (x) =>\n      !cols[x].name.startsWith(code) &&\n      cols[x].name !== \"__batch__\" &&\n      cols[x].type !== \"continuous\" &&\n      (cols[x][\"type\"] === \"both\" ||\n        (cols[x][\"type\"] === \"categorical\" && cols[x][\"truncated\"] === false))\n  );\n};\n\nexport const resetApp = () => {\n  window.location.reload();\n};\n","import * as bakana from \"bakana\";\nimport * as scran from \"scran.js\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as gesel from \"gesel\";\nimport * as hashwasm from \"hash-wasm\";\nimport * as remotes from \"bakana-remotes\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\nimport JSZip from \"jszip\";\n\nimport * as translate from \"./translate.js\";\nimport {\n  extractBuffers,\n  postAttempt,\n  postSuccess,\n  postError,\n  fetchStepSummary,\n  describeColumn,\n  isArrayOrView,\n  fetchWithProgress,\n  formatMarkerResults,\n} from \"./helpers.js\";\nimport { code } from \"../utils/utils.js\";\n/***************************************/\n\nconst default_cluster = `${code}::CLUSTERS`;\nconst default_selection = `${code}::SELECTION`;\n\nlet superstate = null;\nlet preflights = {};\nlet preflights_summary = {};\nlet cache_matrix = null;\nlet cache_anno_markers = {};\n\nfunction createDataset(args) {\n  let output;\n  if (args.format === \"10X\") {\n    output = new bakana.TenxHdf5Dataset(args.h5);\n  } else if (args.format === \"MatrixMarket\") {\n    output = new bakana.TenxMatrixMarketDataset(args.mtx, args.genes || null, args.annotations || null);\n  } else if (args.format === \"H5AD\") {\n    output = new bakana.H5adDataset(args.h5);\n  } else if (args.format === \"SummarizedExperiment\") {\n    output = new bakana.SummarizedExperimentDataset(args.rds);\n  } else if (args.format === \"ZippedADB\") {\n    if (args.ziplegacy) {\n      output = new bakana.ZippedArtifactdbDataset(args.zipname, args.zipfile);\n    } else {\n      output = new bakana.ZippedAlabasterDataset(args.zipname, args.zipfile);\n    }\n  } else if (args.format === \"ExperimentHub\") {\n    output = new remotes.GypsumDataset(\"scRNAseq\", args.id, ExperimentHub_registry[args.id], null);\n  } else {\n    throw new Error(\"unknown format '\" + args.format + \"'\");\n  }\n  if (args.options) {\n    output.setOptions(args.options);\n  }\n  return output;\n}\n\nfunction summarizeDataset(summary, args) {\n  // TODO: figure out a way to deal with nested dataframes later\n  let cells_summary = {};\n  for (const k of summary.cells.columnNames()) {\n    const kcol = summary.cells.column(k);\n    if (isArrayOrView(kcol))\n      cells_summary[k] = describeColumn(kcol, {\n        all: true,\n        unique: true,\n        colname: k,\n      });\n  }\n  let tmp_meta = {\n    cells: {\n      columns: cells_summary,\n      numberOfCells: summary.cells.numberOfRows(),\n    },\n  };\n\n  if (args.format === \"H5AD\") {\n    tmp_meta[\"all_features\"] = {};\n    let tmod_summary = {};\n    for (const k of summary[\"all_features\"].columnNames()) {\n      const kcol = summary[\"all_features\"].column(k);\n      if (isArrayOrView(kcol)) {\n        tmod_summary[k] = describeColumn(kcol, {\n          all: true,\n          unique: true,\n          colname: k,\n        });\n      }\n    }\n    tmp_meta[\"all_features\"] = {\n      columns: tmod_summary,\n      numberOfFeatures: summary[\"all_features\"].numberOfRows(),\n      rownames: Array.isArray(summary[\"all_features\"].rowNames()),\n    };\n  } else if (args.format === \"SummarizedExperiment\") {\n    tmp_meta[\"modality_features\"] = {};\n    if (\"modality_features\" in summary) {\n      for (const [k, v] of Object.entries(summary.modality_features)) {\n        let tmod_summary = {};\n        for (const k of v.columnNames()) {\n          const kcol = v.column(k);\n          if (isArrayOrView(kcol)) {\n            tmod_summary[k] = describeColumn(kcol, {\n              all: true,\n              unique: true,\n              colname: k,\n            });\n          }\n        }\n        tmp_meta[\"modality_features\"][k] = {\n          columns: tmod_summary,\n          numberOfFeatures: v.numberOfRows(),\n          rownames: Array.isArray(v.rowNames()),\n        };\n      }\n    }\n  } else {\n    tmp_meta[\"modality_features\"] = {};\n    if (\"modality_features\" in summary) {\n      for (const [k, v] of Object.entries(summary.modality_features)) {\n        let tmod_summary = {};\n        for (const k of v.columnNames()) {\n          const kcol = v.column(k);\n          if (isArrayOrView(kcol)) {\n            tmod_summary[k] = describeColumn(kcol, {\n              all: true,\n              unique: true,\n              colname: k,\n            });\n          }\n        }\n        tmp_meta[\"modality_features\"][k] = {\n          columns: tmod_summary,\n          numberOfFeatures: v.numberOfRows(),\n          rownames: Array.isArray(v.rowNames()),\n        };\n      }\n    }\n  }\n\n  if (args.format === \"H5AD\") {\n    tmp_meta[\"all_assay_names\"] = summary.all_assay_names;\n  } else if (\n    args.format === \"SummarizedExperiment\" ||\n    args.format === \"ZippedADB\" ||\n    args.format === \"ExperimentHub\"\n  ) {\n    tmp_meta[\"modality_assay_names\"] = summary.modality_assay_names;\n  }\n  return tmp_meta;\n}\n\nbakana.setVisualizationAnimate((type, x, y, iter) => {\n  postMessage(\n    {\n      type: type + \"_iter\",\n      x: x,\n      y: y,\n      iteration: iter,\n    },\n    [x.buffer, y.buffer]\n  );\n});\n\nfunction linkKanaDb(collected) {\n  return async (type, file) => {\n    let buffer = file.buffer();\n    var md5 = await hashwasm.md5(buffer);\n    var id = type + \"_\" + file.name() + \"_\" + buffer.length + \"_\" + md5;\n    await kana_db.saveFile(id, buffer);\n    collected.push(id);\n    return id;\n  };\n}\n\nbakana.setResolveLink(kana_db.loadFile);\n\nasync function postStepSummary(step) {\n  try {\n    let output = await fetchStepSummary(superstate, step);\n\n    postSuccess(step, output);\n  } catch (err) {\n    console.error(err);\n    postError(step, err, true);\n  }\n}\n\nfunction getMarkerStandAloneForAnnot(annotation, annotation_vec) {\n  let mds;\n  if (!(annotation in cache_anno_markers)) {\n    mds = new bakana.MarkerDetectionStandalone(\n      getMatrix(),\n      annotation_vec.ids.slice()\n    );\n\n    mds.computeAll();\n    cache_anno_markers[annotation] = mds;\n  }\n\n  return cache_anno_markers[annotation];\n}\n\nconst getAnnotation = (annotation, unfiltered = false) => {\n  let vec;\n  if (annotation === \"__batch__\") {\n    vec = superstate.inputs.fetchBlock().slice();\n  } else if (annotation.startsWith(`${code}::QC::`)) {\n    let metric = annotation.replace(`${code}::QC::`, \"\");\n    let split_metric = metric.split(\"_\");\n    let metrics =\n      superstate[\n        `${split_metric[0].toLowerCase()}_quality_control`\n      ].fetchMetrics();\n\n    if (split_metric[1] === \"sums\") {\n      vec = metrics.sum();\n    } else if (split_metric[1] === \"detected\") {\n      vec = metrics.detected();\n    } else if (split_metric[1] === \"proportion\") {\n      if (split_metric[0].toLowerCase() === \"rna\") {\n        vec = metrics.subsetProportion(0);\n      } else if (split_metric[0].toLowerCase() === \"adt\") {\n        vec = metrics.subsetSum(0);\n      } else if (split_metric[0].toLowerCase() === \"crispr\") {\n        vec = metrics.maxProportion(0);\n      }\n    }\n  } else {\n    vec = superstate.inputs.fetchCellAnnotations().column(annotation);\n  }\n\n  if (!unfiltered) {\n    vec = superstate.cell_filtering.applyFilter(vec);\n  }\n\n  return vec.slice();\n};\n\nconst getMatrix = () => {\n  if (cache_matrix === null) {\n    cache_matrix = new scran.MultiMatrix();\n    let mapping = {\n      RNA: \"rna_normalization\",\n      ADT: \"adt_normalization\",\n      CRISPR: \"crispr_normalization\",\n    };\n    for (const [k, v] of Object.entries(mapping)) {\n      let state = superstate[v];\n      if (state.valid()) {\n        cache_matrix.add(k, state.fetchNormalizedMatrix());\n      }\n    }\n  }\n  return cache_matrix;\n};\n\nconst resetMarkerState = () => {\n  for (const [k, v] of Object.entries(cache_anno_markers)) {\n    v.free();\n  }\n\n  cache_anno_markers = {};\n};\n\nconst ExperimentHub_registry = {\n  \"zeisel-brain-2015\": \"2023-12-14\",\n  \"segerstolpe-pancreas-2016\": \"2023-12-19\",\n  \"nestorowa-hsc-2016\": \"2024-04-18\",\n  \"aztekin-tail-2019\": \"2023-12-14\",\n  \"wu-kidney-2019\": \"2023-12-20\",\n  \"zilionis-lung-2019\": \"2023-12-20\"\n};\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n  const { type, payload } = msg.data;\n\n  // console.log(\"SCRAN.WORKER ::RCV::\", type, payload);\n\n  let fatal = false;\n  if (type === \"INIT\") {\n    fatal = true;\n    let nthreads = Math.round((navigator.hardwareConcurrency * 2) / 3);\n    let back_init = bakana.initialize({ numberOfThreads: nthreads });\n\n    let state_init = back_init.then(() => {\n      return bakana.createAnalysis();\n    });\n\n    state_init.then((x) => {\n      superstate = x;\n      postMessage({\n        type: type,\n        msg: \"Success: analysis state created\",\n      });\n    });\n\n    let kana_init = kana_db.initialize();\n    kana_init\n      .then((output) => {\n        if (output !== null) {\n          postMessage({\n            type: \"KanaDB_store\",\n            resp: output,\n            msg: \"Success: KanaDB initialized\",\n          });\n        }\n      })\n      .catch((error) => {\n        console.error(error);\n        postMessage({\n          type: \"KanaDB_ERROR\",\n          msg: \"Error: Cannot initialize KanaDB\",\n        });\n      });\n\n    let down_init = downloads.initialize();\n    down_init\n      .then((output) => {\n        postMessage({\n          type: \"DownloadsDB_store\",\n          resp: output,\n          msg: \"Success: DownloadsDB initialized\",\n        });\n      })\n      .catch((error) => {\n        console.error(error);\n        postMessage({\n          type: \"DownloadsDB_ERROR\",\n          msg: \"Error: Cannot initialize DownloadsDB\",\n        });\n      });\n\n    try {\n      postMessage({\n        type: \"ExperimentHub_store\",\n        resp: Array.from(Object.keys(ExperimentHub_registry)),\n        msg: \"Success: ExperimentHub initialized\",\n      });\n    } catch (err) {\n      console.error(err);\n      postMessage({\n        type: \"ExperimentHub_ERROR\",\n        msg: \"Error: Cannot access datasets in ExperimentHub\",\n      });\n    }\n\n    loaded = Promise.all([back_init, kana_init, down_init, state_init]);\n\n    loaded\n      .then(() => {\n        postMessage({\n          type: type,\n          msg: \"Success: bakana initialized\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    /**************** RUNNING AN ANALYSIS *******************/\n  } else if (type === \"RUN\") {\n    fatal = true;\n    loaded\n      .then((x) => {\n        let inputs = payload.inputs;\n        let files = inputs.files;\n\n        if (files !== null) {\n          // Extracting existing datasets from the preflights.\n          let current = {};\n          for (const [k, v] of Object.entries(files)) {\n            if (\"uid\" in v && v.uid in preflights) {\n              current[k] = preflights[v.uid];\n            } else {\n              current[k] = createDataset(v);\n            }\n            current[k].setOptions(v.options);\n          }\n\n          // Cleaning out the preflight datasets that weren't used.\n          for (const [k, v] of Object.entries(preflights)) {\n            v.clear();\n            delete preflights[k];\n          }\n\n          files = current;\n        }\n\n        resetMarkerState();\n\n        let formatted = translate.fromUI(inputs, payload.params);\n        bakana\n          .runAnalysis(superstate, files, formatted, {\n            startFun: postAttempt,\n            finishFun: postStepSummary,\n          })\n          .catch((err) => {\n            console.error(err);\n            postError(type, err, fatal);\n          });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n    /**************** LOADING EXISTING ANALYSES *******************/\n  } else if (type === \"LOAD\") {\n    fatal = true;\n    let fs = payload.inputs.files;\n\n    if (fs[Object.keys(fs)[0]].format === \"kana\") {\n      let f = fs[Object.keys(fs)[0]].file;\n      loaded\n        .then(async (x) => {\n          const reader = new FileReaderSync(); // eslint-disable-line\n          const zipbuffer = reader.readAsArrayBuffer(f);\n          const unzipped = await JSZip.loadAsync(zipbuffer);\n          let config = JSON.parse(\n            await unzipped.file(\"config.json\").async(\"string\")\n          );\n\n          let buffers = {};\n          for (const x in unzipped.files) {\n            if (x.startsWith(\"datasets/\")) {\n              let current = await unzipped.files[x].async(\"uint8array\");\n              buffers[x.split(\"/\")[1]] = current;\n            }\n          }\n\n          // This re-runs the entire analysis, so throw startFun/finishFun callbacks here.\n          superstate = await bakana.unserializeConfiguration(\n            config,\n            (id) => buffers[id],\n            {\n              state: superstate,\n              startFun: postAttempt,\n              finishFun: postStepSummary,\n            }\n          );\n\n          const other = {\n            custom_selections: superstate.custom_selections.fetchSelections(),\n          };\n\n          var transferrable = [];\n          extractBuffers(config.parameters, transferrable);\n          postMessage(\n            {\n              type: \"loadedParameters\",\n              resp: {\n                parameters: config.parameters,\n                other: other,\n              },\n            },\n            transferrable\n          );\n\n          let features = {};\n          let resp = {};\n          const loaded_ds = superstate.inputs.fetchDatasets();\n          for (const [k, v] of Object.entries(loaded_ds)) {\n            let res = await v.previewPrimaryIds({ cache: true });\n\n            for (const i_mod of [\"RNA\", \"ADT\", \"CRISPR\"]) {\n              if (i_mod in res) {\n                if (!features[i_mod]) {\n                  features[i_mod] = [res[i_mod]];\n                } else {\n                  features[i_mod].push(res[i_mod]);\n                }\n              }\n            }\n          }\n\n          for (const [k, v] of Object.entries(features)) {\n            resp[k] = gesel.intersect(v).length;\n          }\n\n          postMessage({\n            type: \"PREFLIGHT_OPTIONS_DATA\",\n            resp: resp,\n            msg: \"Success: PREFLIGHT_OPTIONS done\",\n          });\n        })\n        .catch((err) => {\n          console.error(err);\n          postError(type, err, fatal);\n        });\n    } else if (fs[Object.keys(fs)[0]].format === \"kanadb\") {\n      loaded\n        .then(async (x) => {\n          var id = fs[Object.keys(fs)[0]].file;\n\n          const jsonbuffer = await kana_db.loadAnalysis(id);\n          const dec = new TextDecoder();\n          let config = JSON.parse(dec.decode(jsonbuffer));\n\n          superstate = await bakana.unserializeConfiguration(\n            config,\n            kana_db.loadFile,\n            {\n              state: superstate,\n              startFun: postAttempt,\n              finishFun: postStepSummary,\n            }\n          );\n        })\n        .catch((err) => {\n          console.error(err);\n          postError(type, err, fatal);\n        });\n    }\n    /**************** SAVING EXISTING ANALYSES *******************/\n  } else if (type === \"EXPORT\") {\n    loaded\n      .then(async (x) => {\n        let buffers = [];\n        let saver = (name, format, file) => {\n          let id = String(buffers.length);\n          buffers.push(file.buffer());\n          return id;\n        };\n\n        // Returns a configuration object.\n        let collected = await bakana.serializeConfiguration(superstate, saver);\n\n        // Let's zip it all up!\n        const zipper = new JSZip();\n        zipper.file(\"config.json\", JSON.stringify(collected));\n        for (var i = 0; i < buffers.length; i++) {\n          zipper.file(\"datasets/\" + String(i), buffers[i]);\n        }\n        let zipbuffer = await zipper.generateAsync({ type: \"uint8array\" });\n        postMessage(\n          {\n            type: \"exportState\",\n            resp: zipbuffer,\n            msg: \"Success: application state exported\",\n          },\n          [zipbuffer.buffer]\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"EXPORT_RDS\") {\n    loaded\n      .then(async (x) => {\n        let files = await bakana.saveSingleCellExperiment(superstate, \"sce\");\n        let gene_files = await bakana.saveGenewiseResults(superstate, null);\n\n        let zipper = new JSZip;\n        for (const [k, v] of Object.entries(files)) {\n          zipper.file(k, v);\n        }\n        for (const [k, v] of Object.entries(gene_files)) {\n          zipper.file(k, v);\n        }\n        let zipbuffer = await zipper.generateAsync({ type: \"uint8array\", compression: \"DEFLATE\" });\n\n        postMessage(\n          {\n            type: \"exportRDSState\",\n            resp: zipbuffer,\n            msg: \"Success: application state exported\",\n          },\n          [zipbuffer.buffer]\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"SAVEKDB\") {\n    // save analysis to inbrowser indexedDB\n    var title = payload.title;\n    loaded\n      .then(async (x) => {\n        let buffers = [];\n        let saver = async (name, format, file) => {\n          // basically linkKanaDb with an extra arg.\n          let buffer = file.buffer();\n          var md5 = await hashwasm.md5(buffer);\n          var id = type + \"_\" + file.name() + \"_\" + buffer.length + \"_\" + md5;\n          await kana_db.saveFile(id, buffer);\n          buffers.push(id);\n          return id;\n        };\n\n        let collected = await bakana.serializeConfiguration(superstate, saver);\n        const enc = new TextEncoder();\n        let config = enc.encode(JSON.stringify(collected));\n        let id = await kana_db.saveAnalysis(null, config, collected, title);\n\n        let recs = await kana_db.getRecords();\n        postMessage({\n          type: \"KanaDB_store\",\n          resp: recs,\n          msg: `Success: Saved analysis to browser (${id})`,\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    /**************** KANADB EVENTS *******************/\n  } else if (type === \"REMOVEKDB\") {\n    // remove a saved analysis\n    var id = payload.id;\n    kana_db\n      .removeAnalysis(id)\n      .then(async (output) => {\n        let recs = await kana_db.getRecords();\n        postMessage({\n          type: \"KanaDB_store\",\n          resp: recs,\n          msg: `Success: Removed file from cache (${id})`,\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"PREFLIGHT_OPTIONS\") {\n    loaded.then(async (x) => {\n      let resp = {};\n      try {\n        let counter = 0;\n        let features = {};\n\n        for (const [k, v] of Object.entries(payload.inputs.files)) {\n          if (\"uid\" in v) {\n            let ds = preflights[v.uid];\n\n            if (\n              Array.isArray(payload.options) &&\n              payload.options.length > counter\n            ) {\n              ds.setOptions(payload.options[counter]);\n\n              let res = await ds.previewPrimaryIds({ cache: true });\n\n              for (const i_mod of [\"RNA\", \"ADT\", \"CRISPR\"]) {\n                if (i_mod in res) {\n                  if (!features[i_mod]) {\n                    features[i_mod] = [res[i_mod]];\n                  } else {\n                    features[i_mod].push(res[i_mod]);\n                  }\n                }\n              }\n            }\n          }\n          counter++;\n        }\n\n        for (const [k, v] of Object.entries(features)) {\n          if (v.length !== payload.options.length) {\n            resp[k] = 0;\n          } else {\n            resp[k] = gesel.intersect(v).length;\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        resp.status = \"ERROR\";\n        resp.reason = e.toString();\n      }\n\n      postMessage({\n        type: \"PREFLIGHT_OPTIONS_DATA\",\n        resp: resp,\n        msg: \"Success: PREFLIGHT_OPTIONS done\",\n      });\n    });\n  } else if (type === \"PREFLIGHT_INPUT\") {\n    loaded\n      .then(async (x) => {\n        let resp = {};\n        try {\n          // Registering the UIDs of each new dataset.\n          let current = {};\n          let summary = {};\n          for (const [k, v] of Object.entries(payload.inputs.files)) {\n            if (\"uid\" in v) {\n              if (!(v.uid in preflights)) {\n                preflights[v.uid] = createDataset(v);\n                preflights_summary[v.uid] = await preflights[v.uid].summary({\n                  cache: true,\n                });\n              }\n              current[k] = preflights[v.uid];\n              summary[k] = summarizeDataset(preflights_summary[v.uid], v);\n            } else {\n              let tmp_dataset = createDataset(v);\n              current[k] = tmp_dataset;\n              summary[k] = summarizeDataset(\n                await current[k].summary({ cache: true }),\n                v\n              );\n            }\n          }\n\n          resp.status = \"SUCCESS\";\n          resp.details = summary;\n          // resp.details = await bakana.validateAnnotations(current, { cache: true });\n          // i guess iterate through each dataset and call summary\n        } catch (e) {\n          console.error(e);\n          resp.status = \"ERROR\";\n          resp.reason = e.toString();\n        }\n\n        postMessage({\n          type: \"PREFLIGHT_INPUT_DATA\",\n          resp: resp,\n          msg: \"Success: PREFLIGHT_INPUT done\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    /**************** VERSUS MODE *******************/\n  } else if (type === \"computeVersusClusters\") {\n    loaded\n      .then((x) => {\n        let rank_type = payload.rank_type;\n        let modality = payload.modality;\n        let annotation = payload.annotation;\n\n        let resp, raw_res;\n        if (default_cluster === annotation) {\n          raw_res = superstate.marker_detection.computeVersus(\n            payload.left,\n            payload.right\n          );\n\n          resp = formatMarkerResults(\n            raw_res.results[modality],\n            raw_res.left,\n            rank_type\n          );\n        } else {\n          let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n          raw_res = mds.computeVersus(\n            annotation_vec.levels.indexOf(payload.left),\n            annotation_vec.levels.indexOf(payload.right)\n          );\n          resp = formatMarkerResults(\n            raw_res.results[modality],\n            raw_res.left,\n            rank_type\n          );\n        }\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"computeVersusClusters\",\n            resp: resp,\n            msg: \"Success: COMPUTE_VERSUS_CLUSTERS done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeVersusSelections\") {\n    loaded\n      .then((x) => {\n        let rank_type = payload.rank_type;\n        let res = superstate.custom_selections.computeVersus(\n          payload.left,\n          payload.right\n        );\n        let resp = formatMarkerResults(\n          res[\"results\"][payload.modality],\n          res.left,\n          rank_type\n        );\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"computeVersusSelections\",\n            resp: resp,\n            msg: \"Success: COMPUTE_VERSUS_SELECTIONS done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n\n    /**************** OTHER EVENTS FROM UI *******************/\n  } else if (type === \"getMarkersForCluster\") {\n    loaded\n      .then((x) => {\n        let cluster = payload.cluster;\n        let rank_type = payload.rank_type;\n        let modality = payload.modality;\n        let annotation = payload.annotation;\n        let resp;\n        let raw_res;\n        if (default_cluster === annotation) {\n          raw_res = superstate.marker_detection.fetchResults()[modality];\n          resp = formatMarkerResults(raw_res, cluster, rank_type);\n        } else {\n          let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n          raw_res = mds.fetchResults()[modality];\n          // cache_anno_markers[annotation][modality];\n\n          resp = formatMarkerResults(\n            raw_res,\n            annotation_vec.levels.indexOf(cluster),\n            rank_type\n          );\n        }\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"setMarkersForCluster\",\n            resp: resp,\n            msg: \"Success: GET_MARKERS_FOR_CLUSTER done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getGeneExpression\") {\n    loaded\n      .then((x) => {\n        let row_idx = payload.gene;\n        let modality = payload.modality;\n\n        const matrix = getMatrix(modality);\n        let vec;\n        if (modality === \"RNA\") {\n          vec = matrix.get(modality).row(row_idx);\n        } else if (modality === \"ADT\") {\n          vec = matrix.get(modality).row(row_idx);\n        } else if (modality === \"CRISPR\") {\n          vec = matrix.get(modality).row(row_idx);\n        } else {\n          throw new Error(\"unknown feature type '\" + modality + \"'\");\n        }\n\n        postMessage(\n          {\n            type: \"setGeneExpression\",\n            resp: {\n              gene: row_idx,\n              expr: vec,\n            },\n            msg: \"Success: GET_GENE_EXPRESSION done\",\n          },\n          [vec.buffer]\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeCustomMarkers\") {\n    loaded\n      .then((x) => {\n        superstate.custom_selections.addSelection(\n          payload.id,\n          payload.selection\n        );\n        postMessage({\n          type: \"computeCustomMarkers\",\n          msg: \"Success: COMPUTE_CUSTOM_MARKERS done\",\n        });\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getMarkersForSelection\") {\n    loaded\n      .then((x) => {\n        let raw_res = superstate.custom_selections.fetchResults(\n          payload.cluster\n        )[payload.modality];\n        let resp = formatMarkerResults(raw_res, 1, payload.rank_type);\n\n        var transferrable = [];\n        extractBuffers(resp, transferrable);\n        postMessage(\n          {\n            type: \"setMarkersForCustomSelection\",\n            resp: resp,\n            msg: \"Success: GET_MARKERS_FOR_SELECTION done\",\n          },\n          transferrable\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"removeCustomMarkers\") {\n    loaded\n      .then((x) => {\n        superstate.custom_selections.removeSelection(payload.id);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"animateTSNE\") {\n    loaded\n      .then(async (x) => {\n        await superstate.tsne.animate();\n        postSuccess(\"tsne\", await superstate.tsne.fetchResults());\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"animateUMAP\") {\n    loaded\n      .then(async (x) => {\n        await superstate.umap.animate();\n        postSuccess(\"umap\", await superstate.umap.fetchResults());\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getAnnotation\") {\n    loaded\n      .then((x) => {\n        let annot = payload.annotation;\n        let vec, output;\n\n        vec = getAnnotation(annot, !!payload.unfiltered);\n\n        if (ArrayBuffer.isView(vec)) {\n          output = {\n            type: \"array\",\n            values: vec.slice(),\n          };\n        } else {\n          let uniq_vals = [];\n          let uniq_map = {};\n          let indices = new Int32Array(vec.length);\n          vec.map((x, i) => {\n            if (!(x in uniq_map)) {\n              uniq_map[x] = uniq_vals.length;\n              uniq_vals.push(x);\n            }\n            indices[i] = uniq_map[x];\n          });\n\n          output = {\n            type: \"factor\",\n            index: indices,\n            levels: uniq_vals,\n          };\n        }\n\n        let extracted = [];\n        extractBuffers(output, extracted);\n        postMessage(\n          {\n            type: \"setAnnotation\",\n            resp: {\n              annotation: annot,\n              values: output,\n            },\n            msg: \"Success: GET_ANNOTATION done\",\n          },\n          extracted\n        );\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeFeaturesetSummary\") {\n    loaded\n      .then(async (x) => {\n        let { annotation, rank_type, cluster } = payload;\n        let index = rank_type.indexOf(\"-\");\n        let resp;\n        if (default_cluster === annotation) {\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            superstate.marker_detection.fetchResults()[\"RNA\"],\n            cluster,\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetSummary\", resp);\n        } else if (default_selection === annotation) {\n          let sel_indices =\n            superstate.custom_selections.fetchSelectionIndices(cluster);\n          let num_cells = superstate.cell_filtering\n            .fetchFilteredMatrix()\n            .numberOfColumns();\n\n          let arr_sel_indices = new Uint8Array(num_cells);\n          sel_indices.map((x) => arr_sel_indices.set([1], x));\n          let annotation_vec = scran.convertToFactor(arr_sel_indices);\n\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n          let anno_markers = mds.fetchResults()[\"RNA\"];\n\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            anno_markers,\n            annotation_vec.levels.indexOf(1),\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetSummary\", resp);\n        } else {\n          let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n          let anno_markers = mds.fetchResults()[\"RNA\"];\n\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            anno_markers,\n            annotation_vec.levels.indexOf(cluster),\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetSummary\", resp);\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeFeaturesetVSSummary\") {\n    loaded\n      .then(async (x) => {\n        let { annotation, rank_type, left, right } = payload;\n        let index = rank_type.indexOf(\"-\");\n        let resp;\n        if (default_cluster === annotation) {\n          let raw_res = superstate.marker_detection.computeVersus(left, right);\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            raw_res.results[\"RNA\"],\n            raw_res.left,\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetVSSummary\", resp);\n        } else if (default_selection === annotation) {\n          let anno_markers = superstate.custom_selections.computeVersus(\n            left,\n            right\n          );\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            anno_markers.results[\"RNA\"],\n            0,\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetVSSummary\", resp);\n        } else {\n          let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n          let raw_res = mds.computeVersus(\n            annotation_vec.levels.indexOf(payload.left),\n            annotation_vec.levels.indexOf(payload.right)\n          );\n\n          resp = superstate.feature_set_enrichment.computeEnrichment(\n            raw_res.results[\"RNA\"],\n            raw_res.left,\n            rank_type.slice(0, index),\n            rank_type.slice(index + 1)\n          );\n          postSuccess(\"computeFeaturesetVSSummary\", resp);\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getFeatureScores\") {\n    loaded\n      .then((x) => {\n        let { index } = payload;\n\n        let resp =\n          superstate.feature_set_enrichment.computePerCellScores(index);\n        postSuccess(\"setFeatureScores\", resp);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"getFeatureGeneIndices\") {\n    loaded\n      .then((x) => {\n        let { index, cluster, annotation, modality, rank_type } = payload;\n\n        let resp =\n          superstate.feature_set_enrichment.fetchFeatureSetIndices(index);\n\n        let raw_res, marker_resp;\n\n        if (default_cluster === annotation) {\n          raw_res = superstate.marker_detection.fetchResults()[modality];\n          marker_resp = formatMarkerResults(raw_res, cluster, rank_type);\n        } else if (default_selection === annotation) {\n          raw_res = superstate.custom_selections.fetchResults(payload.cluster)[\n            payload.modality\n          ];\n          marker_resp = formatMarkerResults(\n            raw_res,\n            1,\n            payload.rank_type\n          );\n        } else {\n          let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n          let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n\n          raw_res = mds.fetchResults()[modality];\n          // cache_anno_markers[annotation][modality];\n\n          marker_resp = formatMarkerResults(\n            raw_res,\n            annotation_vec.levels.indexOf(cluster),\n            rank_type\n          );\n        }\n\n        let indices = marker_resp.ordering\n          .map((x, i) => (resp.includes(x) ? i : -100))\n          .filter((x) => x !== -100);\n\n        let filtered_marker_resp = {};\n        for (const [k, v] of Object.entries(marker_resp)) {\n          filtered_marker_resp[k] = v\n            .map((x, i) => (indices.includes(i) ? x : -100))\n            .filter((x) => x !== -100);\n        }\n\n        postSuccess(\"setFeatureGeneIndices\", filtered_marker_resp);\n      })\n      .catch((err) => {\n        console.error(err);\n        postError(type, err, fatal);\n      });\n  } else if (type === \"computeCellAnnotation\") {\n    let { annotation, cluster } = payload;\n    let result = { per_reference: {} };\n    let markers = null;\n    if (default_cluster === annotation) {\n      markers = superstate.marker_detection.fetchResults();\n    } else if (default_selection === annotation) {\n      markers = superstate.custom_selections.fetchResults(cluster);\n    } else {\n      let annotation_vec = scran.convertToFactor(getAnnotation(annotation));\n      let mds = getMarkerStandAloneForAnnot(annotation, annotation_vec);\n      markers = mds.fetchResults();\n    }\n    if (markers !== null && \"RNA\" in markers) {\n      result = superstate.cell_labelling.computeLabels(markers[\"RNA\"]);\n    }\n    postSuccess(\"computeCellAnnotation\", result);\n  } else {\n    console.error(`Type: ${type} not defined`);\n    postError(type, `Type: ${type} not defined`, fatal);\n  }\n};\n","/*****************************************************\n * This file is intended to be vendored into kanapi,\n * so you shouldn't add too many dependencies here.\n * The canonical version of the file is expected to\n * live at src/workers/translate.js in the kana repo.\n *****************************************************/\n\nimport * as bakana from \"bakana\";\n\nconst mappings = {\n  quality_control: {\n    use_mito_default: [\"qc\", \"qc-usemitodefault\"],\n    mito_prefix: [\"qc\", \"qc-mito\"],\n    nmads: [\"qc\", \"qc-nmads\"],\n    skip: [\"qc\", \"skip\"],\n  },\n  adt_quality_control: {\n    nmads: [\"adt_qualitycontrol\", \"nmads\"],\n    min_detected_drop: [\"adt_qualitycontrol\", \"min_detected_drop\"],\n    igg_prefix: [\"adt_qualitycontrol\", \"igg_prefix\"],\n    skip: [\"adt_qualitycontrol\", \"skip\"],\n  },\n  adt_normalization: {\n    num_pcs: [\"adt_normalization\", \"num_pcs\"],\n    num_clusters: [\"adt_normalization\", \"num_clusters\"],\n  },\n  feature_selection: {\n    span: [\"fSelection\", \"fsel-span\"],\n  },\n  pca: {\n    num_hvgs: [\"pca\", \"pca-hvg\"],\n    num_pcs: [\"pca\", \"pca-npc\"],\n  },\n  adt_pca: {\n    num_pcs: [\"adt_pca\", \"num_pcs\"],\n  },\n  combine_embeddings: {\n    weights: [\"combine_embeddings\", \"weights\"],\n  },\n  cell_labelling: {\n    references: null,\n    automatic: true,\n    species: [],\n    gene_id_column: null,\n    gene_id_type: \"ENSEMBL\",\n  },\n  batch_correction: {\n    // method is handled by configureBatchCorrection.\n    num_neighbors: [\"batch_correction\", \"num_neighbors\"],\n  },\n  choose_clustering: {\n    method: [\"cluster\", \"clus-method\"],\n  },\n  // Neighbor indexing is handled by configureApproximateNeighbors.\n  tsne: {\n    perplexity: [\"tsne\", \"tsne-perp\"],\n    iterations: [\"tsne\", \"tsne-iter\"],\n    animate: [\"tsne\", \"animate\"],\n  },\n  umap: {\n    num_neighbors: [\"umap\", \"umap-nn\"],\n    num_epochs: [\"umap\", \"umap-epochs\"],\n    min_dist: [\"umap\", \"umap-min_dist\"],\n    animate: [\"umap\", \"animate\"],\n  },\n  kmeans_cluster: {\n    k: [\"cluster\", \"kmeans-k\"],\n  },\n  snn_graph_cluster: {\n    k: [\"cluster\", \"clus-k\"],\n    scheme: [\"cluster\", \"clus-scheme\"],\n    resolution: [\"cluster\", \"clus-res\"],\n  },\n  // cell_labelling: {\n  //   human_references: [\"annotateCells\", \"annotateCells-human_references\"],\n  //   mouse_references: [\"annotateCells\", \"annotateCells-mouse_references\"],\n  // },\n};\n\nexport function fromUI(inputs, params) {\n  let formatted = params;\n\n  // Replacing all 1:1 mappings.\n  let safeReplace = (step, par, value) => {\n    if (typeof value == \"undefined\") {\n      throw new Error(\n        \"cannot assign undefined parameter to '\" + step + \".\" + par + \"'\"\n      );\n    }\n    if (!(step in formatted)) {\n      throw new Error(\"unknown analysis step '\" + step + \"'\");\n    }\n    let target = formatted[step];\n    if (!(par in target)) {\n      throw new Error(\n        \"unknown analysis parameter '\" + par + \"' for step '\" + step + \"'\"\n      );\n    }\n    target[par] = value;\n  };\n\n  safeReplace(\"inputs\", \"block_factor\", inputs.batch);\n  safeReplace(\"inputs\", \"subset\", inputs.subset);\n\n  // Special handling for multi-step parameters.\n  bakana.configureBatchCorrection(formatted, params.batch_correction[\"method\"]);\n  bakana.configureApproximateNeighbors(\n    formatted,\n    params.neighbor_index[\"approximate\"]\n  );\n\n  // Simplify the combine_embeddings if we see it is all equal.\n  if (formatted.combine_embeddings.weights !== null) {\n    let uniq_weights = new Set([\n      formatted.combine_embeddings.rna_weight,\n      formatted.combine_embeddings.adt_weight,\n      formatted.combine_embeddings.crispr_weight,\n    ]);\n    if (uniq_weights.size <= 1) {\n      formatted.combine_embeddings.weights = null;\n    }\n  }\n\n  return formatted;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [691,985,978], () => (__webpack_require__(2866)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"120\":\"568b3440\",\"343\":\"07177662\",\"691\":\"9a33b0ff\",\"814\":\"bc231a0d\",\"978\":\"92a21f88\",\"985\":\"b0e597fb\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t866: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([691,985,978].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["kanaDB","init","get_records","allAnalysis","result","transaction","objectStore","getAll","Promise","resolve","reject","onsuccess","event","vals","forEach","x","files","onerror","Error","concat","target","errorCode","async","getRecords","loadFile","id","file_store","meta_promise","request","get","undefined","meta","Uint8Array","superResolver","resolved","Array","replacement","y","push","remove_file","meta_store","refcount","promises","delete","count","put","DownloadsDB","fetchWrapper","url","params","arguments","length","out","startFun","iterFun","endFun","res","fetch","ok","headers","reader","body","getReader","chunks","total","done","value","read","output","start","set","fetchWithProgress","cl","postMessage","type","String","download","total_bytes","msg","sofar","downloaded_bytes","error","req","status","buffer","arrayBuffer","force","download_store","data_check","already","payload","found","trans","fin","oncomplete","saving","putrequest","proxy","proxyAndCache","downloads","encodeURIComponent","extractBuffers","object","store","isArray","element","constructor","Object","key","entries","ArrayBuffer","isView","postAttempt","step","postSuccess","info","transferable","resp","postError","err","fatal","reason","toString","splitMetricsByBlock","metrics","blockLevels","blockIds","blocks","slice","b","current","val","filter","i","splitThresholdsByBlock","thresholds","isArrayOrView","col","describeColumn","all","unique","colname","bakana","uqVals","Set","size","sort","formatMarkerResults","results","group","rankEffect","ordering","summary","ranking","increasing","match","cohensD","copy","auc","deltaMean","deltaDetected","Int32Array","f","s","reorder","stats","thing","Float64Array","stat_mean","mean","stat_detected","detected","stat_lfc","stat_delta_d","setDownload","gesel","file","end","full","Response","remotes","setDownloadFun","code","default_cluster","default_selection","superstate","preflights","preflights_summary","cache_matrix","cache_anno_markers","createDataset","args","format","h5","mtx","genes","annotations","rds","ziplegacy","zipname","zipfile","ExperimentHub_registry","options","setOptions","summarizeDataset","cells_summary","k","cells","columnNames","kcol","column","tmp_meta","columns","numberOfCells","numberOfRows","tmod_summary","numberOfFeatures","rownames","rowNames","v","modality_features","all_assay_names","modality_assay_names","postStepSummary","state","changed","ngenes","a","fetchCountMatrix","available","gene_info","fetchFeatureAnnotations","c","cell_info","fetchCellAnnotations","ksumm","fetchBlockLevels","fetchBlock","num_cells","numberOfColumns","num_genes","sums","fetchMetrics","sum","proportion","subsetProportion","data","default","bids","listed","fetchFilters","subsetSum","NaN","maxProportion","maxValue","remaining","keep_vec","keepBuff","fetchKeep","inputs","retained","keep","means","fetchResults","vars","variances","fitted","resids","residuals","pcs","fetchPCs","var_exp","varianceExplained","total_var","totalVariance","clusters","fetchClusters","markers","marker_detection","computeLabels","RNA","per_reference","collections","feature_set_enrichment","fetchCollectionDetails","sets","fetchSetDetails","names","descriptions","sizes","fetchStepSummary","console","getMarkerStandAloneForAnnot","annotation","annotation_vec","mds","getMatrix","ids","computeAll","iter","iteration","kana_db","getAnnotation","vec","unfiltered","startsWith","split_metric","replace","split","toLowerCase","cell_filtering","applyFilter","scran","mapping","ADT","CRISPR","valid","add","fetchNormalizedMatrix","loaded","onmessage","nthreads","Math","round","navigator","hardwareConcurrency","back_init","numberOfThreads","state_init","then","kana_init","indexedDB","open","onupgradeneeded","e","kanaDBClient","deleteObjectStore","createObjectStore","keyPath","catch","down_init","DownloadsDBClient","from","keys","uid","clear","resetMarkerState","free","formatted","safeReplace","par","batch","subset","batch_correction","neighbor_index","combine_embeddings","weights","rna_weight","adt_weight","crispr_weight","translate","finishFun","fs","zipbuffer","FileReaderSync","readAsArrayBuffer","unzipped","JSZip","config","JSON","parse","buffers","other","custom_selections","fetchSelections","transferrable","parameters","features","loaded_ds","fetchDatasets","previewPrimaryIds","cache","i_mod","jsonbuffer","analysis_store","ana_promise","dec","TextDecoder","decode","collected","saver","name","zipper","stringify","generateAsync","gene_files","compression","title","md5","hashwasm","data_saving","ref_saving","TextEncoder","encode","output_promise","callback","new_id","id_saving","time","Number","Date","recs","analysis_meta_store","file_meta_store","analysis_removal","file_removal","my_promises","values","deleted","counter","ds","tmp_dataset","details","raw_res","rank_type","modality","computeVersus","left","right","levels","indexOf","cluster","row_idx","gene","matrix","row","expr","addSelection","selection","removeSelection","tsne","animate","umap","annot","uniq_vals","uniq_map","indices","map","index","extracted","computeEnrichment","sel_indices","fetchSelectionIndices","fetchFilteredMatrix","arr_sel_indices","anno_markers","computePerCellScores","marker_resp","fetchFeatureSetIndices","includes","filtered_marker_resp","cell_labelling","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","chunkId","reduce","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}