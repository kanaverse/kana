{"version":3,"file":"static/js/525.012a6612.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/steps/abstract/worker_child.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/viz_child.js","../node_modules/scran.js/browser/factorize.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/wasm.js","../node_modules/wasmarrays.js/src/create.js","../node_modules/wasmarrays.js/src/derived.js"],"sourcesContent":["export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.FindNearestNeighborsResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import * as wa from \"wasmarrays.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Convert an arbitrary array into a R-style factor, with integer indices into an array of levels.\n * This is useful for formatting grouping or blocking vectors for {@linkcode scoreMarkers}, {@linkcode modelGeneVar}, etc.\n *\n * @param {Array|TypedArray} x - Array of values to be converted into a factor.\n * \n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.asWasmArray=true] - Whether to return an Int32WasmArray instance for the indices.\n * If `false`, an Int32Array is returned instead.\n * Only used if `buffer` is not supplied.\n * @param {?(Int32WasmArray|Int32Array)} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to that of `x`.\n * @param {?Array} [options.levels=null] - An existing array of known levels to be matched against `x`.\n * Values in `x` that are not in `levels` are considered to be invalid.\n * If `null`, the levels are automatically inferred from `x`; these will be sorted if all-numeric or all-string.\n * @param {string} [options.action=\"error\"] - Action to take when invalid values (i.e., null, NaNs) are detected in `x`.\n *\n * - `\"none\"`: the index is silently set to `placeholder`.\n * - `\"warn\"`: a warning is raised on the first occurrence of an invalid value, and the index is set to `placeholder`.\n * - `\"error\"`: an error is raised.\n * \n * @param {number} [options.placeholder=-1] - Placeholder index to use upon detecting invalid values in `x`.\n *\n * @return {object} Object containing:\n *\n * - `ids`: an Int32WasmArray or Int32Array of length equal to `x`, containing the index into `levels` for each cell.\n * - `levels`: an array of unique levels, such that `Array.from(ids).map(i => levels[i])` returns the same contents as `x` (aside from invalid values).\n *   If an input `levels` is supplied, this is returned directly.\n *\n * If `buffer` was supplied, it is used as the value of the `ids` property.\n */\nexport function convertToFactor(x, { asWasmArray = true, buffer = null, levels = null, action = \"error\", placeholder = -1 } = {}) {\n    let local_buffer;\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing invalid values with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected invalid value (e.g., null, NaN) in 'x'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling invalid entries\");\n    }\n\n    try {\n        if (buffer == null) {\n            local_buffer = (asWasmArray ? utils.createInt32WasmArray(x.length) : new Int32Array(x.length));\n            buffer = local_buffer;\n        } else {\n            if (buffer.length !== x.length) {\n                throw new Error(\"'buffer' should have length equal to that of 'x'\");\n            }\n            asWasmArray = buffer instanceof wa.Int32WasmArray;\n        }\n\n        let barr = (asWasmArray ? buffer.array() : buffer); // no allocations from this point onwards!\n        let mapping = new Map;\n\n        if (levels == null) {\n            levels = [];\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                if (y == null || (typeof y == \"number\" && !Number.isFinite(y))) {\n                    failure();\n                    barr[i] = placeholder;\n                    continue;\n                }\n\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    let n = levels.length;\n                    mapping.set(y, n);\n                    levels.push(y);\n                    barr[i] = n;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n\n            // Sorting them by default, to make life nicer.\n            if (levels.every(x => typeof x == \"string\")) {\n                let oldlevels = levels.slice();\n                levels.sort();\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            } else if (levels.every(x => typeof x == \"number\")) {\n                let oldlevels = levels.slice();\n                levels.sort((a, b) => a - b);\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            }\n\n        } else {\n            for (var l = 0; l < levels.length; l++) {\n                mapping.set(levels[l], l);\n            }\n\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    failure();\n                    barr[i] = placeholder;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n        }\n\n    } catch (e) {\n        if (local_buffer instanceof wa.WasmArray) {\n            utils.free(local_buffer);\n        }\n        throw e;\n    }\n\n    return {\n        ids: buffer,\n        levels: levels\n    };\n}\n\n// Back-compatible renaming.\nexport function factorize(x, options = {}) {\n    return convertToFactor(x, options);\n}\n\n/**\n * Reindex the factor indices to remove unused levels.\n * This is done by adjusting the indices such that every index from `[0, N)` is represented at least once, where `N` is the number of (used) levels.\n *\n * @param {Int32WasmArray|TypedArray|Array} x - Array of factor indices such as that produced by {@linkcode convertToFactor}. \n *\n * @return {Array} `x` is modified in place to remove unused levels.\n *\n * An array (denoted here as `y`) is returned that represents the mapping between the original and modified IDs,\n * i.e., running `x.map(i => y[i])` will recover the input `x`.\n * This is most commonly used to create a new array of levels, i.e., `y.map(i => old_levels[i])` will drop the unused levels. \n */\nexport function dropUnusedLevels(x) {\n    if (x instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        x = x.array();\n    }\n\n    let uniq = new Set(x);\n    let uniq_arr = Array.from(uniq).sort();\n    let mapping = {};\n    uniq_arr.forEach((y, i) => { mapping[y] = i; });\n\n    x.forEach((y, i) => {\n        x[i] = mapping[y];\n    });\n\n    return uniq_arr;\n}\n\n/**\n * Change the levels of a factor, updating the indices appropriately.\n *\n * @param {object} x - Factor object produced by {@linkcode convertToFactor}.\n * @param {Array} newLevels - Array of new levels.\n * This should be a superset of `x.levels`.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.action=\"error\"] - Action to take when `newLevels` is not a superset of `x.levels`.\n * This can be `\"error\"`, `\"warn\"` or `\"none\"`.\n * @param {number} [options.placeholder=-1] - Placeholder index corresponding to invalid values of `x.ids`.\n * Any placeholders in `x.ids` will be preserved on function return.\n * Additionally, if entries of `x.ids` refer to entries of `x.levels` that are missing in `newLevels`, they will be set to the placeholder value on function return;\n * this is only relevant if `action = \"warn\"` or `\"none\"`.\n *\n * @return `x` is modified by reference such that `x.levels` is set to `newLevels`.\n * `x.ids` is updated so that the indices now refer to the appropriate value in `newLevels`.\n */\nexport function resetLevels(x, newLevels, { action = \"error\", placeholder = -1 } = {}) {\n    let mapping = new Map;\n    for (var i = 0; i < newLevels.length; i++) {\n        mapping.set(newLevels[i], i);\n    }\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing missing levels with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected level in 'x.levels' that is missing from 'newLevels'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling missing levels\");\n    }\n\n    let oldLevels = x.levels;\n    let conversion = new Array(oldLevels.length);\n    let warned = false;\n    for (var i = 0; i < oldLevels.length; i++) {\n        let found = mapping.get(oldLevels[i]);\n        if (typeof found == \"undefined\") {\n            failure();\n            conversion[i] = placeholder;\n        } else {\n            conversion[i] = found;\n        }\n    }\n    x.levels = newLevels;\n\n    let target = x.ids;\n    if (target instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        target = target.array();\n    }\n    target.forEach((y, i) => {\n        if (y !== placeholder) {\n            target[i] = conversion[y];\n        }\n    });\n}\n\n/**\n * Subset a factor, possibly also dropping its unused levels.\n * This is typically based on the same filtering vector as {@linkcode filterCells}.\n *\n * @param {object} x - An object representing a factor, containing the following properties:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices.\n * - `levels`: An array of levels that can be indexed by entries of `ids`.\n *\n * This is typically produced by {@linkcode convertToFactor}. \n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n *\n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.drop=true] - Whether to drop unused levels in the output, see {@linkcode dropUnusedLevels}.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?(Int32Array|Int32WasmArray)} [options.buffer=null] - Array in which the output is to be stored, of the same type as `x.ids`.\n * If provided, this should be of length equal to `subset`, if `filter = null`;\n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {object} An object like `x`, containing:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices, subsetted from those in `x.ids`.\n * - `levels`: Array of levels that can be indexed by entries of the output `ids`.\n *   If `drop = true`, this may be a subset of `x.levels` where every entry is represented at least once in the output `ids`.\n *\n * If `buffer` is supplied, the returned `ids` will be set to `buffer`.\n */\nexport function subsetFactor(x, subset, { drop = true, filter = null, buffer = null } = {}) {\n    let output = { ids: null, levels: x.levels };\n\n    if (x.ids instanceof wa.WasmArray) {\n        output.ids = wa.subsetWasmArray(x.ids, subset, { filter, buffer });\n    } else {\n        let n = wa.checkSubsetLength(subset, filter, x.length, \"x\");\n        if (buffer == null) {\n            buffer = new x.ids.constructor(n);\n        }\n        wa.fillSubset(subset, filter, x.ids, buffer);\n        output.ids = buffer;\n    }\n\n    if (drop) {\n        let remapping = dropUnusedLevels(output.ids);\n        output.levels = remapping.map(i => x.levels[i]);\n    }\n    return output;\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int8WasmArray} Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int16WasmArray} Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int32WasmArray} Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigInt64WasmArray} Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return {Uint8Array} A Uint8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string}\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return {Int8Array} An Int8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number}\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return {Uint16Array} A Uint16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return {Int16Array} An Int16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return {Uint32Array} A Uint32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return {Int32Array} An Int32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return {BigUint64Array} A BigUint64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return {BigInt64Array} An BigInt64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return {Float32Array} A Float32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return {Float64Array} A Float64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return {class} Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n"],"names":["registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","freeCache","object","scran","changedParametersIllegal","x","y","xskip","yskip","ArrayBuffer","isView","Error","changedParameters","xnull","ynull","xarr","Array","yarr","length","i","xkeys","Object","keys","ykeys","sort","k","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","set","runs","indices","distances","unserialize","free","convertToFactor","local_buffer","failure","asWasmArray","buffer","levels","action","placeholder","arguments","undefined","warned","console","warn","String","utils","Int32Array","wa","barr","array","mapping","Map","Number","isFinite","existing","get","n","push","every","oldlevels","slice","resetLevels","ids","a","b","l","e","newLevels","oldLevels","conversion","found","target","forEach","_id","WeakMap","_index","BuildNeighborSearchIndexResults","constructor","id","raw","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","this","numberOfCells","_classPrivateFieldGet","numberOfDims","num_dim","gc","index","_id2","_results","FindNearestNeighborsResults","results","serialize","run_data","ind_data","dist_data","copy","s","offset","module","NeighborResults","findNearestNeighbors","numberOfThreads","nthreads","find_nearest_neighbors","createUint8WasmArray","wasmArraySpace","createInt32WasmArray","createFloat64WasmArray","wasmifyArray","expected","className","space","owner","view","clone","chooseNumberOfThreads","threads","maximumThreads","extractXY","ncells","coordinates","Float64Array","possibleCopy","view_class","name","replace","byteOffset","cache","async","initialize","localFile","options","scran_custom_nthreads","locateFile","import","substring","loadScran","register","call","func","get_error_message","wasmMemory","terminate","PThread","terminateAllThreads","createWasmArray","arrayClass","allocate","Uint8WasmArray","Int32WasmArray","Float64WasmArray","WasmArray","Uint8Array","_defineProperty","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Uint32Array","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","choices","stringToClass"],"sourceRoot":""}