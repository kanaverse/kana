{"version":3,"file":"static/js/525.a985dee2.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/steps/abstract/worker_child.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/viz_child.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/wasm.js","../node_modules/wasmarrays.js/src/create.js","../node_modules/wasmarrays.js/src/derived.js"],"sourcesContent":["export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.FindNearestNeighborsResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int8WasmArray} Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int16WasmArray} Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int32WasmArray} Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigInt64WasmArray} Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return {Uint8Array} A Uint8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string}\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return {Int8Array} An Int8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number}\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return {Uint16Array} A Uint16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return {Int16Array} An Int16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return {Uint32Array} A Uint32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return {Int32Array} An Int32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return {BigUint64Array} A BigUint64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return {BigInt64Array} An BigInt64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return {Float32Array} A Float32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return {Float64Array} A Float64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return {class} Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n"],"names":["registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","freeCache","object","scran","changedParametersIllegal","x","y","xskip","yskip","ArrayBuffer","isView","Error","changedParameters","xnull","ynull","xarr","Array","yarr","length","i","xkeys","Object","keys","ykeys","sort","k","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","set","runs","indices","distances","unserialize","free","_id","WeakMap","_index","BuildNeighborSearchIndexResults","constructor","id","raw","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","this","numberOfCells","_classPrivateFieldGet","numberOfDims","num_dim","gc","index","_id2","_results","FindNearestNeighborsResults","results","serialize","arguments","undefined","run_data","ind_data","dist_data","copy","utils","s","offset","slice","array","module","NeighborResults","e","findNearestNeighbors","numberOfThreads","nthreads","find_nearest_neighbors","createInt32WasmArray","wa","wasmArraySpace","createFloat64WasmArray","wasmifyArray","expected","className","space","owner","view","clone","chooseNumberOfThreads","threads","maximumThreads","extractXY","ncells","coordinates","Float64Array","cache","async","initialize","localFile","options","scran_custom_nthreads","locateFile","import","substring","loadScran","register","call","func","get_error_message","terminate","PThread","terminateAllThreads","createWasmArray","arrayClass","allocate","Int32WasmArray","Float64WasmArray","Uint8WasmArray","WasmArray","Uint8Array","buffer","_defineProperty","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Uint32Array","Int32Array","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","choices","stringToClass","name"],"sourceRoot":""}