{"version":3,"file":"static/js/623.fe8f6da0.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/steps/abstract/worker_child.js","../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/viz_child.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/utils.js","../node_modules/scran.js/browser/wasm.js","../node_modules/wasmarrays.js/src/create.js","../node_modules/wasmarrays.js/src/derived.js"],"sourcesContent":["export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.FindNearestNeighborsResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return A Uint8Array view of the allocated memory.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return An Int8Array view of the allocated memory.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return A Uint16Array view of the allocated memory.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return An `Int16Array` view of the allocated memory.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return A Uint32Array view of the allocated memory.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return An Int32Array view of the allocated memory.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return A BigUint64Array view of the allocated memory.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return An BigInt64Array view of the allocated memory.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return A Float32Array view of the allocated memory.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return A Float64Array view of the allocated memory.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n"],"names":["registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","freeCache","object","scran","changedParametersIllegal","x","y","xskip","yskip","ArrayBuffer","isView","Error","changedParameters","xnull","ynull","xarr","Array","yarr","length","i","xkeys","Object","keys","ykeys","sort","_i","_xkeys","k","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","set","runs","indices","distances","free","_id","WeakMap","_index","BuildNeighborSearchIndexResults","id","raw","_classCallCheck","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","this","_createClass","key","_classPrivateFieldGet","num_dim","gc","get","_id2","_results","FindNearestNeighborsResults","run_data","ind_data","dist_data","_ref2","arguments","undefined","_ref2$runs","_ref2$indices","_ref2$distances","copy","utils","numberOfCells","s","serialize","offset","slice","array","module","NeighborResults","e","findNearestNeighbors","_ref3$numberOfThreads","numberOfThreads","nthreads","find_nearest_neighbors","index","createInt32WasmArray","wa","wasmArraySpace","createFloat64WasmArray","wasmifyArray","expected","constructor","className","space","owner","view","clone","chooseNumberOfThreads","threads","maximumThreads","extractXY","ncells","coordinates","Float64Array","cache","initialize","_initialize","apply","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref","_ref$numberOfThreads","_ref$localFile","localFile","options","_args","wrap","_context","prev","next","abrupt","scran_custom_nthreads","locateFile","import","substring","loadScran","sent","register","stop","call","func","get_error_message","terminate","PThread","terminateAllThreads","createWasmArray","arrayClass","allocate","Int32WasmArray","Float64WasmArray","Uint8WasmArray","_WasmArray","_inherits","_super","_createSuper","Uint8Array","buffer","WasmArray","_defineProperty","Int8WasmArray","_WasmArray2","_super2","Int8Array","Uint16WasmArray","_WasmArray3","_super3","Uint16Array","Int16WasmArray","_WasmArray4","_super4","Int16Array","Uint32WasmArray","_WasmArray5","_super5","Uint32Array","_WasmArray6","_super6","Int32Array","BigUint64WasmArray","_WasmArray7","_super7","BigUint64Array","BigInt64WasmArray","_WasmArray8","_super8","BigInt64Array","Float32WasmArray","_WasmArray9","_super9","Float32Array","_WasmArray10","_super10","choices","stringToClass","name"],"sourceRoot":""}