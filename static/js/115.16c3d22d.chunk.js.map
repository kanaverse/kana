{"version":3,"file":"static/js/115.16c3d22d.chunk.js","mappings":"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","sources":["../node_modules/bakana/browser/steps/utils/general.js","../node_modules/bakana/browser/steps/utils/viz_child.js","../node_modules/wasmarrays.js/src/derived.js","../node_modules/scran.js/browser/findNearestNeighbors.js","../node_modules/scran.js/browser/factorize.js","../node_modules/bakana/browser/steps/abstract/worker_child.js","../node_modules/scran.js/browser/wasm.js","../node_modules/scran.js/browser/utils.js","../node_modules/wasmarrays.js/src/create.js"],"sourcesContent":["import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    // Just an alias for back-compatibility.\n    scran.free(object);\n    return;\n}\n\nfunction changedParametersIllegal(x, y, xskip, yskip) {\n    // Failing if this is a TypedArray or ArrayBuffer;\n    // we shouldn't be seeing these things here anyway.\n    if (!xskip) {\n        if (x instanceof ArrayBuffer || ArrayBuffer.isView(x)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n    if (!yskip) {\n        if (y instanceof ArrayBuffer || ArrayBuffer.isView(y)) {\n            throw new Error(\"parameters cannot contain ArrayBuffers or their views\");\n        }\n    }\n}\n\nexport function changedParameters(x, y) {\n    if (typeof x != typeof y) {\n        changedParametersIllegal(x, y, false, false);\n        return true;\n    } else if (typeof x != \"object\") {\n        return x != y;\n    }\n\n    //Handling nulls (which are objects).\n    let xnull = x === null;\n    let ynull = y === null;\n    if (xnull !== ynull) {\n        changedParametersIllegal(x, y, xnull, ynull);\n        return true;\n    } else if (xnull) {\n        return false;\n    }\n\n    // Handling arrays (which are also objects).\n    let xarr = x instanceof Array;\n    let yarr = y instanceof Array;\n    if (xarr != yarr) {\n        changedParametersIllegal(x, y, xarr, yarr);\n        return true;\n    } else if (xarr) {\n        if (x.length != y.length) {\n            return true;\n        }\n\n        for (var i = 0; i < x.length; i++) {\n            if (changedParameters(x[i], y[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    changedParametersIllegal(x, y, false, false);\n    \n    // Now actually handling objects. We don't \n    // worry about the order of the keys here.\n    let xkeys = Object.keys(x);\n    let ykeys = Object.keys(y);\n    if (xkeys.length != ykeys.length) {\n        return true;\n    }\n\n    xkeys.sort();\n    ykeys.sort();\n    for (var i = 0; i < xkeys.length; i++) {\n        if (xkeys[i] != ykeys[i]) {\n            return true;\n        }\n    }\n\n    for (const k of xkeys) {\n        if (changedParameters(x[k], y[k])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n\n        // Views also trigger reallocation, because it is assumed that the\n        // caller of this function does not own the view, but downstream\n        // uses of the array will involve writing to it.\n        if (candidate.size != size || candidate.constructor.className != type || candidate.owner !== null) { \n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function findValidUpstreamStates(states, msg) {\n    let to_use = [];\n    for (const [k, v] of Object.entries(states)) {\n        if (v.valid()) {\n            to_use.push(k);\n        }\n    }\n    if (to_use.length == 0) {\n        throw new Error(\"expected at least one valid upstream \" + msg + \" state\");\n    }\n    return to_use;\n}\n\nexport function checkIndices(indices, max) {\n    if (max !== null) {\n        for (const i of indices) {\n            if (i < 0 || i >= max) {\n                throw new Error(\"subset indices are out of range\");\n            }\n        }\n    }\n\n    for (var i = 1; i < indices.length; i++) {\n        if (indices[i] <= indices[i-1]) {\n            throw new Error(\"subset indices must be sorted and unique\");\n        }\n    }\n}\n\nexport async function defaultDownload(url) {\n    let resp = await fetch(url);\n    if (!resp.ok) {\n        throw new Error(\"failed to fetch content at \" + url + \"(\" + resp.status + \")\");\n    }\n    return new Uint8Array(await resp.arrayBuffer());\n}\n\nexport function guessFeatureTypes(genes) {\n    let output = { columns: {} };\n\n    let rn = genes.rowNames();\n    if (rn !== null) {\n        output.row_names = scran.guessFeatures(rn, { forceTaxonomy: true });\n    }\n\n    for (const key of genes.columnNames()) {\n        let curcol = genes.column(key);\n        if (curcol instanceof Array) {\n            output.columns[key] = scran.guessFeatures(genes.column(key), { forceTaxonomy: true });\n        }\n    }\n\n    return output;\n}\n\nexport function subsetInvalidFactors(arrays) {\n    let N = arrays[0].length;\n    let output = { arrays: [], retain: null };\n\n    let invalid = new Uint8Array(N);\n    invalid.fill(0);\n    for (const x of arrays) {\n        let transformed = scran.factorize(x, { action: \"none\", placeholder: -1 });\n        output.arrays.push(transformed);\n        transformed.ids.forEach((y, i) => {\n            if (y == -1) {\n                invalid[i] = 1;\n            }\n        });\n    }\n\n    let num_invalid = 0;\n    invalid.forEach(y => { num_invalid += y; });\n    if (num_invalid == 0) {\n        return output;\n    }\n\n    let retain = new Int32Array(N - num_invalid);\n    {\n        let counter = 0;\n        for (var i = 0; i < N; i++) {\n            if (invalid[i] == 0) {\n                retain[counter] = i;\n                counter++;\n            }\n        }\n    }\n    output.retain = retain;\n\n    for (var i = 0; i < output.arrays.length; i++) {\n        let x = output.arrays[i];\n        let new_ids = scran.subsetBlock(x.ids, retain);\n        let remapping = scran.dropUnusedBlock(new_ids);\n        let new_levels = remapping.map(i => x.levels[i]);\n\n        scran.free(x.ids);\n        x.ids = new_ids;\n        x.levels = new_levels;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\n\nexport function chooseDelay(animate) {\n    if (animate) {\n        // TODO: using 75 for now\n        // in the future the user can choose a bar for speed on the UI\n        // options would be 1x, 2x, 3x\n        return 75;\n    } else {\n        return 1000000; // effectively no delay.\n    }\n};\n\nexport function recreateNeighbors(neighbors) {\n    var output = null;\n    var rbuf = null;\n    var ibuf = null;\n    var dbuf = null;\n  \n    try {\n        var num_obs = neighbors.num_obs;\n        var size = neighbors.size;\n\n        rbuf = scran.createInt32WasmArray(num_obs);\n        rbuf.set(neighbors.runs);\n        ibuf = scran.createInt32WasmArray(size);\n        ibuf.set(neighbors.indices);\n        dbuf = scran.createFloat64WasmArray(size);\n        dbuf.set(neighbors.distances);\n\n        output = scran.FindNearestNeighborsResults.unserialize(rbuf, ibuf, dbuf);\n\n    } finally {\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n};\n","import { buffer } from \"./globals.js\";\nimport { WasmArray } from \"./base.js\";\n\n/** \n * Wrapper around an unsigned 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint8WasmArray extends WasmArray {\n    /**\n     * @return {Uint8Array} A Uint8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string}\n     */\n    static className = \"Uint8WasmArray\";\n    // We're returning the name explicitly here instead of relying\n    // on the constructor.name trick, as the name of the class can\n    // change during minification.\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around a signed 8-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt8WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int8WasmArray extends WasmArray {\n    /**\n     * @return {Int8Array} An Int8Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int8Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int8WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number}\n     */\n    static valueSize = 1;\n}\n\n/** \n * Wrapper around an unsigned 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint16WasmArray extends WasmArray {\n    /**\n     * @return {Uint16Array} A Uint16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint16WasmArray\";\n\n    /**\n     * Size of the each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage a signed 16-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt16WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int16WasmArray extends WasmArray {\n    /**\n     * @return {Int16Array} An Int16Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int16Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Int16WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 2;\n}\n\n/** \n * Manage an unsigned 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createUint32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Uint32WasmArray extends WasmArray {\n    /**\n     * @return {Uint32Array} A Uint32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Uint32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"Uint32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a signed 32-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createInt32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Int32WasmArray extends WasmArray {\n    /**\n     * @return {Int32Array} An Int32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Int32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Int32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage an unsigned 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigUint64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigUint64WasmArray extends WasmArray {\n    /**\n     * @return {BigUint64Array} A BigUint64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigUint64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * Name of the class.\n     * @type {string} \n     */\n    static className = \"BigUint64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a signed 64-bit integer array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createBigInt64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class BigInt64WasmArray extends WasmArray {\n    /**\n     * @return {BigInt64Array} An BigInt64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new BigInt64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"BigInt64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\n/** \n * Manage a 32-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat32WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float32WasmArray extends WasmArray {\n    /**\n     * @return {Float32Array} A Float32Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float32Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float32WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 4;\n}\n\n/** \n * Manage a 64-bit float array allocated on the Wasm heap.\n * Users may create instances using the {@linkcode createFloat64WasmArray} function.\n *\n * @hideconstructor\n * @augments WasmArray\n */\nexport class Float64WasmArray extends WasmArray {\n    /**\n     * @return {Float64Array} A Float64Array view of the allocated memory.\n     * Note that this may be invalidated by subsequent Wasm heap allocations.\n     */\n    array() {\n        return new Float64Array(buffer(this.space), this.offset, this.length);\n    }\n\n    /**\n     * @return Name of the class.\n     * @type {string} \n     */\n    static className = \"Float64WasmArray\";\n\n    /**\n     * Size of each data value, in bytes.\n     * @type {number} \n     */\n    static valueSize = 8;\n}\n\nconst choices = {\n    \"Uint8WasmArray\": Uint8WasmArray,\n    \"Int8WasmArray\": Int8WasmArray,\n    \"Uint16WasmArray\": Uint16WasmArray,\n    \"Int16WasmArray\": Int16WasmArray,\n    \"Uint32WasmArray\": Uint32WasmArray,\n    \"Int32WasmArray\": Int32WasmArray,\n    \"BigUint64WasmArray\": BigUint64WasmArray,\n    \"BigInt64WasmArray\": BigInt64WasmArray,\n    \"Float32WasmArray\": Float32WasmArray,\n    \"Float64WasmArray\": Float64WasmArray\n};\n\n/**\n * Retrieve class from its name.\n *\n * @param {string} name - Name of the {@linkplain WasmArray} class.\n *\n * @return {class} Class object corresponding to `name`.\n */\nexport function stringToClass(name) {\n    if (!(name in choices)){ \n        throw new Error(\"unknown WasmArray class '\" + name + \"'\");\n    }\n    return choices[name];\n}\n","import * as utils from \"./utils.js\";\nimport * as gc from \"./gc.js\";\nimport { RunPCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap, typically produced by {@linkcode buildNeighborSearchIndex}.\n * @hideconstructor\n */\nexport class BuildNeighborSearchIndexResults {\n    #id;\n    #index; \n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#index = raw;\n        return;\n    }\n\n    /**\n     * @return {number} Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.#index.num_obs();\n    }\n\n    /**\n     * @return {number} Number of dimensions in the index.\n     */\n    numberOfDims() {\n        return this.#index.num_dim();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#index !== null) {\n            gc.release(this.#id);\n            this.#index = null;\n        }\n        return;\n    }\n\n    // Internal only, not documented.\n    get index() {\n        return this.#index;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(RunPCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a {@linkplain RunPCAResults} input, we extract the principal components.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfDims=null] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {?number} [options.numberOfCells=null] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate=true] - Whether to build an index for an approximate neighbor search.\n *\n * @return {BuildNeighborSearchIndexResults} Index object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof RunPCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw new Error(\"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\");\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw new Error(\"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\");\n            }\n\n            pptr = buffer.offset;\n        }\n\n        output = gc.call(\n            module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate),\n            BuildNeighborSearchIndexResults\n        );\n\n    } catch (e) {\n        utils.free(output);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap, typically produced by {@linkcode findNearestNeighbors}.\n * @hideconstructor\n */\nexport class FindNearestNeighborsResults {\n    #id;\n    #results;\n\n    constructor(id, raw) {\n        this.#id = id;\n        this.#results = raw;\n        return;\n    }\n\n    /**\n     * @return {number} The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.#results.size();\n    }\n\n    /**\n     * @return {number} The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.#results.num_obs();\n    }\n\n    // Internal use only, not documented.\n    get results() {\n        return this.#results;\n    }\n\n    /**\n     * @param {object} [options={}] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs=null] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances=null] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return {object} \n     * An object is returned with the `runs`, `indices` and `distances` keys, each with an appropriate TypedArray as the value.\n     *\n     * If all of the arguments are non-`null`, the TypedArrays in the returned object are views on the corresponding input WasmArrays.\n     * Note that these views may be invalidated on the next allocation on the Wasm heap.\n     *\n     * If only some of the arguments are non-`null`, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw new Error(\"either all or none of 'runs', 'indices' and 'distances' can be 'null'\");\n        }\n\n        var output;\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            \n            try {\n                run_data = utils.createInt32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = utils.createInt32WasmArray(s);\n                dist_data = utils.createFloat64WasmArray(s);\n                this.#results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n        } else {\n            this.#results.serialize(runs.offset, indices.offset, distances.offset);\n            output = {\n                \"runs\": runs.array(),\n                \"indices\": indices.array(),\n                \"distances\": distances.array()\n            };\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return {FindNearestNeighborsResults} Object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            output = gc.call(\n                module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset),\n                FindNearestNeighborsResults\n            );\n\n        } catch (e) {\n            utils.free(output);\n            throw e;\n\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        if (this.#results !== null) {\n            gc.release(this.#id);\n            this.#results = null;\n        }\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The neighbor search index built by {@linkcode buildNeighborSearchIndex}.\n * @param {number} k Number of neighbors to find.\n * @param {object} [options={}] - Optional parameters.\n * @param {?number} [options.numberOfThreads=null] - Number of threads to use.\n * If `null`, defaults to {@linkcode maximumThreads}.\n *\n * @return {FindNearestNeighborsResults} Object containing the search results.\n */\nexport function findNearestNeighbors(x, k, { numberOfThreads = null } = {}) {\n    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);\n    return gc.call(\n        module => module.find_nearest_neighbors(x.index, k, nthreads),\n        FindNearestNeighborsResults\n    );\n}\n","import * as wa from \"wasmarrays.js\";\nimport * as utils from \"./utils.js\";\n\n/**\n * Convert an arbitrary array into a R-style factor, with integer indices into an array of levels.\n * This is useful for formatting grouping or blocking vectors for {@linkcode scoreMarkers}, {@linkcode modelGeneVar}, etc.\n *\n * @param {Array|TypedArray} x - Array of values to be converted into a factor.\n * \n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.asWasmArray=true] - Whether to return an Int32WasmArray instance for the indices.\n * If `false`, an Int32Array is returned instead.\n * Only used if `buffer` is not supplied.\n * @param {?(Int32WasmArray|Int32Array)} [options.buffer=null] - Array in which the output is to be stored.\n * If provided, this should be of length equal to that of `x`.\n * @param {?Array} [options.levels=null] - An existing array of known levels to be matched against `x`.\n * Values in `x` that are not in `levels` are considered to be invalid.\n * If `null`, the levels are automatically inferred from `x`; these will be sorted if all-numeric or all-string.\n * @param {string} [options.action=\"error\"] - Action to take when invalid values (i.e., null, NaNs) are detected in `x`.\n *\n * - `\"none\"`: the index is silently set to `placeholder`.\n * - `\"warn\"`: a warning is raised on the first occurrence of an invalid value, and the index is set to `placeholder`.\n * - `\"error\"`: an error is raised.\n * \n * @param {number} [options.placeholder=-1] - Placeholder index to use upon detecting invalid values in `x`.\n *\n * @return {object} Object containing:\n *\n * - `ids`: an Int32WasmArray or Int32Array of length equal to `x`, containing the index into `levels` for each cell.\n * - `levels`: an array of unique levels, such that `Array.from(ids).map(i => levels[i])` returns the same contents as `x` (aside from invalid values).\n *   If an input `levels` is supplied, this is returned directly.\n *\n * If `buffer` was supplied, it is used as the value of the `ids` property.\n */\nexport function convertToFactor(x, { asWasmArray = true, buffer = null, levels = null, action = \"error\", placeholder = -1 } = {}) {\n    let local_buffer;\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing invalid values with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected invalid value (e.g., null, NaN) in 'x'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling invalid entries\");\n    }\n\n    try {\n        if (buffer == null) {\n            local_buffer = (asWasmArray ? utils.createInt32WasmArray(x.length) : new Int32Array(x.length));\n            buffer = local_buffer;\n        } else {\n            if (buffer.length !== x.length) {\n                throw new Error(\"'buffer' should have length equal to that of 'x'\");\n            }\n            asWasmArray = buffer instanceof wa.Int32WasmArray;\n        }\n\n        let barr = (asWasmArray ? buffer.array() : buffer); // no allocations from this point onwards!\n        let mapping = new Map;\n\n        if (levels == null) {\n            levels = [];\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                if (y == null || (typeof y == \"number\" && !Number.isFinite(y))) {\n                    failure();\n                    barr[i] = placeholder;\n                    continue;\n                }\n\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    let n = levels.length;\n                    mapping.set(y, n);\n                    levels.push(y);\n                    barr[i] = n;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n\n            // Sorting them by default, to make life nicer.\n            if (levels.every(x => typeof x == \"string\")) {\n                let oldlevels = levels.slice();\n                levels.sort();\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            } else if (levels.every(x => typeof x == \"number\")) {\n                let oldlevels = levels.slice();\n                levels.sort((a, b) => a - b);\n                resetLevels({ ids: buffer, levels: oldlevels }, levels);\n            }\n\n        } else {\n            for (var l = 0; l < levels.length; l++) {\n                mapping.set(levels[l], l);\n            }\n\n            for (var i = 0; i < x.length; i++) {\n                let y = x[i];\n                let existing = mapping.get(y);\n                if (typeof existing == \"undefined\") {\n                    failure();\n                    barr[i] = placeholder;\n                } else {\n                    barr[i] = existing;\n                }\n            }\n        }\n\n    } catch (e) {\n        if (local_buffer instanceof wa.WasmArray) {\n            utils.free(local_buffer);\n        }\n        throw e;\n    }\n\n    return {\n        ids: buffer,\n        levels: levels\n    };\n}\n\n// Back-compatible renaming.\nexport function factorize(x, options = {}) {\n    return convertToFactor(x, options);\n}\n\n/**\n * Reindex the factor indices to remove unused levels.\n * This is done by adjusting the indices such that every index from `[0, N)` is represented at least once, where `N` is the number of (used) levels.\n *\n * @param {Int32WasmArray|TypedArray|Array} x - Array of factor indices such as that produced by {@linkcode convertToFactor}. \n *\n * @return {Array} `x` is modified in place to remove unused levels.\n *\n * An array (denoted here as `y`) is returned that represents the mapping between the original and modified IDs,\n * i.e., running `x.map(i => y[i])` will recover the input `x`.\n * This is most commonly used to create a new array of levels, i.e., `y.map(i => old_levels[i])` will drop the unused levels. \n */\nexport function dropUnusedLevels(x) {\n    if (x instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        x = x.array();\n    }\n\n    let uniq = new Set(x);\n    let uniq_arr = Array.from(uniq).sort();\n    let mapping = {};\n    uniq_arr.forEach((y, i) => { mapping[y] = i; });\n\n    x.forEach((y, i) => {\n        x[i] = mapping[y];\n    });\n\n    return uniq_arr;\n}\n\n/**\n * Change the levels of a factor, updating the indices appropriately.\n *\n * @param {object} x - Factor object produced by {@linkcode convertToFactor}.\n * @param {Array} newLevels - Array of new levels.\n * This should be a superset of `x.levels`.\n * @param {object} [options={}] - Optional parameters.\n * @param {string} [options.action=\"error\"] - Action to take when `newLevels` is not a superset of `x.levels`.\n * This can be `\"error\"`, `\"warn\"` or `\"none\"`.\n * @param {number} [options.placeholder=-1] - Placeholder index corresponding to invalid values of `x.ids`.\n * Any placeholders in `x.ids` will be preserved on function return.\n * Additionally, if entries of `x.ids` refer to entries of `x.levels` that are missing in `newLevels`, they will be set to the placeholder value on function return;\n * this is only relevant if `action = \"warn\"` or `\"none\"`.\n *\n * @return `x` is modified by reference such that `x.levels` is set to `newLevels`.\n * `x.ids` is updated so that the indices now refer to the appropriate value in `newLevels`.\n */\nexport function resetLevels(x, newLevels, { action = \"error\", placeholder = -1 } = {}) {\n    let mapping = new Map;\n    for (var i = 0; i < newLevels.length; i++) {\n        mapping.set(newLevels[i], i);\n    }\n\n    let failure;\n    if (action == \"warn\") {\n        let warned = false;\n        failure = () => {\n            if (!warned) {\n                console.warn (\"replacing missing levels with the placeholder index '\" + String(placeholder) + \"'\");\n                warned = true;\n            }\n        };\n    } else if (action == \"none\") {\n        failure = () => {};\n    } else if (action == \"error\") {\n        failure = () => {\n            throw new Error(\"detected level in 'x.levels' that is missing from 'newLevels'\");\n        };\n    } else {\n        throw new Error(\"unknown action '\" + action + \"' for handling missing levels\");\n    }\n\n    let oldLevels = x.levels;\n    let conversion = new Array(oldLevels.length);\n    let warned = false;\n    for (var i = 0; i < oldLevels.length; i++) {\n        let found = mapping.get(oldLevels[i]);\n        if (typeof found == \"undefined\") {\n            failure();\n            conversion[i] = placeholder;\n        } else {\n            conversion[i] = found;\n        }\n    }\n    x.levels = newLevels;\n\n    let target = x.ids;\n    if (target instanceof wa.WasmArray) {\n        // No more wasm allocations past this point!\n        target = target.array();\n    }\n    target.forEach((y, i) => {\n        if (y !== placeholder) {\n            target[i] = conversion[y];\n        }\n    });\n}\n\n/**\n * Subset a factor, possibly also dropping its unused levels.\n * This is typically based on the same filtering vector as {@linkcode filterCells}.\n *\n * @param {object} x - An object representing a factor, containing the following properties:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices.\n * - `levels`: An array of levels that can be indexed by entries of `ids`.\n *\n * This is typically produced by {@linkcode convertToFactor}. \n * @param {(Array|TypedArray|WasmArray)} subset - Array specifying the subset to retain or filter out, depending on `filter`.\n *\n * If `filter = null`, the array is expected to contain integer indices specifying the entries in `x` to retain.\n * The ordering of indices in `subset` will be respected in the subsetted array.\n *\n * If `filter = true`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be filtered out.\n *\n * If `filter = false`, the array should be of length equal to that of `x`.\n * Each value is interpreted as a boolean and, if truthy, indicates that the corresponding entry of `x` should be retained.\n *\n * Note that TypedArray views on Wasm-allocated buffers should only be provided if `buffer` is also provided;\n * otherwise, a Wasm memory allocation may invalidate the view.\n * @param {object} [options={}] - Optional parameters.\n * @param {boolean} [options.drop=true] - Whether to drop unused levels in the output, see {@linkcode dropUnusedLevels}.\n * @param {?boolean} [options.filter=null] - Whether to retain truthy or falsey values in a `subset` boolean filter.\n * If `null`, `subset` should instead contain the indices of elements to retain.\n * @param {?(Int32Array|Int32WasmArray)} [options.buffer=null] - Array in which the output is to be stored, of the same type as `x.ids`.\n * If provided, this should be of length equal to `subset`, if `filter = null`;\n * the number of truthy elements in `subset`, if `filter = false`;\n * or the number of falsey elements in `subset`, if `filter = true`.\n *\n * @return {object} An object like `x`, containing:\n *\n * - `ids`: An Int32Array or Int32WasmArray of integer indices, subsetted from those in `x.ids`.\n * - `levels`: Array of levels that can be indexed by entries of the output `ids`.\n *   If `drop = true`, this may be a subset of `x.levels` where every entry is represented at least once in the output `ids`.\n *\n * If `buffer` is supplied, the returned `ids` will be set to `buffer`.\n */\nexport function subsetFactor(x, subset, { drop = true, filter = null, buffer = null } = {}) {\n    let output = { ids: null, levels: x.levels };\n\n    if (x.ids instanceof wa.WasmArray) {\n        output.ids = wa.subsetWasmArray(x.ids, subset, { filter, buffer });\n    } else {\n        let n = wa.checkSubsetLength(subset, filter, x.length, \"x\");\n        if (buffer == null) {\n            buffer = new x.ids.constructor(n);\n        }\n        wa.fillSubset(subset, filter, x.ids, buffer);\n        output.ids = buffer;\n    }\n\n    if (drop) {\n        let remapping = dropUnusedLevels(output.ids);\n        output.levels = remapping.map(i => x.levels[i]);\n    }\n    return output;\n}\n","export function registerCallback(callback) {\n    self.onmessage = callback;\n    return;\n}\n\nexport function sendMessage(message, transfer) {\n    self.postMessage(message, transfer);\n    return;\n}\n","import loadScran from \"./wasm/scran.js\";\nimport { register } from \"wasmarrays.js\";\nimport * as afile from \"./abstract/file.js\";\n\nconst cache = {};\n\n/**\n * @param {object} [options={}] - Optional parameters.\n * @param {number} [options.numberOfThreads=4] - Number of threads to use for calculations.\n * This will spin up the requested number of Web Workers during module initialization.\n * @param {boolean} [options.localFile=false] - Whether or not to look for the Wasm and worker scripts locally.\n * This should only be `true` when using old versions of Node.js where file URLs are not supported, \n * and is ignored completely outside of Node.js contexts.\n *\n * @return {boolean}\n * The Wasm bindings are initialized and `true` is returned.\n * If the bindings were already initialized (e.g., by a previous call), nothing is done and `false` is returned.\n */\nexport async function initialize({ numberOfThreads = 4, localFile = false } = {}) {\n    if (\"module\" in cache) {\n        return false;\n    }\n\n    let options = {\n        scran_custom_nthreads: numberOfThreads\n    };\n\n    if (localFile) {                                                                /** NODE ONLY **/  \n        options.locateFile = (x) => import.meta.url.substring(7) + \"/../wasm/\" + x; /** NODE ONLY **/\n    }                                                                               /** NODE ONLY **/\n\n    cache.module = await loadScran(options);\n    cache.space = register(cache.module);\n\n    return true;\n}\n\n/**\n * Maximum number of threads available for computation.\n * This depends on the value specified during module initialization in {@linkcode initialize}. \n *\n * @return {number} Maximum number of available threads.\n */\nexport function maximumThreads() {\n    return cache.module.scran_custom_nthreads;\n}\n\nexport function call(func) {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n\n    var output;\n    try {\n        output = func(cache.module);    \n    } catch (e) {\n        if (typeof e == \"number\") {\n            throw new Error(cache.module.get_error_message(e));\n        } else {\n            throw e;\n        }\n    }\n    return output;\n}\n\nexport function buffer() {\n    if (! (\"module\" in cache)) {\n        throw new Error(\"Wasm module needs to be initialized via 'initialize()'\");\n    }\n    return cache.module.wasmMemory.buffer;\n}\n\n/**\n * @return {number} Integer containing the **wasmarrays.js** identifier for **scran.js**'s memory space.\n * This can be used with `createWasmArray()` and related functions from **wasmarrays.js**.\n */\nexport function wasmArraySpace() {\n    return cache.space;\n}\n\n/**\n * @return All worker threads are terminated and the module is deleted from the cache.\n * This is useful for cleaning up at the end of the analysis,\n * otherwise the workers will be shut done ungracefully on program exit.\n */\nexport function terminate() {\n    cache.module.PThread.terminateAllThreads();\n    delete cache.module;\n    return;\n}\n\n/**\n * @return {number} The current size of the Wasm heap, typically used for diagnostic reporting.\n */\nexport function heapSize() {\n    return buffer().byteLength;\n}\n","import { buffer, wasmArraySpace, maximumThreads } from \"./wasm.js\";\nimport * as wa from \"wasmarrays.js\";\n\n/**\n * Helper function to create a Uint8WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Uint8WasmArray} Uint8WasmArray on the **scran.js** Wasm heap.\n */\nexport function createUint8WasmArray(length) {\n    return wa.createUint8WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Int32WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Int32WasmArray} Int32WasmArray on the **scran.js** Wasm heap.\n */\nexport function createInt32WasmArray(length) {\n    return wa.createInt32WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a BigUint64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {BigUint64WasmArray} BigUint64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createBigUint64WasmArray (length) {\n    return wa.createBigUint64WasmArray(wasmArraySpace(), length);\n}\n\n/**\n * Helper function to create a Float64WasmArray from the **wasmarrays.js** package.\n *\n * @param {number} length - Length of the array.\n *\n * @return {Float64WasmArray} Float64WasmArray on the **scran.js** Wasm heap.\n */\nexport function createFloat64WasmArray(length) {\n    return wa.createFloat64WasmArray(wasmArraySpace(), length);\n}\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof wa.WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw new Error(\"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\");\n        }\n\n        if (x.space === wasmArraySpace()) {\n            // Creating a view. This ensures that callers can always call\n            // free() on the output of this function without worrying about\n            // whether they are breaking something else that was using 'x'.\n            if (x.owner === null) {\n                return x.view();\n            } else {\n                return x; // it's already a view, so we just pass it along.\n            }\n        } else {\n            // If it's a different space, then we have to make a copy.\n            return x.clone(wasmArraySpace());\n        }\n    }\n\n    let y = null;\n    if (expected !== null) {\n        y = wa.convertToWasmArray(wasmArraySpace(), x, wa.stringToClass(expected));\n    } else {\n        y = wa.convertToWasmArray(wasmArraySpace(), x);\n    }\n\n    return y;\n}\n\nexport function chooseNumberOfThreads(threads) {\n    if (threads == null) {\n        return maximumThreads();\n    } else {\n        return threads;\n    }\n}\n\n/**\n * Try to free a **scran.js** object's memory (typically involving some memory allocated on the Wasm heap) by calling its `free` method.\n *\n * @param {?object} x - Instance of a **scran.js** or **wasmarrays.js** class to be freed.\n * May also be `null` or undefined.\n * \n * @return The output of `x.free()` - unless `x` is undefined or `null`, in which case nothing is performed.\n */\nexport function free(x) {\n    if (typeof x == \"undefined\" || x == null) {\n        return;\n    }\n    return x.free();\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\n/**\n * Possibly copy an array out of the Wasm heap, avoiding potential invalidation at the cost of some efficiency.\n *\n * @param {TypedArray} x - Array of data, possibly on the **scran.js** Wasm heap.\n * @param {(string|boolean)} copy - Copying mode to use.\n *\n * @return {TypedArray|WasmArray} The return value depends on the value of `copy`:\n * - If `copy = true`, a TypedArray copy of `x` is created with `x.slice()` and returned.\n *   This is a good default to avoid invalidation of TypedArray views on the heap upon reallocation, by creating a Javascript-owned copy for downstream use.\n * - If `copy = false`, `x` is returned directly.\n *   This avoids making any copy but runs the risk of invalidation when the Wasm heap is resized;\n *   it should only be used when no further Wasm allocations are performed within the lifetime of `x`.\n * - If `copy = \"view\"`, a WasmArray view is created from `x` and returned.\n *   This avoids any copy and is robust to invalidation but requires an extra `WasmArray.array()` call to create a TypedArray.\n */\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw new Error(\"cannot use copy = \\\"view\\\" for non-Wasm TypedArrays\");\n        }\n\n        let view_class = x.constructor.name.replace(\"Array\", \"WasmArray\");\n\n        // This function should only be used for objects generated in the\n        // buffer owned by scran.js, so we can assume that x's space is the\n        // same as that of the wasmArraySpace().\n        return wa.createWasmArrayView(wasmArraySpace(), x.length, x.byteOffset, wa.stringToClass(view_class));\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n\nexport function matchOptions(name, value, choices) {\n    if (choices.indexOf(value) == -1) {\n        throw new Error(\"'\" + name + \"=' should be one of '\" + choices.join(\"', '\") + \"'\");\n    }\n}\n\nexport function spawnArray(n, fill) {\n    let output = new Array(n);\n    output.fill(fill);\n    return output;\n}\n\nexport function checkFillness(fill, copy, check, setFilledFun, getFun) {\n    if (!check) {\n        if (fill) {\n            setFilledFun();\n            if (copy) {\n                copy = false;\n            }\n        } else {\n            return null;\n        }\n    }\n    return getFun(copy);\n}\n","import { allocate } from \"./globals.js\";\nimport { \n    Int8WasmArray, Uint8WasmArray,\n    Int16WasmArray, Uint16WasmArray,\n    Int32WasmArray, Uint32WasmArray,\n    BigInt64WasmArray, BigUint64WasmArray,\n    Float32WasmArray, Float64WasmArray\n} from \"./derived.js\";\n\n/**\n * Create a {@linkplain WasmArray} of the specified subclass.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * @param {class} arrayClass - Desired subclass of the {@linkplain WasmArray}.\n * \n * @return {WasmArray} Instance of a {@linkplain WasmArray} subclass.\n */\nexport function createWasmArray(space, length, arrayClass) {\n    return allocate(space, length, arrayClass);\n}\n\n/**\n * Create a {@linkplain Uint8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint8WasmArray} Instance of a {@linkplain Uint8WasmArray}.\n */\nexport function createUint8WasmArray(space, length) { \n    return createWasmArray(space, length, Uint8WasmArray); \n}\n\n/**\n * Create a {@linkplain Int8WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int8WasmArray} Instance of a {@linkplain Int8WasmArray}.\n */\nexport function createInt8WasmArray(space, length) { \n    return createWasmArray(space, length, Int8WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint16WasmArray} Instance of a {@linkplain Uint16WasmArray}.\n */\nexport function createUint16WasmArray(space, length) { \n    return createWasmArray(space, length, Uint16WasmArray); \n}\n\n/**\n * Create a {@linkplain Int16WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int16WasmArray} Instance of a {@linkplain Int16WasmArray}.\n */\nexport function createInt16WasmArray(space, length) { \n    return createWasmArray(space, length, Int16WasmArray); \n}\n\n/**\n * Create a {@linkplain Uint32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Uint32WasmArray} Instance of a {@linkplain Uint32WasmArray}.\n */\nexport function createUint32WasmArray(space, length) { \n    return createWasmArray(space, length, Uint32WasmArray); \n}\n\n/**\n * Create a {@linkplain Int32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Int32WasmArray} Instance of a {@linkplain Int32WasmArray}.\n */\nexport function createInt32WasmArray(space, length) { \n    return createWasmArray(space, length, Int32WasmArray); \n}\n\n/**\n * Create a {@linkplain BigUint64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigUint64WasmArray} Instance of a {@linkplain BigUint64WasmArray}.\n */\nexport function createBigUint64WasmArray(space, length) { \n    return createWasmArray(space, length, BigUint64WasmArray); \n}\n\n/**\n * Create a {@linkplain BigInt64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {BigInt64WasmArray} Instance of a {@linkplain BigInt64WasmArray}.\n */\nexport function createBigInt64WasmArray(space, length) { \n    return createWasmArray(space, length, BigInt64WasmArray); \n}\n\n/**\n * Create a {@linkplain Float32WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float32WasmArray} Instance of a {@linkplain Float32WasmArray}.\n */\nexport function createFloat32WasmArray(space, length) { \n    return createWasmArray(space, length, Float32WasmArray); \n}\n\n/**\n * Create a {@linkplain Float64WasmArray}.\n *\n * @param {number} space - Identifier for the Wasm memory space, produced by {@linkcode register}.\n * @param {number} length - Length of the array to allocate.\n * \n * @return {Float64WasmArray} Instance of a {@linkplain Float64WasmArray}.\n */\nexport function createFloat64WasmArray(space, length) { \n    return createWasmArray(space, length, Float64WasmArray); \n}\n"],"names":["freeCache","object","scran","changedParametersIllegal","x","y","xskip","yskip","ArrayBuffer","isView","Error","changedParameters","xnull","ynull","xarr","Array","yarr","length","i","xkeys","Object","keys","ykeys","sort","k","chooseDelay","animate","recreateNeighbors","neighbors","output","rbuf","ibuf","dbuf","num_obs","size","set","runs","indices","distances","unserialize","free","Uint8WasmArray","WasmArray","array","Uint8Array","buffer","this","space","offset","_defineProperty","Int8WasmArray","Int8Array","Uint16WasmArray","Uint16Array","Int16WasmArray","Int16Array","Uint32WasmArray","Uint32Array","Int32WasmArray","Int32Array","BigUint64WasmArray","BigUint64Array","BigInt64WasmArray","BigInt64Array","Float32WasmArray","Float32Array","Float64WasmArray","Float64Array","choices","stringToClass","name","_id","WeakMap","_index","BuildNeighborSearchIndexResults","constructor","id","raw","_classPrivateFieldInitSpec","_classPrivateFieldSet","numberOfCells","_classPrivateFieldGet","numberOfDims","num_dim","gc","index","_id2","_results","FindNearestNeighborsResults","results","serialize","arguments","undefined","run_data","ind_data","dist_data","copy","utils","s","slice","module","NeighborResults","e","findNearestNeighbors","numberOfThreads","nthreads","find_nearest_neighbors","convertToFactor","local_buffer","failure","asWasmArray","levels","action","placeholder","warned","console","warn","String","wa","barr","mapping","Map","Number","isFinite","existing","get","n","push","every","oldlevels","resetLevels","ids","a","b","l","newLevels","oldLevels","conversion","found","target","forEach","registerCallback","callback","self","onmessage","sendMessage","message","transfer","postMessage","cache","async","initialize","localFile","options","scran_custom_nthreads","locateFile","import","substring","loadScran","register","maximumThreads","call","func","get_error_message","wasmMemory","wasmArraySpace","terminate","PThread","terminateAllThreads","createUint8WasmArray","createInt32WasmArray","createFloat64WasmArray","wasmifyArray","expected","className","owner","view","clone","chooseNumberOfThreads","threads","extractXY","ncells","coordinates","possibleCopy","view_class","replace","byteOffset","createWasmArray","arrayClass","allocate"],"sourceRoot":""}